{"version":3,"file":"vendor.common-694cdba6.bundle.js","mappings":";;;;;;AAAa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,2BAA2B,mBAAO,CAAC,KAAO;AAC1C,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI,gBAAgB,GAAG,qBAAqB,kBAAkB;AACtG;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qBAAqB,GAAG,0BAA0B;AACpG;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;;;;;;AClJa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,6BAA6B,mBAAO,CAAC,KAAqC;AAC1E,sDAAqD,EAAE,qCAAqC,mDAAmD,EAAC;AAChJ;;;;;;;ACLa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;;;;;;AC7Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,uBAAuB,mBAAO,CAAC,IAAsB;AACrD,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,2BAA2B,mBAAO,CAAC,KAA0B;AAC7D,0BAA0B,mBAAO,CAAC,KAAyB;AAC3D,iBAAiB,mBAAO,CAAC,IAAqB;AAC9C,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,qBAAqB,mBAAO,CAAC,KAAc;AAC3C,qBAAqB,mBAAO,CAAC,KAAoB;AACjD,oBAAoB,mBAAO,CAAC,KAAmB;AAC/C,oBAAoB,mBAAO,CAAC,KAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,0CAA0C;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,gFAAgF;AACnI,8DAA8D,oDAAoD;AAClH,sEAAsE,yIAAyI;AAC/M,sEAAsE,gIAAgI;AACtM;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,mDAAmD,gFAAgF;AACnI,8DAA8D,oDAAoD;AAClH,sEAAsE,yIAAyI;AAC/M,sEAAsE,gIAAgI;AACtM;AACA;AACA;AACA;AACA,iFAAiF;AACjF,+CAA+C,kCAAkC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,yCAAyC;AACzH;AACA,0EAA0E,wIAAwI;AAClN,kEAAkE,oDAAoD;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qEAAqE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAkE;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAkE;AAC1G,sCAAsC,4DAA4D;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;;;;;;ACzRa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,uBAAuB,mBAAO,CAAC,IAAsB;AACrD,2BAA2B,mBAAO,CAAC,KAA0B;AAC7D,0BAA0B,mBAAO,CAAC,KAAyB;AAC3D,qBAAqB,mBAAO,CAAC,KAAoB;AACjD,oBAAoB,mBAAO,CAAC,KAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;ACjGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,wBAAwB,mBAAO,CAAC,KAAkB;AAClD,iBAAiB,mBAAO,CAAC,IAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB;AACpB;;;;;;;AChCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,wBAAwB,mBAAO,CAAC,KAAkB;AAClD,iBAAiB,mBAAO,CAAC,IAAwB;AACjD,oBAAoB,mBAAO,CAAC,KAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wBAAwB;AACxB;AACA;;;;;;;ACtGa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,wBAAwB,mBAAO,CAAC,KAAkB;AAClD,iBAAiB,mBAAO,CAAC,IAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB;AACvB;AACA;;;;;;;AC9Da;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,wBAAwB,mBAAO,CAAC,KAAkB;AAClD,iBAAiB,mBAAO,CAAC,IAAwB;AACjD,oBAAoB,mBAAO,CAAC,KAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA;;;;;;;ACzFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,wBAAwB,mBAAO,CAAC,KAAkB;AAClD,iBAAiB,mBAAO,CAAC,IAAwB;AACjD,oBAAoB,mBAAO,CAAC,KAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iBAAiB;AACjB;AACA;;;;;;;AChIa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,kBAAkB,GAAG,uBAAuB,GAAG,wBAAwB,GAAG,oBAAoB,GAAG,qBAAqB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,mBAAmB;AAC1M,wBAAwB,mBAAO,CAAC,KAAgC;AAChE,iDAAgD,EAAE,qCAAqC,yCAAyC,EAAC;AACjI,sBAAsB,mBAAO,CAAC,KAA8B;AAC5D,+CAA8C,EAAE,qCAAqC,qCAAqC,EAAC;AAC3H,qBAAqB,mBAAO,CAAC,KAA6B;AAC1D,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,uBAAuB,mBAAO,CAAC,IAAqC;AACpE,gDAA+C,EAAE,qCAAqC,uCAAuC,EAAC;AAC9H,2BAA2B,mBAAO,CAAC,KAAyC;AAC5E,oDAAmD,EAAE,qCAAqC,+CAA+C,EAAC;AAC1I,0BAA0B,mBAAO,CAAC,KAAwC;AAC1E,mDAAkD,EAAE,qCAAqC,6CAA6C,EAAC;AACvI,qBAAqB,mBAAO,CAAC,KAAmC;AAChE,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,oBAAoB,mBAAO,CAAC,KAAkC;AAC9D,6CAA4C,EAAE,qCAAqC,iCAAiC,EAAC;AACrH,iBAAiB,mBAAO,CAAC,IAAoB;AAC7C,8CAA6C,EAAE,qCAAqC,+BAA+B,EAAC;AACpH;;;;;;;ACrBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,kBAAkB,KAAK;AAC9D","sources":["webpack://spinlio-workspace/./node_modules/@shapediver/viewer.rendering-engine.intersection-engine/dist/implementation/IntersectionEngine.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.rendering-engine.intersection-engine/dist/index.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.rendering-engine.light-engine/dist/implementation/AbstractLight.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.rendering-engine.light-engine/dist/implementation/LightEngine.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.rendering-engine.light-engine/dist/implementation/LightScene.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.rendering-engine.light-engine/dist/implementation/types/AmbientLight.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.rendering-engine.light-engine/dist/implementation/types/DirectionalLight.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.rendering-engine.light-engine/dist/implementation/types/HemisphereLight.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.rendering-engine.light-engine/dist/implementation/types/PointLight.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.rendering-engine.light-engine/dist/implementation/types/SpotLight.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.rendering-engine.light-engine/dist/index.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.rendering-engine.light-engine/dist/interface/ILight.js"],"sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IntersectionEngine = void 0;\r\nconst THREE = __importStar(require(\"three\"));\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nclass IntersectionEngine {\r\n    // #endregion Properties (5)\r\n    // #region Constructors (1)\r\n    constructor() {\r\n        // #region Properties (5)\r\n        this._eventEngine = viewer_shared_services_1.EventEngine.instance;\r\n        this._raycaster = new THREE.Raycaster();\r\n        this._tree = viewer_shared_node_tree_1.Tree.instance;\r\n        this._intersectNodes = [];\r\n        this.gatherNodes();\r\n        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.VIEWPORT.VIEWPORT_UPDATED, () => {\r\n            this.gatherNodes();\r\n        });\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Static Getters And Setters (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Getters And Setters (1)\r\n    // #region Public Methods (2)\r\n    intersect(ray, viewportId, filterCriteria, rayCasterParams) {\r\n        let intersections = [];\r\n        this._intersectNodes.forEach(i => {\r\n            const currentIntersections = this.intersectNode(ray, i.node, i.geometryData, viewportId, filterCriteria, rayCasterParams);\r\n            if (currentIntersections)\r\n                intersections = intersections.concat(currentIntersections);\r\n        });\r\n        intersections.sort((a, b) => a.distance - b.distance);\r\n        return intersections;\r\n    }\r\n    intersectNode(ray, node, geometryData, viewportId, filterCriteria, rayCasterParams) {\r\n        if (node.visible === false)\r\n            return;\r\n        if (viewportId !== undefined) {\r\n            if (node.excludeViewports.includes(viewportId))\r\n                return;\r\n            if (node.restrictViewports.length > 0 && !node.restrictViewports.includes(viewportId))\r\n                return;\r\n        }\r\n        if (filterCriteria) {\r\n            for (let i = 0; i < filterCriteria.length; i++) {\r\n                if (filterCriteria[i](node))\r\n                    return this.intersectionTest(ray, node, geometryData, viewportId, rayCasterParams);\r\n            }\r\n        }\r\n        else {\r\n            return this.intersectionTest(ray, node, geometryData, viewportId, rayCasterParams);\r\n        }\r\n    }\r\n    // #endregion Public Methods (2)\r\n    // #region Private Methods (2)\r\n    /**\r\n     * Gather all nodes that contain geometry data.\r\n     */\r\n    gatherNodes() {\r\n        this._intersectNodes = [];\r\n        this._tree.root.traverse(node => {\r\n            if (node.visible === false)\r\n                return;\r\n            for (let i = 0; i < node.data.length; i++) {\r\n                if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {\r\n                    const geometryData = node.data[i];\r\n                    let tempNode = node;\r\n                    let visible = true, restrictViewports = [], excludeViewports = [];\r\n                    while (tempNode.parent) {\r\n                        visible = tempNode.visible && visible;\r\n                        restrictViewports = restrictViewports.concat(tempNode.restrictViewports);\r\n                        excludeViewports = excludeViewports.concat(tempNode.excludeViewports);\r\n                        tempNode = tempNode.parent;\r\n                    }\r\n                    this._intersectNodes.push({\r\n                        node,\r\n                        geometryData: { [`${geometryData.id}_${geometryData.version}`]: geometryData },\r\n                        visible,\r\n                        restrictViewports: [...new Set(restrictViewports)],\r\n                        excludeViewports: [...new Set(excludeViewports)]\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Do the intersection test with the ray and the node.\r\n     *\r\n     * @param ray the ray to test\r\n     * @param node the node to test\r\n     * @param geometryData the geometry data of the node\r\n     * @param viewportId the viewport id\r\n     * @returns\r\n     */\r\n    intersectionTest(ray, node, geometryData, viewportId, rayCasterParams) {\r\n        if (rayCasterParams)\r\n            this._raycaster.params = rayCasterParams;\r\n        this._raycaster.ray.direction.set(ray.direction[0], ray.direction[1], ray.direction[2]);\r\n        this._raycaster.ray.origin.set(ray.origin[0], ray.origin[1], ray.origin[2]);\r\n        let intersections = [];\r\n        const threeJsObject = node.convertedObject[viewportId];\r\n        if (threeJsObject) {\r\n            const intersectionThree = this._raycaster.intersectObject(threeJsObject);\r\n            const intersection = intersectionThree.map(i => {\r\n                const intersection = {\r\n                    distance: i.distance,\r\n                    point: [i.point.x, i.point.y, i.point.z],\r\n                    node: node,\r\n                    geometryData: geometryData[`${i.object.parent.SDid}_${i.object.parent.SDversion}`]\r\n                };\r\n                return intersection;\r\n            });\r\n            intersections = intersections.concat(intersection);\r\n        }\r\n        intersections.sort((a, b) => a.distance - b.distance);\r\n        return intersections;\r\n    }\r\n}\r\nexports.IntersectionEngine = IntersectionEngine;\r\n//# sourceMappingURL=IntersectionEngine.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IntersectionEngine = void 0;\r\nconst IntersectionEngine_1 = require(\"./implementation/IntersectionEngine\");\r\nObject.defineProperty(exports, \"IntersectionEngine\", { enumerable: true, get: function () { return IntersectionEngine_1.IntersectionEngine; } });\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _AbstractLight_type, _AbstractLight_color, _AbstractLight_intensity, _AbstractLight_name, _AbstractLight_order, _AbstractLight_parentNode, _AbstractLight_useNodeData;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AbstractLight = void 0;\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nclass AbstractLight extends viewer_shared_node_tree_1.AbstractTreeNodeData {\r\n    // #endregion Properties (8)\r\n    // #region Constructors (1)\r\n    constructor(properties) {\r\n        super(properties.id, properties.version);\r\n        // #region Properties (8)\r\n        _AbstractLight_type.set(this, void 0);\r\n        _AbstractLight_color.set(this, void 0);\r\n        _AbstractLight_intensity.set(this, void 0);\r\n        _AbstractLight_name.set(this, void 0);\r\n        _AbstractLight_order.set(this, void 0);\r\n        _AbstractLight_parentNode.set(this, void 0);\r\n        _AbstractLight_useNodeData.set(this, false);\r\n        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;\r\n        __classPrivateFieldSet(this, _AbstractLight_color, properties.color, \"f\");\r\n        __classPrivateFieldSet(this, _AbstractLight_intensity, properties.intensity, \"f\");\r\n        __classPrivateFieldSet(this, _AbstractLight_type, properties.type, \"f\");\r\n        __classPrivateFieldSet(this, _AbstractLight_name, properties.name, \"f\");\r\n        __classPrivateFieldSet(this, _AbstractLight_order, properties.order, \"f\");\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Getters And Setters (13)\r\n    get color() {\r\n        return __classPrivateFieldGet(this, _AbstractLight_color, \"f\");\r\n    }\r\n    set color(value) {\r\n        __classPrivateFieldSet(this, _AbstractLight_color, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get intensity() {\r\n        return __classPrivateFieldGet(this, _AbstractLight_intensity, \"f\");\r\n    }\r\n    set intensity(value) {\r\n        __classPrivateFieldSet(this, _AbstractLight_intensity, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get name() {\r\n        return __classPrivateFieldGet(this, _AbstractLight_name, \"f\");\r\n    }\r\n    set name(value) {\r\n        __classPrivateFieldSet(this, _AbstractLight_name, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get order() {\r\n        return __classPrivateFieldGet(this, _AbstractLight_order, \"f\");\r\n    }\r\n    set order(value) {\r\n        __classPrivateFieldSet(this, _AbstractLight_order, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get parentNode() {\r\n        return __classPrivateFieldGet(this, _AbstractLight_parentNode, \"f\");\r\n    }\r\n    set parentNode(value) {\r\n        __classPrivateFieldSet(this, _AbstractLight_parentNode, value, \"f\");\r\n    }\r\n    get type() {\r\n        return __classPrivateFieldGet(this, _AbstractLight_type, \"f\");\r\n    }\r\n    get useNodeData() {\r\n        return __classPrivateFieldGet(this, _AbstractLight_useNodeData, \"f\");\r\n    }\r\n    set useNodeData(value) {\r\n        __classPrivateFieldSet(this, _AbstractLight_useNodeData, value, \"f\");\r\n    }\r\n}\r\nexports.AbstractLight = AbstractLight;\r\n_AbstractLight_type = new WeakMap(), _AbstractLight_color = new WeakMap(), _AbstractLight_intensity = new WeakMap(), _AbstractLight_name = new WeakMap(), _AbstractLight_order = new WeakMap(), _AbstractLight_parentNode = new WeakMap(), _AbstractLight_useNodeData = new WeakMap();\r\n//# sourceMappingURL=AbstractLight.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LightEngine = void 0;\r\nconst AmbientLight_1 = require(\"./types/AmbientLight\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst DirectionalLight_1 = require(\"./types/DirectionalLight\");\r\nconst HemisphereLight_1 = require(\"./types/HemisphereLight\");\r\nconst ILight_1 = require(\"../interface/ILight\");\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst LightScene_1 = require(\"./LightScene\");\r\nconst PointLight_1 = require(\"./types/PointLight\");\r\nconst SpotLight_1 = require(\"./types/SpotLight\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nclass LightEngine {\r\n    // #endregion Properties (7)\r\n    // #region Constructors (1)\r\n    constructor(_renderingEngine) {\r\n        this._renderingEngine = _renderingEngine;\r\n        // #region Properties (7)\r\n        this._converter = viewer_shared_services_1.Converter.instance;\r\n        this._lightNode = new viewer_shared_node_tree_1.TreeNode('lights');\r\n        this._tree = viewer_shared_node_tree_1.Tree.instance;\r\n        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;\r\n        this._lightScenes = {};\r\n        this._tree.root.addChild(this._lightNode);\r\n        this._lightNode.restrictViewports = [this._renderingEngine.id];\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Getters And Setters (4)\r\n    get lightScene() {\r\n        return this._lightScene;\r\n    }\r\n    get lightScenes() {\r\n        return this._lightScenes;\r\n    }\r\n    get update() {\r\n        return this._update;\r\n    }\r\n    set update(value) {\r\n        this._update = value;\r\n    }\r\n    // #endregion Public Getters And Setters (4)\r\n    // #region Public Methods (6)\r\n    applySettings(settingsEngine) {\r\n        this._lightScenes = {};\r\n        for (const lightSceneId in settingsEngine.light.lightScenes) {\r\n            const lightSceneUUID = this._uuidGenerator.validate(lightSceneId) ? lightSceneId : this._uuidGenerator.create();\r\n            const lightSceneName = settingsEngine.light.lightScenes[lightSceneId].name ? settingsEngine.light.lightScenes[lightSceneId].name : lightSceneId;\r\n            const ls = new LightScene_1.LightScene(this._renderingEngine, { id: lightSceneUUID, name: lightSceneName });\r\n            for (const lightId in settingsEngine.light.lightScenes[lightSceneId].lights) {\r\n                const lightUUID = this._uuidGenerator.validate(lightId) ? lightId : this._uuidGenerator.create();\r\n                const light = settingsEngine.light.lightScenes[lightSceneId].lights[lightId];\r\n                let l;\r\n                switch (light.type) {\r\n                    case ILight_1.LIGHT_TYPE.DIRECTIONAL:\r\n                        l = new DirectionalLight_1.DirectionalLight({\r\n                            color: this._converter.toHexColor(light.properties.color),\r\n                            intensity: light.properties.intensity,\r\n                            direction: this._converter.toVec3(light.properties.direction),\r\n                            castShadow: light.properties.castShadow,\r\n                            shadowMapResolution: light.properties.shadowMapResolution,\r\n                            shadowMapBias: light.properties.shadowMapBias,\r\n                            name: light.name ? light.name : lightId,\r\n                            order: light.order,\r\n                            id: lightUUID\r\n                        });\r\n                        break;\r\n                    case ILight_1.LIGHT_TYPE.HEMISPHERE:\r\n                        l = new HemisphereLight_1.HemisphereLight({\r\n                            color: this._converter.toHexColor(light.properties.skyColor),\r\n                            intensity: light.properties.intensity,\r\n                            groundColor: this._converter.toHexColor(light.properties.groundColor),\r\n                            name: light.name ? light.name : lightId,\r\n                            order: light.order,\r\n                            id: lightUUID\r\n                        });\r\n                        break;\r\n                    case ILight_1.LIGHT_TYPE.POINT:\r\n                        l = new PointLight_1.PointLight({\r\n                            color: this._converter.toHexColor(light.properties.color),\r\n                            intensity: light.properties.intensity,\r\n                            position: this._converter.toVec3(light.properties.position),\r\n                            distance: light.properties.distance,\r\n                            decay: light.properties.decay,\r\n                            name: light.name ? light.name : lightId,\r\n                            order: light.order,\r\n                            id: lightUUID\r\n                        });\r\n                        break;\r\n                    case ILight_1.LIGHT_TYPE.SPOT:\r\n                        l = new SpotLight_1.SpotLight({\r\n                            color: this._converter.toHexColor(light.properties.color),\r\n                            intensity: light.properties.intensity,\r\n                            position: this._converter.toVec3(light.properties.position),\r\n                            target: this._converter.toVec3(light.properties.target),\r\n                            distance: light.properties.distance,\r\n                            decay: light.properties.decay,\r\n                            angle: light.properties.angle,\r\n                            penumbra: light.properties.penumbra,\r\n                            name: light.name ? light.name : lightId,\r\n                            order: light.order,\r\n                            id: lightUUID\r\n                        });\r\n                        break;\r\n                    case ILight_1.LIGHT_TYPE.AMBIENT:\r\n                    default:\r\n                        l = new AmbientLight_1.AmbientLight({\r\n                            color: this._converter.toHexColor(light.properties.color),\r\n                            intensity: light.properties.intensity,\r\n                            name: light.name ? light.name : lightId,\r\n                            order: light.order,\r\n                            id: lightUUID\r\n                        });\r\n                }\r\n                ls.addLight(l);\r\n            }\r\n            this._lightScenes[ls.id] = ls;\r\n        }\r\n        // there is a light scene but no id is saved (old viewer)\r\n        if (settingsEngine.light.lightSceneId === undefined && Object.values(settingsEngine.light.lightScenes).length > 0) {\r\n            const res = this.assignLightScene(Object.keys(settingsEngine.light.lightScenes)[0]);\r\n            if (res === false) {\r\n                const ls = this.createLightScene({ name: settingsEngine.light.lightSceneId === 'default' ? 'default' : 'standard' });\r\n                ls.addLight(new AmbientLight_1.AmbientLight({ color: '#ffffff', intensity: 0.5, name: 'ambient0' }));\r\n                ls.addLight(new DirectionalLight_1.DirectionalLight({ color: '#ffffff', intensity: 0.75, direction: gl_matrix_1.vec3.fromValues(.5774, -.5774, .5774), castShadow: true, name: 'directional0' }));\r\n                ls.addLight(new DirectionalLight_1.DirectionalLight({ color: '#ffffff', intensity: 0.35, direction: gl_matrix_1.vec3.fromValues(.25, -1, 1), castShadow: false, name: 'directional1' }));\r\n                this._lightScenes[ls.id] = ls;\r\n            }\r\n        } // there is no standard light scene in the light scenes, but a light scene name is specified (old viewer)\r\n        else if (settingsEngine.light.lightSceneId) {\r\n            const res = this.assignLightScene(settingsEngine.light.lightSceneId);\r\n            if (res === false) {\r\n                const ls = this.createLightScene({ name: settingsEngine.light.lightSceneId === 'default' ? 'default' : 'standard' });\r\n                ls.addLight(new AmbientLight_1.AmbientLight({ color: '#ffffff', intensity: 0.5, name: 'ambient0' }));\r\n                ls.addLight(new DirectionalLight_1.DirectionalLight({ color: '#ffffff', intensity: 0.75, direction: gl_matrix_1.vec3.fromValues(.5774, -.5774, .5774), castShadow: true, name: 'directional0' }));\r\n                ls.addLight(new DirectionalLight_1.DirectionalLight({ color: '#ffffff', intensity: 0.35, direction: gl_matrix_1.vec3.fromValues(.25, -1, 1), castShadow: false, name: 'directional1' }));\r\n                this._lightScenes[ls.id] = ls;\r\n            }\r\n        }\r\n        // this can only be the case if the settings were completely empty, therefore we assign the new light scene\r\n        else if (JSON.stringify(settingsEngine.settingsJson) == JSON.stringify({})) {\r\n            const ls = this.createLightScene({ name: 'standard', standard: true });\r\n            this._lightScenes[ls.id] = ls;\r\n        }\r\n        if (this._update)\r\n            this._update();\r\n    }\r\n    assignLightScene(id) {\r\n        if (!this._lightScenes[id]) {\r\n            for (const lightSceneId in this._lightScenes) {\r\n                const lightScene = this._lightScenes[lightSceneId];\r\n                const lightSceneName = lightScene.name || lightSceneId;\r\n                if (lightSceneName === id) {\r\n                    const res = this.assignLightScene(lightSceneId);\r\n                    return res;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        this._lightScene = this._lightScenes[id];\r\n        while (this._lightNode.children.length > 0)\r\n            this._lightNode.removeChild(this._lightNode.children[0]);\r\n        this._lightNode.addChild(this._lightScene.node);\r\n        this._lightNode.updateVersion();\r\n        return true;\r\n    }\r\n    close() {\r\n        this._tree.root.removeChild(this._lightNode);\r\n    }\r\n    createLightScene(properties) {\r\n        const lightSceneId = this._uuidGenerator.create();\r\n        const lightScene = new LightScene_1.LightScene(this._renderingEngine, { id: lightSceneId, name: properties.name });\r\n        if (properties.standard === true) {\r\n            lightScene.addLight(new DirectionalLight_1.DirectionalLight({ color: '#ffffff', intensity: 2.5, direction: gl_matrix_1.vec3.fromValues(.5774, -.5774, .5774), castShadow: true, name: 'directional0' }));\r\n            lightScene.addLight(new AmbientLight_1.AmbientLight({ color: '#ffffff', intensity: 0.3, name: 'ambient0' }));\r\n        }\r\n        this._lightScenes[lightSceneId] = lightScene;\r\n        this._lightScene = lightScene;\r\n        while (this._lightNode.children.length > 0)\r\n            this._lightNode.removeChild(this._lightNode.children[0]);\r\n        this._lightNode.addChild(this._lightScene.node);\r\n        this._lightNode.updateVersion();\r\n        if (this._update)\r\n            this._update();\r\n        return lightScene;\r\n    }\r\n    removeLightScene(id) {\r\n        if (!this._lightScenes[id]) {\r\n            for (const lightSceneId in this._lightScenes) {\r\n                const lightScene = this._lightScenes[lightSceneId];\r\n                const lightSceneName = lightScene.name || lightSceneId;\r\n                if (lightSceneName === id) {\r\n                    const res = this.removeLightScene(lightSceneId);\r\n                    return res;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        if (this._lightScene && this._lightScene.id === id) {\r\n            this._lightScene = undefined;\r\n            while (this._lightNode.children.length > 0)\r\n                this._lightNode.removeChild(this._lightNode.children[0]);\r\n            this._lightNode.updateVersion();\r\n        }\r\n        delete this._lightScenes[id];\r\n        if (this._update)\r\n            this._update();\r\n        return true;\r\n    }\r\n    saveSettings(settingsEngine) {\r\n        settingsEngine.light.lightSceneId = this.lightScene ? this.lightScene.id : undefined;\r\n        const converted = {};\r\n        for (const lightSceneId in this._lightScenes) {\r\n            const lightScene = this._lightScenes[lightSceneId];\r\n            const lightSceneName = lightScene.name || lightSceneId;\r\n            converted[lightSceneId] = {\r\n                name: lightSceneName,\r\n                lights: {}\r\n            };\r\n            for (const lightId in lightScene.lights) {\r\n                const light = lightScene.lights[lightId];\r\n                let properties;\r\n                switch (light.type) {\r\n                    case ILight_1.LIGHT_TYPE.DIRECTIONAL:\r\n                        properties = {\r\n                            color: this._converter.toHexColor(light.color),\r\n                            intensity: light.intensity,\r\n                            direction: { x: light.direction[0], y: light.direction[1], z: light.direction[2] },\r\n                            castShadow: light.castShadow,\r\n                            shadowMapResolution: light.shadowMapResolution,\r\n                            shadowMapBias: light.shadowMapBias\r\n                        };\r\n                        break;\r\n                    case ILight_1.LIGHT_TYPE.HEMISPHERE:\r\n                        properties = {\r\n                            skyColor: this._converter.toHexColor(light.color),\r\n                            intensity: light.intensity,\r\n                            groundColor: this._converter.toHexColor(light.groundColor)\r\n                        };\r\n                        break;\r\n                    case ILight_1.LIGHT_TYPE.POINT:\r\n                        properties = {\r\n                            color: this._converter.toHexColor(light.color),\r\n                            intensity: light.intensity,\r\n                            position: { x: light.position[0], y: light.position[1], z: light.position[2] },\r\n                            distance: light.distance,\r\n                            decay: light.decay\r\n                        };\r\n                        break;\r\n                    case ILight_1.LIGHT_TYPE.SPOT:\r\n                        properties = {\r\n                            color: this._converter.toHexColor(light.color),\r\n                            intensity: light.intensity,\r\n                            position: { x: light.position[0], y: light.position[1], z: light.position[2] },\r\n                            target: { x: light.target[0], y: light.target[1], z: light.target[2] },\r\n                            distance: light.distance,\r\n                            decay: light.decay,\r\n                            angle: light.angle,\r\n                            penumbra: light.penumbra\r\n                        };\r\n                        break;\r\n                    case ILight_1.LIGHT_TYPE.AMBIENT:\r\n                    default:\r\n                        properties = {\r\n                            color: this._converter.toHexColor(light.color),\r\n                            intensity: light.intensity\r\n                        };\r\n                }\r\n                converted[lightSceneId].lights[lightId] = {\r\n                    name: light.name,\r\n                    type: light.type,\r\n                    properties\r\n                };\r\n                if (light.order !== undefined)\r\n                    converted[lightSceneId].lights[lightId].order = light.order;\r\n            }\r\n        }\r\n        settingsEngine.light.lightScenes = converted;\r\n    }\r\n}\r\nexports.LightEngine = LightEngine;\r\n//# sourceMappingURL=LightEngine.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LightScene = void 0;\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst AmbientLight_1 = require(\"./types/AmbientLight\");\r\nconst DirectionalLight_1 = require(\"./types/DirectionalLight\");\r\nconst HemisphereLight_1 = require(\"./types/HemisphereLight\");\r\nconst PointLight_1 = require(\"./types/PointLight\");\r\nconst SpotLight_1 = require(\"./types/SpotLight\");\r\nclass LightScene {\r\n    // #endregion Properties (5)\r\n    // #region Constructors (1)\r\n    constructor(_renderingEngine, properties) {\r\n        this._renderingEngine = _renderingEngine;\r\n        this._lights = {};\r\n        this._id = properties.id;\r\n        this._name = properties.name;\r\n        this._node = new viewer_shared_node_tree_1.TreeNode(properties.name || properties.id);\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Accessors (5)\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    get lights() {\r\n        return this._lights;\r\n    }\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    set name(value) {\r\n        this._name = value;\r\n    }\r\n    get node() {\r\n        return this._node;\r\n    }\r\n    get update() {\r\n        return this._update;\r\n    }\r\n    set update(value) {\r\n        this._update = value;\r\n    }\r\n    // #endregion Public Accessors (5)\r\n    // #region Public Methods (8)\r\n    addAmbientLight(properties) {\r\n        const light = new AmbientLight_1.AmbientLight(properties);\r\n        this.addLight(light);\r\n        return light;\r\n    }\r\n    addDirectionalLight(properties) {\r\n        const light = new DirectionalLight_1.DirectionalLight(properties);\r\n        this.addLight(light);\r\n        return light;\r\n    }\r\n    addHemisphereLight(properties) {\r\n        const light = new HemisphereLight_1.HemisphereLight(properties);\r\n        this.addLight(light);\r\n        return light;\r\n    }\r\n    addLight(light) {\r\n        const node = new viewer_shared_node_tree_1.TreeNode(light.id);\r\n        light.parentNode = node;\r\n        node.data.push(light);\r\n        this._node.addChild(node);\r\n        this._lights[light.id] = light;\r\n        this._node.updateVersion();\r\n        if (this._update)\r\n            this._update();\r\n    }\r\n    addPointLight(properties) {\r\n        const light = new PointLight_1.PointLight(properties);\r\n        this.addLight(light);\r\n        return light;\r\n    }\r\n    addSpotLight(properties) {\r\n        const light = new SpotLight_1.SpotLight(properties);\r\n        this.addLight(light);\r\n        return light;\r\n    }\r\n    removeLight(id) {\r\n        if (!this._lights[id])\r\n            return false;\r\n        for (let i = 0; i < this._node.children.length; i++) {\r\n            const node = this._node.children[i];\r\n            if (node && node.name === id) {\r\n                this._node.removeChild(node);\r\n                break;\r\n            }\r\n        }\r\n        delete this._lights[id];\r\n        this._node.updateVersion();\r\n        if (this._update)\r\n            this._update();\r\n        return true;\r\n    }\r\n}\r\nexports.LightScene = LightScene;\r\n//# sourceMappingURL=LightScene.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AmbientLight = void 0;\r\nconst AbstractLight_1 = require(\"../AbstractLight\");\r\nconst ILight_1 = require(\"../../interface/ILight\");\r\nclass AmbientLight extends AbstractLight_1.AbstractLight {\r\n    // #region Constructors (1)\r\n    constructor(properties) {\r\n        super({\r\n            color: properties.color || '#ffffff',\r\n            intensity: properties.intensity !== undefined ? properties.intensity : 1,\r\n            type: ILight_1.LIGHT_TYPE.AMBIENT,\r\n            name: properties.name,\r\n            order: properties.order,\r\n            id: properties.id,\r\n            version: properties.version\r\n        });\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Methods (1)\r\n    clone() {\r\n        return new AmbientLight({\r\n            color: this.color || '#ffffff',\r\n            intensity: this.intensity || 0.5,\r\n            name: this.name,\r\n            order: this.order,\r\n            id: this.id,\r\n            version: this.version\r\n        });\r\n    }\r\n}\r\nexports.AmbientLight = AmbientLight;\r\n//# sourceMappingURL=AmbientLight.js.map","\"use strict\";\r\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _DirectionalLight_castShadow, _DirectionalLight_direction, _DirectionalLight_shadowMapBias, _DirectionalLight_shadowMapResolution;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DirectionalLight = void 0;\r\nconst AbstractLight_1 = require(\"../AbstractLight\");\r\nconst ILight_1 = require(\"../../interface/ILight\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nclass DirectionalLight extends AbstractLight_1.AbstractLight {\r\n    // #endregion Properties (4)\r\n    // #region Constructors (1)\r\n    constructor(properties) {\r\n        super({\r\n            color: properties.color || '#ffffff',\r\n            intensity: properties.intensity !== undefined ? properties.intensity : 1,\r\n            type: ILight_1.LIGHT_TYPE.DIRECTIONAL,\r\n            name: properties.name,\r\n            order: properties.order,\r\n            id: properties.id,\r\n            version: properties.version\r\n        });\r\n        // #region Properties (4)\r\n        _DirectionalLight_castShadow.set(this, true);\r\n        _DirectionalLight_direction.set(this, gl_matrix_1.vec3.fromValues(-1, 0, 1));\r\n        _DirectionalLight_shadowMapBias.set(this, -0.003);\r\n        _DirectionalLight_shadowMapResolution.set(this, 1024);\r\n        if (properties.direction)\r\n            __classPrivateFieldSet(this, _DirectionalLight_direction, properties.direction, \"f\");\r\n        if (properties.castShadow !== undefined)\r\n            __classPrivateFieldSet(this, _DirectionalLight_castShadow, properties.castShadow, \"f\");\r\n        if (properties.shadowMapResolution)\r\n            __classPrivateFieldSet(this, _DirectionalLight_shadowMapResolution, properties.shadowMapResolution, \"f\");\r\n        if (properties.shadowMapBias)\r\n            __classPrivateFieldSet(this, _DirectionalLight_shadowMapBias, properties.shadowMapBias, \"f\");\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Getters And Setters (8)\r\n    get castShadow() {\r\n        return __classPrivateFieldGet(this, _DirectionalLight_castShadow, \"f\");\r\n    }\r\n    set castShadow(value) {\r\n        __classPrivateFieldSet(this, _DirectionalLight_castShadow, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get direction() {\r\n        return __classPrivateFieldGet(this, _DirectionalLight_direction, \"f\");\r\n    }\r\n    set direction(value) {\r\n        __classPrivateFieldSet(this, _DirectionalLight_direction, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get shadowMapBias() {\r\n        return __classPrivateFieldGet(this, _DirectionalLight_shadowMapBias, \"f\");\r\n    }\r\n    set shadowMapBias(value) {\r\n        __classPrivateFieldSet(this, _DirectionalLight_shadowMapBias, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get shadowMapResolution() {\r\n        return __classPrivateFieldGet(this, _DirectionalLight_shadowMapResolution, \"f\");\r\n    }\r\n    set shadowMapResolution(value) {\r\n        __classPrivateFieldSet(this, _DirectionalLight_shadowMapResolution, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    // #endregion Public Getters And Setters (8)\r\n    // #region Public Methods (1)\r\n    clone() {\r\n        return new DirectionalLight({\r\n            color: this.color,\r\n            intensity: this.intensity,\r\n            direction: this.direction,\r\n            castShadow: this.castShadow,\r\n            shadowMapResolution: this.shadowMapResolution,\r\n            shadowMapBias: this.shadowMapBias,\r\n            name: this.name,\r\n            order: this.order,\r\n            id: this.id,\r\n            version: this.version\r\n        });\r\n    }\r\n}\r\nexports.DirectionalLight = DirectionalLight;\r\n_DirectionalLight_castShadow = new WeakMap(), _DirectionalLight_direction = new WeakMap(), _DirectionalLight_shadowMapBias = new WeakMap(), _DirectionalLight_shadowMapResolution = new WeakMap();\r\n//# sourceMappingURL=DirectionalLight.js.map","\"use strict\";\r\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _HemisphereLight_groundColor;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HemisphereLight = void 0;\r\nconst AbstractLight_1 = require(\"../AbstractLight\");\r\nconst ILight_1 = require(\"../../interface/ILight\");\r\nclass HemisphereLight extends AbstractLight_1.AbstractLight {\r\n    // #endregion Properties (1)\r\n    // #region Constructors (1)\r\n    constructor(properties) {\r\n        super({\r\n            color: properties.color || '#ffffff',\r\n            intensity: properties.intensity !== undefined ? properties.intensity : 1,\r\n            type: ILight_1.LIGHT_TYPE.HEMISPHERE,\r\n            name: properties.name,\r\n            order: properties.order,\r\n            id: properties.id,\r\n            version: properties.version\r\n        });\r\n        // #region Properties (1)\r\n        _HemisphereLight_groundColor.set(this, '#000000');\r\n        if (properties.groundColor)\r\n            __classPrivateFieldSet(this, _HemisphereLight_groundColor, properties.groundColor, \"f\");\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Getters And Setters (2)\r\n    get groundColor() {\r\n        return __classPrivateFieldGet(this, _HemisphereLight_groundColor, \"f\");\r\n    }\r\n    set groundColor(value) {\r\n        __classPrivateFieldSet(this, _HemisphereLight_groundColor, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    // #endregion Public Getters And Setters (2)\r\n    // #region Public Methods (1)\r\n    clone() {\r\n        return new HemisphereLight({\r\n            color: this.color,\r\n            groundColor: this.groundColor,\r\n            intensity: this.intensity,\r\n            name: this.name,\r\n            order: this.order,\r\n            id: this.id,\r\n            version: this.version\r\n        });\r\n    }\r\n}\r\nexports.HemisphereLight = HemisphereLight;\r\n_HemisphereLight_groundColor = new WeakMap();\r\n//# sourceMappingURL=HemisphereLight.js.map","\"use strict\";\r\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _PointLight_decay, _PointLight_distance, _PointLight_position;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PointLight = void 0;\r\nconst AbstractLight_1 = require(\"../AbstractLight\");\r\nconst ILight_1 = require(\"../../interface/ILight\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nclass PointLight extends AbstractLight_1.AbstractLight {\r\n    // #endregion Properties (3)\r\n    // #region Constructors (1)\r\n    constructor(properties) {\r\n        super({\r\n            color: properties.color || '#ffffff',\r\n            intensity: properties.intensity !== undefined ? properties.intensity : 1,\r\n            type: ILight_1.LIGHT_TYPE.POINT,\r\n            name: properties.name,\r\n            order: properties.order,\r\n            id: properties.id,\r\n            version: properties.version\r\n        });\r\n        // #region Properties (3)\r\n        _PointLight_decay.set(this, 0);\r\n        _PointLight_distance.set(this, 0);\r\n        _PointLight_position.set(this, gl_matrix_1.vec3.fromValues(0, 0, 0));\r\n        if (properties.position)\r\n            __classPrivateFieldSet(this, _PointLight_position, properties.position, \"f\");\r\n        if (properties.distance)\r\n            __classPrivateFieldSet(this, _PointLight_distance, properties.distance, \"f\");\r\n        if (properties.decay)\r\n            __classPrivateFieldSet(this, _PointLight_decay, properties.decay, \"f\");\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Getters And Setters (6)\r\n    get decay() {\r\n        return __classPrivateFieldGet(this, _PointLight_decay, \"f\");\r\n    }\r\n    set decay(value) {\r\n        __classPrivateFieldSet(this, _PointLight_decay, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get distance() {\r\n        return __classPrivateFieldGet(this, _PointLight_distance, \"f\");\r\n    }\r\n    set distance(value) {\r\n        __classPrivateFieldSet(this, _PointLight_distance, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get position() {\r\n        return __classPrivateFieldGet(this, _PointLight_position, \"f\");\r\n    }\r\n    set position(value) {\r\n        __classPrivateFieldSet(this, _PointLight_position, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    // #endregion Public Getters And Setters (6)\r\n    // #region Public Methods (1)\r\n    clone() {\r\n        return new PointLight({\r\n            color: this.color,\r\n            position: this.position,\r\n            distance: this.distance,\r\n            decay: this.decay,\r\n            intensity: this.intensity,\r\n            name: this.name,\r\n            order: this.order,\r\n            id: this.id,\r\n            version: this.version\r\n        });\r\n    }\r\n}\r\nexports.PointLight = PointLight;\r\n_PointLight_decay = new WeakMap(), _PointLight_distance = new WeakMap(), _PointLight_position = new WeakMap();\r\n//# sourceMappingURL=PointLight.js.map","\"use strict\";\r\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _SpotLight_angle, _SpotLight_decay, _SpotLight_distance, _SpotLight_penumbra, _SpotLight_position, _SpotLight_target;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SpotLight = void 0;\r\nconst AbstractLight_1 = require(\"../AbstractLight\");\r\nconst ILight_1 = require(\"../../interface/ILight\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nclass SpotLight extends AbstractLight_1.AbstractLight {\r\n    // #endregion Properties (6)\r\n    // #region Constructors (1)\r\n    constructor(properties) {\r\n        super({\r\n            color: properties.color || '#ffffff',\r\n            intensity: properties.intensity !== undefined ? properties.intensity : 1,\r\n            type: ILight_1.LIGHT_TYPE.SPOT,\r\n            name: properties.name,\r\n            order: properties.order,\r\n            id: properties.id,\r\n            version: properties.version\r\n        });\r\n        // #region Properties (6)\r\n        _SpotLight_angle.set(this, Math.PI / 4.0);\r\n        _SpotLight_decay.set(this, 0);\r\n        _SpotLight_distance.set(this, 0);\r\n        _SpotLight_penumbra.set(this, 0.5);\r\n        _SpotLight_position.set(this, gl_matrix_1.vec3.fromValues(-1, 0, 1));\r\n        _SpotLight_target.set(this, gl_matrix_1.vec3.fromValues(0, 0, 0));\r\n        if (properties.position)\r\n            __classPrivateFieldSet(this, _SpotLight_position, properties.position, \"f\");\r\n        if (properties.target)\r\n            __classPrivateFieldSet(this, _SpotLight_target, properties.target, \"f\");\r\n        if (properties.distance)\r\n            __classPrivateFieldSet(this, _SpotLight_distance, properties.distance, \"f\");\r\n        if (properties.decay)\r\n            __classPrivateFieldSet(this, _SpotLight_decay, properties.decay, \"f\");\r\n        if (properties.angle)\r\n            __classPrivateFieldSet(this, _SpotLight_angle, properties.angle, \"f\");\r\n        if (properties.penumbra)\r\n            __classPrivateFieldSet(this, _SpotLight_penumbra, properties.penumbra, \"f\");\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Getters And Setters (12)\r\n    get angle() {\r\n        return __classPrivateFieldGet(this, _SpotLight_angle, \"f\");\r\n    }\r\n    set angle(value) {\r\n        __classPrivateFieldSet(this, _SpotLight_angle, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get decay() {\r\n        return __classPrivateFieldGet(this, _SpotLight_decay, \"f\");\r\n    }\r\n    set decay(value) {\r\n        __classPrivateFieldSet(this, _SpotLight_decay, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get distance() {\r\n        return __classPrivateFieldGet(this, _SpotLight_distance, \"f\");\r\n    }\r\n    set distance(value) {\r\n        __classPrivateFieldSet(this, _SpotLight_distance, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get penumbra() {\r\n        return __classPrivateFieldGet(this, _SpotLight_penumbra, \"f\");\r\n    }\r\n    set penumbra(value) {\r\n        __classPrivateFieldSet(this, _SpotLight_penumbra, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get position() {\r\n        return __classPrivateFieldGet(this, _SpotLight_position, \"f\");\r\n    }\r\n    set position(value) {\r\n        __classPrivateFieldSet(this, _SpotLight_position, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    get target() {\r\n        return __classPrivateFieldGet(this, _SpotLight_target, \"f\");\r\n    }\r\n    set target(value) {\r\n        __classPrivateFieldSet(this, _SpotLight_target, value, \"f\");\r\n        this.updateVersion();\r\n        if (this.parentNode)\r\n            this.parentNode.updateVersion();\r\n    }\r\n    // #endregion Public Getters And Setters (12)\r\n    // #region Public Methods (1)\r\n    clone() {\r\n        return new SpotLight({\r\n            color: this.color,\r\n            position: this.position,\r\n            target: this.target,\r\n            distance: this.distance,\r\n            decay: this.decay,\r\n            angle: this.angle,\r\n            penumbra: this.penumbra,\r\n            intensity: this.intensity,\r\n            name: this.name,\r\n            order: this.order,\r\n            id: this.id,\r\n            version: this.version\r\n        });\r\n    }\r\n}\r\nexports.SpotLight = SpotLight;\r\n_SpotLight_angle = new WeakMap(), _SpotLight_decay = new WeakMap(), _SpotLight_distance = new WeakMap(), _SpotLight_penumbra = new WeakMap(), _SpotLight_position = new WeakMap(), _SpotLight_target = new WeakMap();\r\n//# sourceMappingURL=SpotLight.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SpotLight = exports.PointLight = exports.HemisphereLight = exports.DirectionalLight = exports.AmbientLight = exports.AbstractLight = exports.LightScene = exports.LIGHT_TYPE = exports.LightEngine = void 0;\r\nconst AbstractLight_1 = require(\"./implementation/AbstractLight\");\r\nObject.defineProperty(exports, \"AbstractLight\", { enumerable: true, get: function () { return AbstractLight_1.AbstractLight; } });\r\nconst LightEngine_1 = require(\"./implementation/LightEngine\");\r\nObject.defineProperty(exports, \"LightEngine\", { enumerable: true, get: function () { return LightEngine_1.LightEngine; } });\r\nconst LightScene_1 = require(\"./implementation/LightScene\");\r\nObject.defineProperty(exports, \"LightScene\", { enumerable: true, get: function () { return LightScene_1.LightScene; } });\r\nconst AmbientLight_1 = require(\"./implementation/types/AmbientLight\");\r\nObject.defineProperty(exports, \"AmbientLight\", { enumerable: true, get: function () { return AmbientLight_1.AmbientLight; } });\r\nconst DirectionalLight_1 = require(\"./implementation/types/DirectionalLight\");\r\nObject.defineProperty(exports, \"DirectionalLight\", { enumerable: true, get: function () { return DirectionalLight_1.DirectionalLight; } });\r\nconst HemisphereLight_1 = require(\"./implementation/types/HemisphereLight\");\r\nObject.defineProperty(exports, \"HemisphereLight\", { enumerable: true, get: function () { return HemisphereLight_1.HemisphereLight; } });\r\nconst PointLight_1 = require(\"./implementation/types/PointLight\");\r\nObject.defineProperty(exports, \"PointLight\", { enumerable: true, get: function () { return PointLight_1.PointLight; } });\r\nconst SpotLight_1 = require(\"./implementation/types/SpotLight\");\r\nObject.defineProperty(exports, \"SpotLight\", { enumerable: true, get: function () { return SpotLight_1.SpotLight; } });\r\nconst ILight_1 = require(\"./interface/ILight\");\r\nObject.defineProperty(exports, \"LIGHT_TYPE\", { enumerable: true, get: function () { return ILight_1.LIGHT_TYPE; } });\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LIGHT_TYPE = void 0;\r\nvar LIGHT_TYPE;\r\n(function (LIGHT_TYPE) {\r\n    LIGHT_TYPE[\"AMBIENT\"] = \"ambient\";\r\n    LIGHT_TYPE[\"DIRECTIONAL\"] = \"directional\";\r\n    LIGHT_TYPE[\"HEMISPHERE\"] = \"hemisphere\";\r\n    LIGHT_TYPE[\"POINT\"] = \"point\";\r\n    LIGHT_TYPE[\"RECTANGLE\"] = \"rectangle\";\r\n    LIGHT_TYPE[\"SPOT\"] = \"spot\";\r\n})(LIGHT_TYPE = exports.LIGHT_TYPE || (exports.LIGHT_TYPE = {}));\r\n//# sourceMappingURL=ILight.js.map"],"names":[],"sourceRoot":""}