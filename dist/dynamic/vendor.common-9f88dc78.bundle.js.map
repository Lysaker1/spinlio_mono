{"version":3,"file":"vendor.common-9f88dc78.bundle.js","mappings":";;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,0BAA0B,GAAG,eAAe,GAAG,iBAAiB,GAAG,sBAAsB,GAAG,mBAAmB;AACxI,mCAAmC,mBAAO,CAAC,KAAsC;AACjF,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,6CAA6C,mBAAO,CAAC,KAAgD;AACrG,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,MAAM;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,MAAM;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,MAAM;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,MAAM;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,MAAM;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,KAAK;AACxE;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,GAAG;AACvE;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,oDAAoD,sEAAsE;AAC1H;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;;;;;;AC3Ia;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC;AACpC,mCAAmC,mBAAO,CAAC,KAAsC;AACjF,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,0BAA0B,mBAAO,CAAC,KAA6B;AAC/D,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,+CAA+C,mBAAO,CAAC,IAAkD;AACzG,oCAAoC,mBAAO,CAAC,IAA6B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oJAAoJ,GAAG;AACvJ;AACA,+CAA+C,QAAQ,mLAAmL;AAC1O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8IAA8I;AAC9I,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gKAAgK,eAAe;AAC/K,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sHAAsH;AAC3J;AACA;AACA;AACA,yCAAyC,oIAAoI;AAC7K;AACA,+JAA+J,gBAAgB;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,oCAAoC,8HAA8H;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,oCAAoC;AACpC,yBAAyB;AACzB;AACA,4LAA4L,4BAA4B;AACxN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,oCAAoC;AACpC,yBAAyB;AACzB;AACA;AACA,gMAAgM,4BAA4B;AAC5N;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,8IAA8I,iBAAiB;AAC/J;AACA;AACA;AACA,kJAAkJ;AAClJ,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qHAAqH;AACxJ;AACA,qKAAqK,4BAA4B;AACjM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+IAA+I;AACtL;AACA;AACA,uCAAuC,4HAA4H;AACnK;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,UAAU;AACnH;AACA;AACA,2FAA2F,UAAU;AACrG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;;;;;;;ACxUa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;;;;;;;ACjEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC;AACpC,uCAAuC,mBAAO,CAAC,KAA+C;AAC9F,gEAA+D,EAAE,qCAAqC,uEAAuE,EAAC;AAC9K;;;;;;;ACLa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qCAAqC;AACrC,6BAA6B,mBAAO,CAAC,KAAgC;AACrE,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,2DAA2D,mBAAO,CAAC,KAA8D;AACjI,qCAAqC,mBAAO,CAAC,KAA8B;AAC3E,mDAAmD,mBAAO,CAAC,KAAsD;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,0FAA0F;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6JAA6J,GAAG;AAChK;AACA,+CAA+C,QAAQ,qLAAqL;AAC5O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mKAAmK,gBAAgB;AACnL,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wHAAwH;AAC7J;AACA;AACA;AACA,yCAAyC,sIAAsI;AAC/K;AACA,gKAAgK,iBAAiB;AACjL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iJAAiJ,iBAAiB;AAClK,mCAAmC,uHAAuH;AAC1J;AACA;AACA,wKAAwK,8BAA8B;AACtM;AACA;AACA;AACA;AACA,uCAAuC,kJAAkJ;AACzL;AACA;AACA;AACA;AACA,yCAAyC;AACzC,uCAAuC,uIAAuI;AAC9K;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,qCAAqC;AACrC;AACA;;;;;;;AC9Na;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC;AAClC,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;;;;;;;ACjFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qCAAqC;AACrC,wCAAwC,mBAAO,CAAC,KAAgD;AAChG,iEAAgE,EAAE,qCAAqC,yEAAyE,EAAC;AACjL;;;;;;;ACLa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,6CAA6C,mBAAO,CAAC,KAAgD;AACrG,wDAAwD,mBAAO,CAAC,KAA2D;AAC3H,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,oBAAoB,mBAAO,CAAC,KAAW;AACvC,6CAA6C,mBAAO,CAAC,KAAgD;AACrG,yCAAyC,mBAAO,CAAC,KAA4C;AAC7F,0CAA0C,mBAAO,CAAC,KAA6C;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,mIAAmI;AACrO;AACA,gGAAgG,kIAAkI;AAClO;AACA;AACA,kGAAkG,yHAAyH;AAC3N;AACA,gGAAgG,wHAAwH;AACxN;AACA;AACA,kGAAkG,yHAAyH;AAC3N;AACA,gGAAgG,wHAAwH;AACxN;AACA;AACA,kGAAkG,2HAA2H;AAC7N;AACA,gGAAgG,0HAA0H;AAC1N;AACA;AACA,kGAAkG,+HAA+H;AACjO;AACA,oFAAoF;AACpF,gGAAgG,8HAA8H;AAC9N;AACA;AACA;AACA,gCAAgC,oCAAoC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;;;;;;;AClGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,qBAAqB,mBAAO,CAAC,KAAc;AAC3C,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,8CAA8C,mBAAO,CAAC,KAAiD;AACvG;AACA;AACA;;;;;;;ACRa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,qBAAqB,mBAAO,CAAC,KAAqB;AAClD,qBAAqB,mBAAO,CAAC,IAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB;AACtB;;;;;;;ACzIa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,0CAA0C,mBAAO,CAAC,IAA6C;AAC/F,oBAAoB,mBAAO,CAAC,KAAW;AACvC,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,sBAAsB,mBAAO,CAAC,KAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+LAA+L,6BAA6B,GAAG,qBAAqB;AAC5R;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;;;;;;;ACpUa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,0CAA0C,mBAAO,CAAC,IAA6C;AAC/F,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,oBAAoB,mBAAO,CAAC,KAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG;AACxG;AACA,4BAA4B,oCAAoC;AAChE;AACA,wFAAwF;AACxF;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG;AACzG;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA,2FAA2F;AAC3F;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB;AACnB;;;;;;;ACtrBa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,uBAAuB;AAC5C,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,oBAAoB,mBAAO,CAAC,KAAW;AACvC,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,gDAAgD,mBAAO,CAAC,KAAmD;AAC3G,+CAA+C,mBAAO,CAAC,IAAkD;AACzG,uBAAuB,mBAAO,CAAC,KAAwB;AACvD,2BAA2B,mBAAO,CAAC,KAA4B;AAC/D,yBAAyB,mBAAO,CAAC,KAA0B;AAC3D,wBAAwB,mBAAO,CAAC,KAAyB;AACzD,yBAAyB,mBAAO,CAAC,KAA0B;AAC3D,yBAAyB,mBAAO,CAAC,KAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA,cAAc,mBAAO,CAAC,KAA0B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA,gCAAgC,iFAAiF;AACjH;AACA;AACA;AACA;AACA;AACA,wCAAwC,2BAA2B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sFAAsF;AACtH;AACA,+BAA+B;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qCAAqC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,OAAO;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,OAAO;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,OAAO;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8LAA8L,6BAA6B,GAAG,qBAAqB;AAC3R;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0DAA0D,SAAS;AACnE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAA6C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;ACpca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,0CAA0C,mBAAO,CAAC,IAA6C;AAC/F,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;;;;;;ACrFa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA,0DAA0D,aAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB,yCAAyC;AACnF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB;AACpB;;;;;;;AChFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sCAAsC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;;;;;;AC1Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,qBAAqB,mBAAO,CAAC,IAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA,gCAAgC,6BAA6B;AAC7D,yDAAyD,wCAAwC;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;;;;;;ACxKa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,oBAAoB,mBAAO,CAAC,KAAW;AACvC,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,6CAA6C,mBAAO,CAAC,KAAgD;AACrG,qBAAqB,mBAAO,CAAC,IAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAoC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB;AACtB;;;;;;;ACtVa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mCAAmC;AAC/D;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,oCAAoC,yBAAyB;AAC7D;AACA,qEAAqE,sBAAsB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,mHAAmH,cAAc,GAAG,UAAU;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB;AACrB;;;;;;;AC3Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,yBAAyB,mBAAO,CAAC,KAAkB;AACnD,kDAAiD,EAAE,qCAAqC,2CAA2C,EAAC;AACpI;;;;;;;ACLa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,qBAAqB;AAC/C,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,mCAAmC,mBAAO,CAAC,KAAsC;AACjF,8CAA8C,mBAAO,CAAC,KAAiD;AACvG,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,oBAAoB,mBAAO,CAAC,KAAW;AACvC,0CAA0C,mBAAO,CAAC,IAA6C;AAC/F,8BAA8B,mBAAO,CAAC,KAAiC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,yCAAyC,oDAAoD;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA,gCAAgC,iCAAiC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,mDAAmD,kCAAkC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kCAAkC;AACnE;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA,oBAAoB;AACpB;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA,oBAAoB;AACpB,kCAAkC,mBAAmB;AACrD;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,oFAAoF;AACpF;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,kGAAkG;AAClG;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+KAA+K,2BAA2B,GAAG,qBAAqB;AAC1Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kBAAkB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA;;;;;;;AC31Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,wBAAwB,mBAAO,CAAC,KAAiB;AACjD,iDAAgD,EAAE,qCAAqC,yCAAyC,EAAC;AACjI;;;;;;;ACLa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,6BAA6B,mBAAO,CAAC,KAAgC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,yHAAyH,eAAe;AACxI,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B;AAC/B;;;;;;;ACpIa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,kCAAkC,mBAAO,CAAC,KAA2B;AACrE,2DAA0D,EAAE,qCAAqC,6DAA6D,EAAC;AAC/J;;;;;;;ACLa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,2BAA2B,mBAAO,CAAC,IAAoB;AACvD,oBAAoB,mBAAO,CAAC,KAAW;AACvC;AACA,8BAA8B,mBAAO,CAAC,KAAiC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,0BAA0B;AAC5F;AACA;AACA,iFAAiF,0BAA0B;AAC3G;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,4OAA4O;AAC9S;AACA;AACA,iFAAiF,4OAA4O;AAC7T;AACA,SAAS;AACT;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wCAAwC;AACpF,2CAA2C,wCAAwC;AACnF;AACA;AACA,4CAA4C,6BAA6B;AACzE,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;;;;;;AC/qBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,yBAAyB,mBAAO,CAAC,IAAkB;AACnD,kDAAiD,EAAE,qCAAqC,2CAA2C,EAAC;AACpI;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB;AACxB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvLa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,sBAAsB,mBAAO,CAAC,KAAyB;AACvD,8BAA8B,mBAAO,CAAC,KAAiC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,qBAAqB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAoC;AAChE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wCAAwC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;;;;;;;AC/Qa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,qBAAqB,mBAAO,CAAC,KAAc;AAC3C,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD,2BAA2B,KAAK;AACzF;;;;;;;ACfa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,6BAA6B,GAAG,6BAA6B;AACpF,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,6BAA6B,GAAG,6BAA6B;AACpF,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,uBAAuB,GAAG,gCAAgC,GAAG,gCAAgC,GAAG,uBAAuB,GAAG,gCAAgC,GAAG,gCAAgC;AAC3N,qBAAqB,mBAAO,CAAC,KAAqB;AAClD,uDAAsD,EAAE,qCAAqC,4CAA4C,EAAC;AAC1I,mBAAmB,mBAAO,CAAC,KAAmB;AAC9C,4DAA2D,EAAE,qCAAqC,4CAA4C,EAAC;AAC/I,4DAA2D,EAAE,qCAAqC,4CAA4C,EAAC;AAC/I,mDAAkD,EAAE,qCAAqC,mCAAmC,EAAC;AAC7H,mBAAmB,mBAAO,CAAC,KAAmB;AAC9C,4DAA2D,EAAE,qCAAqC,4CAA4C,EAAC;AAC/I,4DAA2D,EAAE,qCAAqC,4CAA4C,EAAC;AAC/I,mDAAkD,EAAE,qCAAqC,mCAAmC,EAAC;AAC7H;;;;;;;ACba;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,8CAA8C,mBAAO,CAAC,KAAiD;AACvG,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB;AACnB;;;;;;;ACnEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,sBAAsB,mBAAO,CAAC,KAAe;AAC7C,+CAA8C,EAAE,qCAAqC,qCAAqC,EAAC;AAC3H;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,yBAAyB,GAAG,6BAA6B,GAAG,0BAA0B,GAAG,yBAAyB,GAAG,uBAAuB,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,wBAAwB,GAAG,wBAAwB,GAAG,iBAAiB,GAAG,iBAAiB,GAAG,2BAA2B,GAAG,6BAA6B,GAAG,yBAAyB,GAAG,qBAAqB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,qBAAqB,GAAG,wBAAwB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,6BAA6B,GAAG,4BAA4B,GAAG,uBAAuB,GAAG,oBAAoB,GAAG,wBAAwB,GAAG,qCAAqC,GAAG,uBAAuB,GAAG,qBAAqB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,2BAA2B,GAAG,+BAA+B,GAAG,mBAAmB,GAAG,sBAAsB,GAAG,iBAAiB,GAAG,gBAAgB,GAAG,YAAY,GAAG,eAAe,GAAG,sBAAsB,GAAG,iBAAiB,GAAG,sBAAsB,GAAG,mBAAmB,GAAG,gBAAgB,GAAG,qBAAqB,GAAG,iBAAiB,GAAG,sBAAsB;AACjwC,yCAAyC,GAAG,wCAAwC,GAAG,uCAAuC,GAAG,mCAAmC,GAAG,kCAAkC,GAAG,+BAA+B,GAAG,oCAAoC,GAAG,qCAAqC,GAAG,oCAAoC,GAAG,qCAAqC,GAAG,kCAAkC,GAAG,2CAA2C,GAAG,2CAA2C,GAAG,6BAA6B,GAAG,iCAAiC,GAAG,yBAAyB,GAAG,mBAAmB,GAAG,kBAAkB,GAAG,sBAAsB,GAAG,sBAAsB,GAAG,kBAAkB,GAAG,8BAA8B,GAAG,oBAAoB,GAAG,yBAAyB,GAAG,0BAA0B,GAAG,wBAAwB,GAAG,kBAAkB,GAAG,6BAA6B,GAAG,kCAAkC,GAAG,iCAAiC,GAAG,mCAAmC,GAAG,4BAA4B,GAAG,qBAAqB,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,qBAAqB,GAAG,eAAe,GAAG,6BAA6B,GAAG,8BAA8B,GAAG,yBAAyB,GAAG,uBAAuB,GAAG,sCAAsC,GAAG,0BAA0B,GAAG,yBAAyB,GAAG,4BAA4B,GAAG,gDAAgD,GAAG,mBAAmB,GAAG,cAAc,GAAG,WAAW,GAAG,sBAAsB;AACrhD,mCAAmC,GAAG,mCAAmC,GAAG,qCAAqC,GAAG,uCAAuC,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,yBAAyB,GAAG,qBAAqB,GAAG,sBAAsB,GAAG,cAAc,GAAG,sBAAsB,GAAG,uBAAuB,GAAG,mBAAmB,GAAG,4BAA4B,GAAG,sBAAsB,GAAG,kBAAkB,GAAG,wBAAwB,GAAG,qBAAqB,GAAG,mBAAmB,GAAG,2BAA2B,GAAG,kBAAkB,GAAG,qBAAqB,GAAG,uBAAuB,GAAG,0BAA0B,GAAG,iCAAiC,GAAG,mBAAmB,GAAG,mCAAmC,GAAG,+BAA+B,GAAG,4CAA4C,GAAG,2CAA2C,GAAG,2CAA2C,GAAG,oCAAoC,GAAG,iCAAiC,GAAG,gCAAgC,GAAG,+BAA+B,GAAG,iBAAiB,GAAG,2BAA2B,GAAG,0BAA0B,GAAG,6BAA6B,GAAG,4BAA4B,GAAG,6BAA6B,GAAG,0BAA0B,GAAG,mCAAmC,GAAG,mCAAmC,GAAG,4BAA4B,GAAG,qBAAqB,GAAG,kDAAkD,GAAG,8CAA8C,GAAG,6CAA6C,GAAG,sCAAsC;AAC9iD,iBAAiB,GAAG,eAAe,GAAG,qBAAqB,GAAG,sBAAsB;AACpF,6BAA6B,mBAAO,CAAC,KAAgC;AACrE,+CAA8C,EAAE,qCAAqC,4CAA4C,EAAC;AAClI,kDAAiD,EAAE,qCAAqC,+CAA+C,EAAC;AACxI,kDAAiD,EAAE,qCAAqC,+CAA+C,EAAC;AACxI,6CAA4C,EAAE,qCAAqC,0CAA0C,EAAC;AAC9H,2CAA0C,EAAE,qCAAqC,wCAAwC,EAAC;AAC1H,8BAA8B,mBAAO,CAAC,KAAiC;AACvE,iDAAgD,EAAE,qCAAqC,+CAA+C,EAAC;AACvI,iDAAgD,EAAE,qCAAqC,+CAA+C,EAAC;AACvI,8CAA6C,EAAE,qCAAqC,4CAA4C,EAAC;AACjI,gDAA+C,EAAE,qCAAqC,8CAA8C,EAAC;AACrI,+DAA8D,EAAE,qCAAqC,6DAA6D,EAAC;AACnK,yDAAwD,EAAE,qCAAqC,uDAAuD,EAAC;AACvJ,8DAA6D,EAAE,qCAAqC,4DAA4D,EAAC;AACjK,6DAA4D,EAAE,qCAAqC,2DAA2D,EAAC;AAC/J,+DAA8D,EAAE,qCAAqC,6DAA6D,EAAC;AACnK,+DAA8D,EAAE,qCAAqC,6DAA6D,EAAC;AACnK,mEAAkE,EAAE,qCAAqC,iEAAiE,EAAC;AAC3K,iEAAgE,EAAE,qCAAqC,+DAA+D,EAAC;AACvK,2CAA0C,EAAE,qCAAqC,yCAAyC,EAAC;AAC3H,kDAAiD,EAAE,qCAAqC,gDAAgD,EAAC;AACzI,oDAAmD,EAAE,qCAAqC,kDAAkD,EAAC;AAC7I,iDAAgD,EAAE,qCAAqC,+CAA+C,EAAC;AACvI,iDAAgD,EAAE,qCAAqC,+CAA+C,EAAC;AACvI,yDAAwD,EAAE,qCAAqC,uDAAuD,EAAC;AACvJ,mDAAkD,EAAE,qCAAqC,iDAAiD,EAAC;AAC3I,0DAAyD,EAAE,qCAAqC,wDAAwD,EAAC;AACzJ,qDAAoD,EAAE,qCAAqC,mDAAmD,EAAC;AAC/I,sDAAqD,EAAE,qCAAqC,oDAAoD,EAAC;AACjJ,kEAAiE,EAAE,qCAAqC,gEAAgE,EAAC;AACzK,wDAAuD,EAAE,qCAAqC,sDAAsD,EAAC;AACrJ,qDAAoD,EAAE,qCAAqC,mDAAmD,EAAC;AAC/I,wDAAuD,EAAE,qCAAqC,sDAAsD,EAAC;AACrJ,kDAAiD,EAAE,qCAAqC,gDAAgD,EAAC;AACzI,2DAA0D,EAAE,qCAAqC,yDAAyD,EAAC;AAC3J,kDAAiD,EAAE,qCAAqC,gDAAgD,EAAC;AACzI,iDAAgD,EAAE,qCAAqC,+CAA+C,EAAC;AACvI,iDAAgD,EAAE,qCAAqC,+CAA+C,EAAC;AACvI,qDAAoD,EAAE,qCAAqC,mDAAmD,EAAC;AAC/I,sDAAqD,EAAE,qCAAqC,oDAAoD,EAAC;AACjJ,gDAA+C,EAAE,qCAAqC,8CAA8C,EAAC;AACrI,oDAAmD,EAAE,qCAAqC,kDAAkD,EAAC;AAC7I,0DAAyD,EAAE,qCAAqC,wDAAwD,EAAC;AACzJ,6CAA4C,EAAE,qCAAqC,2CAA2C,EAAC;AAC/H,qDAAoD,EAAE,qCAAqC,mDAAmD,EAAC;AAC/I,oDAAmD,EAAE,qCAAqC,kDAAkD,EAAC;AAC7I,2DAA2D,mBAAO,CAAC,KAA8D;AACjI,2DAA0D,EAAE,qCAAqC,sFAAsF,EAAC;AACxL,iDAAgD,EAAE,qCAAqC,4EAA4E,EAAC;AACpK,+CAA8C,EAAE,qCAAqC,0EAA0E,EAAC;AAChK,6DAA4D,EAAE,qCAAqC,wFAAwF,EAAC;AAC5L,sDAAqD,EAAE,qCAAqC,iFAAiF,EAAC;AAC9K,mDAAkD,EAAE,qCAAqC,8EAA8E,EAAC;AACxK,0CAAyC,EAAE,qCAAqC,qEAAqE,EAAC;AACtJ,kDAAiD,EAAE,qCAAqC,6EAA6E,EAAC;AACtK,mDAAkD,EAAE,qCAAqC,8EAA8E,EAAC;AACxK,wDAAuD,EAAE,qCAAqC,mFAAmF,EAAC;AAClL,yDAAwD,EAAE,qCAAqC,oFAAoF,EAAC;AACpL,iDAAgD,EAAE,qCAAqC,4EAA4E,EAAC;AACpK,8CAA6C,EAAE,qCAAqC,yEAAyE,EAAC;AAC9J,uDAAsD,EAAE,qCAAqC,kFAAkF,EAAC;AAChL,8CAA6C,EAAE,qCAAqC,yEAAyE,EAAC;AAC9J,+CAA8C,EAAE,qCAAqC,0EAA0E,EAAC;AAChK,iDAAgD,EAAE,qCAAqC,4EAA4E,EAAC;AACpK,oDAAmD,EAAE,qCAAqC,+EAA+E,EAAC;AAC1K,+DAA8D,EAAE,qCAAqC,0FAA0F,EAAC;AAChM,8CAA6C,EAAE,qCAAqC,yEAAyE,EAAC;AAC9J,kDAAiD,EAAE,qCAAqC,6EAA6E,EAAC;AACtK,wDAAuD,EAAE,qCAAqC,mFAAmF,EAAC;AAClL,+CAA8C,EAAE,qCAAqC,0EAA0E,EAAC;AAChK,8CAA6C,EAAE,qCAAqC,yEAAyE,EAAC;AAC9J,+CAA8C,EAAE,qCAAqC,0EAA0E,EAAC;AAChK,mDAAkD,EAAE,qCAAqC,8EAA8E,EAAC;AACxK,kDAAiD,EAAE,qCAAqC,6EAA6E,EAAC;AACtK,qDAAoD,EAAE,qCAAqC,gFAAgF,EAAC;AAC5K,6BAA6B,mBAAO,CAAC,KAAgC;AACrE,uCAAsC,EAAE,qCAAqC,oCAAoC,EAAC;AAClH,0CAAyC,EAAE,qCAAqC,uCAAuC,EAAC;AACxH,mDAAmD,mBAAO,CAAC,KAAsD;AACjH,qDAAoD,EAAE,qCAAqC,wEAAwE,EAAC;AACpK,6CAA4C,EAAE,qCAAqC,gEAAgE,EAAC;AACpJ,iDAAgD,EAAE,qCAAqC,oEAAoE,EAAC;AAC5J,uDAAsD,EAAE,qCAAqC,0EAA0E,EAAC;AACxK,oDAAmD,EAAE,qCAAqC,uEAAuE,EAAC;AAClK,gDAA+C,EAAE,qCAAqC,mEAAmE,EAAC;AAC1J,mDAAkD,EAAE,qCAAqC,sEAAsE,EAAC;AAChK,gDAAgD,mBAAO,CAAC,KAAmD;AAC3G,+CAA8C,EAAE,qCAAqC,+DAA+D,EAAC;AACrJ,iEAAgE,EAAE,qCAAqC,iFAAiF,EAAC;AACzL,yBAAyB,mBAAO,CAAC,KAA4B;AAC7D,iDAAgD,EAAE,qCAAqC,0CAA0C,EAAC;AAClI,iDAAgD,EAAE,qCAAqC,0CAA0C,EAAC;AAClI,kDAAiD,EAAE,qCAAqC,2CAA2C,EAAC;AACpI,4CAA2C,EAAE,qCAAqC,qCAAqC,EAAC;AACxH,0BAA0B,mBAAO,CAAC,KAA6B;AAC/D,kDAAiD,EAAE,qCAAqC,4CAA4C,EAAC;AACrI,6CAA4C,EAAE,qCAAqC,uCAAuC,EAAC;AAC3H,yCAAyC,mBAAO,CAAC,KAA4C;AAC7F,8CAA6C,EAAE,qCAAqC,uDAAuD,EAAC;AAC5I,iCAAiC,mBAAO,CAAC,IAAoC;AAC7E,6CAA4C,EAAE,qCAAqC,8CAA8C,EAAC;AAClI,oDAAmD,EAAE,qCAAqC,qDAAqD,EAAC;AAChJ,2DAA0D,EAAE,qCAAqC,4DAA4D,EAAC;AAC9J,qDAAoD,EAAE,qCAAqC,sDAAsD,EAAC;AAClJ,yDAAwD,EAAE,qCAAqC,0DAA0D,EAAC;AAC1J,oDAAmD,EAAE,qCAAqC,qDAAqD,EAAC;AAChJ,uDAAsD,EAAE,qCAAqC,wDAAwD,EAAC;AACtJ,uDAAsD,EAAE,qCAAqC,wDAAwD,EAAC;AACtJ,mDAAkD,EAAE,qCAAqC,oDAAoD,EAAC;AAC9I,qDAAoD,EAAE,qCAAqC,sDAAsD,EAAC;AAClJ,kDAAiD,EAAE,qCAAqC,mDAAmD,EAAC;AAC5I,sDAAqD,EAAE,qCAAqC,uDAAuD,EAAC;AACpJ,6CAA4C,EAAE,qCAAqC,8CAA8C,EAAC;AAClI,2CAA0C,EAAE,qCAAqC,4CAA4C,EAAC;AAC9H,uDAAsD,EAAE,qCAAqC,wDAAwD,EAAC;AACtJ,+DAA8D,EAAE,qCAAqC,gEAAgE,EAAC;AACtK,6DAA4D,EAAE,qCAAqC,8DAA8D,EAAC;AAClK,+DAA8D,EAAE,qCAAqC,gEAAgE,EAAC;AACtK,iDAAgD,EAAE,qCAAqC,kDAAkD,EAAC;AAC1I,gEAA+D,EAAE,qCAAqC,iEAAiE,EAAC;AACxK,uEAAsE,EAAE,qCAAqC,wEAAwE,EAAC;AACtL,uEAAsE,EAAE,qCAAqC,wEAAwE,EAAC;AACtL,wEAAuE,EAAE,qCAAqC,yEAAyE,EAAC;AACxL,4DAA2D,EAAE,qCAAqC,6DAA6D,EAAC;AAChK,sDAAqD,EAAE,qCAAqC,uDAAuD,EAAC;AACpJ,wDAAuD,EAAE,qCAAqC,yDAAyD,EAAC;AACxJ,yDAAwD,EAAE,qCAAqC,0DAA0D,EAAC;AAC1J,wDAAuD,EAAE,qCAAqC,yDAAyD,EAAC;AACxJ,2DAA0D,EAAE,qCAAqC,4DAA4D,EAAC;AAC9J,yDAAwD,EAAE,qCAAqC,0DAA0D,EAAC;AAC1J,sDAAqD,EAAE,qCAAqC,uDAAuD,EAAC;AACpJ,iDAAgD,EAAE,qCAAqC,kDAAkD,EAAC;AAC1I,yDAAwD,EAAE,qCAAqC,0DAA0D,EAAC;AAC1J,kEAAiE,EAAE,qCAAqC,mEAAmE,EAAC;AAC5K,yEAAwE,EAAE,qCAAqC,0EAA0E,EAAC;AAC1L,0EAAyE,EAAE,qCAAqC,2EAA2E,EAAC;AAC5L,8EAA6E,EAAE,qCAAqC,+EAA+E,EAAC;AACpM,2DAA0D,EAAE,qCAAqC,4DAA4D,EAAC;AAC9J,+DAA8D,EAAE,qCAAqC,gEAAgE,EAAC;AACtK,uEAAsE,EAAE,qCAAqC,wEAAwE,EAAC;AACtL,qEAAoE,EAAE,qCAAqC,sEAAsE,EAAC;AAClL,uEAAsE,EAAE,qCAAqC,wEAAwE,EAAC;AACtL,yDAAwD,EAAE,qCAAqC,0DAA0D,EAAC;AAC1J,6DAA4D,EAAE,qCAAqC,8DAA8D,EAAC;AAClK,oEAAmE,EAAE,qCAAqC,qEAAqE,EAAC;AAChL,8DAA6D,EAAE,qCAAqC,+DAA+D,EAAC;AACpK,gEAA+D,EAAE,qCAAqC,iEAAiE,EAAC;AACxK,iEAAgE,EAAE,qCAAqC,kEAAkE,EAAC;AAC1K,gEAA+D,EAAE,qCAAqC,iEAAiE,EAAC;AACxK,mEAAkE,EAAE,qCAAqC,oEAAoE,EAAC;AAC9K,iEAAgE,EAAE,qCAAqC,kEAAkE,EAAC;AAC1K,8DAA6D,EAAE,qCAAqC,+DAA+D,EAAC;AACpK,6CAA4C,EAAE,qCAAqC,8CAA8C,EAAC;AAClI,8CAA6C,EAAE,qCAAqC,+CAA+C,EAAC;AACpI,6CAA6C,mBAAO,CAAC,KAAgD;AACrG,kDAAiD,EAAE,qCAAqC,+DAA+D,EAAC;AACxJ,0CAA0C,mBAAO,CAAC,IAA6C;AAC/F,uDAAsD,EAAE,qCAAqC,iEAAiE,EAAC;AAC/J,+CAA+C,mBAAO,CAAC,IAAkD;AACzG,+CAA8C,EAAE,qCAAqC,8DAA8D,EAAC;AACpJ,qDAAoD,EAAE,qCAAqC,oEAAoE,EAAC;AAChK,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,wCAAuC,EAAE,qCAAqC,0CAA0C,EAAC;AACzH,4CAA2C,EAAE,qCAAqC,8CAA8C,EAAC;AACjI,+CAA+C,mBAAO,CAAC,IAAkD;AACzG,8CAA6C,EAAE,qCAAqC,6DAA6D,EAAC;AAClJ,6CAA6C,mBAAO,CAAC,KAAgD;AACrG,kDAAiD,EAAE,qCAAqC,+DAA+D,EAAC;AACxJ,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,4EAA2E,EAAE,qCAAqC,8EAA8E,EAAC;AACjM,kCAAkC,mBAAO,CAAC,KAAqC;AAC/E,+CAA8C,EAAE,qCAAqC,4EAA4E,EAAC;AAClK","sources":["webpack://spinlio-workspace/./node_modules/@shapediver/viewer.api.general/dist/index.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.creation-control-center.session/dist/implementation/CreationControlCenterSession.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.creation-control-center.session/dist/implementation/SessionGlobalAccessObject.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.creation-control-center.session/dist/index.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.creation-control-center.viewport/dist/implementation/CreationControlCenterViewport.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.creation-control-center.viewport/dist/implementation/ViewportGlobalAccessObject.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.creation-control-center.viewport/dist/index.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.data-engine/dist/DataEngine.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.data-engine/dist/index.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/GeometryEngine.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/gltfv1/GLTFLoader.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/gltfv1/SDGTFLoader.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/gltfv2/GLTFLoader.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/gltfv2/loaders/AccessorLoader.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/gltfv2/loaders/BufferLoader.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/gltfv2/loaders/BufferViewLoader.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/gltfv2/loaders/GeometryLoader.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/gltfv2/loaders/MaterialLoader.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/gltfv2/loaders/TextureLoader.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/index.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.gltf-converter/dist/GLTFConverter.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.gltf-converter/dist/index.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.html-element-anchor-engine/dist/HTMLElementAnchorEngine.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.html-element-anchor-engine/dist/index.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.material-engine/dist/MaterialEngine.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.material-engine/dist/index.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.material-engine/dist/materialDatabase.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.sdtf-engine/dist/SDTFEngine.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.sdtf-engine/dist/index.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.shared-types/dist/anchor/interfaces.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.shared-types/dist/gltfv1/IGLTF_v1.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.shared-types/dist/gltfv2/IGLTF_v2.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.shared-types/dist/index.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.tag3d-engine/dist/Tag3dEngine.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer.data-engine.tag3d-engine/dist/index.js","webpack://spinlio-workspace/./node_modules/@shapediver/viewer/dist/index.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.generalOptions = exports.showConsoleMessage = exports.version = exports.sceneTree = exports.removeListener = exports.addListener = void 0;\r\nconst viewer_shared_build_data_1 = require(\"@shapediver/viewer.shared.build-data\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_data_engine_geometry_engine_1 = require(\"@shapediver/viewer.data-engine.geometry-engine\");\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\n// #endregion Interfaces (1)\r\n// #region Classes (1)\r\nclass GeneralOptions {\r\n    // #region Public Getters And Setters (10)\r\n    get caching() {\r\n        return {\r\n            enable: httpClient.enableCaching,\r\n            excludedQueryParameters: httpClient.excludedQueryParameters,\r\n            maxCacheSize: httpClient.maxCacheSize\r\n        };\r\n    }\r\n    set caching(value) {\r\n        inputValidator.validateAndError('caching', value, 'object', true);\r\n        inputValidator.validateAndError('caching', value.enable, 'boolean');\r\n        inputValidator.validateAndError('caching', value.excludedQueryParameters, 'stringArray');\r\n        inputValidator.validateAndError('caching', value.maxCacheSize, 'number');\r\n        if (value.enable !== undefined)\r\n            httpClient.enableCaching = value.enable;\r\n        if (value.excludedQueryParameters !== undefined)\r\n            httpClient.excludedQueryParameters = value.excludedQueryParameters;\r\n        if (value.maxCacheSize !== undefined)\r\n            httpClient.maxCacheSize = value.maxCacheSize;\r\n        logger.debug(`caching: CoggingLevel was set to: ${value}`);\r\n    }\r\n    get consoleBranding() {\r\n        return consoleBranding;\r\n    }\r\n    set consoleBranding(value) {\r\n        inputValidator.validateAndError('consoleBranding', value, 'boolean');\r\n        consoleBranding = value;\r\n        logger.debug(`consoleBranding: ConsoleBranding was set to: ${value}`);\r\n    }\r\n    get loggingLevel() {\r\n        return logger.loggingLevel;\r\n    }\r\n    set loggingLevel(value) {\r\n        inputValidator.validateAndError('loggingLevel', value, 'enum', true, Object.values(viewer_shared_services_1.LOGGING_LEVEL));\r\n        logger.loggingLevel = value;\r\n        logger.debug(`loggingLevel: LoggingLevel was set to: ${value}`);\r\n    }\r\n    get parallelGlTFProcessing() {\r\n        return geometryEngine.parallelGlTFProcessing;\r\n    }\r\n    set parallelGlTFProcessing(value) {\r\n        inputValidator.validateAndError('parallelGlTFProcessing', value, 'number');\r\n        geometryEngine.parallelGlTFProcessing = value;\r\n        logger.debug(`parallelGlTFProcessing: ParallelGlTFProcessing was set to: ${value}`);\r\n    }\r\n    get showMessages() {\r\n        return logger.showMessages;\r\n    }\r\n    set showMessages(value) {\r\n        inputValidator.validateAndError('showMessages', value, 'boolean');\r\n        logger.showMessages = value;\r\n        logger.debug(`showMessages: ShowMessages was set to: ${value}`);\r\n    }\r\n}\r\n// #endregion Classes (1)\r\n// #region Variables (12)\r\nconst httpClient = viewer_shared_services_1.HttpClient.instance;\r\nconst inputValidator = viewer_shared_services_1.InputValidator.instance;\r\nconst logger = viewer_shared_services_1.Logger.instance;\r\nconst eventEngine = viewer_shared_services_1.EventEngine.instance;\r\nconst geometryEngine = viewer_data_engine_geometry_engine_1.GeometryEngine.instance;\r\nlet createdConsoleMessage = false, consoleBranding = true;\r\n/**\r\n * Adds an event listener.\r\n *\r\n * @param type The type of event.\r\n * @param cb The callback.\r\n * @returns\r\n */\r\nconst addListener = (type, cb) => {\r\n    inputValidator.validateAndError('addListener', type, 'string');\r\n    inputValidator.validateAndError('addListener', cb, 'function');\r\n    logger.debug(`addListener: Event Listener was registered for ${type}.`);\r\n    return eventEngine.addListener(type, cb);\r\n};\r\nexports.addListener = addListener;\r\n/**\r\n * Removes an event listener.\r\n *\r\n * @param id The id of the listener.\r\n * @returns\r\n */\r\nconst removeListener = (id) => {\r\n    inputValidator.validateAndError('removeListener', id, 'string');\r\n    logger.debug(`removeListener: Removing event listener with id ${id}.`);\r\n    return eventEngine.removeListener(id);\r\n};\r\nexports.removeListener = removeListener;\r\n/**\r\n * The scene tree that is used to store the scene.\r\n * The scene tree contains a unique node and child nodes for each session,\r\n * and can also be used to add your own nodes.\r\n */\r\nexports.sceneTree = viewer_shared_node_tree_1.Tree.instance;\r\n/**\r\n * The version of the viewer.\r\n */\r\nexports.version = viewer_shared_build_data_1.build_data.build_version.replace('3.', '');\r\nconst showConsoleMessage = () => {\r\n    if (createdConsoleMessage === true)\r\n        return;\r\n    createdConsoleMessage = true;\r\n    if (consoleBranding === true) {\r\n        console.log(`Powered by:\r\n   _____  __                         ____   _                   \r\n  / ___/ / /_   ____ _ ____   ___   / __ \\\\ (_)_   __ ___   _____\r\n  \\\\__ \\\\ / __ \\\\ / __ '// __ \\\\ / _ \\\\ / / / // /| | / // _ \\\\ / ___/\r\n ___/ // / / // /_/ // /_/ //  __// /_/ // / | |/ //  __// /    \r\n/____//_/ /_/ \\\\__,_// .___/ \\\\___//_____//_/  |___/ \\\\___//_/     \r\n                   /_/                                          \r\nShapeDiver Viewer 3, Version ${viewer_shared_build_data_1.build_data.build_version.replace('3.', '')}\r\nVisit us at https://shapediver.com/ and find out more!\r\n`);\r\n    }\r\n    else {\r\n        console.log(`ShapeDiver Viewer 3, Version ${viewer_shared_build_data_1.build_data.build_version.replace('3.', '')}`);\r\n    }\r\n};\r\nexports.showConsoleMessage = showConsoleMessage;\r\n/**\r\n * General Viewer options that are used everywhere.\r\n * - loggingLevel: The logging level that is used.\r\n * - showMessages: Option to show/hide messages in the browser console.\r\n * - parallelGlTFProcessing: The number of glTFs that are downloaded and processed at the same time.\r\n * - consoleBranding: When set to false, the branding in the viewer console will be limited to a single line.\r\n * - caching: Caching Options.\r\n */\r\nexports.generalOptions = new GeneralOptions();\r\n// #endregion Variables (12)\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar _CreationControlCenterSession_eventEngine, _CreationControlCenterSession_logger, _CreationControlCenterSession_stateEngine, _CreationControlCenterSession_uuidGenerator, _CreationControlCenterSession_firstSessionEngine;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CreationControlCenterSession = void 0;\r\nconst viewer_shared_build_data_1 = require(\"@shapediver/viewer.shared.build-data\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_settings_1 = require(\"@shapediver/viewer.settings\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst viewer_session_engine_session_engine_1 = require(\"@shapediver/viewer.session-engine.session-engine\");\r\nconst SessionGlobalAccessObject_1 = require(\"./SessionGlobalAccessObject\");\r\nclass CreationControlCenterSession {\r\n    constructor() {\r\n        // #region Properties (8)\r\n        _CreationControlCenterSession_eventEngine.set(this, viewer_shared_services_1.EventEngine.instance);\r\n        _CreationControlCenterSession_logger.set(this, viewer_shared_services_1.Logger.instance);\r\n        _CreationControlCenterSession_stateEngine.set(this, viewer_shared_services_1.StateEngine.instance);\r\n        _CreationControlCenterSession_uuidGenerator.set(this, viewer_shared_services_1.UuidGenerator.instance);\r\n        _CreationControlCenterSession_firstSessionEngine.set(this, void 0);\r\n        this.sessionEngines = {};\r\n        // #endregion Private Methods (2)\r\n    }\r\n    // #endregion Properties (8)\r\n    // #region Public Static Getters And Setters (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Getters And Setters (1)\r\n    // #region Public Methods (5)\r\n    applySettings(sessionId, response, sections) {\r\n        sections = sections || {};\r\n        this.sessionEngines[sessionId].applySettings(response, sections);\r\n        const promises = [];\r\n        if (sections.session && sections.session.parameter && sections.session.parameter.value)\r\n            promises.push(this.sessionEngines[sessionId].customize());\r\n        for (const r in __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines) {\r\n            const viewportEngineState = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r];\r\n            if ((viewportEngineState && viewportEngineState.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.FIRST && __classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\") && sessionId === __classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\").id) ||\r\n                (viewportEngineState && viewportEngineState.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.MANUAL && sessionId === viewportEngineState.sessionSettingsId)) {\r\n                viewportEngineState.settingsAssigned.reset();\r\n                promises.push(new Promise(resolve => {\r\n                    var _a;\r\n                    (_a = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r]) === null || _a === void 0 ? void 0 : _a.settingsAssigned.then(() => {\r\n                        resolve();\r\n                    });\r\n                }));\r\n                viewportEngineState.applySettings(sections.viewport);\r\n            }\r\n        }\r\n        return new Promise(resolve => Promise.all(promises).then(() => resolve()));\r\n    }\r\n    closeSessionEngine(id) {\r\n        var _a, _b, _c, _d, _e;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this.sessionEngines[id])\r\n                return;\r\n            __classPrivateFieldGet(this, _CreationControlCenterSession_logger, \"f\").debugLow(`CreationControlCenter.closeSession: Closing session ${id}.`);\r\n            if (((_a = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[id]) === null || _a === void 0 ? void 0 : _a.initialized.resolved) === false)\r\n                yield new Promise(resolve => { var _a; (_a = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[id]) === null || _a === void 0 ? void 0 : _a.initialized.then(() => resolve()); });\r\n            yield this.sessionEngines[id].close();\r\n            // remove from rendering engines (also directly assigned)\r\n            for (const r in __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines) {\r\n                const viewportEngineState = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r];\r\n                if (viewportEngineState && (viewportEngineState.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.MANUAL && viewportEngineState.sessionSettingsId === id) ||\r\n                    (viewportEngineState && viewportEngineState.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.FIRST && __classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\") === this.sessionEngines[id])) {\r\n                    viewportEngineState.reset();\r\n                }\r\n            }\r\n            if (__classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\") === this.sessionEngines[id]) {\r\n                const engines = Object.values(this.sessionEngines).filter(s => s.id !== id);\r\n                __classPrivateFieldSet(this, _CreationControlCenterSession_firstSessionEngine, engines.length === 0 ? undefined : engines[0], \"f\");\r\n                if (__classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\")) {\r\n                    if (!__classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[__classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\").id])\r\n                        return;\r\n                    Object.values(__classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines).forEach(s => { if (s)\r\n                        s.isFirstSession = false; });\r\n                    __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[__classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\").id].isFirstSession = true;\r\n                    const promises = [];\r\n                    for (const r in __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines) {\r\n                        const viewportEngineState = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r];\r\n                        if (((_b = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r]) === null || _b === void 0 ? void 0 : _b.settingsAssigned.resolved) === false) {\r\n                            if (viewportEngineState && viewportEngineState.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.FIRST) {\r\n                                promises.push(viewportEngineState.settingsAssigned);\r\n                                this.assignSettings(viewportEngineState.id, (_c = __classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\")) === null || _c === void 0 ? void 0 : _c.id);\r\n                            }\r\n                        }\r\n                    }\r\n                    yield Promise.all(promises);\r\n                    if (this.updateSessions)\r\n                        this.updateSessions(this.sessionEngines);\r\n                }\r\n            }\r\n            (_d = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[id]) === null || _d === void 0 ? void 0 : _d.settingsRegistered.reset();\r\n            this.sessionEngines[id] = undefined;\r\n            delete this.sessionEngines[id];\r\n            delete __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[id];\r\n            __classPrivateFieldGet(this, _CreationControlCenterSession_logger, \"f\").debug('CreationControlCenter.closeSessionEngine: Session closed.');\r\n            for (const r in __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines)\r\n                (_e = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r]) === null || _e === void 0 ? void 0 : _e.update('CreationControlCenter.closeSessionEngine');\r\n            if (this.updateSessions)\r\n                this.updateSessions(this.sessionEngines);\r\n            __classPrivateFieldGet(this, _CreationControlCenterSession_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.SESSION.SESSION_CLOSED, { sessionId: id });\r\n        });\r\n    }\r\n    createSessionEngine(properties) {\r\n        var _a, _b, _c, _d, _e;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const eventId = __classPrivateFieldGet(this, _CreationControlCenterSession_uuidGenerator, \"f\").create();\r\n            const sessionEngineId = properties.id || __classPrivateFieldGet(this, _CreationControlCenterSession_uuidGenerator, \"f\").create();\r\n            properties.id = sessionEngineId;\r\n            properties.loadOutputs = properties.allowOutputLoading === false ? false : properties.loadOutputs;\r\n            try {\r\n                const eventStart = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CREATION, id: eventId, progress: 0, status: 'Creating session', data: { sessionId: sessionEngineId } };\r\n                __classPrivateFieldGet(this, _CreationControlCenterSession_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);\r\n                // check if the given id is valid\r\n                if (this.sessionEngines[sessionEngineId]) {\r\n                    const eventClose = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CREATION, id: eventId, progress: 0.1, status: 'Closing session with same id', data: { sessionId: sessionEngineId } };\r\n                    __classPrivateFieldGet(this, _CreationControlCenterSession_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventClose);\r\n                    __classPrivateFieldGet(this, _CreationControlCenterSession_logger, \"f\").warn(`CreationControlCenter.createSession: Session with this id (${sessionEngineId}) already exists. Closing initial instance.`);\r\n                    yield this.closeSessionEngine(sessionEngineId);\r\n                }\r\n                // create the actual session \r\n                const sessionEngine = new viewer_session_engine_session_engine_1.SessionEngine({\r\n                    id: sessionEngineId,\r\n                    guid: properties.guid,\r\n                    ticket: properties.ticket,\r\n                    modelViewUrl: properties.modelViewUrl,\r\n                    excludeViewports: properties.excludeViewports,\r\n                    buildVersion: viewer_shared_build_data_1.build_data.build_version,\r\n                    buildDate: viewer_shared_build_data_1.build_data.build_date,\r\n                    jwtToken: properties.jwtToken,\r\n                    allowOutputLoading: properties.allowOutputLoading === undefined ? true : properties.allowOutputLoading,\r\n                    loadSdtf: properties.loadSdtf === undefined ? false : properties.loadSdtf,\r\n                    modelStateId: properties.modelStateId\r\n                });\r\n                __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[sessionEngineId] = new SessionGlobalAccessObject_1.SessionGlobalAccessObject(sessionEngine);\r\n                const eventInit = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CREATION, id: eventId, progress: 0.25, status: 'Initializing session.', data: { sessionId: sessionEngineId } };\r\n                __classPrivateFieldGet(this, _CreationControlCenterSession_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventInit);\r\n                yield sessionEngine.init(properties.initialParameterValues);\r\n                if (properties.loadOutputs !== false) {\r\n                    if (properties.waitForOutputs !== false) {\r\n                        yield sessionEngine.updateOutputs({\r\n                            eventId,\r\n                            type: viewer_shared_types_1.TASK_TYPE.SESSION_CREATION,\r\n                            progressRange: {\r\n                                min: 0.25,\r\n                                max: 0.9\r\n                            },\r\n                            data: { sessionId: sessionEngineId }\r\n                        });\r\n                        (_a = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[sessionEngineId]) === null || _a === void 0 ? void 0 : _a.initialOutputsLoaded.resolve(true);\r\n                        __classPrivateFieldGet(this, _CreationControlCenterSession_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.SESSION.SESSION_INITIAL_OUTPUTS_LOADED, { sessionId: sessionEngineId });\r\n                    }\r\n                    else {\r\n                        sessionEngine.updateOutputs({\r\n                            eventId,\r\n                            type: viewer_shared_types_1.TASK_TYPE.SESSION_CREATION,\r\n                            progressRange: {\r\n                                min: 0.25,\r\n                                max: 0.9\r\n                            },\r\n                            data: { sessionId: sessionEngineId }\r\n                        }).then(() => {\r\n                            var _a, _b;\r\n                            (_a = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[sessionEngineId]) === null || _a === void 0 ? void 0 : _a.initialOutputsLoaded.resolve(true);\r\n                            __classPrivateFieldGet(this, _CreationControlCenterSession_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.SESSION.SESSION_INITIAL_OUTPUTS_LOADED, { sessionId: sessionEngineId });\r\n                            for (const r in __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines)\r\n                                (_b = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r]) === null || _b === void 0 ? void 0 : _b.update('CreationControlCenter.createSessionEngine.waitForOutputs=false');\r\n                        });\r\n                    }\r\n                }\r\n                // save the session\r\n                this.sessionEngines[sessionEngineId] = sessionEngine;\r\n                (_b = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[sessionEngineId]) === null || _b === void 0 ? void 0 : _b.initialized.resolve(true);\r\n                __classPrivateFieldGet(this, _CreationControlCenterSession_logger, \"f\").debug(`CreationControlCenter.createSession: Session(${sessionEngine.id}) created.`);\r\n                if (!__classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\")) {\r\n                    if (__classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[sessionEngine.id]) {\r\n                        __classPrivateFieldSet(this, _CreationControlCenterSession_firstSessionEngine, sessionEngine, \"f\");\r\n                        Object.values(__classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines).forEach(s => { if (s)\r\n                            s.isFirstSession = false; });\r\n                        __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[__classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\").id].isFirstSession = true;\r\n                    }\r\n                }\r\n                const promises = [];\r\n                for (const r in __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines) {\r\n                    const viewportEngine = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r];\r\n                    if (((_c = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r]) === null || _c === void 0 ? void 0 : _c.settingsAssigned.resolved) === false) {\r\n                        if (viewportEngine && viewportEngine.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.FIRST || (viewportEngine && viewportEngine.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.MANUAL && viewportEngine.sessionSettingsId === sessionEngineId)) {\r\n                            promises.push(viewportEngine.settingsAssigned);\r\n                            this.assignSettings(viewportEngine.id, sessionEngineId);\r\n                        }\r\n                    }\r\n                }\r\n                yield Promise.all(promises);\r\n                for (const r in __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines)\r\n                    (_d = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r]) === null || _d === void 0 ? void 0 : _d.update('CreationControlCenter.createSessionEngine');\r\n                if (this.updateSessions)\r\n                    this.updateSessions(this.sessionEngines);\r\n                const eventEnd = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CREATION, id: eventId, progress: 1, status: 'Session created', data: { sessionId: sessionEngineId } };\r\n                __classPrivateFieldGet(this, _CreationControlCenterSession_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);\r\n                __classPrivateFieldGet(this, _CreationControlCenterSession_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.SESSION.SESSION_CREATED, { sessionId: sessionEngineId });\r\n                return sessionEngine;\r\n            }\r\n            catch (e) {\r\n                // special behavior, if this was the only session, display the error on the logo screen\r\n                if ((0, viewer_shared_services_1.isViewerError)(e)) {\r\n                    if ((this.sessionEngines[sessionEngineId] && Object.values(this.sessionEngines).length === 1) || (!this.sessionEngines[sessionEngineId] && Object.values(this.sessionEngines).length === 0)) {\r\n                        for (const r in __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines)\r\n                            (_e = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r]) === null || _e === void 0 ? void 0 : _e.displayErrorMessage(e.message);\r\n                    }\r\n                }\r\n                const eventCancel1 = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CREATION, id: eventId, progress: 0.9, status: 'Session created failed, closing session', data: { sessionId: sessionEngineId } };\r\n                __classPrivateFieldGet(this, _CreationControlCenterSession_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventCancel1);\r\n                yield this.closeSessionEngine(sessionEngineId);\r\n                const eventCancel2 = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CREATION, id: eventId, progress: 1, status: 'Session created failed', data: { sessionId: sessionEngineId } };\r\n                __classPrivateFieldGet(this, _CreationControlCenterSession_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel2);\r\n                throw e;\r\n            }\r\n        });\r\n    }\r\n    resetSettings(sessionId, sections) {\r\n        var _a;\r\n        sections = sections || {};\r\n        this.sessionEngines[sessionId].resetSettings(sections);\r\n        const promises = [];\r\n        if (sections.session && sections.session.parameter && sections.session.parameter.value)\r\n            promises.push(this.sessionEngines[sessionId].customize());\r\n        for (const r in __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines) {\r\n            const viewportEngine = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r];\r\n            if ((viewportEngine && viewportEngine.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.FIRST && __classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\") && sessionId === __classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\").id) ||\r\n                (viewportEngine && viewportEngine.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.MANUAL && sessionId === viewportEngine.sessionSettingsId)) {\r\n                (_a = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r]) === null || _a === void 0 ? void 0 : _a.settingsAssigned.reset();\r\n                promises.push(new Promise(resolve => {\r\n                    var _a;\r\n                    (_a = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r]) === null || _a === void 0 ? void 0 : _a.settingsAssigned.then(() => {\r\n                        resolve();\r\n                    });\r\n                }));\r\n                viewportEngine.applySettings(sections.viewport);\r\n            }\r\n        }\r\n        return new Promise(resolve => Promise.all(promises).then(() => resolve()));\r\n    }\r\n    saveSettings(sessionId, viewportId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const session = this.sessionEngines[sessionId];\r\n            yield session.saveUiProperties(false);\r\n            const settingsObject = this.createSettingsObject(sessionId, viewportId);\r\n            const response = yield session.saveSettings(settingsObject);\r\n            if (response) {\r\n                __classPrivateFieldGet(this, _CreationControlCenterSession_logger, \"f\").debug(`Session(${sessionId}).saveSettings: Saved settings.`);\r\n            }\r\n            else {\r\n                throw new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session(${sessionId}).saveSettings: Could not save settings.`);\r\n            }\r\n            return response;\r\n        });\r\n    }\r\n    // #endregion Public Methods (5)\r\n    // #region Private Methods (2)\r\n    assignSettings(viewportEngineId, sessionId, updateViewport = false) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const viewportEngine = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[viewportEngineId];\r\n            if (!viewportEngine)\r\n                return;\r\n            if (((_a = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[sessionId]) === null || _a === void 0 ? void 0 : _a.initialized.resolved) === true) {\r\n                // immediate\r\n                viewportEngine.assignSettingsEngine(this.sessionEngines[sessionId].settingsEngine);\r\n                yield viewportEngine.applySettings(undefined, undefined, updateViewport);\r\n            }\r\n            else {\r\n                yield new Promise(resolve => {\r\n                    var _a;\r\n                    (_a = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").sessionEngines[sessionId]) === null || _a === void 0 ? void 0 : _a.initialized.then(() => __awaiter(this, void 0, void 0, function* () {\r\n                        viewportEngine.assignSettingsEngine(this.sessionEngines[sessionId].settingsEngine);\r\n                        yield viewportEngine.applySettings(undefined, undefined, updateViewport);\r\n                        resolve();\r\n                    }));\r\n                });\r\n            }\r\n        });\r\n    }\r\n    createSettingsObject(sessionId, viewportId) {\r\n        const session = this.sessionEngines[sessionId];\r\n        session.settingsEngine.settings.build_version = viewer_shared_build_data_1.build_data.build_version;\r\n        session.settingsEngine.settings.build_date = viewer_shared_build_data_1.build_data.build_date;\r\n        session.settingsEngine.settings.settings_version = viewer_settings_1.latestVersion;\r\n        let viewportEngine;\r\n        if (viewportId && __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[viewportId]) {\r\n            viewportEngine = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[viewportId];\r\n        }\r\n        else {\r\n            for (const r in __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines) {\r\n                const viewportEngineToCheck = __classPrivateFieldGet(this, _CreationControlCenterSession_stateEngine, \"f\").viewportEngines[r];\r\n                if ((viewportEngineToCheck && viewportEngineToCheck.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.FIRST && __classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\") && sessionId === __classPrivateFieldGet(this, _CreationControlCenterSession_firstSessionEngine, \"f\").id) ||\r\n                    (viewportEngineToCheck && viewportEngineToCheck.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.MANUAL && sessionId === viewportEngineToCheck.sessionSettingsId)) {\r\n                    viewportEngine = viewportEngineToCheck;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        if (viewportEngine)\r\n            viewportEngine.saveSettings();\r\n        return session.settingsEngine.settings;\r\n    }\r\n}\r\nexports.CreationControlCenterSession = CreationControlCenterSession;\r\n_CreationControlCenterSession_eventEngine = new WeakMap(), _CreationControlCenterSession_logger = new WeakMap(), _CreationControlCenterSession_stateEngine = new WeakMap(), _CreationControlCenterSession_uuidGenerator = new WeakMap(), _CreationControlCenterSession_firstSessionEngine = new WeakMap();\r\n//# sourceMappingURL=CreationControlCenterSession.js.map","\"use strict\";\r\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _SessionGlobalAccessObject_sessionEngine, _SessionGlobalAccessObject_initialOutputsLoaded, _SessionGlobalAccessObject_initialized, _SessionGlobalAccessObject_isFirstSession, _SessionGlobalAccessObject_settingsRegistered;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SessionGlobalAccessObject = void 0;\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nclass SessionGlobalAccessObject {\r\n    // #endregion Properties (5)\r\n    // #region Constructors (1)\r\n    constructor(sessionEngine) {\r\n        // #region Properties (5)\r\n        _SessionGlobalAccessObject_sessionEngine.set(this, void 0);\r\n        _SessionGlobalAccessObject_initialOutputsLoaded.set(this, new viewer_shared_services_1.StatePromise());\r\n        _SessionGlobalAccessObject_initialized.set(this, new viewer_shared_services_1.StatePromise());\r\n        _SessionGlobalAccessObject_isFirstSession.set(this, false);\r\n        _SessionGlobalAccessObject_settingsRegistered.set(this, new viewer_shared_services_1.StatePromise());\r\n        __classPrivateFieldSet(this, _SessionGlobalAccessObject_sessionEngine, sessionEngine, \"f\");\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Getters And Setters (9)\r\n    get canUploadGLTF() {\r\n        return __classPrivateFieldGet(this, _SessionGlobalAccessObject_sessionEngine, \"f\").canUploadGLTF;\r\n    }\r\n    get id() {\r\n        return __classPrivateFieldGet(this, _SessionGlobalAccessObject_sessionEngine, \"f\").id;\r\n    }\r\n    get initialOutputsLoaded() {\r\n        return __classPrivateFieldGet(this, _SessionGlobalAccessObject_initialOutputsLoaded, \"f\");\r\n    }\r\n    get initialized() {\r\n        return __classPrivateFieldGet(this, _SessionGlobalAccessObject_initialized, \"f\");\r\n    }\r\n    get isFirstSession() {\r\n        return __classPrivateFieldGet(this, _SessionGlobalAccessObject_isFirstSession, \"f\");\r\n    }\r\n    set isFirstSession(value) {\r\n        __classPrivateFieldSet(this, _SessionGlobalAccessObject_isFirstSession, value, \"f\");\r\n    }\r\n    get modelViewUrl() {\r\n        return __classPrivateFieldGet(this, _SessionGlobalAccessObject_sessionEngine, \"f\").modelViewUrl;\r\n    }\r\n    get settingsEngine() {\r\n        return __classPrivateFieldGet(this, _SessionGlobalAccessObject_sessionEngine, \"f\").settingsEngine;\r\n    }\r\n    get settingsRegistered() {\r\n        return __classPrivateFieldGet(this, _SessionGlobalAccessObject_settingsRegistered, \"f\");\r\n    }\r\n    // #endregion Public Getters And Setters (9)\r\n    // #region Public Methods (1)\r\n    uploadGLTF(gltf, name) {\r\n        return __classPrivateFieldGet(this, _SessionGlobalAccessObject_sessionEngine, \"f\").uploadGLTF(gltf, name);\r\n    }\r\n}\r\nexports.SessionGlobalAccessObject = SessionGlobalAccessObject;\r\n_SessionGlobalAccessObject_sessionEngine = new WeakMap(), _SessionGlobalAccessObject_initialOutputsLoaded = new WeakMap(), _SessionGlobalAccessObject_initialized = new WeakMap(), _SessionGlobalAccessObject_isFirstSession = new WeakMap(), _SessionGlobalAccessObject_settingsRegistered = new WeakMap();\r\n//# sourceMappingURL=SessionGlobalAccessObject.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CreationControlCenterSession = void 0;\r\nconst CreationControlCenterSession_1 = require(\"./implementation/CreationControlCenterSession\");\r\nObject.defineProperty(exports, \"CreationControlCenterSession\", { enumerable: true, get: function () { return CreationControlCenterSession_1.CreationControlCenterSession; } });\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _CreationControlCenterViewport_eventEngine, _CreationControlCenterViewport_logger, _CreationControlCenterViewport_sceneTree, _CreationControlCenterViewport_stateEngine, _CreationControlCenterViewport_uuidGenerator;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CreationControlCenterViewport = void 0;\r\nconst viewer_shared_math_1 = require(\"@shapediver/viewer.shared.math\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_rendering_engine_rendering_engine_threejs_1 = require(\"@shapediver/viewer.rendering-engine.rendering-engine-threejs\");\r\nconst ViewportGlobalAccessObject_1 = require(\"./ViewportGlobalAccessObject\");\r\nconst viewer_rendering_engine_rendering_engine_1 = require(\"@shapediver/viewer.rendering-engine.rendering-engine\");\r\nclass CreationControlCenterViewport {\r\n    constructor() {\r\n        // #region Properties (8)\r\n        _CreationControlCenterViewport_eventEngine.set(this, viewer_shared_services_1.EventEngine.instance);\r\n        _CreationControlCenterViewport_logger.set(this, viewer_shared_services_1.Logger.instance);\r\n        _CreationControlCenterViewport_sceneTree.set(this, viewer_shared_node_tree_1.Tree.instance);\r\n        _CreationControlCenterViewport_stateEngine.set(this, viewer_shared_services_1.StateEngine.instance);\r\n        _CreationControlCenterViewport_uuidGenerator.set(this, viewer_shared_services_1.UuidGenerator.instance);\r\n        this.viewportEngines = {};\r\n        // #endregion Private Methods (1)\r\n    }\r\n    // #endregion Properties (8)\r\n    // #region Public Static Getters And Setters (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Getters And Setters (1)\r\n    // #region Public Methods (4)\r\n    applyViewportSettings(viewportId, settings, sections = { ar: false, scene: false, camera: false, light: false, environment: false, general: false }) {\r\n        var _a;\r\n        sections = sections || {};\r\n        const settingsEngine = new viewer_shared_services_1.SettingsEngine();\r\n        settingsEngine.loadSettings(settings);\r\n        const promises = [];\r\n        (_a = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[viewportId]) === null || _a === void 0 ? void 0 : _a.settingsAssigned.reset();\r\n        promises.push(new Promise(resolve => {\r\n            var _a;\r\n            (_a = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[viewportId]) === null || _a === void 0 ? void 0 : _a.settingsAssigned.then(() => {\r\n                resolve();\r\n            });\r\n        }));\r\n        this.viewportEngines[viewportId].applySettings(sections, settingsEngine);\r\n        return new Promise(resolve => Promise.all(promises).then(() => resolve()));\r\n    }\r\n    closeViewportEngine(id) {\r\n        var _a, _b, _c, _d;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this.viewportEngines[id])\r\n                return;\r\n            __classPrivateFieldGet(this, _CreationControlCenterViewport_logger, \"f\").debugLow(`CreationControlCenter.closeViewportEngine: Closing viewport ${id}.`);\r\n            if (((_a = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[id]) === null || _a === void 0 ? void 0 : _a.initialized.resolved) === false)\r\n                yield new Promise(resolve => { var _a; (_a = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[id]) === null || _a === void 0 ? void 0 : _a.initialized.then(() => resolve()); });\r\n            (_b = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[id]) === null || _b === void 0 ? void 0 : _b.settingsAssigned.reset();\r\n            (_c = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[id]) === null || _c === void 0 ? void 0 : _c.environmentMapLoaded.reset();\r\n            (_d = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[id]) === null || _d === void 0 ? void 0 : _d.initialized.reset();\r\n            yield this.viewportEngines[id].close();\r\n            this.viewportEngines[id] = undefined;\r\n            delete this.viewportEngines[id];\r\n            delete __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[id];\r\n            __classPrivateFieldGet(this, _CreationControlCenterViewport_logger, \"f\").debug('CreationControlCenter.closeViewportEngine: Viewport closed.');\r\n            if (this.updateViewports)\r\n                this.updateViewports(this.viewportEngines);\r\n            __classPrivateFieldGet(this, _CreationControlCenterViewport_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.VIEWPORT.VIEWPORT_CLOSED, { viewportId: id });\r\n        });\r\n    }\r\n    createViewportEngine(properties) {\r\n        var _a, _b, _c;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const eventId = __classPrivateFieldGet(this, _CreationControlCenterViewport_uuidGenerator, \"f\").create();\r\n            const viewportEngineId = properties.id || __classPrivateFieldGet(this, _CreationControlCenterViewport_uuidGenerator, \"f\").create();\r\n            properties.id = viewportEngineId;\r\n            try {\r\n                const eventStart = { type: viewer_shared_types_1.TASK_TYPE.VIEWPORT_CREATION, id: eventId, progress: 0, status: 'Creating viewport', data: { viewportId: viewportEngineId } };\r\n                __classPrivateFieldGet(this, _CreationControlCenterViewport_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);\r\n                // check if the given id is valid\r\n                if (this.viewportEngines[viewportEngineId]) {\r\n                    const eventClose = { type: viewer_shared_types_1.TASK_TYPE.VIEWPORT_CREATION, id: eventId, progress: 0.1, status: 'Closing viewport with same id', data: { viewportId: viewportEngineId } };\r\n                    __classPrivateFieldGet(this, _CreationControlCenterViewport_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventClose);\r\n                    __classPrivateFieldGet(this, _CreationControlCenterViewport_logger, \"f\").warn(`CreationControlCenter.createViewport: Viewer with this id (${viewportEngineId}) already exists. Closing initial instance.`);\r\n                    yield this.closeViewportEngine(viewportEngineId);\r\n                }\r\n                const viewportEngine = new viewer_rendering_engine_rendering_engine_threejs_1.RenderingEngine(properties);\r\n                __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[viewportEngineId] = new ViewportGlobalAccessObject_1.ViewportGlobalAccessObject(viewportEngine);\r\n                this.viewportEngines[viewportEngineId] = viewportEngine;\r\n                viewportEngine.start();\r\n                viewportEngine.cameraEngine.createDefaultCameras();\r\n                if (properties.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.MANUAL) {\r\n                    if (!properties.sessionSettingsId)\r\n                        throw new viewer_shared_services_1.ShapeDiverViewerViewportError('Session with sessionSettingsMode MANUAL needs to have a sessionSettingsId.');\r\n                    const sessionSettingsId = properties.sessionSettingsId;\r\n                    if (__classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").sessionEngines[sessionSettingsId]) {\r\n                        yield this.assignSettings(viewportEngine.id, sessionSettingsId, true);\r\n                    }\r\n                    else {\r\n                        // in createSession\r\n                    }\r\n                }\r\n                else if (properties.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.FIRST) {\r\n                    const firstSessionEngine = Object.values(__classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").sessionEngines).find(sessionEngine => sessionEngine && sessionEngine.isFirstSession === true);\r\n                    if (firstSessionEngine) {\r\n                        yield this.assignSettings(viewportEngine.id, firstSessionEngine.id, true);\r\n                    }\r\n                    else {\r\n                        // in createSession\r\n                    }\r\n                }\r\n                if (viewportEngine.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.NONE &&\r\n                    viewportEngine.visibility === viewer_rendering_engine_rendering_engine_1.VISIBILITY_MODE.SESSION) {\r\n                    viewportEngine.show = true;\r\n                }\r\n                else if (viewportEngine.visibility === viewer_rendering_engine_rendering_engine_1.VISIBILITY_MODE.INSTANT) {\r\n                    viewportEngine.show = true;\r\n                }\r\n                else if (viewportEngine.visibility === viewer_rendering_engine_rendering_engine_1.VISIBILITY_MODE.SESSION) {\r\n                    // wait for settings to load before showing the scene\r\n                    if (__classPrivateFieldGet(this, _CreationControlCenterViewport_sceneTree, \"f\").root.boundingBox.isEmpty()) {\r\n                        __classPrivateFieldGet(this, _CreationControlCenterViewport_eventEngine, \"f\").addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => {\r\n                            var _a, _b;\r\n                            const event = e;\r\n                            if (event.viewportId === viewportEngine.id) {\r\n                                const boundingBox = new viewer_shared_math_1.Box(event.boundingBox.min, event.boundingBox.max);\r\n                                if (boundingBox.isEmpty()) {\r\n                                    viewportEngine.show = false;\r\n                                }\r\n                                else {\r\n                                    if ((_a = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[viewportEngineId]) === null || _a === void 0 ? void 0 : _a.settingsAssigned.resolved) {\r\n                                        viewportEngine.show = true;\r\n                                    }\r\n                                    else {\r\n                                        (_b = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[viewportEngineId]) === null || _b === void 0 ? void 0 : _b.settingsAssigned.then(() => {\r\n                                            viewportEngine.show = true;\r\n                                        });\r\n                                    }\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        if ((_a = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[viewportEngineId]) === null || _a === void 0 ? void 0 : _a.settingsAssigned.resolved) {\r\n                            viewportEngine.show = true;\r\n                        }\r\n                        else {\r\n                            (_b = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[viewportEngineId]) === null || _b === void 0 ? void 0 : _b.settingsAssigned.then(() => {\r\n                                viewportEngine.show = true;\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                (_c = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[viewportEngineId]) === null || _c === void 0 ? void 0 : _c.initialized.resolve(true);\r\n                __classPrivateFieldGet(this, _CreationControlCenterViewport_logger, \"f\").debug(`CreationControlCenter.createViewport: Viewport(${viewportEngineId}) created.`);\r\n                const eventEnd = { type: viewer_shared_types_1.TASK_TYPE.VIEWPORT_CREATION, id: eventId, progress: 1, status: 'Viewport created', data: { viewportId: viewportEngineId } };\r\n                if (this.updateViewports)\r\n                    this.updateViewports(this.viewportEngines);\r\n                __classPrivateFieldGet(this, _CreationControlCenterViewport_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.VIEWPORT.VIEWPORT_CREATED, { viewportId: viewportEngineId });\r\n                __classPrivateFieldGet(this, _CreationControlCenterViewport_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);\r\n                return this.viewportEngines[viewportEngineId];\r\n            }\r\n            catch (e) {\r\n                const eventCancel1 = { type: viewer_shared_types_1.TASK_TYPE.VIEWPORT_CREATION, id: eventId, progress: 0.9, status: 'Viewport created failed, closing viewport', data: { viewportId: viewportEngineId } };\r\n                __classPrivateFieldGet(this, _CreationControlCenterViewport_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventCancel1);\r\n                try {\r\n                    yield this.closeViewportEngine(viewportEngineId);\r\n                }\r\n                catch ( /* empty */_d) { /* empty */ }\r\n                const eventCancel2 = { type: viewer_shared_types_1.TASK_TYPE.VIEWPORT_CREATION, id: eventId, progress: 1, status: 'Viewport created failed, exiting', data: { viewportId: viewportEngineId } };\r\n                __classPrivateFieldGet(this, _CreationControlCenterViewport_eventEngine, \"f\").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel2);\r\n                throw e;\r\n            }\r\n        });\r\n    }\r\n    getViewportSettings(viewportId) {\r\n        const viewportEngine = this.viewportEngines[viewportId];\r\n        if (!viewportEngine)\r\n            throw new viewer_shared_services_1.ShapeDiverViewerViewportError('Viewport with id ' + viewportId + ' could not be found.');\r\n        const settingsEngine = new viewer_shared_services_1.SettingsEngine();\r\n        viewportEngine.saveSettings(settingsEngine);\r\n        return settingsEngine.settings;\r\n    }\r\n    // #endregion Public Methods (4)\r\n    // #region Private Methods (1)\r\n    assignSettings(viewportEngineId, sessionEngineId, updateViewports = false) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const viewportEngine = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").viewportEngines[viewportEngineId];\r\n            if (!viewportEngine)\r\n                return;\r\n            if (__classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").sessionEngines[sessionEngineId] && __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").sessionEngines[sessionEngineId].initialized.resolved === true) {\r\n                // immediate\r\n                viewportEngine.assignSettingsEngine(__classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").sessionEngines[sessionEngineId].settingsEngine);\r\n                yield viewportEngine.applySettings(undefined, undefined, updateViewports);\r\n            }\r\n            else {\r\n                yield new Promise(resolve => {\r\n                    var _a;\r\n                    (_a = __classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").sessionEngines[sessionEngineId]) === null || _a === void 0 ? void 0 : _a.initialized.then(() => __awaiter(this, void 0, void 0, function* () {\r\n                        if (__classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").sessionEngines[sessionEngineId]) {\r\n                            viewportEngine.assignSettingsEngine(__classPrivateFieldGet(this, _CreationControlCenterViewport_stateEngine, \"f\").sessionEngines[sessionEngineId].settingsEngine);\r\n                            yield viewportEngine.applySettings(undefined, undefined, updateViewports);\r\n                        }\r\n                        resolve();\r\n                    }));\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.CreationControlCenterViewport = CreationControlCenterViewport;\r\n_CreationControlCenterViewport_eventEngine = new WeakMap(), _CreationControlCenterViewport_logger = new WeakMap(), _CreationControlCenterViewport_sceneTree = new WeakMap(), _CreationControlCenterViewport_stateEngine = new WeakMap(), _CreationControlCenterViewport_uuidGenerator = new WeakMap();\r\n//# sourceMappingURL=CreationControlCenterViewport.js.map","\"use strict\";\r\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _ViewportGlobalAccessObject_boundingBoxCreated, _ViewportGlobalAccessObject_initialized, _ViewportGlobalAccessObject_settingsAssigned, _ViewportGlobalAccessObject_viewportEngine, _ViewportGlobalAccessObject_busy, _ViewportGlobalAccessObject_environmentMapLoaded;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ViewportGlobalAccessObject = void 0;\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nclass ViewportGlobalAccessObject {\r\n    // #endregion Properties (6)\r\n    // #region Constructors (1)\r\n    constructor(viewportEngine) {\r\n        // #region Properties (6)\r\n        _ViewportGlobalAccessObject_boundingBoxCreated.set(this, new viewer_shared_services_1.StatePromise());\r\n        _ViewportGlobalAccessObject_initialized.set(this, new viewer_shared_services_1.StatePromise());\r\n        _ViewportGlobalAccessObject_settingsAssigned.set(this, new viewer_shared_services_1.StatePromise());\r\n        _ViewportGlobalAccessObject_viewportEngine.set(this, void 0);\r\n        _ViewportGlobalAccessObject_busy.set(this, []);\r\n        _ViewportGlobalAccessObject_environmentMapLoaded.set(this, new viewer_shared_services_1.StatePromise());\r\n        __classPrivateFieldSet(this, _ViewportGlobalAccessObject_viewportEngine, viewportEngine, \"f\");\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Getters And Setters (9)\r\n    get boundingBoxCreated() {\r\n        return __classPrivateFieldGet(this, _ViewportGlobalAccessObject_boundingBoxCreated, \"f\");\r\n    }\r\n    get busy() {\r\n        return __classPrivateFieldGet(this, _ViewportGlobalAccessObject_busy, \"f\");\r\n    }\r\n    get environmentMapLoaded() {\r\n        return __classPrivateFieldGet(this, _ViewportGlobalAccessObject_environmentMapLoaded, \"f\");\r\n    }\r\n    set environmentMapLoaded(value) {\r\n        __classPrivateFieldSet(this, _ViewportGlobalAccessObject_environmentMapLoaded, value, \"f\");\r\n    }\r\n    get id() {\r\n        return __classPrivateFieldGet(this, _ViewportGlobalAccessObject_viewportEngine, \"f\").id;\r\n    }\r\n    get initialized() {\r\n        return __classPrivateFieldGet(this, _ViewportGlobalAccessObject_initialized, \"f\");\r\n    }\r\n    get sessionSettingsId() {\r\n        return __classPrivateFieldGet(this, _ViewportGlobalAccessObject_viewportEngine, \"f\").sessionSettingsId;\r\n    }\r\n    get sessionSettingsMode() {\r\n        return __classPrivateFieldGet(this, _ViewportGlobalAccessObject_viewportEngine, \"f\").sessionSettingsMode;\r\n    }\r\n    get settingsAssigned() {\r\n        return __classPrivateFieldGet(this, _ViewportGlobalAccessObject_settingsAssigned, \"f\");\r\n    }\r\n    // #endregion Public Getters And Setters (9)\r\n    // #region Public Methods (6)\r\n    applySettings(sections, settingsEngine, updateViewport) {\r\n        return __classPrivateFieldGet(this, _ViewportGlobalAccessObject_viewportEngine, \"f\").applySettings(sections, settingsEngine, updateViewport);\r\n    }\r\n    assignSettingsEngine(settingsEngine) {\r\n        __classPrivateFieldGet(this, _ViewportGlobalAccessObject_viewportEngine, \"f\").assignSettingsEngine(settingsEngine);\r\n    }\r\n    displayErrorMessage(message) {\r\n        __classPrivateFieldGet(this, _ViewportGlobalAccessObject_viewportEngine, \"f\").displayErrorMessage(message);\r\n    }\r\n    reset() {\r\n        __classPrivateFieldGet(this, _ViewportGlobalAccessObject_viewportEngine, \"f\").reset();\r\n    }\r\n    saveSettings() {\r\n        __classPrivateFieldGet(this, _ViewportGlobalAccessObject_viewportEngine, \"f\").saveSettings();\r\n    }\r\n    update(id) {\r\n        __classPrivateFieldGet(this, _ViewportGlobalAccessObject_viewportEngine, \"f\").update(id);\r\n    }\r\n}\r\nexports.ViewportGlobalAccessObject = ViewportGlobalAccessObject;\r\n_ViewportGlobalAccessObject_boundingBoxCreated = new WeakMap(), _ViewportGlobalAccessObject_initialized = new WeakMap(), _ViewportGlobalAccessObject_settingsAssigned = new WeakMap(), _ViewportGlobalAccessObject_viewportEngine = new WeakMap(), _ViewportGlobalAccessObject_busy = new WeakMap(), _ViewportGlobalAccessObject_environmentMapLoaded = new WeakMap();\r\n//# sourceMappingURL=ViewportGlobalAccessObject.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CreationControlCenterViewport = void 0;\r\nconst CreationControlCenterViewport_1 = require(\"./implementation/CreationControlCenterViewport\");\r\nObject.defineProperty(exports, \"CreationControlCenterViewport\", { enumerable: true, get: function () { return CreationControlCenterViewport_1.CreationControlCenterViewport; } });\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DataEngine = void 0;\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_data_engine_geometry_engine_1 = require(\"@shapediver/viewer.data-engine.geometry-engine\");\r\nconst viewer_data_engine_html_element_anchor_engine_1 = require(\"@shapediver/viewer.data-engine.html-element-anchor-engine\");\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nconst viewer_data_engine_material_engine_1 = require(\"@shapediver/viewer.data-engine.material-engine\");\r\nconst viewer_data_engine_sdtf_engine_1 = require(\"@shapediver/viewer.data-engine.sdtf-engine\");\r\nconst viewer_data_engine_tag3d_engine_1 = require(\"@shapediver/viewer.data-engine.tag3d-engine\");\r\nclass DataEngine {\r\n    constructor() {\r\n        // #region Properties (8)\r\n        this._eventEngine = viewer_shared_services_1.EventEngine.instance;\r\n        this._geometryEngine = viewer_data_engine_geometry_engine_1.GeometryEngine.instance;\r\n        this._htmlElementAnchorEngine = viewer_data_engine_html_element_anchor_engine_1.HTMLElementAnchorEngine.instance;\r\n        this._materialEngine = viewer_data_engine_material_engine_1.MaterialEngine.instance;\r\n        this._sdtfEngine = viewer_data_engine_sdtf_engine_1.SDTFEngine.instance;\r\n        this._tag3dEngine = viewer_data_engine_tag3d_engine_1.Tag3dEngine.instance;\r\n        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;\r\n        // #endregion Public Methods (1)\r\n    }\r\n    // #endregion Properties (8)\r\n    // #region Public Static Getters And Setters (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Getters And Setters (1)\r\n    // #region Public Methods (1)\r\n    loadContent(content, jwtToken, taskEventId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!content || (content && !content.format))\r\n                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('DataEngine cannot load content.');\r\n            taskEventId = taskEventId || this._uuidGenerator.create();\r\n            let node;\r\n            if (content.format === 'glb' || content.format === 'gltf') {\r\n                node = yield this._geometryEngine.loadContent(content, taskEventId);\r\n            }\r\n            else if (content.format === 'material') {\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, { type: viewer_shared_types_1.TASK_TYPE.MATERIAL_CONTENT_LOADING, id: taskEventId, progress: 0, status: 'Loading material content.' });\r\n                node = yield this._materialEngine.loadContent(content);\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, { type: viewer_shared_types_1.TASK_TYPE.MATERIAL_CONTENT_LOADING, id: taskEventId, progress: 1, status: 'MATERIAL content loaded.' });\r\n            }\r\n            else if (content.format === 'tag2d' || content.format === 'anchor') {\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, { type: viewer_shared_types_1.TASK_TYPE.TAG_CONTENT_LOADING, id: taskEventId, progress: 0, status: 'Loading tag content.' });\r\n                node = yield this._htmlElementAnchorEngine.loadContent(content);\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, { type: viewer_shared_types_1.TASK_TYPE.TAG_CONTENT_LOADING, id: taskEventId, progress: 1, status: 'Tag content loaded.' });\r\n            }\r\n            else if (content.format === 'tag3d') {\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, { type: viewer_shared_types_1.TASK_TYPE.TAG_CONTENT_LOADING, id: taskEventId, progress: 0, status: 'Loading tag content.' });\r\n                node = yield this._tag3dEngine.loadContent(content);\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, { type: viewer_shared_types_1.TASK_TYPE.TAG_CONTENT_LOADING, id: taskEventId, progress: 1, status: 'Tag content loaded.' });\r\n            }\r\n            else if (content.format === 'sdtf') {\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, { type: viewer_shared_types_1.TASK_TYPE.SDTF_CONTENT_LOADING, id: taskEventId, progress: 0, status: 'Loading sdTF content.' });\r\n                node = yield this._sdtfEngine.loadContent(content, jwtToken);\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, { type: viewer_shared_types_1.TASK_TYPE.SDTF_CONTENT_LOADING, id: taskEventId, progress: 1, status: 'SdTF content loaded.' });\r\n            }\r\n            else {\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, { type: viewer_shared_types_1.TASK_TYPE.CUSTOM_CONTENT_LOADING, id: taskEventId, progress: 0, status: 'Loading custom content.' });\r\n                node = new viewer_shared_node_tree_1.TreeNode('custom');\r\n                node.data.push(new viewer_shared_types_1.CustomData(Object.assign({}, content)));\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, { type: viewer_shared_types_1.TASK_TYPE.CUSTOM_CONTENT_LOADING, id: taskEventId, progress: 1, status: 'Custom content loaded.' });\r\n            }\r\n            const transformationNode = new viewer_shared_node_tree_1.TreeNode('transformation');\r\n            if (content.transformations && Array.isArray(content.transformations)) {\r\n                for (let i = 0; i < content.transformations.length; i++) {\r\n                    const t = content.transformations[i];\r\n                    if (Array.isArray(t) && t.length === 16) {\r\n                        const nodeInstance = node.clone();\r\n                        nodeInstance.transformations = [{\r\n                                id: 'content_' + i,\r\n                                matrix: gl_matrix_1.mat4.fromValues(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15])\r\n                            }].concat(node.transformations);\r\n                        transformationNode.updateVersion();\r\n                        transformationNode.addChild(nodeInstance);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                transformationNode.addChild(node);\r\n            }\r\n            return transformationNode;\r\n        });\r\n    }\r\n}\r\nexports.DataEngine = DataEngine;\r\n//# sourceMappingURL=DataEngine.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DataEngine = void 0;\r\nconst DataEngine_1 = require(\"./DataEngine\");\r\nObject.defineProperty(exports, \"DataEngine\", { enumerable: true, get: function () { return DataEngine_1.DataEngine; } });\r\nconst viewer_shared_global_access_objects_1 = require(\"@shapediver/viewer.shared.global-access-objects\");\r\nconst instance = DataEngine_1.DataEngine.instance;\r\nviewer_shared_global_access_objects_1.GlobalAccessObjects.instance.loadContent = instance.loadContent.bind(instance);\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GeometryEngine = void 0;\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst GLTFLoader_1 = require(\"./gltfv1/GLTFLoader\");\r\nconst GLTFLoader_2 = require(\"./gltfv2/GLTFLoader\");\r\nclass GeometryEngine {\r\n    constructor() {\r\n        // #region Properties (7)\r\n        this.BINARY_EXTENSION_HEADER_LENGTH = 20;\r\n        this._httpClient = viewer_shared_services_1.HttpClient.instance;\r\n        this._loadingQueue = [];\r\n        this._logger = viewer_shared_services_1.Logger.instance;\r\n        this._performanceEvaluator = viewer_shared_services_1.PerformanceEvaluator.instance;\r\n        this._loadingQueueLength = Infinity;\r\n        // #endregion Public Methods (1)\r\n    }\r\n    // #endregion Properties (7)\r\n    // #region Public Static Accessors (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Accessors (1)\r\n    // #region Public Accessors (2)\r\n    get parallelGlTFProcessing() {\r\n        return this._loadingQueueLength;\r\n    }\r\n    set parallelGlTFProcessing(value) {\r\n        this._loadingQueueLength = value;\r\n    }\r\n    // #endregion Public Accessors (2)\r\n    // #region Public Methods (1)\r\n    /**\r\n     * Load the geometry content into a scene graph node.\r\n     *\r\n     * @param content the geometry content\r\n     * @returns the scene graph node\r\n     */\r\n    loadContent(content, taskEventId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!content || (content && !content.href))\r\n                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GeometryEngine cannot load content.');\r\n            while (this._loadingQueueLength <= this._loadingQueue.length)\r\n                yield new Promise(resolve => setTimeout(resolve, 10));\r\n            const url = content.href;\r\n            // eslint-disable-next-line no-async-promise-executor\r\n            const loadingPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n                let gltfContent, gltfBinary, gltfBaseUrl, gltfHeader;\r\n                let version = '2.0';\r\n                if (content.format === 'glb' || content.format === 'gltf') {\r\n                    this._performanceEvaluator.startSection('gltfProcessing.' + url);\r\n                    this._performanceEvaluator.startSection('loadGltf.' + url);\r\n                    const axiosResponse = yield this._httpClient.get(url, {\r\n                        responseType: 'arraybuffer'\r\n                    });\r\n                    this._performanceEvaluator.endSection('loadGltf.' + url);\r\n                    const magic = new TextDecoder().decode(new Uint8Array(axiosResponse.data, 0, 4));\r\n                    const isBinary = magic === 'glTF';\r\n                    if (isBinary) {\r\n                        gltfBinary = axiosResponse.data;\r\n                        // create header data\r\n                        const headerDataView = new DataView(gltfBinary, 0, this.BINARY_EXTENSION_HEADER_LENGTH);\r\n                        gltfHeader = {\r\n                            magic: magic,\r\n                            version: headerDataView.getUint32(4, true),\r\n                            length: headerDataView.getUint32(8, true),\r\n                            contentLength: headerDataView.getUint32(12, true),\r\n                            contentFormat: headerDataView.getUint32(16, true)\r\n                        };\r\n                        if (gltfHeader.magic != 'glTF')\r\n                            throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('Invalid data: glTF magic wrong.');\r\n                        // create content\r\n                        const contentDataView = new DataView(gltfBinary, this.BINARY_EXTENSION_HEADER_LENGTH, gltfHeader.contentLength);\r\n                        const contentDecoded = new TextDecoder().decode(contentDataView);\r\n                        gltfContent = JSON.parse(contentDecoded);\r\n                        if (gltfContent && gltfContent.asset && gltfContent.asset.version) {\r\n                            const assetVersion = (gltfContent.asset.version + '').endsWith('.0') ? gltfContent.asset.version : gltfContent.asset.version + '.0';\r\n                            if (gltfHeader.version + '.0' === assetVersion) {\r\n                                version = gltfHeader.version + '.0';\r\n                            }\r\n                            else {\r\n                                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GeometryEngine.loadContent: glTF header version (' + gltfHeader.version + ') is not the same as asset version (' + assetVersion + ').');\r\n                            }\r\n                        }\r\n                        else {\r\n                            version = gltfHeader.version + '.0';\r\n                        }\r\n                    }\r\n                    else {\r\n                        gltfContent = JSON.parse(new TextDecoder().decode(axiosResponse.data));\r\n                        if (gltfContent && gltfContent.asset && gltfContent.asset.version) {\r\n                            if (gltfContent.asset.version !== '2.0')\r\n                                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GeometryEngine.loadContent: Only gltf v2 is supported in a non-binary format.');\r\n                        }\r\n                        else {\r\n                            this._logger.warn('GeometryEngine.loadContent: No version specified in asset, trying to load as v2.');\r\n                            version = '2.0';\r\n                        }\r\n                        const removeLastDirectoryPartOf = (the_url) => {\r\n                            const dir_char = the_url.includes('/') ? '/' : '\\\\';\r\n                            const the_arr = the_url.split(dir_char);\r\n                            the_arr.pop();\r\n                            return the_arr.join(dir_char);\r\n                        };\r\n                        gltfBaseUrl = removeLastDirectoryPartOf(url);\r\n                        if (!gltfBaseUrl && window && window.location && window.location.href)\r\n                            gltfBaseUrl = removeLastDirectoryPartOf(window.location.href);\r\n                    }\r\n                }\r\n                let promise;\r\n                if (version === '1.0') {\r\n                    promise = new GLTFLoader_1.GLTFLoader().load(gltfContent, gltfBinary, gltfHeader, gltfBaseUrl, taskEventId);\r\n                }\r\n                else {\r\n                    promise = new GLTFLoader_2.GLTFLoader().load(gltfContent, gltfBinary, gltfHeader, gltfBaseUrl, taskEventId);\r\n                }\r\n                promise.catch(e => { reject(e); });\r\n                resolve(promise);\r\n            }));\r\n            this._loadingQueue.push(loadingPromise);\r\n            const node = yield loadingPromise;\r\n            this._loadingQueue.splice(this._loadingQueue.indexOf(loadingPromise), 1);\r\n            this._performanceEvaluator.endSection('gltfProcessing.' + url);\r\n            return node;\r\n        });\r\n    }\r\n}\r\nexports.GeometryEngine = GeometryEngine;\r\n//# sourceMappingURL=GeometryEngine.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GLTFLoader = void 0;\r\n/* eslint-disable no-prototype-builtins */\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_data_engine_shared_types_1 = require(\"@shapediver/viewer.data-engine.shared-types\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst SDGTFLoader_1 = require(\"./SDGTFLoader\");\r\nclass GLTFLoader {\r\n    constructor() {\r\n        // #region Properties (5)\r\n        this.BINARY_EXTENSION_HEADER_LENGTH = 20;\r\n        this._httpClient = viewer_shared_services_1.HttpClient.instance;\r\n        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;\r\n        this._logger = viewer_shared_services_1.Logger.instance;\r\n        this._implementedExtensions = ['KHR_materials_common'];\r\n        this._globalTransformation = gl_matrix_1.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);\r\n        this._eventEngine = viewer_shared_services_1.EventEngine.instance;\r\n        this._performanceEvaluator = viewer_shared_services_1.PerformanceEvaluator.instance;\r\n        this._progressUpdateLimit = 500;\r\n        this._eventId = '';\r\n        this._numberOfNodes = 0;\r\n        this._numberOfConvertedNodes = 0;\r\n        this._progressTimer = 0;\r\n        // #endregion Private Methods (6)\r\n    }\r\n    // #endregion Properties (5)\r\n    // #region Public Methods (1)\r\n    load(content, gltfBinary, gltfHeader, baseUri, taskEventId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._eventId = taskEventId || this._uuidGenerator.create();\r\n            const eventStart = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: 0, status: 'Starting glTF 1.0 loading.' };\r\n            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);\r\n            this._numberOfConvertedNodes = 0;\r\n            this._numberOfNodes = content.nodes ? Object.values(content.nodes).length : 0;\r\n            this._progressTimer = performance.now();\r\n            this._baseUri = baseUri;\r\n            if (gltfBinary && gltfHeader)\r\n                this._body = gltfBinary.slice(this.BINARY_EXTENSION_HEADER_LENGTH + gltfHeader.contentLength, gltfHeader.length);\r\n            this._content = content;\r\n            let sdgtfNode;\r\n            if (gltfBinary && gltfHeader)\r\n                sdgtfNode = yield new SDGTFLoader_1.SDGTFLoader().load(gltfBinary, gltfHeader.length);\r\n            const eventProgressSDgTF = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: 0.25, status: 'Loaded SDgTF content.' };\r\n            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventProgressSDgTF);\r\n            this.validateVersionAndExtensions();\r\n            const node = yield this.loadScene();\r\n            if (sdgtfNode)\r\n                node.addChild(sdgtfNode);\r\n            const eventEnd = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: 1, status: 'GlTF loading complete.' };\r\n            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);\r\n            return node;\r\n        });\r\n    }\r\n    loadWithUrl(url) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._performanceEvaluator.startSection('gltfProcessing.' + url);\r\n            this._performanceEvaluator.startSection('loadGltf.' + url);\r\n            const binaryGeometry = (yield this._httpClient.get(url, {\r\n                responseType: 'arraybuffer'\r\n            })).data;\r\n            this._performanceEvaluator.endSection('loadGltf.' + url);\r\n            // create header data\r\n            const headerDataView = new DataView(binaryGeometry, 0, this.BINARY_EXTENSION_HEADER_LENGTH);\r\n            const header = {\r\n                magic: String.fromCharCode(headerDataView.getUint8(0)) + String.fromCharCode(headerDataView.getUint8(1)) + String.fromCharCode(headerDataView.getUint8(2)) + String.fromCharCode(headerDataView.getUint8(3)),\r\n                version: headerDataView.getUint32(4, true),\r\n                length: headerDataView.getUint32(8, true),\r\n                contentLength: headerDataView.getUint32(12, true),\r\n                contentFormat: headerDataView.getUint32(16, true)\r\n            };\r\n            if (header.magic != 'glTF')\r\n                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GLTFLoader.load: Invalid data: glTF magic wrong.');\r\n            // create content\r\n            const contentDataView = new DataView(binaryGeometry, this.BINARY_EXTENSION_HEADER_LENGTH, header.contentLength);\r\n            const contentDecoded = new TextDecoder().decode(contentDataView);\r\n            this._content = JSON.parse(contentDecoded);\r\n            // create body\r\n            this._body = binaryGeometry.slice(this.BINARY_EXTENSION_HEADER_LENGTH + header.contentLength, header.length);\r\n            const sdgtfNode = yield new SDGTFLoader_1.SDGTFLoader().load(binaryGeometry, header.length);\r\n            this.validateVersionAndExtensions();\r\n            const node = yield this.loadScene();\r\n            node.addChild(sdgtfNode);\r\n            this._performanceEvaluator.endSection('gltfProcessing.' + url);\r\n            return node;\r\n        });\r\n    }\r\n    // #endregion Public Methods (1)\r\n    // #region Private Methods (6)\r\n    validateVersionAndExtensions() {\r\n        if (this._content.extensionsUsed) {\r\n            const notSupported = [];\r\n            for (let i = 0; i < this._content.extensionsUsed.length; i++) {\r\n                if (!this._implementedExtensions.includes(this._content.extensionsUsed[i]))\r\n                    notSupported.push(this._content.extensionsUsed[i]);\r\n            }\r\n            if (notSupported.length > 0) {\r\n                let message = 'Extension' + (notSupported.length === 1 ? ' ' : 's ');\r\n                notSupported.forEach((element, index) => {\r\n                    message += '\"' + element + '\"' + (index === notSupported.length - 1 ? '' : index === notSupported.length - 2 ? ' and ' : ', ');\r\n                });\r\n                message += (notSupported.length === 1 ? ' is' : ' are') + ' not supported, but used. Loading glTF regardless.';\r\n                this._logger.info('GLTFLoader.validateVersionAndExtensions: ' + message);\r\n            }\r\n        }\r\n    }\r\n    loadAccessor(accessorName) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.accessors[accessorName])\r\n                throw new Error('Accessor not available.');\r\n            const accessor = this._content.accessors[accessorName];\r\n            const bufferView = yield this.loadBufferView(accessor.bufferView);\r\n            const itemSize = viewer_data_engine_shared_types_1.ACCESSORTYPE_V1[accessor.type];\r\n            if (accessor.componentType === 5124)\r\n                this._logger.warn('GLTFLoader.loadAccessor: The componentType for this accessor is 5124, which is not allowed. Trying to load it anyway.');\r\n            const ArrayType = viewer_data_engine_shared_types_1.ACCESSORCOMPONENTTYPE_V1[accessor.componentType];\r\n            const elementBytes = ArrayType.BYTES_PER_ELEMENT;\r\n            const itemBytes = elementBytes * itemSize;\r\n            const byteOffset = accessor.byteOffset || 0;\r\n            const byteStride = accessor.byteStride;\r\n            const normalized = false;\r\n            const target = this._content.bufferViews[accessor.bufferView] ? this._content.bufferViews[accessor.bufferView].target : undefined;\r\n            const min = this._content.asset && ((_a = this._content.asset) === null || _a === void 0 ? void 0 : _a.generator) === 'ShapeDiverGltfV1Writer' ? accessor.min || [] : [];\r\n            const max = this._content.asset && ((_b = this._content.asset) === null || _b === void 0 ? void 0 : _b.generator) === 'ShapeDiverGltfV1Writer' ? accessor.max || [] : [];\r\n            // The buffer is not interleaved if the stride is the item size in bytes.\r\n            return new viewer_shared_types_1.AttributeData(new ArrayType(bufferView), itemSize, itemBytes, byteOffset, elementBytes, normalized, accessor.count, min, max, byteStride, target);\r\n        });\r\n    }\r\n    loadBuffer(bufferName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.buffers[bufferName])\r\n                throw new Error('Buffer not available.');\r\n            const buffer = this._content.buffers[bufferName];\r\n            if (bufferName === 'binary_glTF')\r\n                return this._body;\r\n            if (buffer.type === 'arraybuffer') {\r\n                const binaryGeometry = (yield this._httpClient.get(buffer.uri, {\r\n                    responseType: 'arraybuffer'\r\n                })).data;\r\n                return binaryGeometry;\r\n            }\r\n            if (!this._body)\r\n                throw new Error('Buffer not available.');\r\n            return this._body;\r\n        });\r\n    }\r\n    loadBufferView(bufferViewName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.bufferViews[bufferViewName])\r\n                throw new Error('Buffer View not available.');\r\n            const bufferView = this._content.bufferViews[bufferViewName];\r\n            const buffer = yield this.loadBuffer(bufferView.buffer);\r\n            const byteLength = bufferView.byteLength !== undefined ? bufferView.byteLength : 0;\r\n            return buffer.slice(bufferView.byteOffset, bufferView.byteOffset + byteLength);\r\n        });\r\n    }\r\n    loadMaterial(materialName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.materials[materialName])\r\n                throw new Error('Material not available.');\r\n            const material = this._content.materials[materialName];\r\n            const materialData = new viewer_shared_types_1.MaterialStandardData();\r\n            if (material.name !== undefined)\r\n                materialData.name = material.name;\r\n            if (material.extensions && material.extensions.KHR_materials_common) {\r\n                const technique = material.extensions.KHR_materials_common.technique;\r\n                if (technique && technique !== 'BLINN')\r\n                    this._logger.warn('The technique ' + technique + ' is not supported. Trying to load the material either way.');\r\n                const values = material.extensions.KHR_materials_common.values;\r\n                if (values.hasOwnProperty('doubleSided'))\r\n                    materialData.side = values.doubleSided ? viewer_shared_types_1.MATERIAL_SIDE.DOUBLE : viewer_shared_types_1.MATERIAL_SIDE.FRONT;\r\n                materialData.color = '#d3d3d3';\r\n                if (values.hasOwnProperty('diffuse') && Array.isArray(values.diffuse)) {\r\n                    const diffuseScaled = values.diffuse.map(element => element *= 255.0);\r\n                    materialData.color = diffuseScaled;\r\n                    materialData.opacity = Math.max(0.0, Math.min(values.diffuse[3], 1.0));\r\n                }\r\n                else if (values.hasOwnProperty('diffuse')) {\r\n                    this._logger.warn('GLTFLoader.loadMaterial: The value diffuse was set for a material, but is not supported in that type.');\r\n                }\r\n                if (!values.hasOwnProperty('diffuse') && values.hasOwnProperty('ambient')) {\r\n                    const ambientScaled = values.ambient.map(element => element *= 255.0);\r\n                    materialData.color = ambientScaled;\r\n                }\r\n                if (values.hasOwnProperty('emission') && Array.isArray(values.emission)) {\r\n                    materialData.emissiveness = values.emission;\r\n                }\r\n                else if (values.hasOwnProperty('emission')) {\r\n                    this._logger.warn('GLTFLoader.loadMaterial: The value emission was set for a material, but is not supported in that type.');\r\n                }\r\n                if (values.hasOwnProperty('shininess')) {\r\n                    materialData.metalness = Math.min(1, values.shininess);\r\n                    materialData.roughness = 1 - Math.min(1, values.shininess);\r\n                }\r\n                if (values.hasOwnProperty('transparency'))\r\n                    materialData.opacity = Math.max(0.0, Math.min(values.transparency, 1.0));\r\n                if (!values.hasOwnProperty('transparency') && values.hasOwnProperty('transparent') && (values.transparency === 'true' || values.transparency === true))\r\n                    materialData.opacity = 0;\r\n                if (values.hasOwnProperty('_roughness'))\r\n                    materialData.roughness = Math.min(1, Math.max(0, values.roughness));\r\n                if (values.hasOwnProperty('_metalness'))\r\n                    materialData.metalness = Math.min(1, Math.max(0, values.metalness));\r\n            }\r\n            return materialData;\r\n        });\r\n    }\r\n    loadMesh(meshName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.meshes[meshName])\r\n                throw new Error('Mesh not available.');\r\n            const mesh = this._content.meshes[meshName];\r\n            const meshNode = new viewer_shared_node_tree_1.TreeNode(meshName);\r\n            if (!mesh.primitives)\r\n                return new viewer_shared_node_tree_1.TreeNode('primitive');\r\n            for (let i = 0, len = mesh.primitives.length; i < len; i++) {\r\n                const primitiveNode = new viewer_shared_node_tree_1.TreeNode('primitive_' + i);\r\n                meshNode.addChild(primitiveNode);\r\n                const primitive = mesh.primitives[i];\r\n                const attributes = {};\r\n                for (const attribute in primitive.attributes) {\r\n                    // attribute name conversion to be consistent witg gltf\r\n                    let attributeName = attribute;\r\n                    if (/\\d/.test(attributeName) && !attributeName.includes('_')) {\r\n                        const index = attributeName.search(/\\d/);\r\n                        attributeName = attributeName.substring(0, index) + '_' + attributeName.substring(index, attributeName.length);\r\n                    }\r\n                    else if (attributeName === 'TEXCOORD' || attributeName === 'COLOR' || attributeName === 'JOINTS' || attributeName === 'WEIGHTS') {\r\n                        attributeName += '_0';\r\n                    }\r\n                    else if (attributeName === 'UV') {\r\n                        attributeName = 'TEXCOORD_0';\r\n                    }\r\n                    attributes[attributeName] = yield this.loadAccessor(primitive.attributes[attribute]);\r\n                    if (attributeName.startsWith('COLOR'))\r\n                        attributes[attributeName] = new viewer_shared_types_1.AttributeData(attributes[attributeName].array, attributes[attributeName].itemSize, attributes[attributeName].itemBytes, attributes[attributeName].byteOffset, attributes[attributeName].elementBytes, true, attributes[attributeName].count, [], [], attributes[attributeName].byteStride, attributes[attributeName].target);\r\n                }\r\n                let material;\r\n                if (primitive.material)\r\n                    material = yield this.loadMaterial(primitive.material);\r\n                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, yield this.loadAccessor(primitive.indices)), viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES, material);\r\n                primitiveNode.data.push(geometry);\r\n            }\r\n            return meshNode;\r\n        });\r\n    }\r\n    loadNode(nodeName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.nodes[nodeName])\r\n                throw new Error('Node not available.');\r\n            const node = this._content.nodes[nodeName];\r\n            const nodeDef = new viewer_shared_node_tree_1.TreeNode(nodeName);\r\n            if (node.matrix) {\r\n                nodeDef.addTransformation({\r\n                    id: this._uuidGenerator.create(),\r\n                    matrix: gl_matrix_1.mat4.fromValues(node.matrix[0], node.matrix[1], node.matrix[2], node.matrix[3], node.matrix[4], node.matrix[5], node.matrix[6], node.matrix[7], node.matrix[8], node.matrix[9], node.matrix[10], node.matrix[11], node.matrix[12], node.matrix[13], node.matrix[14], node.matrix[15])\r\n                });\r\n            }\r\n            else if (node.translation || node.scale || node.rotation) {\r\n                const matT = node.translation ? gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(node.translation[0], node.translation[1], node.translation[2])) : gl_matrix_1.mat4.create();\r\n                const matS = node.scale ? gl_matrix_1.mat4.fromScaling(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(node.scale[0], node.scale[1], node.scale[2])) : gl_matrix_1.mat4.create();\r\n                const matR = node.rotation ? gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), gl_matrix_1.vec4.fromValues(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3])) : gl_matrix_1.mat4.create();\r\n                const matrix = gl_matrix_1.mat4.mul(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.mul(gl_matrix_1.mat4.create(), matT, matS), matR);\r\n                nodeDef.addTransformation({\r\n                    id: this._uuidGenerator.create(),\r\n                    matrix: matrix\r\n                });\r\n            }\r\n            if (node.meshes) {\r\n                for (let i = 0, len = node.meshes.length; i < len; i++) {\r\n                    // we create a child node as we one want to have one mesh as in the GLTF2 def\r\n                    nodeDef.addChild(yield this.loadMesh(node.meshes[i]));\r\n                }\r\n            }\r\n            if (node.children) {\r\n                for (let i = 0, len = node.children.length; i < len; i++) {\r\n                    // got through all children\r\n                    nodeDef.addChild(yield this.loadNode(node.children[i]));\r\n                }\r\n            }\r\n            this._numberOfConvertedNodes++;\r\n            if (performance.now() - this._progressTimer > this._progressUpdateLimit) {\r\n                this._progressTimer = performance.now();\r\n                const eventProgress = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: (this._numberOfConvertedNodes / this._numberOfNodes) / 2 + 0.25, status: `GlTF conversion progress: ${this._numberOfConvertedNodes}/${this._numberOfNodes} nodes.` };\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventProgress);\r\n                yield new Promise(resolve => setTimeout(resolve, 0));\r\n            }\r\n            return nodeDef;\r\n        });\r\n    }\r\n    loadScene() {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.scene)\r\n                throw new Error('No scene.');\r\n            if (!this._content.scenes[this._content.scene])\r\n                throw new Error('Scene not available.');\r\n            const scene = this._content.scenes[this._content.scene];\r\n            const sceneDef = new viewer_shared_node_tree_1.TreeNode(this._content.scene);\r\n            if (this._content.asset && ((_a = this._content.asset) === null || _a === void 0 ? void 0 : _a.generator) !== 'ShapeDiverGltfWriter' && ((_b = this._content.asset) === null || _b === void 0 ? void 0 : _b.generator) !== 'ShapeDiverGltfV1Writer') {\r\n                sceneDef.addTransformation({\r\n                    id: this._uuidGenerator.create(),\r\n                    matrix: this._globalTransformation\r\n                });\r\n            }\r\n            if (scene.nodes)\r\n                for (let i = 0, len = scene.nodes.length; i < len; i++)\r\n                    sceneDef.addChild(yield this.loadNode(scene.nodes[i]));\r\n            return sceneDef;\r\n        });\r\n    }\r\n}\r\nexports.GLTFLoader = GLTFLoader;\r\n//# sourceMappingURL=GLTFLoader.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SDGTFLoader = void 0;\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_data_engine_shared_types_1 = require(\"@shapediver/viewer.data-engine.shared-types\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nclass SDGTFLoader {\r\n    constructor() {\r\n        // #region Properties (5)\r\n        this.BINARY_EXTENSION_HEADER_LENGTH = 20;\r\n        this._logger = viewer_shared_services_1.Logger.instance;\r\n        // #endregion Private Methods (6)\r\n    }\r\n    // #endregion Properties (5)\r\n    // #region Public Methods (1)\r\n    load(binaryGeometry, gltfLength) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (gltfLength < binaryGeometry.byteLength) {\r\n                const headerDataView = new DataView(binaryGeometry, gltfLength, this.BINARY_EXTENSION_HEADER_LENGTH + 1);\r\n                const header = {\r\n                    magic: String.fromCharCode(headerDataView.getUint8(0)) + String.fromCharCode(headerDataView.getUint8(1)) + String.fromCharCode(headerDataView.getUint8(2)) + String.fromCharCode(headerDataView.getUint8(3)) + String.fromCharCode(headerDataView.getUint8(4)),\r\n                    version: headerDataView.getUint32(5, true),\r\n                    length: headerDataView.getUint32(9, true),\r\n                    contentLength: headerDataView.getUint32(13, true),\r\n                    contentFormat: headerDataView.getUint32(17, true)\r\n                };\r\n                if (header.magic != 'sdgTF')\r\n                    throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('SDGTFLoader.load: Invalid data: sdgTF magic wrong.');\r\n                // create content\r\n                const contentDataView = new DataView(binaryGeometry, gltfLength + this.BINARY_EXTENSION_HEADER_LENGTH + 1, header.contentLength);\r\n                const contentDecoded = new TextDecoder().decode(contentDataView);\r\n                this._content = JSON.parse(contentDecoded);\r\n                this._body = binaryGeometry.slice(gltfLength + this.BINARY_EXTENSION_HEADER_LENGTH + 1 + header.contentLength, gltfLength + header.length);\r\n            }\r\n            else {\r\n                return new viewer_shared_node_tree_1.TreeNode();\r\n            }\r\n            return yield this.loadScene();\r\n        });\r\n    }\r\n    // #endregion Public Methods (1)\r\n    // #region Private Methods (6)\r\n    convertToIndicesArray(indices) {\r\n        const max = Math.max(0, ...indices);\r\n        if (max < (1 << 8) - 1) {\r\n            return new Uint8Array(indices);\r\n        }\r\n        else if (max < (1 << 16) - 1) {\r\n            return new Uint16Array(indices);\r\n        }\r\n        else {\r\n            return new Uint32Array(indices);\r\n        }\r\n    }\r\n    loadAccessor(accessorName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.accessors[accessorName])\r\n                throw new Error('Accessor not available.');\r\n            const accessor = this._content.accessors[accessorName];\r\n            const bufferView = this._body;\r\n            const itemSize = viewer_data_engine_shared_types_1.ACCESSORTYPE_V1[accessor.type];\r\n            const ArrayType = viewer_data_engine_shared_types_1.ACCESSORCOMPONENTTYPE_V1[accessor.componentType];\r\n            const elementBytes = ArrayType.BYTES_PER_ELEMENT;\r\n            const itemBytes = elementBytes * itemSize;\r\n            const byteOffset = accessor.byteOffset || 0;\r\n            return new viewer_shared_types_1.AttributeData(new ArrayType(bufferView, byteOffset, itemSize * accessor.count), itemSize, itemBytes, byteOffset, elementBytes, false, accessor.count);\r\n        });\r\n    }\r\n    loadArcs() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.arcs)\r\n                throw new Error('Arcs not available.');\r\n            const arc = this._content.arcs;\r\n            const arcNode = new viewer_shared_node_tree_1.TreeNode('arcs');\r\n            const data = yield this.loadAccessor(arc.attributes['ARCS']);\r\n            // data with an absolute classic array of Vec12s ...\r\n            // like you usually have it in any good program\r\n            // not 4 Vec3s, no, that would be to logic, but a Vec12 instead\r\n            const count = data.array.length / data.itemSize;\r\n            for (let i = 0; i < count; ++i) {\r\n                const singleArcNode = new viewer_shared_node_tree_1.TreeNode('arc_' + i);\r\n                const index = i * 12;\r\n                const arcCenter = gl_matrix_1.vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);\r\n                const arcXAxis = gl_matrix_1.vec3.fromValues(data.array[index + 3], data.array[index + 4], data.array[index + 5]);\r\n                const arcYAxis = gl_matrix_1.vec3.fromValues(data.array[index + 6], data.array[index + 7], data.array[index + 8]);\r\n                const arcRadius = data.array[index + 9];\r\n                const arcMinAngle = data.array[index + 10];\r\n                const arcMaxAngle = data.array[index + 11];\r\n                const arcZAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), arcXAxis, arcYAxis);\r\n                if (arcRadius <= 0) {\r\n                    this._logger.warn('SDGTFLoader.loadArcs: Arc radius is <= 0.');\r\n                    continue;\r\n                }\r\n                const points = [];\r\n                const getPointOnArc = (t) => {\r\n                    const twoPi = Math.PI * 2;\r\n                    let deltaAngle = arcMaxAngle - arcMinAngle;\r\n                    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;\r\n                    // ensures that deltaAngle is 0 .. 2 PI\r\n                    while (deltaAngle < 0)\r\n                        deltaAngle += twoPi;\r\n                    while (deltaAngle > twoPi)\r\n                        deltaAngle -= twoPi;\r\n                    deltaAngle = deltaAngle < Number.EPSILON ? samePoints ? 0 : twoPi : deltaAngle;\r\n                    const angle = arcMinAngle + t * deltaAngle;\r\n                    let x = arcRadius * Math.cos(angle);\r\n                    let y = arcRadius * Math.sin(angle);\r\n                    points.push(x, y, 0);\r\n                };\r\n                const numberOfPoints = Math.max(3, Math.round(50 * ((arcMaxAngle - arcMinAngle) / 2 * Math.PI)));\r\n                for (let d = 0; d <= numberOfPoints; d++)\r\n                    getPointOnArc(d / numberOfPoints);\r\n                const array = new Float32Array(points);\r\n                const attributes = {};\r\n                attributes['POSITION'] = new viewer_shared_types_1.AttributeData(array, 3, 0, 0, 0, false, array.length / 3);\r\n                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, null), viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP);\r\n                singleArcNode.data.push(geometry);\r\n                singleArcNode.addTransformation({\r\n                    id: 'arc_' + i + '_translation',\r\n                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(arcCenter[0], arcCenter[1], arcCenter[2]))\r\n                });\r\n                const arcRotationMatrix = gl_matrix_1.mat4.transpose(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.fromValues(arcXAxis[0], arcYAxis[0], arcZAxis[0], 0, arcXAxis[1], arcYAxis[1], arcZAxis[1], 0, arcXAxis[2], arcYAxis[2], arcZAxis[2], 0, 0, 0, 0, 1));\r\n                singleArcNode.addTransformation({\r\n                    id: 'arc_' + i + '_rotation',\r\n                    matrix: arcRotationMatrix\r\n                });\r\n                arcNode.addChild(singleArcNode);\r\n            }\r\n            return arcNode;\r\n        });\r\n    }\r\n    loadBeziercurve(beziercurveName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.beziercurves[beziercurveName])\r\n                throw new Error('Beziercurve not available.');\r\n            const beziercurve = this._content.beziercurves[beziercurveName];\r\n            const beziercurveNode = new viewer_shared_node_tree_1.TreeNode(beziercurveName);\r\n            const controlPointsData = yield this.loadAccessor(beziercurve.attributes['CONTROLPOINTS']); // vec3\r\n            const controlPoints = [];\r\n            for (let i = 0; i < controlPointsData.array.length; i += 3)\r\n                controlPoints.push(gl_matrix_1.vec4.fromValues(controlPointsData.array[i], controlPointsData.array[i + 1], controlPointsData.array[i + 2], 1));\r\n            const knotsData = yield this.loadAccessor(beziercurve.attributes['KNOTS']); // scalar\r\n            const knots = [knotsData.array[0]];\r\n            for (let i = 0; i < knotsData.array.length; i++)\r\n                knots.push(knotsData.array[i]);\r\n            knots.push(knotsData.array[knotsData.array.length - 1]);\r\n            const degree = beziercurve.degree;\r\n            const findSpan = (u) => {\r\n                const n = knots.length - degree - 1;\r\n                if (u >= knots[n])\r\n                    return n - 1;\r\n                if (u <= knots[degree])\r\n                    return degree;\r\n                let low = degree;\r\n                let high = n;\r\n                let mid = Math.floor((low + high) / 2);\r\n                while (u < knots[mid] || u >= knots[mid + 1]) {\r\n                    if (u < knots[mid]) {\r\n                        high = mid;\r\n                    }\r\n                    else {\r\n                        low = mid;\r\n                    }\r\n                    mid = Math.floor((low + high) / 2);\r\n                }\r\n                return mid;\r\n            };\r\n            const calcBasisFunctions = (span, u) => {\r\n                const N = [];\r\n                const left = [];\r\n                const right = [];\r\n                N[0] = 1.0;\r\n                for (let j = 1; j <= degree; ++j) {\r\n                    left[j] = u - knots[span + 1 - j];\r\n                    right[j] = knots[span + j] - u;\r\n                    let saved = 0.0;\r\n                    for (let r = 0; r < j; ++r) {\r\n                        const rv = right[r + 1];\r\n                        const lv = left[j - r];\r\n                        const temp = N[r] / (rv + lv);\r\n                        N[r] = saved + rv * temp;\r\n                        saved = lv * temp;\r\n                    }\r\n                    N[j] = saved;\r\n                }\r\n                return N;\r\n            };\r\n            const calcBSplinePoint = (u) => {\r\n                const span = findSpan(u);\r\n                const N = calcBasisFunctions(span, u);\r\n                const C = gl_matrix_1.vec4.create();\r\n                for (let j = 0; j <= degree; ++j) {\r\n                    const point = controlPoints[span - degree + j];\r\n                    const Nj = N[j];\r\n                    const wNj = point[3] * Nj;\r\n                    gl_matrix_1.vec4.add(C, C, gl_matrix_1.vec4.fromValues(point[0] * wNj, point[1] * wNj, point[2] * wNj, point[3] * Nj));\r\n                }\r\n                return C;\r\n            };\r\n            const points = [];\r\n            const getPointOnBezierCurve = (t) => {\r\n                const u = knots[0] + t * (knots[knots.length - 1] - knots[0]); // linear mapping t->u\r\n                // following results in (wx, wy, wz, w) homogeneous point\r\n                let hpoint = calcBSplinePoint(u);\r\n                if (hpoint[3] !== 1.0) {\r\n                    // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\r\n                    hpoint = gl_matrix_1.vec4.divide(gl_matrix_1.vec4.create(), hpoint, gl_matrix_1.vec4.fromValues(hpoint[3], hpoint[3], hpoint[3], hpoint[3]));\r\n                }\r\n                points.push(hpoint[0], hpoint[1], hpoint[2]);\r\n            };\r\n            // Number of points calculation\r\n            // We go through the control points, measure the distance\r\n            let distance = 0;\r\n            for (let i = 1; i < controlPoints.length; i++)\r\n                distance += gl_matrix_1.vec3.distance(gl_matrix_1.vec3.fromValues(controlPoints[i - 1][0], controlPoints[i - 1][1], controlPoints[i - 1][2]), gl_matrix_1.vec3.fromValues(controlPoints[i][0], controlPoints[i][1], controlPoints[i][2]));\r\n            const numberOfPoints = Math.min(100, Math.max(25, Math.floor(distance / 0.1)));\r\n            for (let d = 0; d <= numberOfPoints; d++)\r\n                getPointOnBezierCurve(d / numberOfPoints);\r\n            const array = new Float32Array(points);\r\n            const attributes = {};\r\n            attributes['POSITION'] = new viewer_shared_types_1.AttributeData(array, 3, 0, 0, 0, false, array.length / 3);\r\n            const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, null), viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP);\r\n            beziercurveNode.data.push(geometry);\r\n            return beziercurveNode;\r\n        });\r\n    }\r\n    loadCircles() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.circles)\r\n                throw new Error('Circles not available.');\r\n            const circle = this._content.circles;\r\n            const circleNode = new viewer_shared_node_tree_1.TreeNode('circles');\r\n            const data = yield this.loadAccessor(circle.attributes['CIRCLES']);\r\n            const count = data.array.length / data.itemSize;\r\n            for (let i = 0; i < count; i++) {\r\n                const singleCircleNode = new viewer_shared_node_tree_1.TreeNode('circle_' + i);\r\n                const index = i * 10;\r\n                const circleCenter = gl_matrix_1.vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);\r\n                const circleXAxis = gl_matrix_1.vec3.fromValues(data.array[index + 3], data.array[index + 4], data.array[index + 5]);\r\n                const circleYAxis = gl_matrix_1.vec3.fromValues(data.array[index + 6], data.array[index + 7], data.array[index + 8]);\r\n                const circleRadius = data.array[index + 9];\r\n                const circleZAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), circleXAxis, circleYAxis);\r\n                if (circleRadius <= 0) {\r\n                    this._logger.warn('SDGTFLoader.loadCircles: Circle radius is <= 0.');\r\n                    continue;\r\n                }\r\n                const points = [];\r\n                const getPointOnArc = (t) => {\r\n                    const twoPi = Math.PI * 2;\r\n                    let deltaAngle = 2.0 * Math.PI - 0;\r\n                    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;\r\n                    // ensures that deltaAngle is 0 .. 2 PI\r\n                    while (deltaAngle < 0)\r\n                        deltaAngle += twoPi;\r\n                    while (deltaAngle > twoPi)\r\n                        deltaAngle -= twoPi;\r\n                    deltaAngle = deltaAngle < Number.EPSILON ? samePoints ? 0 : twoPi : deltaAngle;\r\n                    const angle = 0 + t * deltaAngle;\r\n                    let x = circleRadius * Math.cos(angle);\r\n                    let y = circleRadius * Math.sin(angle);\r\n                    points.push(x, y, 0);\r\n                };\r\n                const numberOfPoints = 50;\r\n                for (let d = 0; d <= numberOfPoints; d++)\r\n                    getPointOnArc(d / numberOfPoints);\r\n                const array = new Float32Array(points);\r\n                const attributes = {};\r\n                attributes['POSITION'] = new viewer_shared_types_1.AttributeData(array, 3, 0, 0, 0, false, array.length / 3);\r\n                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, null), viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP);\r\n                singleCircleNode.data.push(geometry);\r\n                singleCircleNode.addTransformation({\r\n                    id: 'circle_' + i + '_translation',\r\n                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(circleCenter[0], circleCenter[1], circleCenter[2]))\r\n                });\r\n                const circleRotationMatrix = gl_matrix_1.mat4.transpose(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.fromValues(circleXAxis[0], circleYAxis[0], circleZAxis[0], 0, circleXAxis[1], circleYAxis[1], circleZAxis[1], 0, circleXAxis[2], circleYAxis[2], circleZAxis[2], 0, 0, 0, 0, 1));\r\n                singleCircleNode.addTransformation({\r\n                    id: 'circle_' + i + '_rotation',\r\n                    matrix: circleRotationMatrix\r\n                });\r\n                circleNode.addChild(singleCircleNode);\r\n            }\r\n            return circleNode;\r\n        });\r\n    }\r\n    loadCylinders() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.cylinders)\r\n                throw new Error('Cylinders not available.');\r\n            const cylinder = this._content.cylinders;\r\n            const cylinderNode = new viewer_shared_node_tree_1.TreeNode('cylinders');\r\n            const data = yield this.loadAccessor(cylinder.attributes['CYLINDERS']);\r\n            const count = data.array.length / data.itemSize;\r\n            for (let i = 0; i < count; i++) {\r\n                const singleCylinderNode = new viewer_shared_node_tree_1.TreeNode('cylinder_' + i);\r\n                const index = i * 7;\r\n                const cylinderTop = gl_matrix_1.vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);\r\n                const cylinderBottom = gl_matrix_1.vec3.fromValues(data.array[index + 3], data.array[index + 4], data.array[index + 5]);\r\n                const cylinderRadius = data.array[index + 6];\r\n                const cylinderAxis = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), cylinderTop, cylinderBottom);\r\n                const dotX = Math.abs(gl_matrix_1.vec3.dot(cylinderAxis, gl_matrix_1.vec3.fromValues(1, 0, 0)));\r\n                const dotY = Math.abs(gl_matrix_1.vec3.dot(cylinderAxis, gl_matrix_1.vec3.fromValues(0, 1, 0)));\r\n                let cylinderXAxis;\r\n                if (dotX < dotY) {\r\n                    cylinderXAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), cylinderAxis, gl_matrix_1.vec3.fromValues(1, 0, 0));\r\n                }\r\n                else {\r\n                    cylinderXAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), cylinderAxis, gl_matrix_1.vec3.fromValues(0, 1, 0));\r\n                }\r\n                const cylinderYAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), cylinderAxis, cylinderXAxis);\r\n                gl_matrix_1.vec3.normalize(cylinderAxis, cylinderAxis);\r\n                gl_matrix_1.vec3.normalize(cylinderXAxis, cylinderXAxis);\r\n                gl_matrix_1.vec3.normalize(cylinderYAxis, cylinderYAxis);\r\n                if (cylinderRadius <= 0) {\r\n                    this._logger.warn('SDGTFLoader.loadCylinders: Cylinder radius is <= 0.');\r\n                    continue;\r\n                }\r\n                const indices = [];\r\n                const vertices = [];\r\n                const normals = [];\r\n                const uvs = [];\r\n                const height = gl_matrix_1.vec3.distance(cylinderTop, cylinderBottom);\r\n                const halfHeight = height / 2;\r\n                const thetaStart = 0, thetaLength = Math.PI * 2;\r\n                let indexCounter = 0;\r\n                const indexArray = [];\r\n                const heightSegments = 1, radialSegments = 50;\r\n                const normal = gl_matrix_1.vec3.create();\r\n                const vertex = gl_matrix_1.vec3.create();\r\n                let groupCount = 0;\r\n                // this will be used to calculate the normal\r\n                const slope = 0;\r\n                // generate vertices, normals and uvs\r\n                for (let y = 0; y <= heightSegments; y++) {\r\n                    const indexRow = [];\r\n                    const v = y / heightSegments;\r\n                    // calculate the radius of the current row\r\n                    const radius = cylinderRadius;\r\n                    for (let x = 0; x <= radialSegments; x++) {\r\n                        const u = x / radialSegments;\r\n                        const theta = u * thetaLength + thetaStart;\r\n                        const sinTheta = Math.sin(theta);\r\n                        const cosTheta = Math.cos(theta);\r\n                        // vertex\r\n                        vertex[0] = radius * sinTheta;\r\n                        vertex[1] = -v * height + halfHeight;\r\n                        vertex[2] = radius * cosTheta;\r\n                        vertices.push(vertex[0], vertex[1], vertex[2]);\r\n                        // normal\r\n                        gl_matrix_1.vec3.normalize(normal, gl_matrix_1.vec3.fromValues(sinTheta, slope, cosTheta));\r\n                        normals.push(normal[0], normal[1], normal[2]);\r\n                        // uv\r\n                        uvs.push(u, 1 - v);\r\n                        // save index of vertex in respective row\r\n                        indexRow.push(indexCounter++);\r\n                    }\r\n                    // now save vertices of the row in our index array\r\n                    indexArray.push(indexRow);\r\n                }\r\n                // generate indices\r\n                for (let x = 0; x < radialSegments; x++) {\r\n                    for (let y = 0; y < heightSegments; y++) {\r\n                        // we use the index array to access the correct indices\r\n                        const a = indexArray[y][x];\r\n                        const b = indexArray[y + 1][x];\r\n                        const c = indexArray[y + 1][x + 1];\r\n                        const d = indexArray[y][x + 1];\r\n                        // faces\r\n                        indices.push(a, b, d);\r\n                        indices.push(b, c, d);\r\n                        // update group counter\r\n                        groupCount += 6;\r\n                    }\r\n                }\r\n                const attributes = {};\r\n                attributes['POSITION'] = new viewer_shared_types_1.AttributeData(new Float32Array(vertices), 3, 0, 0, 0, false, vertices.length / 3);\r\n                attributes['NORMAL'] = new viewer_shared_types_1.AttributeData(new Float32Array(normals), 3, 0, 0, 0, false, normals.length / 3);\r\n                attributes['TEXCOORD_0'] = new viewer_shared_types_1.AttributeData(new Float32Array(uvs), 2, 0, 0, 0, false, uvs.length / 2);\r\n                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, new viewer_shared_types_1.AttributeData(this.convertToIndicesArray(indices), 1, 0, 0, 0, false, indices.length)), viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES);\r\n                singleCylinderNode.data.push(geometry);\r\n                singleCylinderNode.addTransformation({\r\n                    id: 'cylinder_' + i + '_translation',\r\n                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), cylinderBottom)\r\n                });\r\n                const cylinderRotationMatrix = gl_matrix_1.mat4.transpose(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.fromValues(cylinderXAxis[0], cylinderYAxis[0], cylinderAxis[0], 0, cylinderXAxis[1], cylinderYAxis[1], cylinderAxis[1], 0, cylinderXAxis[2], cylinderYAxis[2], cylinderAxis[2], 0, 0, 0, 0, 1));\r\n                singleCylinderNode.addTransformation({\r\n                    id: 'cylinder_' + i + '_rotation',\r\n                    matrix: cylinderRotationMatrix\r\n                });\r\n                singleCylinderNode.addTransformation({\r\n                    id: 'cylinder_' + i + '_rotation2',\r\n                    matrix: gl_matrix_1.mat4.rotateX(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), 0.5 * Math.PI)\r\n                });\r\n                singleCylinderNode.addTransformation({\r\n                    id: 'cylinder_' + i + '_translation2',\r\n                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(0, 0, 0.5 * gl_matrix_1.vec3.distance(cylinderTop, cylinderBottom)))\r\n                });\r\n                cylinderNode.addChild(singleCylinderNode);\r\n            }\r\n            return cylinderNode;\r\n        });\r\n    }\r\n    loadSpheres() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.spheres)\r\n                throw new Error('Spheres not available.');\r\n            const sphere = this._content.spheres;\r\n            const sphereNode = new viewer_shared_node_tree_1.TreeNode('spheres');\r\n            const data = yield this.loadAccessor(sphere.attributes['SPHERES']);\r\n            const count = data.array.length / data.itemSize;\r\n            for (let i = 0; i < count; i++) {\r\n                const singleSphereNode = new viewer_shared_node_tree_1.TreeNode('sphere_' + i);\r\n                const index = i * 4;\r\n                const sphereTranslation = gl_matrix_1.vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);\r\n                const sphereRadius = data.array[index + 3];\r\n                if (sphereRadius <= 0) {\r\n                    this._logger.warn('SDGTFLoader.loadSpheres: Sphere radius is <= 0.');\r\n                    continue;\r\n                }\r\n                const indices = [];\r\n                const vertices = [];\r\n                const normals = [];\r\n                const uvs = [];\r\n                const grid = [];\r\n                // for some reason, this doesn't work with values > 15\r\n                // let's not look into it, it's legacy stuff\r\n                const heightSegments = 15, widthSegments = 15;\r\n                const phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI;\r\n                const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\r\n                let indexCounter = 0;\r\n                // generate vertices, normals and uvs\r\n                for (let iy = 0; iy <= heightSegments; iy++) {\r\n                    const verticesRow = [];\r\n                    const v = iy / heightSegments;\r\n                    // special case for the poles\r\n                    let uOffset = 0;\r\n                    if (iy == 0 && thetaStart == 0) {\r\n                        uOffset = 0.5 / widthSegments;\r\n                    }\r\n                    else if (iy == heightSegments && thetaEnd == Math.PI) {\r\n                        uOffset = -0.5 / widthSegments;\r\n                    }\r\n                    for (let ix = 0; ix <= widthSegments; ix++) {\r\n                        const u = ix / widthSegments;\r\n                        // vertex\r\n                        const vertex = gl_matrix_1.vec3.fromValues(-sphereRadius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength), sphereRadius * Math.cos(thetaStart + v * thetaLength), sphereRadius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength));\r\n                        vertices.push(vertex[0], vertex[1], vertex[2]);\r\n                        // normal\r\n                        const normal = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), vertex);\r\n                        normals.push(normal[0], normal[1], normal[2]);\r\n                        // uv\r\n                        uvs.push(u + uOffset, 1 - v);\r\n                        verticesRow.push(indexCounter++);\r\n                    }\r\n                    grid.push(verticesRow);\r\n                }\r\n                // indices\r\n                for (let iy = 0; iy < heightSegments; iy++) {\r\n                    for (let ix = 0; ix < widthSegments; ix++) {\r\n                        const a = grid[iy][ix + 1];\r\n                        const b = grid[iy][ix];\r\n                        const c = grid[iy + 1][ix];\r\n                        const d = grid[iy + 1][ix + 1];\r\n                        if (iy !== 0 || thetaStart > 0)\r\n                            indices.push(a, b, d);\r\n                        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)\r\n                            indices.push(b, c, d);\r\n                    }\r\n                }\r\n                const attributes = {};\r\n                attributes['POSITION'] = new viewer_shared_types_1.AttributeData(new Float32Array(vertices), 3, 0, 0, 0, false, vertices.length / 3);\r\n                attributes['NORMAL'] = new viewer_shared_types_1.AttributeData(new Float32Array(normals), 3, 0, 0, 0, false, normals.length / 3);\r\n                attributes['TEXCOORD_0'] = new viewer_shared_types_1.AttributeData(new Float32Array(uvs), 2, 0, 0, 0, false, uvs.length / 2);\r\n                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, new viewer_shared_types_1.AttributeData(this.convertToIndicesArray(indices), 1, 0, 0, 0, false, indices.length)), viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES);\r\n                singleSphereNode.data.push(geometry);\r\n                singleSphereNode.addTransformation({\r\n                    id: 'sphere_' + i + '_translation',\r\n                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), sphereTranslation)\r\n                });\r\n                sphereNode.addChild(singleSphereNode);\r\n            }\r\n            return sphereNode;\r\n        });\r\n    }\r\n    loadPoint(pointName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.points[pointName])\r\n                throw new Error('Point not available.');\r\n            const point = this._content.points[pointName];\r\n            const pointNode = new viewer_shared_node_tree_1.TreeNode(pointName);\r\n            const attributes = {};\r\n            const data = yield this.loadAccessor(point.attributes['POINTS']);\r\n            attributes['POSITION'] = new viewer_shared_types_1.AttributeData(data.array, 3, data.itemBytes, data.byteOffset, data.elementBytes, data.normalized, data.count);\r\n            const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, null), viewer_shared_types_1.PRIMITIVE_MODE.POINTS);\r\n            pointNode.data.push(geometry);\r\n            return pointNode;\r\n        });\r\n    }\r\n    loadPolyline(polylineName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.polylines[polylineName])\r\n                throw new Error('Polyline not available.');\r\n            const polyLine = this._content.polylines[polylineName];\r\n            const polyLineNode = new viewer_shared_node_tree_1.TreeNode(polylineName);\r\n            const attributes = {};\r\n            const data = yield this.loadAccessor(polyLine.attributes['VERTICES']);\r\n            attributes['POSITION'] = new viewer_shared_types_1.AttributeData(data.array, 3, data.itemBytes, data.byteOffset, data.elementBytes, data.normalized, data.count);\r\n            const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, null), viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP);\r\n            polyLineNode.data.push(geometry);\r\n            return polyLineNode;\r\n        });\r\n    }\r\n    loadSurfacepatch(surfacepatchName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.surfacepatches[surfacepatchName])\r\n                throw new Error('Surfacepatch not available.');\r\n            const surfacepatch = this._content.surfacepatches[surfacepatchName];\r\n            const surfacepatchNode = new viewer_shared_node_tree_1.TreeNode(surfacepatchName);\r\n            const controlPointCountU = surfacepatch.controlPointCountU;\r\n            const controlPointCountV = surfacepatch.controlPointCountV;\r\n            const controlPointsData = yield this.loadAccessor(surfacepatch.attributes['CONTROLPOINTS']); // vec3\r\n            const controlPoints = [];\r\n            let pointCount = 0;\r\n            for (let u = 0; u < controlPointCountU; u++) {\r\n                let innerArray = [];\r\n                for (let v = 0; v < controlPointCountV; v++) {\r\n                    innerArray.push(gl_matrix_1.vec4.fromValues(controlPointsData.array[pointCount * 3], controlPointsData.array[pointCount * 3 + 1], controlPointsData.array[pointCount * 3 + 2], 1));\r\n                    pointCount++;\r\n                }\r\n                controlPoints.push(innerArray);\r\n            }\r\n            const knotsUData = yield this.loadAccessor(surfacepatch.attributes['KNOTSU']); // scalar\r\n            const knotsU = [knotsUData.array[0]];\r\n            for (let i = 0; i < knotsUData.array.length; i++)\r\n                knotsU.push(knotsUData.array[i]);\r\n            knotsU.push(knotsUData.array[knotsUData.array.length - 1]);\r\n            const knotsVData = yield this.loadAccessor(surfacepatch.attributes['KNOTSV']); // scalar\r\n            const knotsV = [knotsVData.array[0]];\r\n            for (let i = 0; i < knotsVData.array.length; i++)\r\n                knotsV.push(knotsVData.array[i]);\r\n            knotsV.push(knotsVData.array[knotsVData.array.length - 1]);\r\n            const degreeU = surfacepatch.degreeU;\r\n            const degreeV = surfacepatch.degreeV;\r\n            const findSpan = (knots, degree, u) => {\r\n                const n = knots.length - degree - 1;\r\n                if (u >= knots[n])\r\n                    return n - 1;\r\n                if (u <= knots[degree])\r\n                    return degree;\r\n                let low = degree;\r\n                let high = n;\r\n                let mid = Math.floor((low + high) / 2);\r\n                while (u < knots[mid] || u >= knots[mid + 1]) {\r\n                    if (u < knots[mid]) {\r\n                        high = mid;\r\n                    }\r\n                    else {\r\n                        low = mid;\r\n                    }\r\n                    mid = Math.floor((low + high) / 2);\r\n                }\r\n                return mid;\r\n            };\r\n            const calcBasisFunctions = (knots, degree, span, u) => {\r\n                const N = [];\r\n                const left = [];\r\n                const right = [];\r\n                N[0] = 1.0;\r\n                for (let j = 1; j <= degree; ++j) {\r\n                    left[j] = u - knots[span + 1 - j];\r\n                    right[j] = knots[span + j] - u;\r\n                    let saved = 0.0;\r\n                    for (let r = 0; r < j; ++r) {\r\n                        const rv = right[r + 1];\r\n                        const lv = left[j - r];\r\n                        const temp = N[r] / (rv + lv);\r\n                        N[r] = saved + rv * temp;\r\n                        saved = lv * temp;\r\n                    }\r\n                    N[j] = saved;\r\n                }\r\n                return N;\r\n            };\r\n            const calcSurfacePoint = (u, v) => {\r\n                const uspan = findSpan(knotsU, degreeU, u);\r\n                const vspan = findSpan(knotsV, degreeV, v);\r\n                const Nu = calcBasisFunctions(knotsU, degreeU, uspan, u);\r\n                const Nv = calcBasisFunctions(knotsV, degreeV, vspan, v);\r\n                const temp = [];\r\n                for (let l = 0; l <= degreeV; ++l) {\r\n                    temp[l] = gl_matrix_1.vec4.create();\r\n                    for (let k = 0; k <= degreeU; ++k) {\r\n                        const point = gl_matrix_1.vec4.clone(controlPoints[uspan - degreeU + k][vspan - degreeV + l]);\r\n                        const w = point[3];\r\n                        point[0] *= w;\r\n                        point[1] *= w;\r\n                        point[2] *= w;\r\n                        gl_matrix_1.vec4.add(temp[l], temp[l], gl_matrix_1.vec4.multiply(gl_matrix_1.vec4.create(), point, gl_matrix_1.vec4.fromValues(Nu[k], Nu[k], Nu[k], Nu[k])));\r\n                    }\r\n                }\r\n                const Sw = gl_matrix_1.vec4.create();\r\n                for (let l = 0; l <= degreeV; ++l) {\r\n                    gl_matrix_1.vec4.add(Sw, Sw, gl_matrix_1.vec4.multiply(gl_matrix_1.vec4.create(), temp[l], gl_matrix_1.vec4.fromValues(Nv[l], Nv[l], Nv[l], Nv[l])));\r\n                }\r\n                gl_matrix_1.vec4.divide(Sw, Sw, gl_matrix_1.vec4.fromValues(Sw[3], Sw[3], Sw[3], Sw[3]));\r\n                return gl_matrix_1.vec3.fromValues(Sw[0], Sw[1], Sw[2]);\r\n            };\r\n            const getPointOnSurfacepatch = (t1, t2) => {\r\n                const u = knotsU[0] + t1 * (knotsU[knotsU.length - 1] - knotsU[0]); // linear mapping t1->u\r\n                const v = knotsV[0] + t2 * (knotsV[knotsV.length - 1] - knotsV[0]); // linear mapping t2->u\r\n                return calcSurfacePoint(u, v);\r\n            };\r\n            const numberOfPoints = 15;\r\n            const indices = [];\r\n            const vertices = [];\r\n            for (let d = 0; d <= numberOfPoints; d++) {\r\n                const v = d / numberOfPoints;\r\n                for (let f = 0; f <= numberOfPoints; f++) {\r\n                    const u = f / numberOfPoints;\r\n                    const vertex = getPointOnSurfacepatch(u, v);\r\n                    vertices.push(vertex[0], vertex[1], vertex[2]);\r\n                }\r\n            }\r\n            for (let d = 0; d < numberOfPoints; d++) {\r\n                for (let f = 0; f < numberOfPoints; f++) {\r\n                    const i1 = d * (numberOfPoints + 1) + f;\r\n                    const i2 = d * (numberOfPoints + 1) + f + 1;\r\n                    const i3 = (d + 1) * (numberOfPoints + 1) + f;\r\n                    const i4 = (d + 1) * (numberOfPoints + 1) + f + 1;\r\n                    // faces one and two\r\n                    indices.push(i3, i2, i1);\r\n                    indices.push(i2, i3, i4);\r\n                }\r\n            }\r\n            const attributes = {};\r\n            attributes['POSITION'] = new viewer_shared_types_1.AttributeData(new Float32Array(vertices), 3, 0, 0, 0, false, vertices.length / 3);\r\n            // to not compute normals ourselves, we just let three.js do it\r\n            // in our geometry loader, this array will cause the computation of vertex normals\r\n            attributes['NORMAL'] = new viewer_shared_types_1.AttributeData(new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), 3, 0, 0, 0, false, vertices.length / 3);\r\n            const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, new viewer_shared_types_1.AttributeData(this.convertToIndicesArray(indices), 1, 0, 0, 0, false, indices.length)), viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES);\r\n            surfacepatchNode.data.push(geometry);\r\n            return surfacepatchNode;\r\n        });\r\n    }\r\n    loadScene() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const sceneNode = new viewer_shared_node_tree_1.TreeNode('sdgtf_content');\r\n            // arcs\r\n            if (this._content.arcs)\r\n                sceneNode.addChild(yield this.loadArcs());\r\n            // beziercurves\r\n            if (this._content.beziercurves) {\r\n                for (let beziercurve in this._content.beziercurves)\r\n                    sceneNode.addChild(yield this.loadBeziercurve(beziercurve));\r\n            }\r\n            // circles\r\n            if (this._content.circles)\r\n                sceneNode.addChild(yield this.loadCircles());\r\n            // cylinders\r\n            if (this._content.cylinders)\r\n                sceneNode.addChild(yield this.loadCylinders());\r\n            //points\r\n            if (this._content.points) {\r\n                for (let point in this._content.points)\r\n                    sceneNode.addChild(yield this.loadPoint(point));\r\n            }\r\n            // polylines\r\n            if (this._content.polylines) {\r\n                for (let line in this._content.polylines)\r\n                    sceneNode.addChild(yield this.loadPolyline(line));\r\n            }\r\n            // spheres\r\n            if (this._content.spheres)\r\n                sceneNode.addChild(yield this.loadSpheres());\r\n            // surfacepatches\r\n            if (this._content.surfacepatches) {\r\n                for (let surfacepatch in this._content.surfacepatches)\r\n                    sceneNode.addChild(yield this.loadSurfacepatch(surfacepatch));\r\n            }\r\n            return sceneNode;\r\n        });\r\n    }\r\n}\r\nexports.SDGTFLoader = SDGTFLoader;\r\n//# sourceMappingURL=SDGTFLoader.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GLTFLoader = exports.GLTF_EXTENSIONS = void 0;\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst viewer_rendering_engine_camera_engine_1 = require(\"@shapediver/viewer.rendering-engine.camera-engine\");\r\nconst viewer_rendering_engine_light_engine_1 = require(\"@shapediver/viewer.rendering-engine.light-engine\");\r\nconst BufferLoader_1 = require(\"./loaders/BufferLoader\");\r\nconst BufferViewLoader_1 = require(\"./loaders/BufferViewLoader\");\r\nconst AccessorLoader_1 = require(\"./loaders/AccessorLoader\");\r\nconst TextureLoader_1 = require(\"./loaders/TextureLoader\");\r\nconst MaterialLoader_1 = require(\"./loaders/MaterialLoader\");\r\nconst GeometryLoader_1 = require(\"./loaders/GeometryLoader\");\r\nvar GLTF_EXTENSIONS;\r\n(function (GLTF_EXTENSIONS) {\r\n    GLTF_EXTENSIONS[\"KHR_BINARY_GLTF\"] = \"KHR_binary_glTF\";\r\n    GLTF_EXTENSIONS[\"KHR_DRACO_MESH_COMPRESSION\"] = \"KHR_draco_mesh_compression\";\r\n    GLTF_EXTENSIONS[\"KHR_LIGHTS_PUNCTUAL\"] = \"KHR_lights_punctual\";\r\n    GLTF_EXTENSIONS[\"KHR_MATERIALS_CLEARCOAT\"] = \"KHR_materials_clearcoat\";\r\n    GLTF_EXTENSIONS[\"KHR_MATERIALS_IOR\"] = \"KHR_materials_ior\";\r\n    GLTF_EXTENSIONS[\"KHR_MATERIALS_PBRSPECULARGLOSSINESS\"] = \"KHR_materials_pbrSpecularGlossiness\";\r\n    GLTF_EXTENSIONS[\"KHR_MATERIALS_SHEEN\"] = \"KHR_materials_sheen\";\r\n    GLTF_EXTENSIONS[\"KHR_MATERIALS_SPECULAR\"] = \"KHR_materials_specular\";\r\n    GLTF_EXTENSIONS[\"KHR_MATERIALS_TRANSMISSION\"] = \"KHR_materials_transmission\";\r\n    GLTF_EXTENSIONS[\"KHR_MATERIALS_UNLIT\"] = \"KHR_materials_unlit\";\r\n    GLTF_EXTENSIONS[\"KHR_MATERIALS_VARIANTS\"] = \"KHR_materials_variants\";\r\n    GLTF_EXTENSIONS[\"KHR_MATERIALS_VOLUME\"] = \"KHR_materials_volume\";\r\n    GLTF_EXTENSIONS[\"KHR_MESH_QUANTIZATION\"] = \"KHR_mesh_quantization\";\r\n    GLTF_EXTENSIONS[\"KHR_TEXTURE_TRANSFORM\"] = \"KHR_texture_transform\";\r\n    GLTF_EXTENSIONS[\"SHAPEDIVER_MATERIALS_PRESET\"] = \"SHAPEDIVER_materials_preset\";\r\n})(GLTF_EXTENSIONS = exports.GLTF_EXTENSIONS || (exports.GLTF_EXTENSIONS = {}));\r\n// eslint-disable-next-line @typescript-eslint/no-var-requires\r\nconst DRACO = require('./draco/draco_decoder.js');\r\nclass GLTFLoader {\r\n    constructor() {\r\n        // #region Properties (22)\r\n        this.BINARY_EXTENSION_HEADER_LENGTH = 20;\r\n        this._eventEngine = viewer_shared_services_1.EventEngine.instance;\r\n        this._globalTransformation = gl_matrix_1.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);\r\n        this._httpClient = viewer_shared_services_1.HttpClient.instance;\r\n        this._logger = viewer_shared_services_1.Logger.instance;\r\n        this._performanceEvaluator = viewer_shared_services_1.PerformanceEvaluator.instance;\r\n        this._progressUpdateLimit = 500;\r\n        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;\r\n        this._eventId = '';\r\n        this._nodes = {};\r\n        this._numberOfConvertedNodes = 0;\r\n        this._numberOfNodes = 0;\r\n        this._progressTimer = 0;\r\n        // #endregion Private Methods (7)\r\n    }\r\n    // #endregion Properties (22)\r\n    // #region Public Methods (2)\r\n    load(content, gltfBinary, gltfHeader, baseUri, taskEventId) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._eventId = taskEventId || this._uuidGenerator.create();\r\n            const eventStart = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: 0, status: 'Starting glTF 2.0 loading.' };\r\n            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);\r\n            this._numberOfConvertedNodes = 0;\r\n            this._numberOfNodes = content.nodes ? content.nodes.length : 0;\r\n            this._progressTimer = performance.now();\r\n            this._baseUri = baseUri;\r\n            if (gltfBinary && gltfHeader)\r\n                this._body = gltfBinary.slice(this.BINARY_EXTENSION_HEADER_LENGTH + gltfHeader.contentLength + 8, gltfHeader.length);\r\n            this._content = content;\r\n            this.validateVersionAndExtensions();\r\n            const dracoModule = yield new DRACO();\r\n            this._bufferLoader = new BufferLoader_1.BufferLoader(this._content, this._body, this._baseUri);\r\n            yield this._bufferLoader.load();\r\n            this._bufferViewLoader = new BufferViewLoader_1.BufferViewLoader(this._content, this._bufferLoader);\r\n            this._bufferViewLoader.load();\r\n            this._accessorLoader = new AccessorLoader_1.AccessorLoader(this._content, this._bufferViewLoader);\r\n            this._accessorLoader.load();\r\n            this._textureLoader = new TextureLoader_1.TextureLoader(this._content, this._bufferViewLoader, this._baseUri);\r\n            yield this._textureLoader.load();\r\n            this._materialLoader = new MaterialLoader_1.MaterialLoader(this._content, this._textureLoader);\r\n            yield this._materialLoader.load();\r\n            this._geometryLoader = new GeometryLoader_1.GeometryLoader(this._content, this._accessorLoader, this._bufferViewLoader, this._materialLoader, dracoModule);\r\n            const eventProgressInit = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: 0.1, status: 'Initial logic of glTF loading.' };\r\n            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventProgressInit);\r\n            const node = yield this.loadScene();\r\n            if (this._content.extensions && this._content.extensions[GLTF_EXTENSIONS.KHR_MATERIALS_VARIANTS]) {\r\n                const variants = this._content.extensions[GLTF_EXTENSIONS.KHR_MATERIALS_VARIANTS].variants;\r\n                for (let i = 0; i < variants.length; i++)\r\n                    this._geometryLoader.materialVariantsData.variants.push(variants[i].name);\r\n                this._geometryLoader.materialVariantsData.variantIndex = 0;\r\n                node.data.push(this._geometryLoader.materialVariantsData);\r\n            }\r\n            if (this._content.skins !== undefined && this._content.nodes !== undefined) {\r\n                for (let i = 0; i < ((_a = this._content.nodes) === null || _a === void 0 ? void 0 : _a.length); i++) {\r\n                    if (this._content.nodes[i].skin !== undefined) {\r\n                        const skinDef = this.loadSkin(this._content.nodes[i].skin);\r\n                        const skinNode = this._nodes[i];\r\n                        const bones = [];\r\n                        const boneInverses = [];\r\n                        for (let j = 0; j < skinDef.joints.length; j++) {\r\n                            this._nodes[skinDef.joints[j]].data.push(new viewer_shared_types_1.BoneData());\r\n                            bones.push(this._nodes[skinDef.joints[j]]);\r\n                            let mat = gl_matrix_1.mat4.create();\r\n                            if (skinDef.inverseBindMatrices !== undefined) {\r\n                                const matricesArray = skinDef.inverseBindMatrices.array;\r\n                                mat = gl_matrix_1.mat4.fromValues(matricesArray[j * 16 + 0], matricesArray[j * 16 + 1], matricesArray[j * 16 + 2], matricesArray[j * 16 + 3], matricesArray[j * 16 + 4], matricesArray[j * 16 + 5], matricesArray[j * 16 + 6], matricesArray[j * 16 + 7], matricesArray[j * 16 + 8], matricesArray[j * 16 + 9], matricesArray[j * 16 + 10], matricesArray[j * 16 + 11], matricesArray[j * 16 + 12], matricesArray[j * 16 + 13], matricesArray[j * 16 + 14], matricesArray[j * 16 + 15]);\r\n                            }\r\n                            boneInverses.push(mat);\r\n                        }\r\n                        skinNode.skinNode = true;\r\n                        skinNode.bones = bones;\r\n                        skinNode.boneInverses = boneInverses;\r\n                    }\r\n                }\r\n            }\r\n            if (this._content.animations)\r\n                for (let i = 0; i < ((_b = this._content.animations) === null || _b === void 0 ? void 0 : _b.length); i++)\r\n                    node.data.push(this.loadAnimation(i));\r\n            const eventEnd = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: 1, status: 'GlTF loading complete.' };\r\n            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);\r\n            return node;\r\n        });\r\n    }\r\n    loadWithUrl(url) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._performanceEvaluator.startSection('gltfProcessing.' + url);\r\n            this._performanceEvaluator.startSection('loadGltf.' + url);\r\n            const axiosResponse = yield this._httpClient.get(url, {\r\n                responseType: 'arraybuffer'\r\n            });\r\n            this._performanceEvaluator.endSection('loadGltf.' + url);\r\n            let gltfContent, gltfBinary, gltfBaseUrl, gltfHeader;\r\n            const magic = new TextDecoder().decode(new Uint8Array(axiosResponse.data, 0, 4));\r\n            const isBinary = magic === 'glTF' || (axiosResponse.headers['content-type'] &&\r\n                (axiosResponse.headers['content-type'] === 'model/gltf-binary' ||\r\n                    axiosResponse.headers['content-type'] === 'application/octet-stream' ||\r\n                    axiosResponse.headers['content-type'] === 'model/gltf.binary'));\r\n            if (isBinary) {\r\n                gltfBinary = axiosResponse.data;\r\n                // create header data\r\n                const headerDataView = new DataView(gltfBinary, 0, this.BINARY_EXTENSION_HEADER_LENGTH);\r\n                gltfHeader = {\r\n                    magic: magic,\r\n                    version: headerDataView.getUint32(4, true),\r\n                    length: headerDataView.getUint32(8, true),\r\n                    contentLength: headerDataView.getUint32(12, true),\r\n                    contentFormat: headerDataView.getUint32(16, true)\r\n                };\r\n                if (gltfHeader.magic != 'glTF')\r\n                    throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GLTFLoader.load: Invalid data: sdgTF magic wrong.');\r\n                // create content\r\n                const contentDataView = new DataView(gltfBinary, this.BINARY_EXTENSION_HEADER_LENGTH, gltfHeader.contentLength);\r\n                const contentDecoded = new TextDecoder().decode(contentDataView);\r\n                gltfContent = JSON.parse(contentDecoded);\r\n                // create body\r\n                this._body = gltfBinary.slice(this.BINARY_EXTENSION_HEADER_LENGTH + gltfHeader.contentLength + 8, gltfHeader.length);\r\n            }\r\n            else {\r\n                gltfContent = JSON.parse(new TextDecoder().decode(axiosResponse.data));\r\n                const removeLastDirectoryPartOf = (the_url) => {\r\n                    const dir_char = the_url.includes('/') ? '/' : '\\\\';\r\n                    const the_arr = the_url.split(dir_char);\r\n                    the_arr.pop();\r\n                    return the_arr.join(dir_char);\r\n                };\r\n                gltfBaseUrl = removeLastDirectoryPartOf(url);\r\n                if (!gltfBaseUrl && window && window.location && window.location.href)\r\n                    gltfBaseUrl = removeLastDirectoryPartOf(window.location.href);\r\n            }\r\n            return yield this.load(gltfContent, gltfBinary, gltfHeader, gltfBaseUrl);\r\n        });\r\n    }\r\n    // #endregion Public Methods (2)\r\n    // #region Private Methods (7)\r\n    /**\r\n         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n         * @param {number} animationIndex\r\n         * @return {Promise<AnimationClip>}\r\n         */\r\n    loadAnimation(animationId) {\r\n        if (!this._content.animations)\r\n            throw new Error('Animations not available.');\r\n        if (!this._content.animations[animationId])\r\n            throw new Error('Animations not available.');\r\n        const animationDef = this._content.animations[animationId];\r\n        const animationTracks = [];\r\n        let min = Infinity, max = -Infinity;\r\n        for (let i = 0; i < animationDef.channels.length; i++) {\r\n            const channel = animationDef.channels[i];\r\n            const sampler = animationDef.samplers[channel.sampler];\r\n            const target = channel.target;\r\n            const path = target.path;\r\n            const node = this._nodes[target.node];\r\n            if (node === undefined)\r\n                throw new Error('Animation node not available.');\r\n            const input = this._accessorLoader.getAccessor(sampler.input);\r\n            min = Math.min(min, input.min[0]);\r\n            max = Math.max(max, input.max[0]);\r\n            const output = this._accessorLoader.getAccessor(sampler.output);\r\n            let interpolation = sampler.interpolation;\r\n            if (interpolation === 'CUBICSPLINE') {\r\n                this._logger.warn('Animation with CUBICSPLINE interpolation is currently not supported. Assigning linear interpolation instead.');\r\n                interpolation = 'linear';\r\n            }\r\n            animationTracks.push({\r\n                node,\r\n                times: input.array,\r\n                values: output.array,\r\n                path: path,\r\n                interpolation: interpolation === null || interpolation === void 0 ? void 0 : interpolation.toLowerCase()\r\n            });\r\n        }\r\n        return new viewer_shared_types_1.AnimationData(animationDef.name || 'gltf_animation_' + animationId, animationTracks, min, max - min);\r\n    }\r\n    loadCamera(cameraId) {\r\n        if (!this._content.cameras)\r\n            throw new Error('Cameras not available.');\r\n        if (!this._content.cameras[cameraId])\r\n            throw new Error('Cameras not available.');\r\n        const cameraDef = this._content.cameras[cameraId];\r\n        const cameraNode = new viewer_shared_node_tree_1.TreeNode(cameraDef.name || 'camera_' + cameraId);\r\n        cameraNode.originalName = cameraDef.name;\r\n        let cameraData;\r\n        if (cameraDef.type === 'perspective') {\r\n            const perspectiveCameraDef = cameraDef.perspective;\r\n            cameraData = new viewer_rendering_engine_camera_engine_1.PerspectiveCamera(cameraNode.id);\r\n            cameraNode.data.push(cameraData);\r\n            cameraData.fov = perspectiveCameraDef.yfov * (180 / Math.PI);\r\n            cameraData.aspect = perspectiveCameraDef.aspectRatio || 1;\r\n            cameraData.near = perspectiveCameraDef.znear || 1;\r\n            cameraData.far = perspectiveCameraDef.zfar || 2e6;\r\n        }\r\n        else {\r\n            const orthographicCameraDef = cameraDef.orthographic;\r\n            cameraData = new viewer_rendering_engine_camera_engine_1.OrthographicCamera(cameraNode.id);\r\n            cameraNode.data.push(cameraData);\r\n            cameraData.left = -orthographicCameraDef.xmag;\r\n            cameraData.right = orthographicCameraDef.xmag;\r\n            cameraData.top = -orthographicCameraDef.ymag;\r\n            cameraData.bottom = orthographicCameraDef.ymag;\r\n            cameraData.near = orthographicCameraDef.znear || 1;\r\n            cameraData.far = orthographicCameraDef.zfar || 2e6;\r\n        }\r\n        cameraData.useNodeData = true;\r\n        cameraData.node = cameraNode;\r\n        return cameraNode;\r\n    }\r\n    loadLights(lightId) {\r\n        if (!this._content.extensions || !this._content.extensions[GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || !this._content.extensions[GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL].lights)\r\n            throw new Error(`Extension ${GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL} not available.`);\r\n        if (!this._content.extensions[GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL].lights[lightId])\r\n            throw new Error('Light not available.');\r\n        const lightDef = this._content.extensions[GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL].lights[lightId];\r\n        const lightNode = new viewer_shared_node_tree_1.TreeNode(lightDef.name || 'light_' + lightId);\r\n        lightNode.originalName = lightDef.name;\r\n        let color = '#ffffffff';\r\n        if (lightDef.color !== undefined)\r\n            color = [lightDef.color[0] * 255, lightDef.color[1] * 255, lightDef.color[2] * 255];\r\n        const range = lightDef.range !== undefined ? lightDef.range : 0;\r\n        let lightData;\r\n        if (lightDef.type === 'directional') {\r\n            lightData = new viewer_rendering_engine_light_engine_1.DirectionalLight({ color });\r\n            lightNode.data.push(lightData);\r\n            const directionalLightData = lightData;\r\n            if (lightDef.intensity !== undefined)\r\n                directionalLightData.intensity = lightDef.intensity;\r\n        }\r\n        else if (lightDef.type === 'point') {\r\n            lightData = new viewer_rendering_engine_light_engine_1.PointLight({ color });\r\n            lightNode.data.push(lightData);\r\n            const pointLightData = lightData;\r\n            pointLightData.distance = range;\r\n            pointLightData.decay = 2;\r\n            if (lightDef.intensity !== undefined)\r\n                lightData.intensity = lightDef.intensity;\r\n            pointLightData.position = [0, 0, 0];\r\n        }\r\n        else if (lightDef.type === 'spot') {\r\n            lightData = new viewer_rendering_engine_light_engine_1.SpotLight({ color });\r\n            lightNode.data.push(lightData);\r\n            lightDef.spot = lightDef.spot || {};\r\n            lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\r\n            lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\r\n            const spotLightData = lightData;\r\n            spotLightData.distance = range;\r\n            spotLightData.angle = lightDef.spot.outerConeAngle;\r\n            spotLightData.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\r\n            spotLightData.decay = 2;\r\n            if (lightDef.intensity !== undefined)\r\n                lightData.intensity = lightDef.intensity;\r\n            spotLightData.position = [0, 0, 0];\r\n            spotLightData.target = [0, 0, -1];\r\n        }\r\n        else {\r\n            throw new Error('Unexpected light type: ' + lightDef.type);\r\n        }\r\n        lightData.useNodeData = true;\r\n        return lightNode;\r\n    }\r\n    loadNode(nodeId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.nodes)\r\n                throw new Error('Nodes not available.');\r\n            if (!this._content.nodes[nodeId])\r\n                throw new Error('Node not available.');\r\n            const node = this._content.nodes[nodeId];\r\n            const nodeDef = new viewer_shared_node_tree_1.TreeNode(node.name || 'node_' + nodeId);\r\n            nodeDef.originalName = node.name;\r\n            this._nodes[nodeId] = nodeDef;\r\n            if (node.matrix) {\r\n                nodeDef.addTransformation({\r\n                    id: 'gltf_matrix',\r\n                    matrix: gl_matrix_1.mat4.fromValues(node.matrix[0], node.matrix[1], node.matrix[2], node.matrix[3], node.matrix[4], node.matrix[5], node.matrix[6], node.matrix[7], node.matrix[8], node.matrix[9], node.matrix[10], node.matrix[11], node.matrix[12], node.matrix[13], node.matrix[14], node.matrix[15])\r\n                });\r\n                nodeDef.addTransformation({\r\n                    id: 'gltf_matrix_translation',\r\n                    matrix: gl_matrix_1.mat4.create()\r\n                });\r\n                nodeDef.addTransformation({\r\n                    id: 'gltf_matrix_rotation',\r\n                    matrix: gl_matrix_1.mat4.create()\r\n                });\r\n                nodeDef.addTransformation({\r\n                    id: 'gltf_matrix_scale',\r\n                    matrix: gl_matrix_1.mat4.create()\r\n                });\r\n            }\r\n            else if (node.translation || node.scale || node.rotation) {\r\n                const matT = node.translation ? gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(node.translation[0], node.translation[1], node.translation[2])) : gl_matrix_1.mat4.create();\r\n                const matS = node.scale ? gl_matrix_1.mat4.fromScaling(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(node.scale[0], node.scale[1], node.scale[2])) : gl_matrix_1.mat4.create();\r\n                const matR = node.rotation ? gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), gl_matrix_1.vec4.fromValues(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3])) : gl_matrix_1.mat4.create();\r\n                nodeDef.addTransformation({\r\n                    id: 'gltf_matrix_translation',\r\n                    matrix: matT\r\n                });\r\n                nodeDef.addTransformation({\r\n                    id: 'gltf_matrix_rotation',\r\n                    matrix: matR\r\n                });\r\n                nodeDef.addTransformation({\r\n                    id: 'gltf_matrix_scale',\r\n                    matrix: matS\r\n                });\r\n            }\r\n            if (node.mesh !== undefined)\r\n                nodeDef.addChild(this._geometryLoader.loadMesh(node.mesh, node.weights));\r\n            if (node.camera !== undefined)\r\n                nodeDef.addChild(this.loadCamera(node.camera));\r\n            if (node.extensions && node.extensions[GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL])\r\n                nodeDef.addChild(this.loadLights(node.extensions[GLTF_EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light));\r\n            if (node.children) {\r\n                for (let i = 0, len = node.children.length; i < len; i++) {\r\n                    // got through all children\r\n                    nodeDef.addChild(yield this.loadNode(node.children[i]));\r\n                }\r\n            }\r\n            this._numberOfConvertedNodes++;\r\n            if (performance.now() - this._progressTimer > this._progressUpdateLimit) {\r\n                this._progressTimer = performance.now();\r\n                const eventProgress = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: (this._numberOfConvertedNodes / this._numberOfNodes) / 2 + 0.1, status: `GlTF conversion progress: ${this._numberOfConvertedNodes}/${this._numberOfNodes} nodes.` };\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventProgress);\r\n                yield new Promise(resolve => setTimeout(resolve, 0));\r\n            }\r\n            return nodeDef;\r\n        });\r\n    }\r\n    loadScene() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.scenes)\r\n                throw new Error('Scenes not available.');\r\n            const sceneId = this._content.scene || 0;\r\n            if (!this._content.scenes[sceneId])\r\n                throw new Error('Scene not available.');\r\n            const scene = this._content.scenes[sceneId];\r\n            const sceneDef = new viewer_shared_node_tree_1.TreeNode(scene.name || 'scene_' + sceneId + '');\r\n            sceneDef.originalName = scene.name;\r\n            sceneDef.addTransformation({\r\n                id: this._uuidGenerator.create(),\r\n                matrix: this._globalTransformation\r\n            });\r\n            if (scene.nodes)\r\n                for (let i = 0, len = scene.nodes.length; i < len; i++)\r\n                    sceneDef.addChild(yield this.loadNode(scene.nodes[i]));\r\n            return sceneDef;\r\n        });\r\n    }\r\n    loadSkin(skinId) {\r\n        if (!this._content.skins)\r\n            throw new Error('Skins not available.');\r\n        if (!this._content.skins[skinId])\r\n            throw new Error('Skin not available.');\r\n        const skinDef = this._content.skins[skinId];\r\n        const skinEntry = {\r\n            joints: skinDef.joints,\r\n            inverseBindMatrices: null\r\n        };\r\n        if (skinDef.inverseBindMatrices === undefined) {\r\n            return skinEntry;\r\n        }\r\n        skinEntry.inverseBindMatrices = this._accessorLoader.getAccessor(skinDef.inverseBindMatrices);\r\n        return skinEntry;\r\n    }\r\n    validateVersionAndExtensions() {\r\n        if (!this._content.asset)\r\n            throw new Error('Asset not available.');\r\n        const asset = this._content.asset;\r\n        if (!asset.version)\r\n            throw new Error('Asset does not have a version.');\r\n        const version = asset.minVersion ? asset.minVersion : asset.version;\r\n        if (!version.startsWith('2'))\r\n            throw new Error('Version of the glTF not supported.');\r\n        if (this._content.extensionsUsed) {\r\n            const notSupported = [];\r\n            for (let i = 0; i < this._content.extensionsUsed.length; i++) {\r\n                if (!Object.values(GLTF_EXTENSIONS).includes(this._content.extensionsUsed[i]))\r\n                    notSupported.push(this._content.extensionsUsed[i]);\r\n            }\r\n            if (notSupported.length > 0) {\r\n                let message = 'Extension' + (notSupported.length === 1 ? ' ' : 's ');\r\n                notSupported.forEach((element, index) => {\r\n                    message += '\"' + element + '\"' + (index === notSupported.length - 1 ? '' : index === notSupported.length - 2 ? ' and ' : ', ');\r\n                });\r\n                message += (notSupported.length === 1 ? ' is' : ' are') + ' not supported, but used. Loading glTF regardless.';\r\n                this._logger.info('GLTFLoader.validateVersionAndExtensions: ' + message);\r\n            }\r\n        }\r\n        if (this._content.extensionsRequired) {\r\n            const notSupported = [];\r\n            for (let i = 0; i < this._content.extensionsRequired.length; i++) {\r\n                if (!Object.values(GLTF_EXTENSIONS).includes(this._content.extensionsRequired[i]))\r\n                    notSupported.push(this._content.extensionsRequired[i]);\r\n            }\r\n            if (notSupported.length > 0) {\r\n                let message = 'Extension' + (notSupported.length === 1 ? ' ' : 's ');\r\n                notSupported.forEach((element, index) => {\r\n                    message += '\"' + element + '\"' + (index === notSupported.length - 1 ? '' : index === notSupported.length - 2 ? ' and ' : ', ');\r\n                });\r\n                message += (notSupported.length === 1 ? ' is' : ' are') + ' not supported, but required. Aborting glTF loading.';\r\n                throw new Error(message);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.GLTFLoader = GLTFLoader;\r\n//# sourceMappingURL=GLTFLoader.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AccessorLoader = void 0;\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst viewer_data_engine_shared_types_1 = require(\"@shapediver/viewer.data-engine.shared-types\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nclass AccessorLoader {\r\n    // #endregion Properties (2)\r\n    // #region Constructors (1)\r\n    constructor(_content, _bufferViewLoader) {\r\n        this._content = _content;\r\n        this._bufferViewLoader = _bufferViewLoader;\r\n        // #region Properties (2)\r\n        this._logger = viewer_shared_services_1.Logger.instance;\r\n        this._loaded = {};\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Methods (2)\r\n    getAccessor(accessorId) {\r\n        if (!this._content.accessors)\r\n            throw new Error('AccessorLoader.getAccessor: Accessors not available.');\r\n        if (!this._content.accessors[accessorId])\r\n            throw new Error('AccessorLoader.getAccessor: Accessor not available.');\r\n        if (!this._loaded[accessorId])\r\n            throw new Error('AccessorLoader.getAccessor: Accessor not loaded.');\r\n        return this._loaded[accessorId];\r\n    }\r\n    load() {\r\n        if (!this._content.accessors)\r\n            return;\r\n        for (let i = 0; i < this._content.accessors.length; i++) {\r\n            const accessorId = i;\r\n            if (!this._content.accessors[accessorId])\r\n                throw new Error('AccessorLoader.load: BufferView not available.');\r\n            const accessor = this._content.accessors[accessorId];\r\n            if (accessor.bufferView === undefined) {\r\n                // Ignore empty accessors, which may be used to declare runtime\r\n                // information about attributes coming from another source (e.g. Draco\r\n                // compression extension).\r\n                this._loaded[accessorId] = null;\r\n                continue;\r\n            }\r\n            const arrayBuffer = this._bufferViewLoader.getBufferView(accessor.bufferView);\r\n            const itemSize = viewer_data_engine_shared_types_1.ACCESSORTYPE_V2[accessor.type];\r\n            if (accessor.componentType === 5124)\r\n                this._logger.warn('GLTFLoader.loadAccessor: The componentType for this accessor is 5124, which is not allowed. Trying to load it anyway.');\r\n            const ArrayType = viewer_data_engine_shared_types_1.ACCESSORCOMPONENTTYPE_V2[accessor.componentType];\r\n            const elementBytes = ArrayType.BYTES_PER_ELEMENT;\r\n            const itemBytes = elementBytes * itemSize;\r\n            const byteOffset = accessor.byteOffset || 0;\r\n            const byteStride = accessor.bufferView !== undefined ? this._content.bufferViews ? this._content.bufferViews[accessor.bufferView].byteStride : undefined : undefined;\r\n            const normalized = accessor.normalized === true;\r\n            const target = this._content.bufferViews ? this._content.bufferViews[accessor.bufferView].target : undefined;\r\n            let array;\r\n            if (byteStride && byteStride !== itemBytes) {\r\n                // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\r\n                // This makes sure that IBA.count reflects accessor.count properly\r\n                const ibSlice = Math.floor(byteOffset / byteStride);\r\n                array = new ArrayType(arrayBuffer, ibSlice * byteStride, accessor.count * byteStride / elementBytes);\r\n            }\r\n            else {\r\n                if (arrayBuffer === null) {\r\n                    array = new ArrayType(accessor.count * itemSize);\r\n                }\r\n                else {\r\n                    array = new ArrayType(arrayBuffer, byteOffset, accessor.count * itemSize);\r\n                }\r\n            }\r\n            if (accessor.sparse !== undefined) {\r\n                const itemSizeIndices = viewer_data_engine_shared_types_1.ACCESSORTYPE_V2.SCALAR;\r\n                const IndicesArrayType = viewer_data_engine_shared_types_1.ACCESSORCOMPONENTTYPE_V2[accessor.sparse.indices.componentType];\r\n                const byteOffsetIndices = accessor.sparse.indices.byteOffset || 0;\r\n                const byteOffsetValues = accessor.sparse.values.byteOffset || 0;\r\n                if (!accessor.sparse.indices.bufferView || !accessor.sparse.values.bufferView)\r\n                    throw new Error('Sparse Mesh not properly defined.');\r\n                const sparseIndices = new IndicesArrayType(this._bufferViewLoader.getBufferView(accessor.sparse.indices.bufferView), byteOffsetIndices, accessor.sparse.count * itemSizeIndices);\r\n                const sparseValues = new ArrayType(this._bufferViewLoader.getBufferView(accessor.sparse.values.bufferView), byteOffsetValues, accessor.sparse.count * itemSize);\r\n                this._loaded[accessorId] = new viewer_shared_types_1.AttributeData(array, itemSize, itemBytes, byteOffset, elementBytes, normalized, accessor.count, accessor.min, accessor.max, byteStride, target, true, sparseIndices, sparseValues);\r\n                continue;\r\n            }\r\n            this._loaded[accessorId] = new viewer_shared_types_1.AttributeData(array, itemSize, itemBytes, byteOffset, elementBytes, normalized, accessor.count, accessor.min, accessor.max, byteStride, target);\r\n        }\r\n    }\r\n}\r\nexports.AccessorLoader = AccessorLoader;\r\n//# sourceMappingURL=AccessorLoader.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BufferLoader = void 0;\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nclass BufferLoader {\r\n    // #endregion Properties (2)\r\n    // #region Constructors (1)\r\n    constructor(_content, _body, _baseUri) {\r\n        this._content = _content;\r\n        this._body = _body;\r\n        this._baseUri = _baseUri;\r\n        // #region Properties (2)\r\n        this._httpClient = viewer_shared_services_1.HttpClient.instance;\r\n        this._loaded = {};\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Methods (2)\r\n    getBuffer(bufferId) {\r\n        if (!this._content.buffers)\r\n            throw new Error('BufferLoader.getBuffer: Buffers not available.');\r\n        if (!this._content.buffers[bufferId])\r\n            throw new Error('BufferLoader.getBuffer: Buffer not available.');\r\n        if (!this._loaded[bufferId])\r\n            throw new Error('BufferLoader.getBuffer: Buffer not loaded.');\r\n        return this._loaded[bufferId];\r\n    }\r\n    load() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.buffers)\r\n                return;\r\n            const promises = [];\r\n            for (let i = 0; i < this._content.buffers.length; i++) {\r\n                const bufferId = i;\r\n                const buffer = this._content.buffers[bufferId];\r\n                if (buffer.type && buffer.type !== 'arraybuffer') {\r\n                    throw new Error(`BufferLoader.load: ${buffer.type} is not supported.`);\r\n                }\r\n                // If present, GLB container is required to be the first buffer.\r\n                if (buffer.uri === undefined && bufferId === 0) {\r\n                    if (!this._body)\r\n                        throw new Error('BufferLoader.load: Buffer not available.');\r\n                    this._loaded[bufferId] = this._body;\r\n                    return;\r\n                }\r\n                const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\r\n                const dataUriRegexResult = buffer.uri.match(dataUriRegex);\r\n                // Safari can not handle Data URIs through XMLHttpRequest so process manually\r\n                if (dataUriRegexResult) {\r\n                    const isBase64 = !!dataUriRegexResult[2];\r\n                    let data = dataUriRegexResult[3];\r\n                    data = decodeURIComponent(data);\r\n                    if (isBase64)\r\n                        data = (0, viewer_shared_services_1.atobCustom)(data);\r\n                    const view = new Uint8Array(data.length);\r\n                    for (let i = 0; i < data.length; i++) {\r\n                        view[i] = data.charCodeAt(i);\r\n                    }\r\n                    this._loaded[bufferId] = view.buffer;\r\n                }\r\n                else {\r\n                    const httpResultPromise = this._httpClient.get(this._baseUri + '/' + buffer.uri, {\r\n                        responseType: 'arraybuffer'\r\n                    }).then(response => { this._loaded[bufferId] = response.data; });\r\n                    promises.push(httpResultPromise);\r\n                }\r\n            }\r\n            yield Promise.all(promises);\r\n        });\r\n    }\r\n}\r\nexports.BufferLoader = BufferLoader;\r\n//# sourceMappingURL=BufferLoader.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BufferViewLoader = void 0;\r\nclass BufferViewLoader {\r\n    // #endregion Properties (1)\r\n    // #region Constructors (1)\r\n    constructor(_content, _bufferLoader) {\r\n        this._content = _content;\r\n        this._bufferLoader = _bufferLoader;\r\n        // #region Properties (1)\r\n        this._loaded = {};\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Methods (2)\r\n    getBufferView(bufferViewId) {\r\n        if (!this._content.bufferViews)\r\n            throw new Error('BufferViewLoader.load: BufferViews not available.');\r\n        if (!this._content.bufferViews[bufferViewId])\r\n            throw new Error('BufferViewLoader.load: BufferView not available.');\r\n        if (!this._loaded[bufferViewId])\r\n            throw new Error('BufferViewLoader.load: BufferView not loaded.');\r\n        return this._loaded[bufferViewId];\r\n    }\r\n    load() {\r\n        if (!this._content.bufferViews)\r\n            return;\r\n        for (let i = 0; i < this._content.bufferViews.length; i++) {\r\n            const bufferViewId = i;\r\n            if (!this._content.bufferViews[bufferViewId])\r\n                throw new Error('BufferViewLoader.load: BufferView not available.');\r\n            const bufferView = this._content.bufferViews[bufferViewId];\r\n            const byteLength = bufferView.byteLength || 0;\r\n            const byteOffset = bufferView.byteOffset || 0;\r\n            if (bufferView.buffer === undefined)\r\n                throw new Error('BufferViewLoader.load: BufferView has no buffer defined.');\r\n            const buffer = this._bufferLoader.getBuffer(bufferView.buffer);\r\n            const result = buffer.slice(byteOffset, byteOffset + byteLength);\r\n            this._loaded[bufferViewId] = result;\r\n        }\r\n    }\r\n}\r\nexports.BufferViewLoader = BufferViewLoader;\r\n//# sourceMappingURL=BufferViewLoader.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GeometryLoader = void 0;\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst GLTFLoader_1 = require(\"../GLTFLoader\");\r\nclass GeometryLoader {\r\n    // #endregion Properties (1)\r\n    // #region Constructors (1)\r\n    constructor(_content, _accessorLoader, _bufferViewLoader, _materialLoader, _dracoModule) {\r\n        this._content = _content;\r\n        this._accessorLoader = _accessorLoader;\r\n        this._bufferViewLoader = _bufferViewLoader;\r\n        this._materialLoader = _materialLoader;\r\n        this._dracoModule = _dracoModule;\r\n        // #region Properties (1)\r\n        this._materialVariantsData = new viewer_shared_types_1.MaterialVariantsData();\r\n        this._loaded = {};\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Accessors (1)\r\n    get materialVariantsData() {\r\n        return this._materialVariantsData;\r\n    }\r\n    // #endregion Public Accessors (1)\r\n    // #region Public Methods (1)\r\n    loadMesh(meshId, weights) {\r\n        if (!this._content.meshes)\r\n            throw new Error('GeometryLoader.loadMesh: Meshes not available.');\r\n        if (!this._content.meshes[meshId])\r\n            throw new Error('GeometryLoader.loadMesh: Mesh not available.');\r\n        const mesh = this._content.meshes[meshId];\r\n        const meshNode = new viewer_shared_node_tree_1.TreeNode(mesh.name || 'mesh_' + meshId);\r\n        meshNode.originalName = mesh.name;\r\n        if (mesh.primitives)\r\n            for (let i = 0, len = mesh.primitives.length; i < len; i++)\r\n                meshNode.addChild(this.loadPrimitive(meshId, mesh.primitives, i, mesh.weights || weights));\r\n        return meshNode;\r\n    }\r\n    // #endregion Public Methods (1)\r\n    // #region Private Methods (1)\r\n    loadPrimitive(meshId, primitives, index, weights = []) {\r\n        const primitive = primitives[index];\r\n        const primitiveNode = new viewer_shared_node_tree_1.TreeNode('primitive_' + index);\r\n        if (this._loaded['mesh_' + meshId + '_primitive_' + index]) {\r\n            primitiveNode.data.push(this._loaded['mesh_' + meshId + '_primitive_' + index].clone());\r\n            return primitiveNode;\r\n        }\r\n        const attributes = {};\r\n        let indices = null;\r\n        const convertedNames = {};\r\n        if (primitive.extensions && primitive.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\r\n            const dracoDef = primitive.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\r\n            const arrayBuffer = this._bufferViewLoader.getBufferView(dracoDef.bufferView);\r\n            const decoder = new this._dracoModule.Decoder();\r\n            const array = new Int8Array(arrayBuffer);\r\n            const geometryType = decoder.GetEncodedGeometryType(array);\r\n            let dracoGeometry;\r\n            if (geometryType === this._dracoModule.TRIANGULAR_MESH) {\r\n                dracoGeometry = new this._dracoModule.Mesh();\r\n                decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);\r\n            }\r\n            else if (geometryType === this._dracoModule.POINT_CLOUD) {\r\n                dracoGeometry = new this._dracoModule.PointCloud();\r\n                decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);\r\n            }\r\n            if (dracoDef.attributes['POSITION'] === undefined) {\r\n                const errorMsg = \"No position attribute found in the mesh.\";\r\n                this._dracoModule.destroy(decoder);\r\n                this._dracoModule.destroy(dracoGeometry);\r\n                throw new Error(errorMsg);\r\n            }\r\n            for (let a in dracoDef.attributes) {\r\n                const attribute = decoder.GetAttributeByUniqueId(dracoGeometry, dracoDef.attributes[a]);\r\n                const attributeData = new this._dracoModule.DracoFloat32Array();\r\n                decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, attributeData);\r\n                const byteOffset = attribute.byte_offset();\r\n                const normalized = attribute.normalized();\r\n                const numComponents = attribute.num_components();\r\n                const numPoints = dracoGeometry.num_points();\r\n                const numValues = numPoints * numComponents;\r\n                const byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\r\n                const ptr = this._dracoModule._malloc(byteLength);\r\n                decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, this._dracoModule.DT_FLOAT32, byteLength, ptr);\r\n                const array = new Float32Array(this._dracoModule.HEAPF32.buffer, ptr, numValues).slice();\r\n                this._dracoModule._free(ptr);\r\n                if (a.includes(\"COLOR\"))\r\n                    array.forEach((n, i) => array[i] = Math.max(0, Math.min(1, n)));\r\n                attributes[a] = new viewer_shared_types_1.AttributeData(array, numComponents, // itemSize\r\n                array.BYTES_PER_ELEMENT * numComponents, // itemBytes = elementBytes * itemSize\r\n                byteOffset, // byteOffset\r\n                array.BYTES_PER_ELEMENT, // elementBytes\r\n                normalized, // normalized\r\n                array.length / numComponents);\r\n            }\r\n            if (geometryType == this._dracoModule.TRIANGULAR_MESH) {\r\n                const numFaces = dracoGeometry.num_faces();\r\n                const numIndices = numFaces * 3;\r\n                const byteLength = numIndices * 4;\r\n                const ptr = this._dracoModule._malloc(byteLength);\r\n                decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\r\n                const indexArray = new Uint32Array(this._dracoModule.HEAPF32.buffer, ptr, numIndices).slice();\r\n                this._dracoModule._free(ptr);\r\n                indices = new viewer_shared_types_1.AttributeData(indexArray, 1, // itemSize\r\n                indexArray.BYTES_PER_ELEMENT * 1, // itemBytes = elementBytes * itemSize\r\n                0, // byteOffset\r\n                indexArray.BYTES_PER_ELEMENT, // elementBytes\r\n                false, // normalized\r\n                indexArray.length // count\r\n                );\r\n            }\r\n            this._dracoModule.destroy(decoder);\r\n            this._dracoModule.destroy(dracoGeometry);\r\n        }\r\n        for (let attribute in primitive.attributes) {\r\n            if (attributes[attribute]) {\r\n                convertedNames[attribute] = attribute;\r\n                continue;\r\n            }\r\n            let attributeName = attribute;\r\n            // attribute name conversion to be consistent with gltf\r\n            if (/\\d/.test(attributeName) && !attributeName.includes('_')) {\r\n                const index = attributeName.search(/\\d/);\r\n                attributeName = attributeName.substring(0, index) + '_' + attributeName.substring(index, attributeName.length);\r\n            }\r\n            else if (attributeName === 'TEXCOORD' || attributeName === 'COLOR' || attributeName === 'JOINTS' || attributeName === 'WEIGHTS') {\r\n                attributeName += '_0';\r\n            }\r\n            else if (attributeName === 'UV') {\r\n                attributeName = 'TEXCOORD_0';\r\n            }\r\n            convertedNames[attribute] = attributeName;\r\n            attributes[attributeName] = (this._accessorLoader.getAccessor(primitive.attributes[attribute]));\r\n        }\r\n        if ((primitive.indices || primitive.indices === 0) && !indices)\r\n            indices = this._accessorLoader.getAccessor(primitive.indices);\r\n        // reading and assigning morph targets\r\n        if (primitive.targets) {\r\n            for (let i = 0; i < primitive.targets.length; i++) {\r\n                for (let target in primitive.targets[i]) {\r\n                    if (!attributes[target])\r\n                        continue;\r\n                    attributes[convertedNames[target]].morphAttributeData.push((this._accessorLoader.getAccessor(primitive.targets[i][target])));\r\n                }\r\n            }\r\n        }\r\n        let material = null;\r\n        if (primitive.material || primitive.material === 0)\r\n            material = this._materialLoader.getMaterial(primitive.material);\r\n        const primitiveData = new viewer_shared_types_1.PrimitiveData(attributes, indices);\r\n        const geometryData = new viewer_shared_types_1.GeometryData(primitiveData, primitive.mode, material);\r\n        if (primitive.extensions && primitive.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_VARIANTS]) {\r\n            this._materialVariantsData.geometryData.push(geometryData);\r\n            const variantsExtension = primitive.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_VARIANTS];\r\n            for (let i = 0; i < variantsExtension.mappings.length; i++) {\r\n                const mapping = variantsExtension.mappings[i];\r\n                const material = this._materialLoader.getMaterial(mapping.material);\r\n                for (let j = 0; j < mapping.variants.length; j++)\r\n                    geometryData.materialVariants.push({ variant: mapping.variants[j], material });\r\n            }\r\n        }\r\n        geometryData.morphWeights = weights;\r\n        this._loaded['mesh_' + meshId + '_primitive_' + index] = geometryData;\r\n        primitiveNode.data.push(geometryData);\r\n        return primitiveNode;\r\n    }\r\n}\r\nexports.GeometryLoader = GeometryLoader;\r\n//# sourceMappingURL=GeometryLoader.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MaterialLoader = void 0;\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst viewer_data_engine_material_engine_1 = require(\"@shapediver/viewer.data-engine.material-engine\");\r\nconst GLTFLoader_1 = require(\"../GLTFLoader\");\r\nclass MaterialLoader {\r\n    // #endregion Properties (4)\r\n    // #region Constructors (1)\r\n    constructor(_content, _textureLoader) {\r\n        this._content = _content;\r\n        this._textureLoader = _textureLoader;\r\n        // #region Properties (4)\r\n        this._converter = viewer_shared_services_1.Converter.instance;\r\n        this._materialEngine = viewer_data_engine_material_engine_1.MaterialEngine.instance;\r\n        this._loaded = {};\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Methods (2)\r\n    getMaterial(materialId) {\r\n        if (!this._content.materials)\r\n            throw new Error('MaterialLoader.getMaterial: Materials not available.');\r\n        if (!this._content.materials[materialId])\r\n            throw new Error('MaterialLoader.getMaterial: Material not available.');\r\n        if (!this._loaded[materialId])\r\n            throw new Error('MaterialLoader.getMaterial: Material not loaded.');\r\n        return this._loaded[materialId];\r\n    }\r\n    load() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._loaded = {};\r\n            if (!this._content.materials)\r\n                return;\r\n            const promises = [];\r\n            for (let i = 0; i < this._content.materials.length; i++) {\r\n                const materialId = i;\r\n                const material = this._content.materials[materialId];\r\n                const materialExtensions = material.extensions || {};\r\n                const materialDataProperties = {};\r\n                if (material.name !== undefined)\r\n                    materialDataProperties.name = material.name;\r\n                if (materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.SHAPEDIVER_MATERIALS_PRESET]) {\r\n                    const materialPreset = materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.SHAPEDIVER_MATERIALS_PRESET];\r\n                    promises.push(new Promise((resolve, reject) => {\r\n                        try {\r\n                            this._materialEngine.loadPresetMaterial(materialPreset.materialpreset)\r\n                                .then(materialData => {\r\n                                materialData.name = material.name;\r\n                                materialData.color = materialPreset.color;\r\n                                this._loaded[materialId] = materialData;\r\n                                resolve();\r\n                            })\r\n                                .catch(reject);\r\n                        }\r\n                        catch (e) {\r\n                            reject(e);\r\n                        }\r\n                    }));\r\n                    continue;\r\n                }\r\n                if (materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_PBRSPECULARGLOSSINESS]) {\r\n                    const pbrSpecularGlossiness = materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_PBRSPECULARGLOSSINESS];\r\n                    const specularGlossinessMaterialDataProperties = materialDataProperties;\r\n                    specularGlossinessMaterialDataProperties.color = '#ffffff';\r\n                    specularGlossinessMaterialDataProperties.opacity = 1.0;\r\n                    if (pbrSpecularGlossiness.diffuseFactor !== undefined) {\r\n                        specularGlossinessMaterialDataProperties.color = [pbrSpecularGlossiness.diffuseFactor[0] * 255, pbrSpecularGlossiness.diffuseFactor[1] * 255, pbrSpecularGlossiness.diffuseFactor[2] * 255];\r\n                        specularGlossinessMaterialDataProperties.opacity = pbrSpecularGlossiness.diffuseFactor[3];\r\n                    }\r\n                    if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\r\n                        const diffuseTextureOptions = pbrSpecularGlossiness.diffuseTexture.extensions && pbrSpecularGlossiness.diffuseTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? pbrSpecularGlossiness.diffuseTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                        if (pbrSpecularGlossiness.diffuseTexture.texCoord !== undefined)\r\n                            diffuseTextureOptions.texCoord = pbrSpecularGlossiness.diffuseTexture.texCoord;\r\n                        specularGlossinessMaterialDataProperties.map = this.loadMap(pbrSpecularGlossiness.diffuseTexture.index, diffuseTextureOptions);\r\n                    }\r\n                    specularGlossinessMaterialDataProperties.emissiveness = '#000000';\r\n                    specularGlossinessMaterialDataProperties.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\r\n                    specularGlossinessMaterialDataProperties.specular = '#ffffff';\r\n                    if (pbrSpecularGlossiness.specularFactor !== undefined) {\r\n                        specularGlossinessMaterialDataProperties.specular = [pbrSpecularGlossiness.specularFactor[0] * 255, pbrSpecularGlossiness.specularFactor[1] * 255, pbrSpecularGlossiness.specularFactor[2] * 255];\r\n                    }\r\n                    if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\r\n                        const specularGlossinessTextureOptions = pbrSpecularGlossiness.specularGlossinessTexture.extensions && pbrSpecularGlossiness.specularGlossinessTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? pbrSpecularGlossiness.specularGlossinessTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                        if (pbrSpecularGlossiness.specularGlossinessTexture.texCoord !== undefined)\r\n                            specularGlossinessTextureOptions.texCoord = pbrSpecularGlossiness.specularGlossinessTexture.texCoord;\r\n                        specularGlossinessMaterialDataProperties.specularGlossinessMap = this.loadMap(pbrSpecularGlossiness.specularGlossinessTexture.index, specularGlossinessTextureOptions);\r\n                    }\r\n                }\r\n                else if (materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_UNLIT]) {\r\n                    const unlitMaterialDataProperties = materialDataProperties;\r\n                    unlitMaterialDataProperties.color = '#ffffff';\r\n                    unlitMaterialDataProperties.opacity = 1.0;\r\n                    if (material.pbrMetallicRoughness !== undefined) {\r\n                        if (material.pbrMetallicRoughness.baseColorFactor !== undefined) {\r\n                            unlitMaterialDataProperties.color = [material.pbrMetallicRoughness.baseColorFactor[0] * 255, material.pbrMetallicRoughness.baseColorFactor[1] * 255, material.pbrMetallicRoughness.baseColorFactor[2] * 255];\r\n                            unlitMaterialDataProperties.opacity = material.pbrMetallicRoughness.baseColorFactor[3];\r\n                        }\r\n                        if (material.pbrMetallicRoughness.baseColorTexture !== undefined) {\r\n                            const baseColorTextureOptions = material.pbrMetallicRoughness.baseColorTexture.extensions && material.pbrMetallicRoughness.baseColorTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? material.pbrMetallicRoughness.baseColorTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                            if (material.pbrMetallicRoughness.baseColorTexture.texCoord !== undefined)\r\n                                baseColorTextureOptions.texCoord = material.pbrMetallicRoughness.baseColorTexture.texCoord;\r\n                            unlitMaterialDataProperties.map = this.loadMap(material.pbrMetallicRoughness.baseColorTexture.index, baseColorTextureOptions);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    const standardMaterialDataProperties = materialDataProperties;\r\n                    if (material.pbrMetallicRoughness !== undefined) {\r\n                        standardMaterialDataProperties.color = '#ffffff';\r\n                        if (material.pbrMetallicRoughness.baseColorFactor !== undefined) {\r\n                            standardMaterialDataProperties.color = [material.pbrMetallicRoughness.baseColorFactor[0] * 255, material.pbrMetallicRoughness.baseColorFactor[1] * 255, material.pbrMetallicRoughness.baseColorFactor[2] * 255];\r\n                            standardMaterialDataProperties.opacity = material.pbrMetallicRoughness.baseColorFactor[3];\r\n                        }\r\n                        if (material.pbrMetallicRoughness.baseColorTexture !== undefined) {\r\n                            const baseColorTextureOptions = material.pbrMetallicRoughness.baseColorTexture.extensions && material.pbrMetallicRoughness.baseColorTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? material.pbrMetallicRoughness.baseColorTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                            if (material.pbrMetallicRoughness.baseColorTexture.texCoord !== undefined)\r\n                                baseColorTextureOptions.texCoord = material.pbrMetallicRoughness.baseColorTexture.texCoord;\r\n                            standardMaterialDataProperties.map = this.loadMap(material.pbrMetallicRoughness.baseColorTexture.index, baseColorTextureOptions);\r\n                        }\r\n                        if (material.pbrMetallicRoughness.metallicFactor !== undefined) {\r\n                            standardMaterialDataProperties.metalness = material.pbrMetallicRoughness.metallicFactor;\r\n                        }\r\n                        if (material.pbrMetallicRoughness.roughnessFactor !== undefined) {\r\n                            standardMaterialDataProperties.roughness = material.pbrMetallicRoughness.roughnessFactor;\r\n                        }\r\n                        if (material.pbrMetallicRoughness.metallicRoughnessTexture !== undefined) {\r\n                            const metallicRoughnessTextureOptions = material.pbrMetallicRoughness.metallicRoughnessTexture.extensions && material.pbrMetallicRoughness.metallicRoughnessTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? material.pbrMetallicRoughness.metallicRoughnessTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                            if (material.pbrMetallicRoughness.metallicRoughnessTexture.texCoord !== undefined)\r\n                                metallicRoughnessTextureOptions.texCoord = material.pbrMetallicRoughness.metallicRoughnessTexture.texCoord;\r\n                            standardMaterialDataProperties.metalnessRoughnessMap = this.loadMap(material.pbrMetallicRoughness.metallicRoughnessTexture.index, metallicRoughnessTextureOptions);\r\n                        }\r\n                    }\r\n                }\r\n                /**\r\n                 * Loading of the general properties\r\n                 */\r\n                if (material.normalTexture !== undefined) {\r\n                    const normalTextureOptions = material.normalTexture.extensions && material.normalTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? material.normalTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                    if (material.normalTexture.texCoord !== undefined)\r\n                        normalTextureOptions.texCoord = material.normalTexture.texCoord;\r\n                    materialDataProperties.normalMap = this.loadMap(material.normalTexture.index, normalTextureOptions);\r\n                    materialDataProperties.normalScale = 1;\r\n                    if (material.normalTexture.scale !== undefined) {\r\n                        materialDataProperties.normalScale = material.normalTexture.scale;\r\n                    }\r\n                }\r\n                if (material.occlusionTexture !== undefined) {\r\n                    const occlusionTextureOptions = material.occlusionTexture.extensions && material.occlusionTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? material.occlusionTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                    if (material.occlusionTexture.texCoord !== undefined)\r\n                        occlusionTextureOptions.texCoord = material.occlusionTexture.texCoord;\r\n                    materialDataProperties.aoMap = this.loadMap(material.occlusionTexture.index, occlusionTextureOptions);\r\n                    if (material.occlusionTexture.strength !== undefined) {\r\n                        materialDataProperties.aoMapIntensity = material.occlusionTexture.strength;\r\n                    }\r\n                }\r\n                if (material.emissiveTexture !== undefined) {\r\n                    const emissiveTextureOptions = material.emissiveTexture.extensions && material.emissiveTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? material.emissiveTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                    if (material.emissiveTexture.texCoord !== undefined)\r\n                        emissiveTextureOptions.texCoord = material.emissiveTexture.texCoord;\r\n                    materialDataProperties.emissiveMap = this.loadMap(material.emissiveTexture.index, emissiveTextureOptions);\r\n                }\r\n                if (material.emissiveFactor !== undefined) {\r\n                    materialDataProperties.emissiveness = [material.emissiveFactor[0] * 255, material.emissiveFactor[1] * 255, material.emissiveFactor[2] * 255];\r\n                }\r\n                if (material.alphaMode !== undefined) {\r\n                    materialDataProperties.alphaMode = material.alphaMode.toLowerCase() === viewer_shared_types_1.MATERIAL_ALPHA.MASK ? viewer_shared_types_1.MATERIAL_ALPHA.MASK : material.alphaMode.toLowerCase() === viewer_shared_types_1.MATERIAL_ALPHA.BLEND ? viewer_shared_types_1.MATERIAL_ALPHA.BLEND : viewer_shared_types_1.MATERIAL_ALPHA.OPAQUE;\r\n                    if (materialDataProperties.alphaMode === viewer_shared_types_1.MATERIAL_ALPHA.MASK) {\r\n                        materialDataProperties.alphaCutoff = material.alphaCutoff !== undefined ? material.alphaCutoff : 0.5;\r\n                    }\r\n                }\r\n                if (material.alphaCutoff !== undefined) {\r\n                    materialDataProperties.alphaCutoff = material.alphaCutoff;\r\n                }\r\n                if (material.doubleSided !== undefined) {\r\n                    materialDataProperties.side = material.doubleSided ? viewer_shared_types_1.MATERIAL_SIDE.DOUBLE : viewer_shared_types_1.MATERIAL_SIDE.FRONT;\r\n                }\r\n                /**\r\n                 * Early exit for specular glossiness and unlit materials\r\n                 */\r\n                if (materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_PBRSPECULARGLOSSINESS]) {\r\n                    const specularGlossinessMaterialDataProperties = materialDataProperties;\r\n                    const materialData = new viewer_shared_types_1.MaterialSpecularGlossinessData(specularGlossinessMaterialDataProperties);\r\n                    this._loaded[materialId] = materialData;\r\n                    continue;\r\n                }\r\n                else if (materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_UNLIT]) {\r\n                    const unlitMaterialDataProperties = materialDataProperties;\r\n                    const materialData = new viewer_shared_types_1.MaterialUnlitData(unlitMaterialDataProperties);\r\n                    this._loaded[materialId] = materialData;\r\n                    continue;\r\n                }\r\n                const standardMaterialDataProperties = materialDataProperties;\r\n                if (materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_CLEARCOAT]) {\r\n                    const clearcoatExtension = materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_CLEARCOAT];\r\n                    if (clearcoatExtension.clearcoatFactor !== undefined) {\r\n                        standardMaterialDataProperties.clearcoat = clearcoatExtension.clearcoatFactor;\r\n                    }\r\n                    if (clearcoatExtension.clearcoatTexture !== undefined) {\r\n                        const clearcoatTextureOptions = clearcoatExtension.clearcoatTexture.extensions && clearcoatExtension.clearcoatTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? clearcoatExtension.clearcoatTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                        if (clearcoatExtension.clearcoatTexture.texCoord !== undefined)\r\n                            clearcoatTextureOptions.texCoord = clearcoatExtension.clearcoatTexture.texCoord;\r\n                        standardMaterialDataProperties.clearcoatMap = this.loadMap(clearcoatExtension.clearcoatTexture.index, clearcoatTextureOptions);\r\n                    }\r\n                    if (clearcoatExtension.clearcoatRoughnessFactor !== undefined) {\r\n                        standardMaterialDataProperties.clearcoatRoughness = clearcoatExtension.clearcoatRoughnessFactor;\r\n                    }\r\n                    if (clearcoatExtension.clearcoatRoughnessTexture !== undefined) {\r\n                        const clearcoatRoughnessTextureOptions = clearcoatExtension.clearcoatRoughnessTexture.extensions && clearcoatExtension.clearcoatRoughnessTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? clearcoatExtension.clearcoatRoughnessTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                        if (clearcoatExtension.clearcoatRoughnessTexture.texCoord !== undefined)\r\n                            clearcoatRoughnessTextureOptions.texCoord = clearcoatExtension.clearcoatRoughnessTexture.texCoord;\r\n                        standardMaterialDataProperties.clearcoatRoughnessMap = this.loadMap(clearcoatExtension.clearcoatRoughnessTexture.index, clearcoatRoughnessTextureOptions);\r\n                    }\r\n                    if (clearcoatExtension.clearcoatNormalTexture !== undefined) {\r\n                        const clearcoatNormalTextureOptions = clearcoatExtension.clearcoatNormalTexture.extensions && clearcoatExtension.clearcoatNormalTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? clearcoatExtension.clearcoatNormalTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                        if (clearcoatExtension.clearcoatNormalTexture.texCoord !== undefined)\r\n                            clearcoatNormalTextureOptions.texCoord = clearcoatExtension.clearcoatNormalTexture.texCoord;\r\n                        standardMaterialDataProperties.clearcoatNormalMap = this.loadMap(clearcoatExtension.clearcoatNormalTexture.index, clearcoatNormalTextureOptions);\r\n                    }\r\n                }\r\n                if (materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_IOR]) {\r\n                    const iorExtension = materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_IOR];\r\n                    if (iorExtension.ior !== undefined) {\r\n                        standardMaterialDataProperties.ior = iorExtension.ior;\r\n                    }\r\n                }\r\n                if (materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_TRANSMISSION]) {\r\n                    const transmissionExtension = materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_TRANSMISSION];\r\n                    if (transmissionExtension.transmissionFactor !== undefined) {\r\n                        standardMaterialDataProperties.transmission = transmissionExtension.transmissionFactor;\r\n                    }\r\n                    if (transmissionExtension.transmissionTexture !== undefined) {\r\n                        const transmissionTextureOptions = transmissionExtension.transmissionTexture.extensions && transmissionExtension.transmissionTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? transmissionExtension.transmissionTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                        if (transmissionExtension.transmissionTexture.texCoord !== undefined)\r\n                            transmissionTextureOptions.texCoord = transmissionExtension.transmissionTexture.texCoord;\r\n                        standardMaterialDataProperties.transmissionMap = this.loadMap(transmissionExtension.transmissionTexture.index, transmissionTextureOptions);\r\n                    }\r\n                }\r\n                if (materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_VOLUME]) {\r\n                    const volumeExtension = materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_VOLUME];\r\n                    if (volumeExtension.thicknessFactor !== undefined) {\r\n                        standardMaterialDataProperties.thickness = volumeExtension.thicknessFactor;\r\n                    }\r\n                    if (volumeExtension.thicknessTexture !== undefined) {\r\n                        const thicknessTextureOptions = volumeExtension.thicknessTexture.extensions && volumeExtension.thicknessTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? volumeExtension.thicknessTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                        if (volumeExtension.thicknessTexture.texCoord !== undefined)\r\n                            thicknessTextureOptions.texCoord = volumeExtension.thicknessTexture.texCoord;\r\n                        standardMaterialDataProperties.thicknessMap = this.loadMap(volumeExtension.thicknessTexture.index, thicknessTextureOptions);\r\n                    }\r\n                    if (volumeExtension.attenuationDistance !== undefined) {\r\n                        standardMaterialDataProperties.attenuationDistance = volumeExtension.attenuationDistance;\r\n                    }\r\n                    if (volumeExtension.attenuationColor !== undefined) {\r\n                        standardMaterialDataProperties.attenuationColor = [volumeExtension.attenuationColor[0] * 255, volumeExtension.attenuationColor[1] * 255, volumeExtension.attenuationColor[2] * 255];\r\n                    }\r\n                }\r\n                if (materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_SHEEN]) {\r\n                    const sheenExtension = materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_SHEEN];\r\n                    standardMaterialDataProperties.sheen = 1.0;\r\n                    if (sheenExtension.sheenColorFactor !== undefined) {\r\n                        standardMaterialDataProperties.sheenColor = [sheenExtension.sheenColorFactor[0] * 255, sheenExtension.sheenColorFactor[1] * 255, sheenExtension.sheenColorFactor[2] * 255];\r\n                    }\r\n                    if (sheenExtension.sheenRoughnessFactor !== undefined) {\r\n                        standardMaterialDataProperties.sheenRoughness = sheenExtension.sheenRoughnessFactor;\r\n                    }\r\n                    if (sheenExtension.sheenColorTexture !== undefined) {\r\n                        const sheenColorTextureOptions = sheenExtension.sheenColorTexture.extensions && sheenExtension.sheenColorTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? sheenExtension.sheenColorTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                        if (sheenExtension.sheenColorTexture.texCoord !== undefined)\r\n                            sheenColorTextureOptions.texCoord = sheenExtension.sheenColorTexture.texCoord;\r\n                        standardMaterialDataProperties.sheenColorMap = this.loadMap(sheenExtension.sheenColorTexture.index, sheenColorTextureOptions);\r\n                    }\r\n                    if (sheenExtension.sheenRoughnessTexture !== undefined) {\r\n                        const sheenRoughnessTextureOptions = sheenExtension.sheenRoughnessTexture.extensions && sheenExtension.sheenRoughnessTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? sheenExtension.sheenRoughnessTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                        if (sheenExtension.sheenRoughnessTexture.texCoord !== undefined)\r\n                            sheenRoughnessTextureOptions.texCoord = sheenExtension.sheenRoughnessTexture.texCoord;\r\n                        standardMaterialDataProperties.sheenRoughnessMap = this.loadMap(sheenExtension.sheenRoughnessTexture.index, sheenRoughnessTextureOptions);\r\n                    }\r\n                }\r\n                if (materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_SPECULAR]) {\r\n                    const specularExtension = materialExtensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_SPECULAR];\r\n                    if (specularExtension.specularFactor !== undefined) {\r\n                        standardMaterialDataProperties.specularIntensity = specularExtension.specularFactor;\r\n                    }\r\n                    if (specularExtension.specularColorFactor !== undefined) {\r\n                        standardMaterialDataProperties.specularColor = [specularExtension.specularColorFactor[0] * 255, specularExtension.specularColorFactor[1] * 255, specularExtension.specularColorFactor[2] * 255];\r\n                    }\r\n                    if (specularExtension.specularColorTexture !== undefined) {\r\n                        const specularColorTextureOptions = specularExtension.specularColorTexture.extensions && specularExtension.specularColorTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? specularExtension.specularColorTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                        if (specularExtension.specularColorTexture.texCoord !== undefined)\r\n                            specularColorTextureOptions.texCoord = specularExtension.specularColorTexture.texCoord;\r\n                        standardMaterialDataProperties.specularColorMap = this.loadMap(specularExtension.specularColorTexture.index, specularColorTextureOptions);\r\n                    }\r\n                    if (specularExtension.specularTexture !== undefined) {\r\n                        const specularTextureOptions = specularExtension.specularTexture.extensions && specularExtension.specularTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] ? specularExtension.specularTexture.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_TEXTURE_TRANSFORM] : {};\r\n                        if (specularExtension.specularTexture.texCoord !== undefined)\r\n                            specularTextureOptions.texCoord = specularExtension.specularTexture.texCoord;\r\n                        standardMaterialDataProperties.specularIntensityMap = this.loadMap(specularExtension.specularTexture.index, specularTextureOptions);\r\n                    }\r\n                }\r\n                const materialData = new viewer_shared_types_1.MaterialStandardData(standardMaterialDataProperties);\r\n                this._loaded[materialId] = materialData;\r\n            }\r\n            yield Promise.all(promises);\r\n        });\r\n    }\r\n    // #endregion Public Methods (2)\r\n    // #region Private Methods (1)\r\n    loadMap(textureId, properties) {\r\n        if (!this._content.textures)\r\n            throw new Error('Textures not available.');\r\n        const texture = this._content.textures[textureId];\r\n        if (!this._content.images)\r\n            throw new Error('Images not available.');\r\n        const sampler = this._content.samplers && texture.sampler && this._content.samplers[texture.sampler] ? this._content.samplers[texture.sampler] : {};\r\n        const loadedTexture = this._textureLoader.getTexture(textureId);\r\n        if (!loadedTexture)\r\n            return;\r\n        return new viewer_shared_types_1.MapData(loadedTexture.image, {\r\n            blob: loadedTexture.blob,\r\n            wrapS: sampler.wrapS,\r\n            wrapT: sampler.wrapT,\r\n            minFilter: sampler.minFilter,\r\n            magFilter: sampler.magFilter,\r\n            offset: properties && properties.offset ? gl_matrix_1.vec2.fromValues(properties.offset[0], properties.offset[1]) : gl_matrix_1.vec2.create(),\r\n            repeat: properties && properties.scale ? gl_matrix_1.vec2.fromValues(properties.scale[0], properties.scale[1]) : gl_matrix_1.vec2.fromValues(1, 1),\r\n            rotation: properties && properties.rotation !== undefined ? properties.rotation : 0,\r\n            texCoord: properties === null || properties === void 0 ? void 0 : properties.texCoord,\r\n            flipY: false\r\n        });\r\n    }\r\n}\r\nexports.MaterialLoader = MaterialLoader;\r\n//# sourceMappingURL=MaterialLoader.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TextureLoader = void 0;\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nclass TextureLoader {\r\n    // #endregion Properties (3)\r\n    // #region Constructors (1)\r\n    constructor(_content, _bufferViewLoader, _baseUri) {\r\n        this._content = _content;\r\n        this._bufferViewLoader = _bufferViewLoader;\r\n        this._baseUri = _baseUri;\r\n        // #region Properties (3)\r\n        this._converter = viewer_shared_services_1.Converter.instance;\r\n        this._httpClient = viewer_shared_services_1.HttpClient.instance;\r\n        this._loaded = {};\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Methods (2)\r\n    getTexture(textureId) {\r\n        if (!this._content.textures)\r\n            throw new Error('TextureLoader.getTexture: Textures not available.');\r\n        if (!this._content.textures[textureId])\r\n            throw new Error('TextureLoader.getTexture: Texture not available.');\r\n        return this._loaded[textureId];\r\n    }\r\n    load() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.textures)\r\n                return;\r\n            const promises = [];\r\n            for (let i = 0; i < this._content.textures.length; i++) {\r\n                const textureId = i;\r\n                const texture = this._content.textures[textureId];\r\n                if (!this._content.images)\r\n                    throw new Error('TextureLoader.load: Images not available.');\r\n                const image = this._content.images[texture.source];\r\n                const DATA_URI_REGEX = /^data:(.*?)(;base64)?,(.*)$/;\r\n                const HTTPS_URI_REGEX = /^https:\\/\\//;\r\n                if (image.bufferView !== undefined) {\r\n                    const bufferView = this._bufferViewLoader.getBufferView(image.bufferView);\r\n                    const dataView = new DataView(bufferView);\r\n                    const array = [];\r\n                    for (let i = 0; i < dataView.byteLength; i += 1)\r\n                        array[i] = dataView.getUint8(i);\r\n                    const blob = new Blob([new Uint8Array(array)], { type: image.mimeType });\r\n                    const dataUri = URL.createObjectURL(blob);\r\n                    const img = new Image();\r\n                    promises.push(new Promise((resolve, reject) => {\r\n                        img.onload = () => {\r\n                            this._loaded[textureId] = {\r\n                                image: img,\r\n                                blob\r\n                            };\r\n                            URL.revokeObjectURL(dataUri);\r\n                            resolve();\r\n                        };\r\n                        img.onerror = reject;\r\n                    }));\r\n                    img.crossOrigin = 'anonymous';\r\n                    img.src = dataUri;\r\n                }\r\n                else {\r\n                    const url = DATA_URI_REGEX.test(image.uri) || HTTPS_URI_REGEX.test(image.uri) ? image.uri : `${this._baseUri}/${image.uri}`;\r\n                    promises.push(new Promise((resolve, reject) => {\r\n                        this._httpClient.loadTexture(url)\r\n                            .then(response => {\r\n                            if (!response) {\r\n                                resolve();\r\n                            }\r\n                            else {\r\n                                if (typeof window !== 'undefined') {\r\n                                    viewer_shared_services_1.Converter.instance.responseToImage(response).then(img => {\r\n                                        this._loaded[textureId] = {\r\n                                            image: img,\r\n                                            blob: response.data.blob\r\n                                        };\r\n                                        resolve();\r\n                                    })\r\n                                        .catch(e => reject(e));\r\n                                }\r\n                                else {\r\n                                    this._loaded[textureId] = {\r\n                                        image: response.data.buffer,\r\n                                        blob: response.data.blob\r\n                                    };\r\n                                    resolve();\r\n                                }\r\n                            }\r\n                        })\r\n                            .catch(e => reject(e));\r\n                    }));\r\n                }\r\n            }\r\n            yield Promise.all(promises);\r\n        });\r\n    }\r\n}\r\nexports.TextureLoader = TextureLoader;\r\n//# sourceMappingURL=TextureLoader.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GeometryEngine = void 0;\r\nconst GeometryEngine_1 = require(\"./GeometryEngine\");\r\nObject.defineProperty(exports, \"GeometryEngine\", { enumerable: true, get: function () { return GeometryEngine_1.GeometryEngine; } });\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GLTF_EXTENSIONS = exports.GLTFConverter = void 0;\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_shared_build_data_1 = require(\"@shapediver/viewer.shared.build-data\");\r\nconst viewer_shared_global_access_objects_1 = require(\"@shapediver/viewer.shared.global-access-objects\");\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nconst viewer_data_engine_shared_types_1 = require(\"@shapediver/viewer.data-engine.shared-types\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\n// #region Classes (1)\r\nclass GLTFConverter {\r\n    constructor() {\r\n        // #region Properties (23)\r\n        this._converter = viewer_shared_services_1.Converter.instance;\r\n        this._eventEngine = viewer_shared_services_1.EventEngine.instance;\r\n        this._globalAccessObjects = viewer_shared_global_access_objects_1.GlobalAccessObjects.instance;\r\n        this._globalTransformationInverse = gl_matrix_1.mat4.fromValues(1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1);\r\n        this._progressUpdateLimit = 500;\r\n        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;\r\n        this._animations = [];\r\n        this._buffers = [];\r\n        this._byteOffset = 0;\r\n        this._content = {\r\n            asset: {\r\n                copyright: '2023 (c) ShapeDiver',\r\n                generator: 'ShapeDiverViewer@' + viewer_shared_build_data_1.build_data.build_version,\r\n                version: '2.0',\r\n                extensions: {}\r\n            },\r\n        };\r\n        this._convertForAR = false;\r\n        this._eventId = '';\r\n        this._extensionsRequired = [];\r\n        this._extensionsUsed = [];\r\n        this._imageCache = {};\r\n        this._materialCache = {};\r\n        this._meshCache = {};\r\n        this._nodes = [];\r\n        this._numberOfNodes = 0;\r\n        this._progressTimer = 0;\r\n        this._promises = [];\r\n        // #endregion Private Methods (17)\r\n    }\r\n    // #endregion Properties (23)\r\n    // #region Public Static Getters And Setters (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Getters And Setters (1)\r\n    // #region Public Methods (1)\r\n    convert(node, convertForAR = false, viewport) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._eventId = this._uuidGenerator.create();\r\n            const eventStart = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CREATION, id: this._eventId, progress: 0, status: 'Starting glTF conversion.' };\r\n            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);\r\n            this._numberOfNodes = 0;\r\n            node.traverse(() => this._numberOfNodes++);\r\n            this._progressTimer = performance.now();\r\n            this.reset();\r\n            this._convertForAR = convertForAR;\r\n            this._viewport = viewport;\r\n            const originalParent = node.parent;\r\n            const sceneNode = new viewer_shared_node_tree_1.TreeNode('ShapeDiverRootNode');\r\n            sceneNode.addChild(node);\r\n            const sceneDef = {\r\n                name: sceneNode.name,\r\n                nodes: []\r\n            };\r\n            const globalTransformationInverseId = this._uuidGenerator.create();\r\n            node.addTransformation({\r\n                id: globalTransformationInverseId,\r\n                matrix: this._globalTransformationInverse,\r\n            });\r\n            const translationMatrixId = this._uuidGenerator.create();\r\n            if (convertForAR) {\r\n                // add translation matrix to scene tree node\r\n                const center = node.boundingBox.boundingSphere.center;\r\n                const translationMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(center[0], center[1], center[2]), gl_matrix_1.vec3.fromValues(-1, -1, -1)));\r\n                node.addTransformation({ id: translationMatrixId, matrix: translationMatrix });\r\n            }\r\n            if (this._viewport) {\r\n                if (this._viewport && node.excludeViewports.includes(this._viewport) === false && (node.restrictViewports.length > 0 && !node.restrictViewports.includes(this._viewport)) === false) {\r\n                    const nodeId = yield this.convertNode(node);\r\n                    if (nodeId !== -1)\r\n                        (_a = sceneDef.nodes) === null || _a === void 0 ? void 0 : _a.push(nodeId);\r\n                }\r\n            }\r\n            else {\r\n                const nodeId = yield this.convertNode(node);\r\n                if (nodeId !== -1)\r\n                    (_b = sceneDef.nodes) === null || _b === void 0 ? void 0 : _b.push(nodeId);\r\n            }\r\n            for (let i = 0; i < node.transformations.length; i++)\r\n                if (node.transformations[i].id === globalTransformationInverseId)\r\n                    node.removeTransformation(node.transformations[i]);\r\n            if (convertForAR) {\r\n                // remove translation the matrix\r\n                for (let i = 0; i < node.transformations.length; i++)\r\n                    if (node.transformations[i].id === translationMatrixId)\r\n                        node.removeTransformation(node.transformations[i]);\r\n            }\r\n            this._content.scenes = [];\r\n            this._content.scenes.push(sceneDef);\r\n            this.convertAnimations();\r\n            // Declare extensions.\r\n            if (this._extensionsUsed.length > 0)\r\n                this._content.extensionsUsed = this._extensionsUsed;\r\n            if (this._extensionsRequired.length > 0)\r\n                this._content.extensionsRequired = this._extensionsRequired;\r\n            let promisesLength = 0;\r\n            while (promisesLength !== this._promises.length) {\r\n                promisesLength = this._promises.length;\r\n                yield Promise.all(this._promises);\r\n                yield new Promise(resolve => setTimeout(resolve, 0));\r\n            }\r\n            const eventProgressImagePromises = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CREATION, id: this._eventId, progress: 0.75, status: 'GlTF images resolved.' };\r\n            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventProgressImagePromises);\r\n            // Merge buffers.\r\n            const blob = new Blob(this._buffers, { type: 'application/octet-stream' });\r\n            if (originalParent)\r\n                originalParent.addChild(node);\r\n            // Update byte length of the single buffer.\r\n            if (this._content.buffers && this._content.buffers.length > 0)\r\n                this._content.buffers[0].byteLength = blob.size;\r\n            return new Promise((resolve, reject) => {\r\n                // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\r\n                try {\r\n                    if (typeof window !== 'undefined' && window.FileReader) {\r\n                        const reader = new window.FileReader();\r\n                        reader.readAsArrayBuffer(blob);\r\n                        reader.onloadend = () => {\r\n                            // Binary chunk.\r\n                            const binaryChunk = this.getPaddedArrayBuffer(reader.result);\r\n                            const binaryChunkPrefix = new DataView(new ArrayBuffer(8));\r\n                            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\r\n                            binaryChunkPrefix.setUint32(4, 0x004E4942, true);\r\n                            // JSON chunk.\r\n                            const jsonChunk = this.getPaddedArrayBuffer(this.stringToArrayBuffer(JSON.stringify(this._content)), 0x20);\r\n                            const jsonChunkPrefix = new DataView(new ArrayBuffer(8));\r\n                            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\r\n                            jsonChunkPrefix.setUint32(4, 0x4E4F534A, true);\r\n                            // GLB header.\r\n                            const header = new ArrayBuffer(12);\r\n                            const headerView = new DataView(header);\r\n                            headerView.setUint32(0, 0x46546C67, true);\r\n                            headerView.setUint32(4, 2, true);\r\n                            const totalByteLength = 12\r\n                                + jsonChunkPrefix.byteLength + jsonChunk.byteLength\r\n                                + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\r\n                            headerView.setUint32(8, totalByteLength, true);\r\n                            const glbBlob = new Blob([\r\n                                header,\r\n                                jsonChunkPrefix,\r\n                                jsonChunk,\r\n                                binaryChunkPrefix,\r\n                                binaryChunk\r\n                            ], { type: 'application/octet-stream' });\r\n                            const glbReader = new window.FileReader();\r\n                            glbReader.readAsArrayBuffer(glbBlob);\r\n                            glbReader.onloadend = () => {\r\n                                const eventEnd = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CREATION, id: this._eventId, progress: 1, status: 'GlTF creation complete.' };\r\n                                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);\r\n                                resolve(glbReader.result);\r\n                            };\r\n                            glbReader.onerror = reject;\r\n                        };\r\n                        reader.onerror = reject;\r\n                    }\r\n                    else {\r\n                        reject('FileReader not available.');\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    // #endregion Public Methods (1)\r\n    // #region Private Methods (17)\r\n    convertAccessor(data) {\r\n        if (!this._content.accessors)\r\n            this._content.accessors = [];\r\n        const bufferView = this.convertBufferView(data);\r\n        const minMax = this.getMinMax(data);\r\n        const accessorDef = {\r\n            bufferView: bufferView,\r\n            byteOffset: 0,\r\n            componentType: this.getComponentType(data.array),\r\n            normalized: data.normalized,\r\n            count: +data.count,\r\n            max: minMax.max,\r\n            min: minMax.min,\r\n            type: this.getType(data.itemSize),\r\n            // sparse: { // TODO\r\n            //     count: number,\r\n            //     indices: {\r\n            //         bufferView: number,\r\n            //         byteOffset?: number,\r\n            //         componentType: number,\r\n            //         extensions?: { [id: string]: any },\r\n            //         extras?: any\r\n            //     },\r\n            //     values: {\r\n            //         bufferView: number,\r\n            //         byteOffset?: number,\r\n            //         extensions?: { [id: string]: any },\r\n            //         extras?: any\r\n            //     },\r\n            //     extensions?: { [id: string]: any },\r\n            //     extras?: any\r\n            // },\r\n        };\r\n        this._content.accessors.push(accessorDef);\r\n        return this._content.accessors.length - 1;\r\n    }\r\n    convertAnimations() {\r\n        var _a;\r\n        if (!this._content.animations && this._animations.length > 0)\r\n            this._content.animations = [];\r\n        for (let i = 0; i < this._animations.length; i++) {\r\n            const animation = this._animations[i];\r\n            const animationDef = {\r\n                name: animation.name || 'animation_' + i,\r\n                channels: [],\r\n                samplers: []\r\n            };\r\n            for (let j = 0; j < animation.tracks.length; j++) {\r\n                const track = animation.tracks[j];\r\n                const value = this._nodes.find(a => a.node === track.node);\r\n                if (!value)\r\n                    continue;\r\n                const inputMin = Math.min(...track.times);\r\n                const inputMax = Math.max(...track.times);\r\n                const inputData = new viewer_shared_types_1.AttributeData(new Float32Array(track.times), 1, 4, 0, 4, false, track.times.length, [inputMin], [inputMax]);\r\n                const outputMin = [];\r\n                outputMin.push(Math.min(...track.values.filter((s, i) => i % (track.path === 'rotation' ? 4 : 3) === 0)));\r\n                outputMin.push(Math.min(...track.values.filter((s, i) => i % (track.path === 'rotation' ? 4 : 3) === 1)));\r\n                outputMin.push(Math.min(...track.values.filter((s, i) => i % (track.path === 'rotation' ? 4 : 3) === 2)));\r\n                if (track.path === 'rotation') {\r\n                    outputMin.push(Math.min(...track.values.filter((s, i) => i % 4 === 3)));\r\n                }\r\n                const outputMax = [];\r\n                outputMax.push(Math.max(...track.values.filter((s, i) => i % (track.path === 'rotation' ? 4 : 3) === 0)));\r\n                outputMax.push(Math.max(...track.values.filter((s, i) => i % (track.path === 'rotation' ? 4 : 3) === 1)));\r\n                outputMax.push(Math.max(...track.values.filter((s, i) => i % (track.path === 'rotation' ? 4 : 3) === 2)));\r\n                if (track.path === 'rotation') {\r\n                    outputMax.push(Math.max(...track.values.filter((s, i) => i % 4 === 3)));\r\n                }\r\n                const outputData = new viewer_shared_types_1.AttributeData(new Float32Array(track.values), track.path === 'rotation' ? 4 : 3, //itemSize\r\n                track.path === 'rotation' ? 16 : 12, //itemBytes\r\n                0, 4, false, track.times.length, outputMin, outputMax, track.path === 'rotation' ? 16 : 12);\r\n                const samplerDef = {\r\n                    input: this.convertAccessor(inputData),\r\n                    output: this.convertAccessor(outputData),\r\n                    interpolation: track.interpolation.toUpperCase()\r\n                };\r\n                animationDef.samplers.push(samplerDef);\r\n                const channelDef = {\r\n                    sampler: animationDef.samplers.length - 1,\r\n                    target: {\r\n                        node: value.id,\r\n                        path: track.path\r\n                    }\r\n                };\r\n                animationDef.channels.push(channelDef);\r\n            }\r\n            (_a = this._content.animations) === null || _a === void 0 ? void 0 : _a.push(animationDef);\r\n        }\r\n    }\r\n    convertBuffer(buffer) {\r\n        if (!this._content.buffers)\r\n            this._content.buffers = [];\r\n        if (this._content.buffers.length === 0)\r\n            this._content.buffers = [{ byteLength: 0 }];\r\n        this._buffers.push(buffer);\r\n        return 0;\r\n    }\r\n    convertBufferView(data) {\r\n        if (!this._content.bufferViews)\r\n            this._content.bufferViews = [];\r\n        const componentTypeNumber = this.getComponentType(data.array);\r\n        const componentSize = viewer_data_engine_shared_types_1.ACCESSORCOMPONENTSIZE_V2[componentTypeNumber];\r\n        const byteLength = Math.ceil(data.count * data.itemSize * componentSize / 4) * 4;\r\n        const dataView = new DataView(new ArrayBuffer(byteLength));\r\n        let offset = 0;\r\n        for (let i = 0; i < data.count; i++) {\r\n            for (let a = 0; a < data.itemSize; a++) {\r\n                let value = 0;\r\n                if (data.itemSize > 4) {\r\n                    // no support for interleaved data for itemSize > 4\r\n                    value = data.array[i * data.itemSize + a];\r\n                }\r\n                else {\r\n                    if (a === 0)\r\n                        value = data.array[i * data.itemSize];\r\n                    else if (a === 1)\r\n                        value = data.array[i * data.itemSize + 1];\r\n                    else if (a === 2)\r\n                        value = data.array[i * data.itemSize + 2];\r\n                    else if (a === 3)\r\n                        value = data.array[i * data.itemSize + 3];\r\n                }\r\n                if (data.array instanceof Float32Array) {\r\n                    dataView.setFloat32(offset, value, true);\r\n                }\r\n                else if (data.array instanceof Uint32Array) {\r\n                    dataView.setUint32(offset, value, true);\r\n                }\r\n                else if (data.array instanceof Uint16Array) {\r\n                    dataView.setUint16(offset, value, true);\r\n                }\r\n                else if (data.array instanceof Int16Array) {\r\n                    dataView.setInt16(offset, value, true);\r\n                }\r\n                else if (data.array instanceof Uint8Array) {\r\n                    dataView.setUint8(offset, value);\r\n                }\r\n                else if (data.array instanceof Int8Array) {\r\n                    dataView.setInt8(offset, value);\r\n                }\r\n                offset += componentSize;\r\n            }\r\n        }\r\n        const bufferViewDef = {\r\n            buffer: this.convertBuffer(dataView.buffer),\r\n            byteOffset: this._byteOffset,\r\n            byteLength: byteLength,\r\n            target: data.target\r\n        };\r\n        this._byteOffset += byteLength;\r\n        this._content.bufferViews.push(bufferViewDef);\r\n        return this._content.bufferViews.length - 1;\r\n    }\r\n    convertBufferViewImage(blob) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.bufferViews)\r\n                this._content.bufferViews = [];\r\n            return new Promise((resolve, reject) => {\r\n                try {\r\n                    if (typeof window !== 'undefined' && window.FileReader) {\r\n                        const reader = new window.FileReader();\r\n                        reader.readAsArrayBuffer(blob);\r\n                        reader.onloadend = () => {\r\n                            const buffer = this.getPaddedArrayBuffer(reader.result);\r\n                            const bufferViewDef = {\r\n                                buffer: this.convertBuffer(buffer),\r\n                                byteOffset: this._byteOffset,\r\n                                byteLength: buffer.byteLength\r\n                            };\r\n                            this._byteOffset += buffer.byteLength;\r\n                            this._content.bufferViews.push(bufferViewDef);\r\n                            resolve(this._content.bufferViews.length - 1);\r\n                        };\r\n                        reader.onerror = reject;\r\n                    }\r\n                    else {\r\n                        reject('FileReader not available.');\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    convertImage(data) {\r\n        if (!this._content.images)\r\n            this._content.images = [];\r\n        if (data.image instanceof ArrayBuffer)\r\n            return;\r\n        if (this._imageCache[data.image.src] !== undefined)\r\n            return this._imageCache[data.image.src];\r\n        const imageDef = {};\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = data.image.width;\r\n        canvas.height = data.image.height;\r\n        const ctx = canvas.getContext('2d');\r\n        if (data.flipY) {\r\n            ctx.translate(0, canvas.height);\r\n            ctx.scale(1, -1);\r\n        }\r\n        if (data.blob) {\r\n            imageDef.mimeType = data.blob.type;\r\n            this._promises.push(new Promise((resolve, reject) => {\r\n                try {\r\n                    this.convertBufferViewImage(data.blob).then(bufferViewIndex => {\r\n                        imageDef.bufferView = bufferViewIndex;\r\n                        resolve();\r\n                    });\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            }));\r\n        }\r\n        else {\r\n            let mimeType = 'image/png';\r\n            if (data.image.src.endsWith('.jpg') || data.image.src.includes('image/jpeg'))\r\n                mimeType = 'image/jpeg';\r\n            imageDef.mimeType = mimeType;\r\n            const DATA_URI_REGEX = /^data:(.*?)(;base64)?,(.*)$/;\r\n            if (DATA_URI_REGEX.test(data.image.src)) {\r\n                const byteString = (0, viewer_shared_services_1.atobCustom)(data.image.src.split(',')[1]);\r\n                const mimeType = data.image.src.split(',')[0].split(':')[1].split(';')[0];\r\n                const ab = new ArrayBuffer(byteString.length);\r\n                const ia = new Uint8Array(ab);\r\n                for (let i = 0; i < byteString.length; i++)\r\n                    ia[i] = byteString.charCodeAt(i);\r\n                const blob = new Blob([ab], { type: mimeType });\r\n                this._promises.push(new Promise((resolve, reject) => {\r\n                    try {\r\n                        this.convertBufferViewImage(blob)\r\n                            .then(bufferViewIndex => {\r\n                            imageDef.bufferView = bufferViewIndex;\r\n                            resolve();\r\n                        })\r\n                            .catch(reject);\r\n                    }\r\n                    catch (e) {\r\n                        reject(e);\r\n                    }\r\n                }));\r\n            }\r\n            else {\r\n                ctx.drawImage(data.image, 0, 0, canvas.width, canvas.height);\r\n                this._promises.push(new Promise((resolve, reject) => {\r\n                    try {\r\n                        canvas.toBlob((blob) => __awaiter(this, void 0, void 0, function* () {\r\n                            try {\r\n                                const bufferViewIndex = yield this.convertBufferViewImage(blob);\r\n                                imageDef.bufferView = bufferViewIndex;\r\n                                resolve();\r\n                            }\r\n                            catch (e) {\r\n                                reject(e);\r\n                            }\r\n                        }), mimeType);\r\n                    }\r\n                    catch (e) {\r\n                        reject(e);\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n        this._content.images.push(imageDef);\r\n        this._imageCache[data.image.src] = this._content.images.length - 1;\r\n        return this._content.images.length - 1;\r\n    }\r\n    convertMaterial(data, includeMaps = true) {\r\n        if (!this._content.materials)\r\n            this._content.materials = [];\r\n        if (this._materialCache[data.id + '_' + data.version] !== undefined)\r\n            return this._materialCache[data.id + '_' + data.version];\r\n        const materialDef = {\r\n            name: data.id,\r\n            pbrMetallicRoughness: {}\r\n        };\r\n        if (data instanceof viewer_shared_types_1.MaterialSpecularGlossinessData) {\r\n            if (!this._extensionsUsed.includes('KHR_materials_pbrSpecularGlossiness'))\r\n                this._extensionsUsed.push('KHR_materials_pbrSpecularGlossiness');\r\n            if (!this._extensionsRequired.includes('KHR_materials_pbrSpecularGlossiness'))\r\n                this._extensionsRequired.push('KHR_materials_pbrSpecularGlossiness');\r\n            const ext = {};\r\n            ext.diffuseFactor = this._converter.toColorArray(data.color);\r\n            ext.diffuseFactor[3] = data.opacity;\r\n            if (data.map && includeMaps) {\r\n                const textureIndex = this.convertTexture(data.map);\r\n                if (textureIndex !== undefined)\r\n                    ext.diffuseTexture = { index: textureIndex };\r\n            }\r\n            ext.specularFactor = this._converter.toColorArray(data.specular);\r\n            ext.glossinessFactor = data.glossiness;\r\n            if (data.specularGlossinessMap && includeMaps) {\r\n                const textureIndex = this.convertTexture(data.specularGlossinessMap);\r\n                if (textureIndex !== undefined)\r\n                    ext.specularGlossinessTexture = { index: textureIndex };\r\n            }\r\n            materialDef.extensions = {\r\n                KHR_materials_pbrSpecularGlossiness: ext\r\n            };\r\n        }\r\n        else if (data instanceof viewer_shared_types_1.MaterialUnlitData) {\r\n            if (!this._extensionsUsed.includes('KHR_materials_unlit'))\r\n                this._extensionsUsed.push('KHR_materials_unlit');\r\n            if (!this._extensionsRequired.includes('KHR_materials_unlit'))\r\n                this._extensionsRequired.push('KHR_materials_unlit');\r\n            materialDef.pbrMetallicRoughness.baseColorFactor = this._converter.toColorArray(data.color);\r\n            materialDef.pbrMetallicRoughness.baseColorFactor[3] = data.opacity;\r\n            if (data.map && includeMaps) {\r\n                const textureIndex = this.convertTexture(data.map);\r\n                if (textureIndex !== undefined)\r\n                    materialDef.pbrMetallicRoughness.baseColorTexture = { index: textureIndex };\r\n            }\r\n            materialDef.extensions = {\r\n                KHR_materials_unlit: {}\r\n            };\r\n        }\r\n        else {\r\n            const standardMaterialData = data;\r\n            materialDef.pbrMetallicRoughness.baseColorFactor = this._converter.toColorArray(standardMaterialData.color);\r\n            materialDef.pbrMetallicRoughness.baseColorFactor[3] = standardMaterialData.opacity;\r\n            if (standardMaterialData.map && includeMaps) {\r\n                const textureIndex = this.convertTexture(standardMaterialData.map);\r\n                if (textureIndex !== undefined)\r\n                    materialDef.pbrMetallicRoughness.baseColorTexture = { index: textureIndex };\r\n            }\r\n            materialDef.pbrMetallicRoughness.metallicFactor = standardMaterialData.metalnessMap ? 1 : standardMaterialData.metalness;\r\n            materialDef.pbrMetallicRoughness.roughnessFactor = standardMaterialData.roughnessMap ? 1 : standardMaterialData.roughness;\r\n            if (standardMaterialData.metalnessRoughnessMap && includeMaps) {\r\n                const textureIndex = this.convertTexture(standardMaterialData.metalnessRoughnessMap);\r\n                if (textureIndex !== undefined)\r\n                    materialDef.pbrMetallicRoughness.metallicRoughnessTexture = { index: textureIndex };\r\n            }\r\n            else if (standardMaterialData.metalnessMap && standardMaterialData.roughnessMap && includeMaps) {\r\n                if (this._globalAccessObjects.combineTextures) {\r\n                    this._promises.push(new Promise((resolve, reject) => {\r\n                        try {\r\n                            // no support for combining textures\r\n                            if (!this._globalAccessObjects.combineTextures)\r\n                                return standardMaterialData.roughnessMap;\r\n                            this._globalAccessObjects.combineTextures(undefined, standardMaterialData.roughnessMap ? standardMaterialData.roughnessMap.image : undefined, standardMaterialData.metalnessMap ? standardMaterialData.metalnessMap.image : undefined)\r\n                                .then(imageData => {\r\n                                const m = (standardMaterialData.roughnessMap || standardMaterialData.metalnessMap);\r\n                                const mapData = new viewer_shared_types_1.MapData(imageData.image, {\r\n                                    blob: imageData.blob,\r\n                                    wrapS: m.wrapS,\r\n                                    wrapT: m.wrapT,\r\n                                    minFilter: m.minFilter,\r\n                                    magFilter: m.magFilter,\r\n                                    center: m.center,\r\n                                    color: m.color,\r\n                                    offset: m.offset,\r\n                                    repeat: m.repeat,\r\n                                    rotation: m.rotation,\r\n                                    texCoord: m.texCoord,\r\n                                    flipY: m.flipY\r\n                                });\r\n                                const textureIndex = this.convertTexture(mapData);\r\n                                if (textureIndex !== undefined)\r\n                                    materialDef.pbrMetallicRoughness.metallicRoughnessTexture = { index: textureIndex };\r\n                                resolve();\r\n                            })\r\n                                .catch(reject);\r\n                        }\r\n                        catch (e) {\r\n                            reject(e);\r\n                        }\r\n                    }));\r\n                }\r\n                else {\r\n                    // no support for combining textures\r\n                    const textureIndex = this.convertTexture(standardMaterialData.roughnessMap);\r\n                    if (textureIndex !== undefined)\r\n                        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = { index: textureIndex };\r\n                }\r\n            }\r\n            else if (standardMaterialData.metalnessMap && includeMaps) {\r\n                const textureIndex = this.convertTexture(standardMaterialData.metalnessMap);\r\n                if (textureIndex !== undefined)\r\n                    materialDef.pbrMetallicRoughness.metallicRoughnessTexture = { index: textureIndex };\r\n            }\r\n            else if (standardMaterialData.roughnessMap && includeMaps) {\r\n                const textureIndex = this.convertTexture(standardMaterialData.roughnessMap);\r\n                if (textureIndex !== undefined)\r\n                    materialDef.pbrMetallicRoughness.metallicRoughnessTexture = { index: textureIndex };\r\n            }\r\n        }\r\n        if (data.normalMap && includeMaps) {\r\n            const textureIndex = this.convertTexture(data.normalMap);\r\n            if (textureIndex !== undefined)\r\n                materialDef.normalTexture = { index: textureIndex };\r\n        }\r\n        if (data.aoMap && includeMaps) {\r\n            const textureIndex = this.convertTexture(data.aoMap);\r\n            if (textureIndex !== undefined)\r\n                materialDef.occlusionTexture = { index: textureIndex };\r\n        }\r\n        if (data.emissiveMap && includeMaps) {\r\n            const textureIndex = this.convertTexture(data.emissiveMap);\r\n            if (textureIndex !== undefined)\r\n                materialDef.emissiveTexture = { index: textureIndex };\r\n        }\r\n        if (data.emissiveness)\r\n            materialDef.emissiveFactor = this._converter.toColorArray(data.emissiveness);\r\n        materialDef.alphaMode = data.alphaMode.toUpperCase();\r\n        if (data.alphaMode === viewer_shared_types_1.MATERIAL_ALPHA.MASK)\r\n            materialDef.alphaCutoff = data.alphaCutoff;\r\n        materialDef.doubleSided = data.side === viewer_shared_types_1.MATERIAL_SIDE.DOUBLE;\r\n        this._content.materials.push(materialDef);\r\n        this._materialCache[data.id + '_' + data.version] = this._content.materials.length - 1;\r\n        return this._materialCache[data.id + '_' + data.version];\r\n    }\r\n    convertMesh(data) {\r\n        var _a;\r\n        if (!this._content.meshes)\r\n            this._content.meshes = [];\r\n        if (this._meshCache[data.id + '_' + data.version] !== undefined)\r\n            return this._meshCache[data.id + '_' + data.version];\r\n        const meshDef = {\r\n            primitives: [],\r\n            name: data.id\r\n        };\r\n        (_a = meshDef.primitives) === null || _a === void 0 ? void 0 : _a.push(this.convertPrimitive(data, data.primitive));\r\n        this._content.meshes.push(meshDef);\r\n        this._meshCache[data.id + '_' + data.version] = this._content.meshes.length - 1;\r\n        return this._meshCache[data.id + '_' + data.version];\r\n    }\r\n    convertNode(node) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.nodes)\r\n                this._content.nodes = [];\r\n            const nodeDef = {\r\n                name: this._convertForAR ? this._uuidGenerator.create() : node.name,\r\n            };\r\n            if (node.transformations.length > 0) {\r\n                let matrix = node.nodeMatrix;\r\n                if (node.nodeMatrix.filter(v => isNaN(v) || v === Infinity || v === -Infinity).length > 0)\r\n                    matrix = gl_matrix_1.mat4.create();\r\n                nodeDef.matrix = [matrix[0], matrix[1], matrix[2], matrix[3],\r\n                    matrix[4], matrix[5], matrix[6], matrix[7],\r\n                    matrix[8], matrix[9], matrix[10], matrix[11],\r\n                    matrix[12], matrix[13], matrix[14], matrix[15]];\r\n            }\r\n            for (let i = 0; i < node.data.length; i++) {\r\n                if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {\r\n                    if (this._convertForAR) {\r\n                        if (node.data[i].mode !== viewer_shared_types_1.PRIMITIVE_MODE.POINTS &&\r\n                            node.data[i].mode !== viewer_shared_types_1.PRIMITIVE_MODE.LINES &&\r\n                            node.data[i].mode !== viewer_shared_types_1.PRIMITIVE_MODE.LINE_LOOP &&\r\n                            node.data[i].mode !== viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP)\r\n                            nodeDef.mesh = this.convertMesh(node.data[i]);\r\n                    }\r\n                    else {\r\n                        nodeDef.mesh = this.convertMesh(node.data[i]);\r\n                    }\r\n                }\r\n                if (node.data[i] instanceof viewer_shared_types_1.AnimationData)\r\n                    this._animations.push(node.data[i]);\r\n            }\r\n            if (node.children.length > 0)\r\n                nodeDef.children = [];\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                if (node.children[i].visible === true) {\r\n                    if (this._viewport) {\r\n                        if (node.children[i].excludeViewports.includes(this._viewport))\r\n                            continue;\r\n                        if (node.children[i].restrictViewports.length > 0 && !node.children[i].restrictViewports.includes(this._viewport))\r\n                            continue;\r\n                    }\r\n                    const nodeId = yield this.convertNode(node.children[i]);\r\n                    if (nodeId !== -1)\r\n                        (_a = nodeDef.children) === null || _a === void 0 ? void 0 : _a.push(nodeId);\r\n                }\r\n            }\r\n            // remove children array if it is empty\r\n            if (nodeDef.children !== undefined && nodeDef.children.length === 0)\r\n                nodeDef.children = undefined;\r\n            if (performance.now() - this._progressTimer > this._progressUpdateLimit) {\r\n                this._progressTimer = performance.now();\r\n                const eventProgress = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CREATION, id: this._eventId, progress: (this._content.nodes.length / this._numberOfNodes) / 2, status: `GlTF conversion progress: ${this._content.nodes.length}/${this._numberOfNodes} nodes.` };\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventProgress);\r\n                yield new Promise(resolve => setTimeout(resolve, 0));\r\n            }\r\n            // if the node is empty, don't add it\r\n            if (nodeDef.camera === undefined && nodeDef.children === undefined && nodeDef.mesh === undefined && nodeDef.extensions === undefined && nodeDef.extras === undefined && nodeDef.skin === undefined)\r\n                return -1;\r\n            this._content.nodes.push(nodeDef);\r\n            this._nodes.push({\r\n                node,\r\n                id: this._content.nodes.length - 1\r\n            });\r\n            return this._content.nodes.length - 1;\r\n        });\r\n    }\r\n    convertPrimitive(geometryData, data) {\r\n        const primitiveDef = {\r\n            attributes: {},\r\n            mode: geometryData.mode\r\n        };\r\n        for (const a in data.attributes) {\r\n            if (data.attributes[a].array.length > 0) {\r\n                if (a.includes('COLOR')) {\r\n                    if (data.attributes[a].itemSize % 4 === 0) {\r\n                        primitiveDef.attributes[a] = this.convertAccessor(data.attributes[a]);\r\n                    }\r\n                    else if (data.attributes[a].itemSize % 3 === 0) {\r\n                        const oldAttributeData = data.attributes[a];\r\n                        const newArray = new Float32Array((oldAttributeData.array.length / 3) * 4);\r\n                        let counter = 0;\r\n                        for (let i = 0; i < newArray.length; i += 4) {\r\n                            newArray[i] = oldAttributeData.array[counter] / (oldAttributeData.elementBytes === 1 ? 255.0 : 1.0);\r\n                            newArray[i + 1] = oldAttributeData.array[counter + 1] / (oldAttributeData.elementBytes === 1 ? 255.0 : 1.0);\r\n                            newArray[i + 2] = oldAttributeData.array[counter + 2] / (oldAttributeData.elementBytes === 1 ? 255.0 : 1.0);\r\n                            newArray[i + 3] = 1.0;\r\n                            counter += 3;\r\n                        }\r\n                        primitiveDef.attributes[a] = this.convertAccessor(new viewer_shared_types_1.AttributeData(newArray, 4, 4 * 4, oldAttributeData.byteOffset, 4, oldAttributeData.normalized, oldAttributeData.count, oldAttributeData.min, oldAttributeData.max, oldAttributeData.byteStride));\r\n                    }\r\n                }\r\n                else {\r\n                    primitiveDef.attributes[a] = this.convertAccessor(data.attributes[a]);\r\n                }\r\n            }\r\n        }\r\n        if (data.indices)\r\n            primitiveDef.indices = this.convertAccessor(data.indices);\r\n        if (geometryData.material) {\r\n            const k = Object.keys(primitiveDef.attributes).find(k => k.includes('TEXCOORD'));\r\n            primitiveDef.material = this.convertMaterial(geometryData.material, !!k);\r\n        }\r\n        return primitiveDef;\r\n    }\r\n    convertTexture(data) {\r\n        if (!this._content.textures)\r\n            this._content.textures = [];\r\n        const imageIndex = this.convertImage(data);\r\n        if (imageIndex === undefined)\r\n            return;\r\n        const textureDef = {\r\n            source: imageIndex\r\n        };\r\n        // TODO samplers\r\n        this._content.textures.push(textureDef);\r\n        return this._content.textures.length - 1;\r\n    }\r\n    getComponentType(array) {\r\n        switch (true) {\r\n            case array instanceof Int8Array:\r\n                return 5120;\r\n            case array instanceof Uint8Array:\r\n                return 5121;\r\n            case array instanceof Int16Array:\r\n                return 5122;\r\n            case array instanceof Uint16Array:\r\n                return 5123;\r\n            case array instanceof Uint32Array:\r\n                return 5125;\r\n            default:\r\n                return 5126;\r\n        }\r\n    }\r\n    getMinMax(data) {\r\n        const output = {\r\n            min: new Array(data.itemSize).fill(Number.POSITIVE_INFINITY),\r\n            max: new Array(data.itemSize).fill(Number.NEGATIVE_INFINITY)\r\n        };\r\n        for (let i = 0; i < data.count; i++) {\r\n            for (let a = 0; a < data.itemSize; a++) {\r\n                let value = 0;\r\n                if (data.itemSize > 4) {\r\n                    // no support for interleaved data for itemSize > 4\r\n                    value = data.array[i * data.itemSize + a];\r\n                }\r\n                else {\r\n                    if (a === 0)\r\n                        value = data.array[i * data.itemSize];\r\n                    else if (a === 1)\r\n                        value = data.array[i * data.itemSize + 1];\r\n                    else if (a === 2)\r\n                        value = data.array[i * data.itemSize + 2];\r\n                    else if (a === 3)\r\n                        value = data.array[i * data.itemSize + 3];\r\n                }\r\n                output.min[a] = Math.min(output.min[a], value);\r\n                output.max[a] = Math.max(output.max[a], value);\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n    getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\r\n        const paddedLength = Math.ceil(arrayBuffer.byteLength / 4) * 4;\r\n        if (paddedLength !== arrayBuffer.byteLength) {\r\n            const array = new Uint8Array(paddedLength);\r\n            array.set(new Uint8Array(arrayBuffer));\r\n            if (paddingByte !== 0) {\r\n                for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\r\n                    array[i] = paddingByte;\r\n                }\r\n            }\r\n            return array.buffer;\r\n        }\r\n        return arrayBuffer;\r\n    }\r\n    getType(itemSize) {\r\n        switch (itemSize) {\r\n            case 1:\r\n                return 'SCALAR';\r\n            case 2:\r\n                return 'VEC2';\r\n            case 3:\r\n                return 'VEC3';\r\n            case 4:\r\n                return 'VEC4';\r\n            case 9:\r\n                return 'MAT3';\r\n            case 18:\r\n                return 'MAT4';\r\n            default:\r\n                return 'VEC3';\r\n        }\r\n    }\r\n    reset() {\r\n        this._animations = [];\r\n        this._buffers = [];\r\n        this._byteOffset = 0;\r\n        this._content = {\r\n            asset: {\r\n                copyright: '2023 (c) ShapeDiver',\r\n                generator: 'ShapeDiverViewer@' + viewer_shared_build_data_1.build_data.build_version,\r\n                version: '2.0',\r\n                extensions: {}\r\n            },\r\n        };\r\n        this._extensionsRequired = [];\r\n        this._extensionsUsed = [];\r\n        this._imageCache = {};\r\n        this._materialCache = {};\r\n        this._meshCache = {};\r\n        this._nodes = [];\r\n        this._promises = [];\r\n        this._convertForAR = false;\r\n        this._viewport = undefined;\r\n    }\r\n    stringToArrayBuffer(text) {\r\n        if (window.TextEncoder !== undefined) {\r\n            return new TextEncoder().encode(text).buffer;\r\n        }\r\n        const array = new Uint8Array(new ArrayBuffer(text.length));\r\n        for (let i = 0, il = text.length; i < il; i++) {\r\n            const value = text.charCodeAt(i);\r\n            // Replacing multi-byte character with space(0x20).\r\n            array[i] = value > 0xFF ? 0x20 : value;\r\n        }\r\n        return array.buffer;\r\n    }\r\n}\r\nexports.GLTFConverter = GLTFConverter;\r\n// #endregion Classes (1)\r\n// #region Enums (1)\r\nvar GLTF_EXTENSIONS;\r\n(function (GLTF_EXTENSIONS) {\r\n    GLTF_EXTENSIONS[\"KHR_BINARY_GLTF\"] = \"KHR_binary_glTF\";\r\n    GLTF_EXTENSIONS[\"KHR_MATERIALS_PBRSPECULARGLOSSINESS\"] = \"KHR_materials_pbrSpecularGlossiness\";\r\n    GLTF_EXTENSIONS[\"KHR_MATERIALS_UNLIT\"] = \"KHR_materials_unlit\";\r\n})(GLTF_EXTENSIONS = exports.GLTF_EXTENSIONS || (exports.GLTF_EXTENSIONS = {}));\r\n// #endregion Enums (1)\r\n//# sourceMappingURL=GLTFConverter.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GLTFConverter = void 0;\r\nconst GLTFConverter_1 = require(\"./GLTFConverter\");\r\nObject.defineProperty(exports, \"GLTFConverter\", { enumerable: true, get: function () { return GLTFConverter_1.GLTFConverter; } });\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HTMLElementAnchorEngine = void 0;\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_shared_math_1 = require(\"@shapediver/viewer.shared.math\");\r\nclass HTMLElementAnchorEngine {\r\n    constructor() {\r\n        // #region Properties (4)\r\n        this._converter = viewer_shared_services_1.Converter.instance;\r\n        this._inputValidator = viewer_shared_services_1.InputValidator.instance;\r\n        this._logger = viewer_shared_services_1.Logger.instance;\r\n        // #endregion Public Methods (1)\r\n    }\r\n    // #endregion Properties (4)\r\n    // #region Public Static Accessors (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Accessors (1)\r\n    // #region Public Methods (1)\r\n    /**\r\n     * Load the material content into a scene graph node.\r\n     *\r\n     * @param content the material content\r\n     * @returns the scene graph node\r\n     */\r\n    loadContent(content) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const node = new viewer_shared_node_tree_1.TreeNode('htmlElementAnchors');\r\n                if (content.format === 'tag2d') {\r\n                    const data = content.data;\r\n                    data.forEach((element) => {\r\n                        // we need a location and a text, otherwise this doesn't make sense\r\n                        if (!element.location || !element.text) {\r\n                            this._logger.warn('HTMLElementAnchorEngine.load: One of the specified Tag2D elements did not have all necessary properties.');\r\n                            return;\r\n                        }\r\n                        const cleanedText = this._inputValidator.sanitize(element.text);\r\n                        node.data.push(new viewer_shared_types_1.HTMLElementAnchorTextData({\r\n                            location: this._converter.toVec3(element.location),\r\n                            data: { color: element.color || '#000000', text: cleanedText }\r\n                        }));\r\n                    });\r\n                }\r\n                else if (content.format === 'anchor') {\r\n                    const data = content.data;\r\n                    data.forEach((element) => {\r\n                        if (!element.location || !element.data) {\r\n                            this._logger.warn('HTMLElementAnchorEngine.load: One of the specified Anchor elements did not have all necessary properties.');\r\n                            return;\r\n                        }\r\n                        let position;\r\n                        if (element.data.position)\r\n                            position = {\r\n                                vertical: element.data.position.vertical,\r\n                                horizontal: element.data.position.horizontal\r\n                            };\r\n                        let intersectionTarget;\r\n                        if (element.intersectionTarget) {\r\n                            if (typeof element.intersectionTarget === 'string' || Array.isArray(element.intersectionTarget)) {\r\n                                intersectionTarget = element.intersectionTarget;\r\n                            }\r\n                            else if (element.intersectionTarget.min && element.intersectionTarget.max) {\r\n                                intersectionTarget = new viewer_shared_math_1.Box(this._converter.toVec3(element.intersectionTarget.min), this._converter.toVec3(element.intersectionTarget.max));\r\n                            }\r\n                        }\r\n                        if (!element.format || (element.format === 'text')) {\r\n                            if (!element.data.text) {\r\n                                this._logger.warn('HTMLElementAnchorEngine.load: The text property for an Anchor element is missing.');\r\n                                return;\r\n                            }\r\n                            const textData = element.data;\r\n                            const cleanedText = this._inputValidator.sanitize(textData.text);\r\n                            node.data.push(new viewer_shared_types_1.HTMLElementAnchorTextData({\r\n                                location: this._converter.toVec3(element.location),\r\n                                data: {\r\n                                    color: textData.color || '#000000',\r\n                                    text: cleanedText,\r\n                                    hidden: textData.hidden,\r\n                                    textAlign: textData.textAlign,\r\n                                    position\r\n                                },\r\n                                hideable: element.hideable,\r\n                                viewports: element.viewports,\r\n                                intersectionTarget\r\n                            }));\r\n                        }\r\n                        else if (element.format === 'image') {\r\n                            if (!element.data.src || !element.data.width || !element.data.height || !element.data.alt) {\r\n                                this._logger.warn('HTMLElementAnchorEngine.load: One of the specified Anchor elements did not have all necessary properties.');\r\n                                return;\r\n                            }\r\n                            const imageData = element.data;\r\n                            node.data.push(new viewer_shared_types_1.HTMLElementAnchorImageData({\r\n                                location: this._converter.toVec3(element.location),\r\n                                data: {\r\n                                    alt: imageData.alt,\r\n                                    height: typeof imageData.height === 'string' ? +imageData.height : imageData.height,\r\n                                    width: typeof imageData.width === 'string' ? +imageData.width : imageData.width,\r\n                                    src: imageData.src,\r\n                                    hidden: imageData.hidden,\r\n                                    position\r\n                                },\r\n                                hideable: element.hideable,\r\n                                viewports: element.viewports,\r\n                                intersectionTarget\r\n                            }));\r\n                        }\r\n                        this._logger.warn(`HTMLElementAnchorEngine.load: The Anchor does not have a recognized format: ${element.format}`);\r\n                    });\r\n                }\r\n                return node;\r\n            }\r\n            catch (e) {\r\n                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('HTMLElementAnchorEngine.load: Loading of anchors failed.');\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.HTMLElementAnchorEngine = HTMLElementAnchorEngine;\r\n//# sourceMappingURL=HTMLElementAnchorEngine.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HTMLElementAnchorEngine = void 0;\r\nconst HTMLElementAnchorEngine_1 = require(\"./HTMLElementAnchorEngine\");\r\nObject.defineProperty(exports, \"HTMLElementAnchorEngine\", { enumerable: true, get: function () { return HTMLElementAnchorEngine_1.HTMLElementAnchorEngine; } });\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MaterialEngine = void 0;\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst materialDatabase_1 = require(\"./materialDatabase\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\n/* eslint-disable no-prototype-builtins */\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nclass MaterialEngine {\r\n    constructor() {\r\n        // #region Properties (4)\r\n        this._converter = viewer_shared_services_1.Converter.instance;\r\n        this._httpClient = viewer_shared_services_1.HttpClient.instance;\r\n        this._logger = viewer_shared_services_1.Logger.instance;\r\n        // #endregion Private Methods (4)\r\n    }\r\n    // #endregion Properties (4)\r\n    // #region Public Static Getters And Setters (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Getters And Setters (1)\r\n    // #region Public Methods (12)\r\n    /**\r\n     * Create a material data based on the material properties\r\n     *\r\n     * @param materialProperties\r\n     * @returns\r\n     */\r\n    createMaterialData(materialProperties) {\r\n        const materialType = materialProperties.type || viewer_shared_types_1.MATERIAL_TYPE.STANDARD;\r\n        switch (materialType) {\r\n            case viewer_shared_types_1.MATERIAL_TYPE.SPECULAR_GLOSSINESS:\r\n                return new viewer_shared_types_1.MaterialSpecularGlossinessData(materialProperties);\r\n            case viewer_shared_types_1.MATERIAL_TYPE.UNLIT:\r\n                return new viewer_shared_types_1.MaterialUnlitData(materialProperties);\r\n            case viewer_shared_types_1.MATERIAL_TYPE.GEM:\r\n                return new viewer_shared_types_1.MaterialGemData(materialProperties);\r\n            default:\r\n                return new viewer_shared_types_1.MaterialStandardData(materialProperties);\r\n        }\r\n    }\r\n    createMaterialDataFromDefinition(definition) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const materialType = definition.type || viewer_shared_types_1.MATERIAL_TYPE.STANDARD;\r\n            const promises = [];\r\n            const abstractProperties = {};\r\n            abstractProperties.alphaCutoff = definition.alphaCutoff;\r\n            promises.push(this.loadMapFromDefinition(definition.alphaMap).then(map => {\r\n                if (map)\r\n                    abstractProperties.alphaMap = map;\r\n                return map;\r\n            }));\r\n            abstractProperties.alphaMode = definition.alphaMode;\r\n            promises.push(this.loadMapFromDefinition(definition.aoMap).then(map => {\r\n                if (map)\r\n                    abstractProperties.aoMap = map;\r\n                return map;\r\n            }));\r\n            abstractProperties.aoMapIntensity = definition.aoMapIntensity;\r\n            promises.push(this.loadMapFromDefinition(definition.bumpMap).then(map => {\r\n                if (map)\r\n                    abstractProperties.bumpMap = map;\r\n                return map;\r\n            }));\r\n            abstractProperties.bumpScale = definition.bumpScale;\r\n            abstractProperties.color = definition.color ? definition.color : undefined;\r\n            abstractProperties.depthTest = definition.depthTest;\r\n            abstractProperties.depthWrite = definition.depthWrite;\r\n            promises.push(this.loadMapFromDefinition(definition.emissiveMap).then(map => {\r\n                if (map)\r\n                    abstractProperties.emissiveMap = map;\r\n                return map;\r\n            }));\r\n            abstractProperties.emissiveness = definition.emissiveness ? definition.emissiveness : undefined;\r\n            promises.push(this.loadMapFromDefinition(definition.map).then(map => {\r\n                if (map)\r\n                    abstractProperties.map = map;\r\n                return map;\r\n            }));\r\n            abstractProperties.name = definition.name;\r\n            promises.push(this.loadMapFromDefinition(definition.normalMap).then(map => {\r\n                if (map)\r\n                    abstractProperties.normalMap = map;\r\n                return map;\r\n            }));\r\n            abstractProperties.normalScale = definition.normalScale;\r\n            abstractProperties.opacity = definition.opacity;\r\n            abstractProperties.shading = definition.shading;\r\n            abstractProperties.side = definition.side;\r\n            abstractProperties.transparent = definition.transparent;\r\n            abstractProperties.type = materialType;\r\n            switch (materialType) {\r\n                case viewer_shared_types_1.MATERIAL_TYPE.SPECULAR_GLOSSINESS:\r\n                    {\r\n                        const specularGlossinessProperties = abstractProperties;\r\n                        const specularGlossinessDefinition = definition;\r\n                        specularGlossinessProperties.envMap = specularGlossinessDefinition.envMap;\r\n                        specularGlossinessProperties.glossiness = specularGlossinessDefinition.glossiness;\r\n                        specularGlossinessProperties.specular = specularGlossinessDefinition.specular;\r\n                        if (specularGlossinessDefinition.specularGlossinessMap) {\r\n                            promises.push(this.loadMapFromDefinition(specularGlossinessDefinition.specularGlossinessMap).then(map => {\r\n                                if (map)\r\n                                    specularGlossinessProperties.specularGlossinessMap = map;\r\n                                return map;\r\n                            }));\r\n                        }\r\n                        else {\r\n                            promises.push(this.loadMapFromDefinition(specularGlossinessDefinition.specularMap).then(map => {\r\n                                if (map)\r\n                                    specularGlossinessProperties.specularMap = map;\r\n                                return map;\r\n                            }));\r\n                            promises.push(this.loadMapFromDefinition(specularGlossinessDefinition.glossinessMap).then(map => {\r\n                                if (map)\r\n                                    specularGlossinessProperties.glossinessMap = map;\r\n                                return map;\r\n                            }));\r\n                        }\r\n                        yield Promise.all(promises);\r\n                        return new viewer_shared_types_1.MaterialSpecularGlossinessData(specularGlossinessProperties);\r\n                    }\r\n                case viewer_shared_types_1.MATERIAL_TYPE.UNLIT:\r\n                    {\r\n                        const unlitProperties = abstractProperties;\r\n                        const unlitDefinition = definition;\r\n                        unlitProperties.envMap = unlitDefinition.envMap;\r\n                        yield Promise.all(promises);\r\n                        return new viewer_shared_types_1.MaterialUnlitData(unlitProperties);\r\n                    }\r\n                case viewer_shared_types_1.MATERIAL_TYPE.GEM:\r\n                    {\r\n                        const gemProperties = abstractProperties;\r\n                        const gemDefinition = definition;\r\n                        gemProperties.brightness = gemDefinition.brightness;\r\n                        gemProperties.center = gemDefinition.center;\r\n                        gemProperties.colorTransferBegin = gemDefinition.colorTransferBegin;\r\n                        gemProperties.colorTransferEnd = gemDefinition.colorTransferEnd;\r\n                        gemProperties.contrast = gemDefinition.contrast;\r\n                        gemProperties.dispersion = gemDefinition.dispersion;\r\n                        gemProperties.envMap = gemDefinition.envMap;\r\n                        gemProperties.gamma = gemDefinition.gamma;\r\n                        promises.push(this.loadMapFromDefinition(gemDefinition.impurityMap).then(map => {\r\n                            if (map)\r\n                                gemProperties.impurityMap = map;\r\n                            return map;\r\n                        }));\r\n                        gemProperties.impurityScale = gemDefinition.impurityScale;\r\n                        gemProperties.radius = gemDefinition.radius;\r\n                        gemProperties.refractionIndex = gemDefinition.refractionIndex;\r\n                        promises.push(this.loadMapFromDefinition(gemDefinition.sphericalNormalMap).then(map => {\r\n                            if (map)\r\n                                gemProperties.sphericalNormalMap = map;\r\n                            return map;\r\n                        }));\r\n                        gemProperties.tracingDepth = gemDefinition.tracingDepth;\r\n                        gemProperties.tracingOpacity = gemDefinition.tracingOpacity;\r\n                        yield Promise.all(promises);\r\n                        return new viewer_shared_types_1.MaterialGemData(gemProperties);\r\n                    }\r\n                default:\r\n                    {\r\n                        const standardProperties = abstractProperties;\r\n                        const standardDefinition = definition;\r\n                        standardProperties.attenuationColor = standardDefinition.attenuationColor;\r\n                        standardProperties.attenuationDistance = standardDefinition.attenuationDistance;\r\n                        standardProperties.clearcoat = standardDefinition.clearcoat;\r\n                        promises.push(this.loadMapFromDefinition(standardDefinition.clearcoatMap).then(map => {\r\n                            if (map)\r\n                                standardProperties.clearcoatMap = map;\r\n                            return map;\r\n                        }));\r\n                        promises.push(this.loadMapFromDefinition(standardDefinition.clearcoatNormalMap).then(map => {\r\n                            if (map)\r\n                                standardProperties.clearcoatNormalMap = map;\r\n                            return map;\r\n                        }));\r\n                        standardProperties.clearcoatRoughness = standardDefinition.clearcoatRoughness;\r\n                        promises.push(this.loadMapFromDefinition(standardDefinition.clearcoatRoughnessMap).then(map => {\r\n                            if (map)\r\n                                standardProperties.clearcoatRoughnessMap = map;\r\n                            return map;\r\n                        }));\r\n                        standardProperties.displacementBias = standardDefinition.displacementBias;\r\n                        promises.push(this.loadMapFromDefinition(standardDefinition.displacementMap).then(map => {\r\n                            if (map)\r\n                                standardProperties.displacementMap = map;\r\n                            return map;\r\n                        }));\r\n                        standardProperties.displacementScale = standardDefinition.displacementScale;\r\n                        standardProperties.envMap = standardDefinition.envMap;\r\n                        standardProperties.ior = standardDefinition.ior;\r\n                        standardProperties.metalness = standardDefinition.metalness;\r\n                        if (standardDefinition.metalnessRoughnessMap) {\r\n                            promises.push(this.loadMapFromDefinition(standardDefinition.metalnessMap).then(map => {\r\n                                if (map)\r\n                                    standardProperties.metalnessMap = map;\r\n                                return map;\r\n                            }));\r\n                        }\r\n                        else {\r\n                            promises.push(this.loadMapFromDefinition(standardDefinition.metalnessMap).then(map => {\r\n                                if (map)\r\n                                    standardProperties.metalnessMap = map;\r\n                                return map;\r\n                            }));\r\n                            promises.push(this.loadMapFromDefinition(standardDefinition.roughnessMap).then(map => {\r\n                                if (map)\r\n                                    standardProperties.roughnessMap = map;\r\n                                return map;\r\n                            }));\r\n                        }\r\n                        standardProperties.roughness = standardDefinition.roughness;\r\n                        standardProperties.sheen = standardDefinition.sheen;\r\n                        standardProperties.sheenColor = standardDefinition.sheenColor;\r\n                        promises.push(this.loadMapFromDefinition(standardDefinition.sheenColorMap).then(map => {\r\n                            if (map)\r\n                                standardProperties.sheenColorMap = map;\r\n                            return map;\r\n                        }));\r\n                        standardProperties.sheenRoughness = standardDefinition.sheenRoughness;\r\n                        promises.push(this.loadMapFromDefinition(standardDefinition.sheenRoughnessMap).then(map => {\r\n                            if (map)\r\n                                standardProperties.sheenRoughnessMap = map;\r\n                            return map;\r\n                        }));\r\n                        standardProperties.specularColor = standardDefinition.specularColor;\r\n                        promises.push(this.loadMapFromDefinition(standardDefinition.specularColorMap).then(map => {\r\n                            if (map)\r\n                                standardProperties.specularColorMap = map;\r\n                            return map;\r\n                        }));\r\n                        standardProperties.specularIntensity = standardDefinition.specularIntensity;\r\n                        promises.push(this.loadMapFromDefinition(standardDefinition.specularIntensityMap).then(map => {\r\n                            if (map)\r\n                                standardProperties.specularIntensityMap = map;\r\n                            return map;\r\n                        }));\r\n                        standardProperties.thickness = standardDefinition.thickness;\r\n                        promises.push(this.loadMapFromDefinition(standardDefinition.thicknessMap).then(map => {\r\n                            if (map)\r\n                                standardProperties.thicknessMap = map;\r\n                            return map;\r\n                        }));\r\n                        standardProperties.transmission = standardDefinition.transmission;\r\n                        promises.push(this.loadMapFromDefinition(standardDefinition.transmissionMap).then(map => {\r\n                            if (map)\r\n                                standardProperties.transmissionMap = map;\r\n                            return map;\r\n                        }));\r\n                        yield Promise.all(promises);\r\n                        return new viewer_shared_types_1.MaterialStandardData(standardProperties);\r\n                    }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n       * Load the material content into a scene graph node.\r\n       *\r\n       * @param content the material content\r\n       * @returns the scene graph node\r\n       */\r\n    loadContent(content) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const node = new viewer_shared_node_tree_1.TreeNode(content.name || 'material');\r\n            if (!content)\r\n                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('MaterialEngine.loadContent: Invalid content was provided to material engine.');\r\n            let material = new viewer_shared_types_1.MaterialStandardData();\r\n            if (content.data) {\r\n                const data = content.data;\r\n                let presetData;\r\n                if (data.materialpreset)\r\n                    presetData = this.loadPresetMaterialDefinition(data.materialpreset);\r\n                if (data.materialType && data.materialType !== 'standard') {\r\n                    // gem material https://shapediver.atlassian.net/browse/SS-2514\r\n                }\r\n                else {\r\n                    if (data.version) {\r\n                        if (data.version === '1.0') {\r\n                            material = yield this.loadMaterialV3(this.loadMaterialDefinitionV1(data, presetData));\r\n                        }\r\n                        else if (data.version === '2.0') {\r\n                            material = yield this.loadMaterialV3(this.loadMaterialDefinitionV2(data, presetData));\r\n                        }\r\n                        else if (data.version === '3.0') {\r\n                            material = yield this.loadMaterialV3(this.loadMaterialDefinitionV3(data, presetData));\r\n                        }\r\n                        else {\r\n                            throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('MaterialEngine.loadContent: Material data version not supported.');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('MaterialEngine.loadContent: No material data was provided to material engine.');\r\n            }\r\n            node.data.push(material);\r\n            return node;\r\n        });\r\n    }\r\n    loadMap(url, id) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let response;\r\n            if (!id) {\r\n                response = yield this._httpClient.loadTexture(url);\r\n            }\r\n            else {\r\n                response = yield this._httpClient.loadTexture('https://viewer.shapediver.com/v2/materials/1024/' + id + '/' + url);\r\n            }\r\n            if (!response)\r\n                return;\r\n            if (typeof window !== 'undefined') {\r\n                const image = yield viewer_shared_services_1.Converter.instance.responseToImage(response);\r\n                return new viewer_shared_types_1.MapData(image, { blob: response.data.blob });\r\n            }\r\n            else {\r\n                return new viewer_shared_types_1.MapData(response.data.buffer, { blob: response.data.blob });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Load a map from a definition.\r\n     *\r\n     * @param definition\r\n     * @returns\r\n     */\r\n    loadMapFromDefinition(definition) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!definition)\r\n                return undefined;\r\n            if (typeof definition === 'string') {\r\n                return this.loadMap(definition);\r\n            }\r\n            else if (definition.image) {\r\n                if (typeof definition.image === 'string') {\r\n                    return this.loadMapWithProperties({\r\n                        href: definition.image,\r\n                        wrapS: definition.wrapS,\r\n                        wrapT: definition.wrapT,\r\n                        center: definition.center,\r\n                        color: definition.color ? this._converter.toColorArray(definition.color) : undefined,\r\n                        offset: definition.offset,\r\n                        repeat: definition.repeat,\r\n                        rotation: definition.rotation\r\n                    });\r\n                }\r\n                else {\r\n                    return new viewer_shared_types_1.MapData(definition.image);\r\n                }\r\n            }\r\n            return;\r\n        });\r\n    }\r\n    loadMapWithProperties(texture) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const response = yield this._httpClient.loadTexture(texture.href);\r\n            if (!response)\r\n                return;\r\n            const wrapS = texture.wrapS === 1 ? viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE : texture.wrapS === 2 ? viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT : viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT;\r\n            const wrapT = texture.wrapT === 1 ? viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE : texture.wrapT === 2 ? viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT : viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT;\r\n            const center = texture.center ? gl_matrix_1.vec2.fromValues(texture.center[0], texture.center[1]) : gl_matrix_1.vec2.fromValues(0, 0);\r\n            const color = texture.color ? gl_matrix_1.vec4.fromValues(texture.color[0] / 255, texture.color[1] / 255, texture.color[2] / 255, texture.color[3] / 255) : gl_matrix_1.vec4.fromValues(1, 1, 1, 1);\r\n            const offset = texture.offset ? gl_matrix_1.vec2.fromValues(texture.offset[0], texture.offset[1]) : gl_matrix_1.vec2.fromValues(0, 0);\r\n            const repeat = texture.repeat ? gl_matrix_1.vec2.fromValues(texture.repeat[0], texture.repeat[1]) : gl_matrix_1.vec2.fromValues(1, 1);\r\n            if (typeof window !== 'undefined') {\r\n                const image = yield viewer_shared_services_1.Converter.instance.responseToImage(response);\r\n                return new viewer_shared_types_1.MapData(image, { blob: response.data.blob, wrapS, wrapT, minFilter: viewer_shared_types_1.TEXTURE_FILTERING.LINEAR_MIPMAP_LINEAR, magFilter: viewer_shared_types_1.TEXTURE_FILTERING.LINEAR, center, color, offset, repeat, rotation: texture.rotation || 0 });\r\n            }\r\n            else {\r\n                return new viewer_shared_types_1.MapData(response.data.buffer, { blob: response.data.blob, wrapS, wrapT, minFilter: viewer_shared_types_1.TEXTURE_FILTERING.LINEAR_MIPMAP_LINEAR, magFilter: viewer_shared_types_1.TEXTURE_FILTERING.LINEAR, center, color, offset, repeat, rotation: texture.rotation || 0 });\r\n            }\r\n        });\r\n    }\r\n    loadMaterialDefinitionV1(data, presetData = {}) {\r\n        // ambient is ignored\r\n        if (data.color) {\r\n            presetData.color = this.multiplyColors(data.color, presetData.color);\r\n        }\r\n        else if (data.diffuse) {\r\n            // multiply color with diffuse\r\n            presetData.color = this.multiplyColors(data.diffuse, presetData.color);\r\n        }\r\n        // emission is ignored\r\n        // specular is ignored\r\n        if (data.shine || data.shine === 0) {\r\n            presetData.metalness = Math.min(1, data.shine);\r\n            presetData.roughness = 1 - (Math.min(1, data.shine));\r\n        }\r\n        if (data.hasOwnProperty('transparency'))\r\n            presetData.transparency = data.transparency;\r\n        if (data.bitmaptexture)\r\n            presetData.bitmaptexture = {\r\n                href: data.bitmaptexture\r\n            };\r\n        if (data.bumptexture)\r\n            presetData.bumptexture = {\r\n                href: data.bumptexture\r\n            };\r\n        if (data.transparencytexture)\r\n            presetData.transparencytexture = {\r\n                href: data.transparencytexture\r\n            };\r\n        return presetData;\r\n    }\r\n    loadMaterialDefinitionV2(data, presetData = {}) {\r\n        // ambient is ignored\r\n        if (data.color)\r\n            presetData.color = this.multiplyColors(data.color, presetData.color);\r\n        presetData.side = data.side;\r\n        if (data.metalness || data.metalness === 0)\r\n            presetData.metalness = data.metalness;\r\n        if (data.roughness || data.roughness === 0)\r\n            presetData.roughness = data.roughness;\r\n        if (data.hasOwnProperty('transparency'))\r\n            presetData.transparency = data.transparency;\r\n        if (data.alphaThreshold || data.alphaThreshold === 0)\r\n            presetData.alphaThreshold = data.alphaThreshold;\r\n        if (data.bitmaptexture)\r\n            presetData.bitmaptexture = {\r\n                href: data.bitmaptexture\r\n            };\r\n        if (data.metalnesstexture)\r\n            presetData.metalnesstexture = {\r\n                href: data.metalnesstexture\r\n            };\r\n        if (data.roughnesstexture)\r\n            presetData.roughnesstexture = {\r\n                href: data.roughnesstexture\r\n            };\r\n        if (data.bumptexture)\r\n            presetData.bumptexture = {\r\n                href: data.bumptexture\r\n            };\r\n        if (data.normaltexture)\r\n            presetData.normaltexture = {\r\n                href: data.normaltexture\r\n            };\r\n        if (data.transparencytexture)\r\n            presetData.transparencytexture = {\r\n                href: data.transparencytexture\r\n            };\r\n        return presetData;\r\n    }\r\n    loadMaterialDefinitionV3(data, presetData = {}) {\r\n        // ambient is ignored\r\n        if (data.color)\r\n            presetData.color = this.multiplyColors(data.color, presetData.color);\r\n        presetData.side = data.side;\r\n        if (data.metalness || data.metalness === 0)\r\n            presetData.metalness = data.metalness;\r\n        if (data.roughness || data.roughness === 0)\r\n            presetData.roughness = data.roughness;\r\n        if (data.hasOwnProperty('transparency'))\r\n            presetData.transparency = data.transparency;\r\n        if (data.alphaThreshold || data.alphaThreshold === 0)\r\n            presetData.alphaThreshold = data.alphaThreshold;\r\n        if (data.bumpAmplitude || data.bumpAmplitude === 0)\r\n            presetData.bumpAmplitude = data.bumpAmplitude;\r\n        if (data.bitmaptexture)\r\n            presetData.bitmaptexture = data.bitmaptexture;\r\n        if (data.metalnesstexture)\r\n            presetData.metalnesstexture = data.metalnesstexture;\r\n        if (data.roughnesstexture)\r\n            presetData.roughnesstexture = data.roughnesstexture;\r\n        if (data.bumptexture)\r\n            presetData.bumptexture = data.bumptexture;\r\n        if (data.normaltexture)\r\n            presetData.normaltexture = data.normaltexture;\r\n        if (data.transparencytexture)\r\n            presetData.transparencytexture = data.transparencytexture;\r\n        // line material https://shapediver.atlassian.net/browse/SS-2272\r\n        return presetData;\r\n    }\r\n    loadMaterialV3(data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const material = new viewer_shared_types_1.MaterialStandardData();\r\n            const promises = [];\r\n            // ambient is ignored\r\n            if (data.color)\r\n                material.color = data.color;\r\n            material.side = data.side === 'front' ? viewer_shared_types_1.MATERIAL_SIDE.FRONT : data.side === 'back' ? viewer_shared_types_1.MATERIAL_SIDE.BACK : viewer_shared_types_1.MATERIAL_SIDE.DOUBLE;\r\n            if (data.metalness || data.metalness === 0)\r\n                material.metalness = data.metalness;\r\n            if (data.roughness || data.roughness === 0)\r\n                material.roughness = data.roughness;\r\n            if (data.hasOwnProperty('transparency'))\r\n                material.opacity = 1 - data.transparency;\r\n            if (data.alphaThreshold || data.alphaThreshold === 0)\r\n                material.alphaCutoff = data.alphaThreshold;\r\n            if (data.bumpAmplitude || data.bumpAmplitude === 0)\r\n                material.bumpScale = data.bumpAmplitude;\r\n            if (data.bitmaptexture) {\r\n                promises.push(this.loadMapWithProperties(data.bitmaptexture).then(map => {\r\n                    if (map)\r\n                        material.map = map;\r\n                    return map;\r\n                }));\r\n            }\r\n            if (data.metalnesstexture) {\r\n                promises.push(this.loadMapWithProperties(data.metalnesstexture).then(map => {\r\n                    if (map)\r\n                        material.metalnessMap = map;\r\n                    return map;\r\n                }));\r\n            }\r\n            if (data.roughnesstexture) {\r\n                promises.push(this.loadMapWithProperties(data.roughnesstexture).then(map => {\r\n                    if (map)\r\n                        material.roughnessMap = map;\r\n                    return map;\r\n                }));\r\n            }\r\n            if (data.bumptexture) {\r\n                promises.push(this.loadMapWithProperties(data.bumptexture).then(map => {\r\n                    if (map)\r\n                        material.bumpMap = map;\r\n                    return map;\r\n                }));\r\n            }\r\n            if (data.normaltexture) {\r\n                promises.push(this.loadMapWithProperties(data.normaltexture).then(map => {\r\n                    if (map)\r\n                        material.normalMap = map;\r\n                    return map;\r\n                }));\r\n            }\r\n            if (data.transparencytexture) {\r\n                promises.push(this.loadMapWithProperties(data.transparencytexture).then(map => {\r\n                    if (map)\r\n                        material.alphaMap = map;\r\n                    return map;\r\n                }));\r\n            }\r\n            // line material https://shapediver.atlassian.net/browse/SS-2272\r\n            yield Promise.all(promises);\r\n            return material;\r\n        });\r\n    }\r\n    loadPresetMaterial(preset) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.loadMaterialV3(this.loadPresetMaterialDefinition(preset));\r\n        });\r\n    }\r\n    loadPresetMaterialDefinition(preset) {\r\n        const definition = {};\r\n        const idStrings = this.getClassAndSpecificId(preset);\r\n        if (materialDatabase_1.materialDatabase[idStrings.class] && materialDatabase_1.materialDatabase[idStrings.class][idStrings.specific]) {\r\n            this.assignSpecificDefinition(idStrings, materialDatabase_1.materialDatabase[idStrings.class][idStrings.specific], definition);\r\n            this.assignGeneralDefinition(idStrings, materialDatabase_1.materialDatabase[idStrings.class].properties, materialDatabase_1.materialDatabase[idStrings.class][idStrings.specific], definition);\r\n        }\r\n        else if (materialDatabase_1.materialDatabase[idStrings.class] && materialDatabase_1.materialDatabase[idStrings.class]['00']) {\r\n            this.assignSpecificDefinition({ class: idStrings.class, specific: '00' }, materialDatabase_1.materialDatabase[idStrings.class]['00'], definition);\r\n            this.assignGeneralDefinition({ class: idStrings.class, specific: '00' }, materialDatabase_1.materialDatabase[idStrings.class].properties, materialDatabase_1.materialDatabase[idStrings.class]['00'], definition);\r\n        }\r\n        else {\r\n            this.assignSpecificDefinition({ class: '00', specific: '00' }, materialDatabase_1.materialDatabase['00']['00'], definition);\r\n            this.assignGeneralDefinition({ class: '00', specific: '00' }, materialDatabase_1.materialDatabase['00'].properties, materialDatabase_1.materialDatabase['00']['00'], definition);\r\n        }\r\n        return definition;\r\n    }\r\n    // #endregion Public Methods (12)\r\n    // #region Private Methods (4)\r\n    assignGeneralDefinition(id, generalDefinition, specificDefinition, definition) {\r\n        if (generalDefinition.transparencytexture && !specificDefinition.transparencytexture)\r\n            definition.transparencytexture = {\r\n                href: 'https://viewer.shapediver.com/v2/materials/1024/' + id.class + '/' + generalDefinition.transparencytexture\r\n            };\r\n        if (generalDefinition.hasOwnProperty('alphaThreshold') && !specificDefinition.hasOwnProperty('alphaThreshold'))\r\n            definition.alphaThreshold = generalDefinition.alphaThreshold;\r\n        if (generalDefinition.bumptexture && !specificDefinition.bumptexture)\r\n            definition.bumptexture = {\r\n                href: 'https://viewer.shapediver.com/v2/materials/1024/' + id.class + '/' + generalDefinition.bumptexture\r\n            };\r\n        if (generalDefinition.hasOwnProperty('bumpAmplitude') && !specificDefinition.hasOwnProperty('bumpAmplitude'))\r\n            definition.bumpAmplitude = generalDefinition.bumpAmplitude;\r\n        if (generalDefinition.color && !specificDefinition.color)\r\n            definition.color = generalDefinition.color;\r\n        if (generalDefinition.bitmaptexture && !specificDefinition.bitmaptexture)\r\n            definition.bitmaptexture = {\r\n                href: 'https://viewer.shapediver.com/v2/materials/1024/' + id.class + '/' + generalDefinition.bitmaptexture\r\n            };\r\n        if (generalDefinition.hasOwnProperty('metalness') && !specificDefinition.hasOwnProperty('metalness'))\r\n            definition.metalness = generalDefinition.metalness;\r\n        if (generalDefinition.metalnesstexture && !specificDefinition.metalnesstexture)\r\n            definition.metalnesstexture = {\r\n                href: 'https://viewer.shapediver.com/v2/materials/1024/' + id.class + '/' + generalDefinition.metalnesstexture\r\n            };\r\n        if (generalDefinition.normaltexture && !specificDefinition.normaltexture)\r\n            definition.normaltexture = {\r\n                href: 'https://viewer.shapediver.com/v2/materials/1024/' + id.class + '/' + generalDefinition.normaltexture\r\n            };\r\n        if (generalDefinition.hasOwnProperty('transparency') && !specificDefinition.hasOwnProperty('transparency'))\r\n            definition.transparency = generalDefinition.transparency;\r\n        if (generalDefinition.hasOwnProperty('roughness') && !specificDefinition.hasOwnProperty('roughness'))\r\n            definition.roughness = generalDefinition.roughness;\r\n        if (generalDefinition.roughnesstexture && !specificDefinition.roughnesstexture)\r\n            definition.roughnesstexture = {\r\n                href: 'https://viewer.shapediver.com/v2/materials/1024/' + id.class + '/' + generalDefinition.roughnesstexture\r\n            };\r\n        if (generalDefinition.side && !specificDefinition.side)\r\n            definition.side = generalDefinition.side;\r\n    }\r\n    assignSpecificDefinition(id, specificDefinition, definition) {\r\n        if (specificDefinition.transparencytexture)\r\n            definition.transparencytexture = {\r\n                href: 'https://viewer.shapediver.com/v2/materials/1024/' + id.class + '/' + id.specific + '/' + specificDefinition.transparencytexture\r\n            };\r\n        if (specificDefinition.hasOwnProperty('alphaThreshold'))\r\n            definition.alphaThreshold = specificDefinition.alphaThreshold;\r\n        if (specificDefinition.bumptexture)\r\n            definition.bumptexture = {\r\n                href: 'https://viewer.shapediver.com/v2/materials/1024/' + id.class + '/' + id.specific + '/' + specificDefinition.bumptexture\r\n            };\r\n        if (specificDefinition.hasOwnProperty('bumpAmplitude'))\r\n            definition.bumpAmplitude = specificDefinition.bumpAmplitude;\r\n        if (specificDefinition.color)\r\n            definition.color = specificDefinition.color;\r\n        if (specificDefinition.bitmaptexture)\r\n            definition.bitmaptexture = {\r\n                href: 'https://viewer.shapediver.com/v2/materials/1024/' + id.class + '/' + id.specific + '/' + specificDefinition.bitmaptexture\r\n            };\r\n        if (specificDefinition.hasOwnProperty('metalness'))\r\n            definition.metalness = specificDefinition.metalness;\r\n        if (specificDefinition.metalnesstexture)\r\n            definition.metalnesstexture = {\r\n                href: 'https://viewer.shapediver.com/v2/materials/1024/' + id.class + '/' + id.specific + '/' + specificDefinition.metalnesstexture\r\n            };\r\n        if (specificDefinition.normaltexture)\r\n            definition.normaltexture = {\r\n                href: 'https://viewer.shapediver.com/v2/materials/1024/' + id.class + '/' + id.specific + '/' + specificDefinition.normaltexture\r\n            };\r\n        if (specificDefinition.hasOwnProperty('transparency'))\r\n            definition.transparency = specificDefinition.transparency;\r\n        if (specificDefinition.hasOwnProperty('roughness'))\r\n            definition.roughness = specificDefinition.roughness;\r\n        if (specificDefinition.roughnesstexture)\r\n            definition.roughnesstexture = {\r\n                href: 'https://viewer.shapediver.com/v2/materials/1024/' + id.class + '/' + id.specific + '/' + specificDefinition.roughnesstexture\r\n            };\r\n        if (specificDefinition.side)\r\n            definition.side = specificDefinition.side;\r\n    }\r\n    getClassAndSpecificId(id) {\r\n        // for a while, we had documented the presets to be 10, 20, 30 and 40 here, we allow for the few cases where this was used to succeed\r\n        if (id < 100 && id % 10 == 0)\r\n            id /= 10;\r\n        // if the id is less than 10, multiply it by 100\r\n        if (id < 10)\r\n            id *= 100;\r\n        const cast = (id) => {\r\n            const idString = String(id);\r\n            return idString.padStart(2, '0').slice(0, 2);\r\n        };\r\n        return {\r\n            class: cast(Math.floor(id / 100)),\r\n            specific: cast(id - (Math.floor(id / 100) * 100))\r\n        };\r\n    }\r\n    /**\r\n     * Multiply two colors\r\n     *\r\n     * @param color1\r\n     * @param color2\r\n     * @returns\r\n     */\r\n    multiplyColors(color1, color2) {\r\n        if (!color2)\r\n            return color1;\r\n        return [\r\n            Math.min(255, (color1[0] * color2[0]) / 255),\r\n            Math.min(255, (color1[1] * color2[1]) / 255),\r\n            Math.min(255, (color1[2] * color2[2]) / 255),\r\n            Math.min(255, ((color1[3] !== undefined ? color1[3] : 255) * (color2[3] !== undefined ? color2[3] : 255)) / 255)\r\n        ];\r\n    }\r\n}\r\nexports.MaterialEngine = MaterialEngine;\r\n//# sourceMappingURL=MaterialEngine.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MaterialEngine = void 0;\r\nconst MaterialEngine_1 = require(\"./MaterialEngine\");\r\nObject.defineProperty(exports, \"MaterialEngine\", { enumerable: true, get: function () { return MaterialEngine_1.MaterialEngine; } });\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.materialDatabase = void 0;\r\nexports.materialDatabase = {\r\n    \"00\": {\r\n        \"00\": {\r\n            \"name\": \"Default material\",\r\n            \"color\": [211, 211, 211, 255],\r\n            \"metalness\": 0,\r\n            \"roughness\": 1\r\n        },\r\n        \"properties\": {\r\n            \"name\": \"Default materials\"\r\n        }\r\n    },\r\n    \"01\": {\r\n        \"01\": {\r\n            \"name\": \"Default groundplane material\",\r\n            \"color\": [211, 211, 211, 255],\r\n            \"metalness\": 0,\r\n            \"roughness\": 1\r\n        },\r\n        \"properties\": {\r\n            \"name\": \"Groundplane materials\"\r\n        }\r\n    },\r\n    \"02\": {\r\n        \"00\": {\r\n            \"name\": \"Default plastic material\",\r\n            \"color\": [211, 211, 211, 255],\r\n            \"metalness\": 0,\r\n            \"roughness\": 1,\r\n            \"normaltexture\": \"normalMap.jpg\",\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"properties\": {\r\n            \"name\": \"Plastic materials\"\r\n        }\r\n    },\r\n    \"03\": {\r\n        \"00\": {\r\n            \"name\": \"Default metal material\",\r\n            \"color\": [205, 205, 205, 255],\r\n            \"roughness\": 0.25\r\n        },\r\n        \"01\": {\r\n            \"name\": \"Used metal material 1\",\r\n            \"color\": [205, 205, 205, 255],\r\n            \"roughness\": 1,\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"02\": {\r\n            \"name\": \"Used metal material 2\",\r\n            \"color\": [205, 205, 205, 255],\r\n            \"roughness\": 1,\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"03\": {\r\n            \"name\": \"Used metal material 3\",\r\n            \"color\": [205, 205, 205, 255],\r\n            \"roughness\": 1,\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"10\": {\r\n            \"name\": \"Gold material\",\r\n            \"color\": [230, 207, 92, 255],\r\n            \"roughness\": 0\r\n        },\r\n        \"11\": {\r\n            \"name\": \"Used gold material\",\r\n            \"color\": [230, 207, 92, 255],\r\n            \"roughness\": 0,\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"21\": {\r\n            \"name\": \"Hammered metal material\",\r\n            \"color\": [205, 205, 205, 255],\r\n            \"roughness\": 1,\r\n            \"normaltexture\": \"normalMap.jpg\"\r\n        },\r\n        \"properties\": {\r\n            \"name\": \"Metal materials\",\r\n            \"metalness\": 1\r\n        }\r\n    },\r\n    \"04\": {\r\n        \"00\": {\r\n            \"name\": \"Default glass material\",\r\n            \"color\": [211, 211, 211, 255],\r\n            \"metalness\": 1,\r\n            \"roughness\": 0,\r\n            \"transparency\": 0.75\r\n        },\r\n        \"properties\": { \"name\": \"Glass materials\" }\r\n    },\r\n    \"05\": {\r\n        \"00\": {\r\n            \"bitmaptexture\": \"map.jpg\",\r\n            \"name\": \"Default wood material\",\r\n            \"metalnesstexture\": \"metalnessMap.jpg\",\r\n            \"normaltexture\": \"normalMap.jpg\",\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"01\": {\r\n            \"bitmaptexture\": \"map.jpg\",\r\n            \"name\": \"Wood floor material\",\r\n            \"metalnesstexture\": \"metalnessMap.jpg\",\r\n            \"normaltexture\": \"normalMap.jpg\",\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"10\": {\r\n            \"bitmaptexture\": \"map.jpg\",\r\n            \"name\": \"Natural oak material\",\r\n            \"normaltexture\": \"normalMap.jpg\",\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"11\": {\r\n            \"bitmaptexture\": \"map.jpg\",\r\n            \"name\": \"Premium oak material\",\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"properties\": {\r\n            \"name\": \"Wood materials\",\r\n            \"color\": [211, 211, 211, 255],\r\n            \"metalness\": 0,\r\n            \"roughness\": 1\r\n        }\r\n    },\r\n    \"06\": {\r\n        \"00\": {\r\n            \"bitmaptexture\": \"map.jpg\",\r\n            \"name\": \"Default leather material\",\r\n            \"metalnesstexture\": \"metalnessMap.jpg\",\r\n            \"normaltexture\": \"normalMap.jpg\",\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"01\": {\r\n            \"bitmaptexture\": \"map.jpg\",\r\n            \"name\": \"Dark brown leather material\",\r\n            \"metalnesstexture\": \"metalnessMap.jpg\",\r\n            \"normaltexture\": \"normalMap.jpg\",\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"02\": {\r\n            \"bitmaptexture\": \"map.jpg\",\r\n            \"name\": \"Black leather material\",\r\n            \"metalnesstexture\": \"metalnessMap.jpg\",\r\n            \"normaltexture\": \"normalMap.jpg\",\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"10\": {\r\n            \"bitmaptexture\": \"map.jpg\",\r\n            \"name\": \"Worn leather material\",\r\n            \"metalnesstexture\": \"metalnessMap.jpg\",\r\n            \"normaltexture\": \"normalMap.jpg\",\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"properties\": {\r\n            \"name\": \"Leather materials\",\r\n            \"metalness\": 0, \"roughness\": 1\r\n        }\r\n    },\r\n    \"07\": {\r\n        \"00\": {\r\n            \"bitmaptexture\": \"map.jpg\",\r\n            \"name\": \"Default fabric material\",\r\n            \"metalnesstexture\": \"metalnessMap.jpg\",\r\n            \"normaltexture\": \"normalMap.jpg\",\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"01\": {\r\n            \"bitmaptexture\": \"map.jpg\",\r\n            \"name\": \"Grey fabric material\",\r\n            \"metalnesstexture\": \"metalnessMap.jpg\",\r\n            \"normaltexture\": \"normalMap.jpg\",\r\n            \"roughnesstexture\": \"roughnessMap.jpg\"\r\n        },\r\n        \"properties\": {\r\n            \"name\": \"Fabric materials\",\r\n            \"metalness\": 1, \"roughness\": 1\r\n        }\r\n    }\r\n};\r\n//# sourceMappingURL=materialDatabase.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SDTFEngine = void 0;\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst sdk_sdtf_v1_1 = require(\"@shapediver/sdk.sdtf-v1\");\r\nconst sdk_sdtf_primitives_1 = require(\"@shapediver/sdk.sdtf-primitives\");\r\nclass SDTFEngine {\r\n    constructor() {\r\n        // #region Properties (3)\r\n        this._logger = viewer_shared_services_1.Logger.instance;\r\n        // #endregion Private Methods (5)\r\n    }\r\n    // #endregion Properties (3)\r\n    // #region Public Static Accessors (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Accessors (1)\r\n    // #region Public Methods (1)\r\n    /**\r\n     * Load the sdtf content into a scene graph node.\r\n     *\r\n     * @param content the geometry content\r\n     * @returns the scene graph node\r\n     */\r\n    loadContent(content, jwtToken) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const node = new viewer_shared_node_tree_1.TreeNode('sdtf');\r\n            // We have to be safe and check if the content is a valid SDTF file\r\n            if (!content || (content && !content.href))\r\n                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('SDTFEngine.loadContent: Invalid content was provided to geometry engine.');\r\n            // create the sdtf sdk\r\n            const sdk = jwtToken ? yield (0, sdk_sdtf_v1_1.create)({ authToken: jwtToken }) : yield (0, sdk_sdtf_v1_1.create)();\r\n            // crete the sdtf parser\r\n            const parser = sdk.createParser();\r\n            // parse the file\r\n            this._parsedFile = yield parser.readFromUrl(content.href);\r\n            // crete the overview and save it in the node data\r\n            node.data.push(yield this.createSDTFOverview());\r\n            // add the loaded chunks to the node\r\n            for (let i = 0; i < this._parsedFile.chunks.length; i++)\r\n                node.children.push(yield this.loadChunk(this._parsedFile.chunks[i], i));\r\n            return node;\r\n        });\r\n    }\r\n    // #endregion Public Methods (1)\r\n    // #region Private Methods (5)\r\n    /**\r\n     * Create an overview of the SDTF file.\r\n     * This overview is used for the data visualization.\r\n     * It is structured as a dictionary with the name as the key and an array of Objects as the value.\r\n     * The array of objects contains the different types that can be found in the SDTF file under the same name.\r\n     *\r\n     * Example:\r\n     * {\r\n     *     \"color\": [\r\n     *         {\r\n     *             typeHint: 'string',\r\n     *             count: 2,\r\n     *             values: [\"red\", \"blue\"]\r\n     *         },\r\n     *         {\r\n     *             typeHint: 'numberArray',\r\n     *             count: 2,\r\n     *             values: [[1,0,0,1], [0,0,1,1]]\r\n     *         },\r\n     *     ]\r\n     * }\r\n     *\r\n     * The overview contains the following information:\r\n     * - name of the attribute + type of the attribute\r\n     * - the count\r\n     * - for numerical attributes, the min and max values\r\n     * - for string attributes, the unique values\r\n     *\r\n     * @returns\r\n     */\r\n    createSDTFOverview() {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const overview = {};\r\n            // go through all attributes\r\n            for (let i = 0; i < this._parsedFile.attributes.length; i++) {\r\n                const attributes = this._parsedFile.attributes[i];\r\n                // go through all entries\r\n                for (let key in attributes.entries) {\r\n                    const dataToCopy = attributes.entries[key];\r\n                    const value = yield dataToCopy.getContent();\r\n                    // create the type hint to use\r\n                    const dataTypehint = dataToCopy.typeHint === undefined ? 'undefined' : dataToCopy.typeHint.name;\r\n                    // check if the attribute is already in the overview\r\n                    const existingEntries = overview[key] ? overview[key].filter(o => o.typeHint === dataTypehint) : [];\r\n                    if (overview[key] && existingEntries.length > 0) {\r\n                        // update the existing entry\r\n                        const entry = existingEntries[0];\r\n                        // update the count\r\n                        entry.count++;\r\n                        // update the values\r\n                        if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isStringType(dataTypehint)) {\r\n                            if (!((_a = entry.values) === null || _a === void 0 ? void 0 : _a.includes(value)))\r\n                                (_b = entry.values) === null || _b === void 0 ? void 0 : _b.push(value);\r\n                        }\r\n                        // update the min and max\r\n                        if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isNumberType(dataTypehint)) {\r\n                            entry.min = Math.min(value, entry.min);\r\n                            entry.max = Math.max(value, entry.max);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // create a new entry, if the name already exists, but the type does not\r\n                        if (overview[key]) {\r\n                            overview[key].push({\r\n                                typeHint: dataTypehint,\r\n                                count: 1,\r\n                            });\r\n                        }\r\n                        // create completely new entry\r\n                        else {\r\n                            overview[key] = [{\r\n                                    typeHint: dataTypehint,\r\n                                    count: 1,\r\n                                }];\r\n                        }\r\n                        // update the values\r\n                        if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isStringType(dataTypehint)) {\r\n                            overview[key][overview[key].length - 1].values = [value];\r\n                        }\r\n                        // update the min and max\r\n                        if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isNumberType(dataTypehint)) {\r\n                            overview[key][overview[key].length - 1].min = value;\r\n                            overview[key][overview[key].length - 1].max = value;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return new viewer_shared_types_1.SDTFOverviewData(overview);\r\n        });\r\n    }\r\n    /**\r\n     * Load the attributes into a SDTFAttributesData data item.\r\n     *\r\n     * @param attributes\r\n     * @returns\r\n     */\r\n    loadAttributes(attributes) {\r\n        var _a, _b, _c, _d;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const data = new viewer_shared_types_1.SDTFAttributesData();\r\n            // go through all attributes entries and save them in data items\r\n            for (let key in attributes.entries) {\r\n                if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isBooleanType((_a = attributes.entries[key].typeHint) === null || _a === void 0 ? void 0 : _a.name) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isColorType((_b = attributes.entries[key].typeHint) === null || _b === void 0 ? void 0 : _b.name) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isNumberType((_c = attributes.entries[key].typeHint) === null || _c === void 0 ? void 0 : _c.name) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isStringType((_d = attributes.entries[key].typeHint) === null || _d === void 0 ? void 0 : _d.name)) {\r\n                    // create the data item and save it in the dictionary\r\n                    const typeHint = attributes.entries[key].typeHint === undefined ? 'undefined' : attributes.entries[key].typeHint.name;\r\n                    data.attributes[key] = new viewer_shared_types_1.SDTFAttributeData(typeHint, yield attributes.entries[key].getContent());\r\n                }\r\n                else {\r\n                    // async data\r\n                    const typeHint = attributes.entries[key].typeHint === undefined ? 'undefined' : attributes.entries[key].typeHint.name;\r\n                    data.attributes[key] = new viewer_shared_types_1.SDTFAttributeData(typeHint, () => __awaiter(this, void 0, void 0, function* () {\r\n                        return yield attributes.entries[key].getContent();\r\n                    }));\r\n                }\r\n            }\r\n            return data;\r\n        });\r\n    }\r\n    /**\r\n     * Load the chunk into a scene graph node.\r\n     *\r\n     * @param chunk\r\n     * @param chunkId\r\n     * @returns\r\n     */\r\n    loadChunk(chunk, chunkId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const chunkDef = new viewer_shared_node_tree_1.TreeNode(chunk.name || 'chunk_' + chunkId);\r\n            // if there are attributes, add them to the chunk as data\r\n            if (chunk.attributes !== undefined) {\r\n                chunkDef.data.push(yield this.loadAttributes(chunk.attributes));\r\n            }\r\n            // if there are items, add them to the chunk as children\r\n            if (chunk.items !== undefined && chunk.items.length > 0) {\r\n                for (let i = 0, len = chunk.items.length; i < len; i++) {\r\n                    // got through all items\r\n                    chunkDef.addChild(yield this.loadItem(chunk.items[i], i));\r\n                }\r\n            }\r\n            // if there are nodes, add them to the chunk as children\r\n            if (chunk.nodes !== undefined && chunk.nodes.length > 0) {\r\n                for (let i = 0, len = chunk.nodes.length; i < len; i++) {\r\n                    // got through all children\r\n                    chunkDef.addChild(yield this.loadNode(chunk.nodes[i], i));\r\n                }\r\n            }\r\n            return chunkDef;\r\n        });\r\n    }\r\n    /**\r\n     * Load the item into a scene graph node.\r\n     *\r\n     * @param item\r\n     * @param itemId\r\n     * @returns\r\n     */\r\n    loadItem(item, itemId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const itemDef = new viewer_shared_node_tree_1.TreeNode(itemId + '');\r\n            // if there are attributes, add them to the item\r\n            let attributes;\r\n            if (item.attributes !== undefined)\r\n                attributes = yield this.loadAttributes(item.attributes);\r\n            // create the typehint\r\n            const typeHint = item.typeHint === undefined ? 'undefined' : item.typeHint.name;\r\n            let itemData;\r\n            // create the data and save it in the item node\r\n            if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isBooleanType(typeHint) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isColorType(typeHint) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isNumberType(typeHint) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isStringType(typeHint)) {\r\n                itemData = new viewer_shared_types_1.SDTFItemData(typeHint, yield item.getContent(), attributes === null || attributes === void 0 ? void 0 : attributes.attributes);\r\n            }\r\n            else {\r\n                itemData = new viewer_shared_types_1.SDTFItemData(typeHint, () => __awaiter(this, void 0, void 0, function* () {\r\n                    return yield item.getContent();\r\n                }), attributes === null || attributes === void 0 ? void 0 : attributes.attributes);\r\n            }\r\n            itemDef.data.push(itemData);\r\n            return itemDef;\r\n        });\r\n    }\r\n    /**\r\n     * Load the node into a scene graph node.\r\n     *\r\n     * @param node\r\n     * @param nodeId\r\n     * @returns\r\n     */\r\n    loadNode(node, nodeId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const nodeDef = new viewer_shared_node_tree_1.TreeNode(node.name || 'node_' + nodeId);\r\n            // if there are attributes, add them to the node as data\r\n            if (node.attributes !== undefined) {\r\n                nodeDef.data.push(yield this.loadAttributes(node.attributes));\r\n            }\r\n            // if there are items, add them to the node as children\r\n            if (node.items !== undefined && node.items.length > 0) {\r\n                for (let i = 0, len = node.items.length; i < len; i++) {\r\n                    // got through all items\r\n                    nodeDef.addChild(yield this.loadItem(node.items[i], i));\r\n                }\r\n            }\r\n            // if there are nodes, add them to the node as children\r\n            if (node.nodes !== undefined && node.nodes.length > 0) {\r\n                for (let i = 0, len = node.nodes.length; i < len; i++) {\r\n                    // got through all children\r\n                    nodeDef.addChild(yield this.loadNode(node.nodes[i], i));\r\n                }\r\n            }\r\n            return nodeDef;\r\n        });\r\n    }\r\n}\r\nexports.SDTFEngine = SDTFEngine;\r\n//# sourceMappingURL=SDTFEngine.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SDTFEngine = void 0;\r\nconst SDTFEngine_1 = require(\"./SDTFEngine\");\r\nObject.defineProperty(exports, \"SDTFEngine\", { enumerable: true, get: function () { return SDTFEngine_1.SDTFEngine; } });\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TAG3D_JUSTIFICATION = void 0;\r\nvar TAG3D_JUSTIFICATION;\r\n(function (TAG3D_JUSTIFICATION) {\r\n    TAG3D_JUSTIFICATION[\"TOP_LEFT\"] = \"TL\";\r\n    TAG3D_JUSTIFICATION[\"TOP_CENTER\"] = \"TC\";\r\n    TAG3D_JUSTIFICATION[\"TOP_RIGHT\"] = \"TR\";\r\n    TAG3D_JUSTIFICATION[\"MIDDLE_LEFT\"] = \"ML\";\r\n    TAG3D_JUSTIFICATION[\"MIDDLE_CENTER\"] = \"MC\";\r\n    TAG3D_JUSTIFICATION[\"MIDDLE_RIGHT\"] = \"MR\";\r\n    TAG3D_JUSTIFICATION[\"BOTTOM_LEFT\"] = \"BL\";\r\n    TAG3D_JUSTIFICATION[\"BOTTOM_CENTER\"] = \"BC\";\r\n    TAG3D_JUSTIFICATION[\"BOTTOM_RIGHT\"] = \"BR\";\r\n})(TAG3D_JUSTIFICATION = exports.TAG3D_JUSTIFICATION || (exports.TAG3D_JUSTIFICATION = {}));\r\n//# sourceMappingURL=interfaces.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ACCESSORTYPE = exports.ACCESSORCOMPONENTSIZE = exports.ACCESSORCOMPONENTTYPE = void 0;\r\nexports.ACCESSORCOMPONENTTYPE = {\r\n    5120: Int8Array,\r\n    5121: Uint8Array,\r\n    5122: Int16Array,\r\n    5123: Uint16Array,\r\n    5124: Uint32Array,\r\n    5125: Uint32Array,\r\n    5126: Float32Array\r\n};\r\nexports.ACCESSORCOMPONENTSIZE = {\r\n    5120: 1,\r\n    5121: 1,\r\n    5122: 2,\r\n    5123: 2,\r\n    5125: 4,\r\n    5126: 4\r\n};\r\nexports.ACCESSORTYPE = {\r\n    SCALAR: 1,\r\n    VEC2: 2,\r\n    VEC3: 3,\r\n    VEC4: 4,\r\n    VEC7: 7,\r\n    VEC10: 10,\r\n    VEC12: 12,\r\n    MAT2: 4,\r\n    MAT3: 9,\r\n    MAT4: 16\r\n};\r\n//# sourceMappingURL=IGLTF_v1.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ACCESSORTYPE = exports.ACCESSORCOMPONENTSIZE = exports.ACCESSORCOMPONENTTYPE = void 0;\r\nexports.ACCESSORCOMPONENTTYPE = {\r\n    5120: Int8Array,\r\n    5121: Uint8Array,\r\n    5122: Int16Array,\r\n    5123: Uint16Array,\r\n    5124: Uint16Array,\r\n    5125: Uint32Array,\r\n    5126: Float32Array\r\n};\r\nexports.ACCESSORCOMPONENTSIZE = {\r\n    5120: 1,\r\n    5121: 1,\r\n    5122: 2,\r\n    5123: 2,\r\n    5125: 4,\r\n    5126: 4\r\n};\r\nexports.ACCESSORTYPE = {\r\n    SCALAR: 1,\r\n    VEC2: 2,\r\n    VEC3: 3,\r\n    VEC4: 4,\r\n    MAT2: 4,\r\n    MAT3: 9,\r\n    MAT4: 16\r\n};\r\n//# sourceMappingURL=IGLTF_v2.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TAG3D_JUSTIFICATION = exports.ACCESSORTYPE_V2 = exports.ACCESSORCOMPONENTSIZE_V2 = exports.ACCESSORCOMPONENTTYPE_V2 = exports.ACCESSORTYPE_V1 = exports.ACCESSORCOMPONENTSIZE_V1 = exports.ACCESSORCOMPONENTTYPE_V1 = void 0;\r\nconst interfaces_1 = require(\"./anchor/interfaces\");\r\nObject.defineProperty(exports, \"TAG3D_JUSTIFICATION\", { enumerable: true, get: function () { return interfaces_1.TAG3D_JUSTIFICATION; } });\r\nconst IGLTF_v1_1 = require(\"./gltfv1/IGLTF_v1\");\r\nObject.defineProperty(exports, \"ACCESSORCOMPONENTSIZE_V1\", { enumerable: true, get: function () { return IGLTF_v1_1.ACCESSORCOMPONENTSIZE; } });\r\nObject.defineProperty(exports, \"ACCESSORCOMPONENTTYPE_V1\", { enumerable: true, get: function () { return IGLTF_v1_1.ACCESSORCOMPONENTTYPE; } });\r\nObject.defineProperty(exports, \"ACCESSORTYPE_V1\", { enumerable: true, get: function () { return IGLTF_v1_1.ACCESSORTYPE; } });\r\nconst IGLTF_v2_1 = require(\"./gltfv2/IGLTF_v2\");\r\nObject.defineProperty(exports, \"ACCESSORCOMPONENTSIZE_V2\", { enumerable: true, get: function () { return IGLTF_v2_1.ACCESSORCOMPONENTSIZE; } });\r\nObject.defineProperty(exports, \"ACCESSORCOMPONENTTYPE_V2\", { enumerable: true, get: function () { return IGLTF_v2_1.ACCESSORCOMPONENTTYPE; } });\r\nObject.defineProperty(exports, \"ACCESSORTYPE_V2\", { enumerable: true, get: function () { return IGLTF_v2_1.ACCESSORTYPE; } });\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Tag3dEngine = void 0;\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst viewer_shared_global_access_objects_1 = require(\"@shapediver/viewer.shared.global-access-objects\");\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nclass Tag3dEngine {\r\n    constructor() {\r\n        // #region Properties (3)\r\n        this._globalAccessObjects = viewer_shared_global_access_objects_1.GlobalAccessObjects.instance;\r\n        this._stateEngine = viewer_shared_services_1.StateEngine.instance;\r\n        // #endregion Public Methods (1)\r\n    }\r\n    // #endregion Properties (3)\r\n    // #region Public Static Getters And Setters (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Getters And Setters (1)\r\n    // #region Public Methods (1)\r\n    /**\r\n     * Load the tag3d content into a scene graph node.\r\n     *\r\n     * @param content the tag3d content\r\n     * @returns the scene graph node\r\n     */\r\n    loadContent(content) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const node = new viewer_shared_node_tree_1.TreeNode('tag3d');\r\n            if (!content)\r\n                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('Tag3dEngine.loadContent: Invalid content was provided to tag3d engine.');\r\n            if (content.data && Array.isArray(content.data)) {\r\n                if (this._globalAccessObjects.loadTag3D) {\r\n                    for (let i = 0; i < content.data.length; i++) {\r\n                        const tag3dInfo = content.data[i];\r\n                        const child = this._globalAccessObjects.loadTag3D(tag3dInfo);\r\n                        if (child)\r\n                            node.addChild(child);\r\n                    }\r\n                }\r\n                else {\r\n                    const customData = new viewer_shared_types_1.CustomData({});\r\n                    for (let i = 0; i < content.data.length; i++) {\r\n                        const tag3dInfo = content.data[i];\r\n                        customData.data['tag3d_' + tag3dInfo.version] = tag3dInfo;\r\n                    }\r\n                    node.addData(customData);\r\n                }\r\n            }\r\n            else {\r\n                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('Tag3dEngine.loadContent: No tag3d data was provided to tag3d engine.');\r\n            }\r\n            return node;\r\n        });\r\n    }\r\n}\r\nexports.Tag3dEngine = Tag3dEngine;\r\n//# sourceMappingURL=Tag3dEngine.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Tag3dEngine = void 0;\r\nconst Tag3dEngine_1 = require(\"./Tag3dEngine\");\r\nObject.defineProperty(exports, \"Tag3dEngine\", { enumerable: true, get: function () { return Tag3dEngine_1.Tag3dEngine; } });\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.EVENTTYPE_DRAWING_TOOLS = exports.EVENTTYPE_GUMBALL = exports.EVENTTYPE_INTERACTION = exports.EVENTTYPE_VIEWPORT = exports.EVENTTYPE_SESSION = exports.EVENTTYPE_SCENE = exports.EVENTTYPE_RENDERING = exports.EVENTTYPE_PARAMETER = exports.EVENTTYPE_OUTPUT = exports.EVENTTYPE_CAMERA = exports.EVENTTYPE = exports.TASK_TYPE = exports.SPINNER_POSITIONING = exports.SESSION_SETTINGS_MODE = exports.BUSY_MODE_DISPLAY = exports.SDTF_TYPEHINT = exports.TEXTURE_FILTERING = exports.TEXTURE_WRAPPING = exports.MATERIAL_TYPE = exports.MATERIAL_SHADING = exports.MATERIAL_ALPHA = exports.MATERIAL_SIDE = exports.PRIMITIVE_MODE = exports.LOGGING_LEVEL = exports.ENVIRONMENT_MAP_EMPTY = exports.ENVIRONMENT_MAP_CUBE = exports.ENVIRONMENT_MAP = exports.TONE_MAPPING = exports.TEXTURE_ENCODING = exports.ORTHOGRAPHIC_CAMERA_DIRECTION = exports.VISIBILITY_MODE = exports.RENDERER_TYPE = exports.LIGHT_TYPE = exports.CAMERA_TYPE = exports.TAG3D_JUSTIFICATION = exports.PARAMETER_VISUALIZATION = exports.EXPORT_TYPE = exports.PARAMETER_TYPE = exports.FLAG_TYPE = exports.TreeNode = exports.Tree = exports.version = exports.generalOptions = exports.sceneTree = exports.removeListener = exports.addListener = exports.sessions = exports.createSession = exports.viewports = exports.createViewport = void 0;\r\nexports.ShapeDiverViewerDrawingToolsError = exports.ShapeDiverViewerInteractionError = exports.ShapeDiverViewerValidationError = exports.ShapeDiverViewerCameraError = exports.ShapeDiverViewerLightError = exports.ShapeDiverViewerArError = exports.ShapeDiverViewerUnknownError = exports.ShapeDiverViewerViewportError = exports.ShapeDiverViewerSessionError = exports.ShapeDiverViewerSettingsError = exports.ShapeDiverViewerWebGLError = exports.ShapeDiverViewerEnvironmentMapError = exports.ShapeDiverViewerDataProcessingError = exports.ShapeDiverViewerError = exports.ShapeDiverViewerErrorType = exports.SessionOutputData = exports.SessionData = exports.SystemInfo = exports.MaterialEngine = exports.GeometryEngine = exports.DataEngine = exports.SdtfPrimitiveTypeGuard = exports.SDTFItemData = exports.SDTFAttributeData = exports.SDTFAttributesData = exports.SDTFOverviewData = exports.CustomData = exports.HTMLElementAnchorData = exports.HTMLElementAnchorImageData = exports.HTMLElementAnchorTextData = exports.HTMLElementAnchorCustomData = exports.MaterialVariantsData = exports.PrimitiveData = exports.AttributeData = exports.GeometryData = exports.AnimationData = exports.MapData = exports.MaterialBasicLineData = exports.MaterialMultiPointData = exports.MaterialPointData = exports.MaterialGemData = exports.MaterialSpecularGlossinessData = exports.MaterialShadowData = exports.MaterialUnlitData = exports.MaterialStandardData = exports.ShapeDiverResponseModelComputationStatus = exports.ThreejsData = exports.Sphere = exports.Box = exports.EVENTTYPE_TASK = void 0;\r\nexports.IDrawingParameterJsonSchema = exports.IGumballParameterJsonSchema = exports.ISelectionParameterJsonSchema = exports.IInteractionParameterJsonSchema = exports.Resolution = exports.KernelSize = exports.VignetteTechnique = exports.BlendFunction = exports.EffectComposer = exports.Effect = exports.VignetteEffect = exports.TiltShiftEffect = exports.SepiaEffect = exports.SelectiveBloomEffect = exports.ScanlineEffect = exports.SSAOEffect = exports.PixelationEffect = exports.OutlineEffect = exports.NoiseEffect = exports.HueSaturationEffect = exports.GridEffect = exports.GodRaysEffect = exports.DotScreenEffect = exports.DepthOfFieldEffect = exports.ChromaticAberrationEffect = exports.BloomEffect = exports.POST_PROCESSING_EFFECT_TYPE = exports.ANTI_ALIASING_TECHNIQUE = exports.isViewerGeometryBackendResponseError = exports.isViewerGeometryBackendRequestError = exports.isViewerGeometryBackendGenericError = exports.isViewerGeometryBackendError = exports.isViewerDrawingToolsError = exports.isViewerInteractionError = exports.isViewerValidationError = exports.isARError = exports.isViewerCameraError = exports.isViewerLightError = exports.isViewerViewportError = exports.isViewerSessionError = exports.isViewerSettingsError = exports.isViewerWebGLError = exports.isViewerEnvironmentMapError = exports.isViewerDataProcessingError = exports.isViewerUnknownError = exports.isViewerError = exports.ShapeDiverGeometryBackendResponseErrorType = exports.ShapeDiverGeometryBackendResponseError = exports.ShapeDiverGeometryBackendRequestError = exports.ShapeDiverGeometryBackendError = void 0;\r\nexports.stringify = exports.isValid = exports.OutputApiData = exports.SessionApiData = void 0;\r\nconst viewer_api_general_1 = require(\"@shapediver/viewer.api.general\");\r\nObject.defineProperty(exports, \"addListener\", { enumerable: true, get: function () { return viewer_api_general_1.addListener; } });\r\nObject.defineProperty(exports, \"generalOptions\", { enumerable: true, get: function () { return viewer_api_general_1.generalOptions; } });\r\nObject.defineProperty(exports, \"removeListener\", { enumerable: true, get: function () { return viewer_api_general_1.removeListener; } });\r\nObject.defineProperty(exports, \"sceneTree\", { enumerable: true, get: function () { return viewer_api_general_1.sceneTree; } });\r\nObject.defineProperty(exports, \"version\", { enumerable: true, get: function () { return viewer_api_general_1.version; } });\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nObject.defineProperty(exports, \"AnimationData\", { enumerable: true, get: function () { return viewer_shared_types_1.AnimationData; } });\r\nObject.defineProperty(exports, \"AttributeData\", { enumerable: true, get: function () { return viewer_shared_types_1.AttributeData; } });\r\nObject.defineProperty(exports, \"CustomData\", { enumerable: true, get: function () { return viewer_shared_types_1.CustomData; } });\r\nObject.defineProperty(exports, \"GeometryData\", { enumerable: true, get: function () { return viewer_shared_types_1.GeometryData; } });\r\nObject.defineProperty(exports, \"HTMLElementAnchorCustomData\", { enumerable: true, get: function () { return viewer_shared_types_1.HTMLElementAnchorCustomData; } });\r\nObject.defineProperty(exports, \"HTMLElementAnchorData\", { enumerable: true, get: function () { return viewer_shared_types_1.HTMLElementAnchorData; } });\r\nObject.defineProperty(exports, \"HTMLElementAnchorImageData\", { enumerable: true, get: function () { return viewer_shared_types_1.HTMLElementAnchorImageData; } });\r\nObject.defineProperty(exports, \"HTMLElementAnchorTextData\", { enumerable: true, get: function () { return viewer_shared_types_1.HTMLElementAnchorTextData; } });\r\nObject.defineProperty(exports, \"IDrawingParameterJsonSchema\", { enumerable: true, get: function () { return viewer_shared_types_1.IDrawingParameterJsonSchema; } });\r\nObject.defineProperty(exports, \"IGumballParameterJsonSchema\", { enumerable: true, get: function () { return viewer_shared_types_1.IGumballParameterJsonSchema; } });\r\nObject.defineProperty(exports, \"IInteractionParameterJsonSchema\", { enumerable: true, get: function () { return viewer_shared_types_1.IInteractionParameterJsonSchema; } });\r\nObject.defineProperty(exports, \"ISelectionParameterJsonSchema\", { enumerable: true, get: function () { return viewer_shared_types_1.ISelectionParameterJsonSchema; } });\r\nObject.defineProperty(exports, \"MapData\", { enumerable: true, get: function () { return viewer_shared_types_1.MapData; } });\r\nObject.defineProperty(exports, \"MATERIAL_ALPHA\", { enumerable: true, get: function () { return viewer_shared_types_1.MATERIAL_ALPHA; } });\r\nObject.defineProperty(exports, \"MATERIAL_SHADING\", { enumerable: true, get: function () { return viewer_shared_types_1.MATERIAL_SHADING; } });\r\nObject.defineProperty(exports, \"MATERIAL_SIDE\", { enumerable: true, get: function () { return viewer_shared_types_1.MATERIAL_SIDE; } });\r\nObject.defineProperty(exports, \"MATERIAL_TYPE\", { enumerable: true, get: function () { return viewer_shared_types_1.MATERIAL_TYPE; } });\r\nObject.defineProperty(exports, \"MaterialBasicLineData\", { enumerable: true, get: function () { return viewer_shared_types_1.MaterialBasicLineData; } });\r\nObject.defineProperty(exports, \"MaterialGemData\", { enumerable: true, get: function () { return viewer_shared_types_1.MaterialGemData; } });\r\nObject.defineProperty(exports, \"MaterialMultiPointData\", { enumerable: true, get: function () { return viewer_shared_types_1.MaterialMultiPointData; } });\r\nObject.defineProperty(exports, \"MaterialPointData\", { enumerable: true, get: function () { return viewer_shared_types_1.MaterialPointData; } });\r\nObject.defineProperty(exports, \"MaterialShadowData\", { enumerable: true, get: function () { return viewer_shared_types_1.MaterialShadowData; } });\r\nObject.defineProperty(exports, \"MaterialSpecularGlossinessData\", { enumerable: true, get: function () { return viewer_shared_types_1.MaterialSpecularGlossinessData; } });\r\nObject.defineProperty(exports, \"MaterialStandardData\", { enumerable: true, get: function () { return viewer_shared_types_1.MaterialStandardData; } });\r\nObject.defineProperty(exports, \"MaterialUnlitData\", { enumerable: true, get: function () { return viewer_shared_types_1.MaterialUnlitData; } });\r\nObject.defineProperty(exports, \"MaterialVariantsData\", { enumerable: true, get: function () { return viewer_shared_types_1.MaterialVariantsData; } });\r\nObject.defineProperty(exports, \"PARAMETER_TYPE\", { enumerable: true, get: function () { return viewer_shared_types_1.PARAMETER_TYPE; } });\r\nObject.defineProperty(exports, \"PARAMETER_VISUALIZATION\", { enumerable: true, get: function () { return viewer_shared_types_1.PARAMETER_VISUALIZATION; } });\r\nObject.defineProperty(exports, \"PRIMITIVE_MODE\", { enumerable: true, get: function () { return viewer_shared_types_1.PRIMITIVE_MODE; } });\r\nObject.defineProperty(exports, \"PrimitiveData\", { enumerable: true, get: function () { return viewer_shared_types_1.PrimitiveData; } });\r\nObject.defineProperty(exports, \"SDTF_TYPEHINT\", { enumerable: true, get: function () { return viewer_shared_types_1.SDTF_TYPEHINT; } });\r\nObject.defineProperty(exports, \"SDTFAttributeData\", { enumerable: true, get: function () { return viewer_shared_types_1.SDTFAttributeData; } });\r\nObject.defineProperty(exports, \"SDTFAttributesData\", { enumerable: true, get: function () { return viewer_shared_types_1.SDTFAttributesData; } });\r\nObject.defineProperty(exports, \"SDTFItemData\", { enumerable: true, get: function () { return viewer_shared_types_1.SDTFItemData; } });\r\nObject.defineProperty(exports, \"SDTFOverviewData\", { enumerable: true, get: function () { return viewer_shared_types_1.SDTFOverviewData; } });\r\nObject.defineProperty(exports, \"SdtfPrimitiveTypeGuard\", { enumerable: true, get: function () { return viewer_shared_types_1.SdtfPrimitiveTypeGuard; } });\r\nObject.defineProperty(exports, \"TASK_TYPE\", { enumerable: true, get: function () { return viewer_shared_types_1.TASK_TYPE; } });\r\nObject.defineProperty(exports, \"TEXTURE_FILTERING\", { enumerable: true, get: function () { return viewer_shared_types_1.TEXTURE_FILTERING; } });\r\nObject.defineProperty(exports, \"TEXTURE_WRAPPING\", { enumerable: true, get: function () { return viewer_shared_types_1.TEXTURE_WRAPPING; } });\r\nconst viewer_rendering_engine_rendering_engine_threejs_1 = require(\"@shapediver/viewer.rendering-engine.rendering-engine-threejs\");\r\nObject.defineProperty(exports, \"ANTI_ALIASING_TECHNIQUE\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.ANTI_ALIASING_TECHNIQUE; } });\r\nObject.defineProperty(exports, \"BlendFunction\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.BlendFunction; } });\r\nObject.defineProperty(exports, \"BloomEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.BloomEffect; } });\r\nObject.defineProperty(exports, \"ChromaticAberrationEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.ChromaticAberrationEffect; } });\r\nObject.defineProperty(exports, \"DepthOfFieldEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.DepthOfFieldEffect; } });\r\nObject.defineProperty(exports, \"DotScreenEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.DotScreenEffect; } });\r\nObject.defineProperty(exports, \"Effect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.Effect; } });\r\nObject.defineProperty(exports, \"EffectComposer\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.EffectComposer; } });\r\nObject.defineProperty(exports, \"ENVIRONMENT_MAP\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.ENVIRONMENT_MAP; } });\r\nObject.defineProperty(exports, \"ENVIRONMENT_MAP_CUBE\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.ENVIRONMENT_MAP_CUBE; } });\r\nObject.defineProperty(exports, \"ENVIRONMENT_MAP_EMPTY\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.ENVIRONMENT_MAP_EMPTY; } });\r\nObject.defineProperty(exports, \"GodRaysEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.GodRaysEffect; } });\r\nObject.defineProperty(exports, \"GridEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.GridEffect; } });\r\nObject.defineProperty(exports, \"HueSaturationEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.HueSaturationEffect; } });\r\nObject.defineProperty(exports, \"KernelSize\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.KernelSize; } });\r\nObject.defineProperty(exports, \"NoiseEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.NoiseEffect; } });\r\nObject.defineProperty(exports, \"OutlineEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.OutlineEffect; } });\r\nObject.defineProperty(exports, \"PixelationEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.PixelationEffect; } });\r\nObject.defineProperty(exports, \"POST_PROCESSING_EFFECT_TYPE\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.POST_PROCESSING_EFFECT_TYPE; } });\r\nObject.defineProperty(exports, \"Resolution\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.Resolution; } });\r\nObject.defineProperty(exports, \"ScanlineEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.ScanlineEffect; } });\r\nObject.defineProperty(exports, \"SelectiveBloomEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.SelectiveBloomEffect; } });\r\nObject.defineProperty(exports, \"SepiaEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.SepiaEffect; } });\r\nObject.defineProperty(exports, \"SSAOEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.SSAOEffect; } });\r\nObject.defineProperty(exports, \"ThreejsData\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.ThreejsData; } });\r\nObject.defineProperty(exports, \"TiltShiftEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.TiltShiftEffect; } });\r\nObject.defineProperty(exports, \"VignetteEffect\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.VignetteEffect; } });\r\nObject.defineProperty(exports, \"VignetteTechnique\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_threejs_1.VignetteTechnique; } });\r\nconst viewer_shared_math_1 = require(\"@shapediver/viewer.shared.math\");\r\nObject.defineProperty(exports, \"Box\", { enumerable: true, get: function () { return viewer_shared_math_1.Box; } });\r\nObject.defineProperty(exports, \"Sphere\", { enumerable: true, get: function () { return viewer_shared_math_1.Sphere; } });\r\nconst viewer_rendering_engine_rendering_engine_1 = require(\"@shapediver/viewer.rendering-engine.rendering-engine\");\r\nObject.defineProperty(exports, \"BUSY_MODE_DISPLAY\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_1.BUSY_MODE_DISPLAY; } });\r\nObject.defineProperty(exports, \"FLAG_TYPE\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_1.FLAG_TYPE; } });\r\nObject.defineProperty(exports, \"RENDERER_TYPE\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE; } });\r\nObject.defineProperty(exports, \"SPINNER_POSITIONING\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_1.SPINNER_POSITIONING; } });\r\nObject.defineProperty(exports, \"TEXTURE_ENCODING\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_1.TEXTURE_ENCODING; } });\r\nObject.defineProperty(exports, \"TONE_MAPPING\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_1.TONE_MAPPING; } });\r\nObject.defineProperty(exports, \"VISIBILITY_MODE\", { enumerable: true, get: function () { return viewer_rendering_engine_rendering_engine_1.VISIBILITY_MODE; } });\r\nconst viewer_rendering_engine_camera_engine_1 = require(\"@shapediver/viewer.rendering-engine.camera-engine\");\r\nObject.defineProperty(exports, \"CAMERA_TYPE\", { enumerable: true, get: function () { return viewer_rendering_engine_camera_engine_1.CAMERA_TYPE; } });\r\nObject.defineProperty(exports, \"ORTHOGRAPHIC_CAMERA_DIRECTION\", { enumerable: true, get: function () { return viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION; } });\r\nconst viewer_session_1 = require(\"@shapediver/viewer.session\");\r\nObject.defineProperty(exports, \"createSession\", { enumerable: true, get: function () { return viewer_session_1.createSession; } });\r\nObject.defineProperty(exports, \"OutputApiData\", { enumerable: true, get: function () { return viewer_session_1.OutputApiData; } });\r\nObject.defineProperty(exports, \"SessionApiData\", { enumerable: true, get: function () { return viewer_session_1.SessionApiData; } });\r\nObject.defineProperty(exports, \"sessions\", { enumerable: true, get: function () { return viewer_session_1.sessions; } });\r\nconst viewer_viewport_1 = require(\"@shapediver/viewer.viewport\");\r\nObject.defineProperty(exports, \"createViewport\", { enumerable: true, get: function () { return viewer_viewport_1.createViewport; } });\r\nObject.defineProperty(exports, \"viewports\", { enumerable: true, get: function () { return viewer_viewport_1.viewports; } });\r\nconst viewer_data_engine_data_engine_1 = require(\"@shapediver/viewer.data-engine.data-engine\");\r\nObject.defineProperty(exports, \"DataEngine\", { enumerable: true, get: function () { return viewer_data_engine_data_engine_1.DataEngine; } });\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nObject.defineProperty(exports, \"EVENTTYPE\", { enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE; } });\r\nObject.defineProperty(exports, \"EVENTTYPE_CAMERA\", { enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_CAMERA; } });\r\nObject.defineProperty(exports, \"EVENTTYPE_DRAWING_TOOLS\", { enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_DRAWING_TOOLS; } });\r\nObject.defineProperty(exports, \"EVENTTYPE_GUMBALL\", { enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_GUMBALL; } });\r\nObject.defineProperty(exports, \"EVENTTYPE_INTERACTION\", { enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_INTERACTION; } });\r\nObject.defineProperty(exports, \"EVENTTYPE_OUTPUT\", { enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_OUTPUT; } });\r\nObject.defineProperty(exports, \"EVENTTYPE_PARAMETER\", { enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_PARAMETER; } });\r\nObject.defineProperty(exports, \"EVENTTYPE_RENDERING\", { enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_RENDERING; } });\r\nObject.defineProperty(exports, \"EVENTTYPE_SCENE\", { enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_SCENE; } });\r\nObject.defineProperty(exports, \"EVENTTYPE_SESSION\", { enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_SESSION; } });\r\nObject.defineProperty(exports, \"EVENTTYPE_TASK\", { enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_TASK; } });\r\nObject.defineProperty(exports, \"EVENTTYPE_VIEWPORT\", { enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_VIEWPORT; } });\r\nObject.defineProperty(exports, \"isARError\", { enumerable: true, get: function () { return viewer_shared_services_1.isARError; } });\r\nObject.defineProperty(exports, \"isValid\", { enumerable: true, get: function () { return viewer_shared_services_1.isValid; } });\r\nObject.defineProperty(exports, \"isViewerCameraError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerCameraError; } });\r\nObject.defineProperty(exports, \"isViewerDataProcessingError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerDataProcessingError; } });\r\nObject.defineProperty(exports, \"isViewerDrawingToolsError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerDrawingToolsError; } });\r\nObject.defineProperty(exports, \"isViewerEnvironmentMapError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerEnvironmentMapError; } });\r\nObject.defineProperty(exports, \"isViewerError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerError; } });\r\nObject.defineProperty(exports, \"isViewerGeometryBackendError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerGeometryBackendError; } });\r\nObject.defineProperty(exports, \"isViewerGeometryBackendGenericError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerGeometryBackendGenericError; } });\r\nObject.defineProperty(exports, \"isViewerGeometryBackendRequestError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerGeometryBackendRequestError; } });\r\nObject.defineProperty(exports, \"isViewerGeometryBackendResponseError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerGeometryBackendResponseError; } });\r\nObject.defineProperty(exports, \"isViewerInteractionError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerInteractionError; } });\r\nObject.defineProperty(exports, \"isViewerLightError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerLightError; } });\r\nObject.defineProperty(exports, \"isViewerSessionError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerSessionError; } });\r\nObject.defineProperty(exports, \"isViewerSettingsError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerSettingsError; } });\r\nObject.defineProperty(exports, \"isViewerUnknownError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerUnknownError; } });\r\nObject.defineProperty(exports, \"isViewerValidationError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerValidationError; } });\r\nObject.defineProperty(exports, \"isViewerViewportError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerViewportError; } });\r\nObject.defineProperty(exports, \"isViewerWebGLError\", { enumerable: true, get: function () { return viewer_shared_services_1.isViewerWebGLError; } });\r\nObject.defineProperty(exports, \"LOGGING_LEVEL\", { enumerable: true, get: function () { return viewer_shared_services_1.LOGGING_LEVEL; } });\r\nObject.defineProperty(exports, \"SESSION_SETTINGS_MODE\", { enumerable: true, get: function () { return viewer_shared_services_1.SESSION_SETTINGS_MODE; } });\r\nObject.defineProperty(exports, \"ShapeDiverGeometryBackendError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverGeometryBackendError; } });\r\nObject.defineProperty(exports, \"ShapeDiverGeometryBackendRequestError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverGeometryBackendRequestError; } });\r\nObject.defineProperty(exports, \"ShapeDiverGeometryBackendResponseError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverGeometryBackendResponseError; } });\r\nObject.defineProperty(exports, \"ShapeDiverGeometryBackendResponseErrorType\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverGeometryBackendResponseErrorType; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerArError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerArError; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerCameraError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerCameraError; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerDataProcessingError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerDataProcessingError; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerDrawingToolsError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerDrawingToolsError; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerEnvironmentMapError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerEnvironmentMapError; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerError; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerErrorType\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerErrorType; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerInteractionError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerInteractionError; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerLightError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerLightError; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerSessionError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerSessionError; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerSettingsError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerSettingsError; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerUnknownError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerUnknownError; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerValidationError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerValidationError; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerViewportError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerViewportError; } });\r\nObject.defineProperty(exports, \"ShapeDiverViewerWebGLError\", { enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerWebGLError; } });\r\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return viewer_shared_services_1.stringify; } });\r\nObject.defineProperty(exports, \"SystemInfo\", { enumerable: true, get: function () { return viewer_shared_services_1.SystemInfo; } });\r\nconst viewer_data_engine_geometry_engine_1 = require(\"@shapediver/viewer.data-engine.geometry-engine\");\r\nObject.defineProperty(exports, \"GeometryEngine\", { enumerable: true, get: function () { return viewer_data_engine_geometry_engine_1.GeometryEngine; } });\r\nconst viewer_data_engine_shared_types_1 = require(\"@shapediver/viewer.data-engine.shared-types\");\r\nObject.defineProperty(exports, \"TAG3D_JUSTIFICATION\", { enumerable: true, get: function () { return viewer_data_engine_shared_types_1.TAG3D_JUSTIFICATION; } });\r\nconst viewer_session_engine_session_engine_1 = require(\"@shapediver/viewer.session-engine.session-engine\");\r\nObject.defineProperty(exports, \"SessionData\", { enumerable: true, get: function () { return viewer_session_engine_session_engine_1.SessionData; } });\r\nObject.defineProperty(exports, \"SessionOutputData\", { enumerable: true, get: function () { return viewer_session_engine_session_engine_1.SessionOutputData; } });\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nObject.defineProperty(exports, \"Tree\", { enumerable: true, get: function () { return viewer_shared_node_tree_1.Tree; } });\r\nObject.defineProperty(exports, \"TreeNode\", { enumerable: true, get: function () { return viewer_shared_node_tree_1.TreeNode; } });\r\nconst viewer_rendering_engine_light_engine_1 = require(\"@shapediver/viewer.rendering-engine.light-engine\");\r\nObject.defineProperty(exports, \"LIGHT_TYPE\", { enumerable: true, get: function () { return viewer_rendering_engine_light_engine_1.LIGHT_TYPE; } });\r\nconst viewer_data_engine_material_engine_1 = require(\"@shapediver/viewer.data-engine.material-engine\");\r\nObject.defineProperty(exports, \"MaterialEngine\", { enumerable: true, get: function () { return viewer_data_engine_material_engine_1.MaterialEngine; } });\r\nconst sdk_geometry_api_sdk_v2_1 = require(\"@shapediver/sdk.geometry-api-sdk-v2\");\r\nObject.defineProperty(exports, \"ShapeDiverResponseModelComputationStatus\", { enumerable: true, get: function () { return sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus; } });\r\nconst sdk_geometry_api_sdk_v2_2 = require(\"@shapediver/sdk.geometry-api-sdk-v2\");\r\nObject.defineProperty(exports, \"EXPORT_TYPE\", { enumerable: true, get: function () { return sdk_geometry_api_sdk_v2_2.ShapeDiverResponseExportDefinitionType; } });\r\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}