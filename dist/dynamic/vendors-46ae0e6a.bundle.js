"use strict";
(self["webpackChunkspinlio_workspace"] = self["webpackChunkspinlio_workspace"] || []).push([[631],{

/***/ 21955:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnimationEngine = void 0;
const gl_matrix_1 = __webpack_require__(61961);
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const viewer_shared_types_1 = __webpack_require__(64766);
class AnimationEngine {
    constructor() {
        // #region Properties (3)
        this._tree = viewer_shared_node_tree_1.Tree.instance;
        this._animations = {};
        // #endregion Private Methods (1)
    }
    // #endregion Properties (3)
    // #region Public Static Accessors (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    // #endregion Public Static Accessors (1)
    // #region Public Accessors (1)
    get animations() {
        return this._animations;
    }
    // #endregion Public Accessors (1)
    // #region Public Methods (3)
    init() { }
    update(deltaTime) {
        const animations = Object.values(this._animations);
        let running = false;
        for (let i = 0; i < animations.length; i++) {
            const animation = animations[i];
            if (animation.animationTime === -1) {
                // if we just stopped we need to render one more time
                running = true;
                animation.animationTime = 0;
            }
            if (!animation.animate)
                continue;
            running = true;
            animation.animationTime += deltaTime;
            if (animation.animationTime / 1000.0 > animation.duration) {
                if (animation.repeat) {
                    animation.startAnimation();
                }
                else {
                    animation.stopAnimation();
                }
            }
            const animationDuration = animation.duration;
            const currentAnimationDeltaTime = (animation.animationTime / 1000.0) % animationDuration;
            for (let j = 0; j < animation.tracks.length; j++) {
                const track = animation.tracks[j];
                const id = animation.id + '_' + j;
                if (currentAnimationDeltaTime < track.times[0] || currentAnimationDeltaTime > track.times[track.times.length - 1])
                    continue;
                for (let k = 1; k < track.times.length; k++) {
                    if (currentAnimationDeltaTime < track.times[k] && currentAnimationDeltaTime > track.times[k - 1]) {
                        const prevAnimation = track.node.transformations.filter(t => t.id === id);
                        track.node.transformations = track.node.transformations.filter((el) => {
                            return !prevAnimation.includes(el);
                        });
                        const factor = (currentAnimationDeltaTime - track.times[k - 1]) / (track.times[k] - track.times[k - 1]);
                        let translationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');
                        if (!translationTransformation) {
                            translationTransformation = {
                                id: 'gltf_matrix_translation',
                                matrix: gl_matrix_1.mat4.create()
                            };
                            track.node.transformations.push(translationTransformation);
                        }
                        let rotationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');
                        if (!rotationTransformation) {
                            rotationTransformation = {
                                id: 'gltf_matrix_rotation',
                                matrix: gl_matrix_1.mat4.create()
                            };
                            track.node.transformations.push(rotationTransformation);
                        }
                        let scaleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');
                        if (!scaleTransformation) {
                            scaleTransformation = {
                                id: 'gltf_matrix_scale',
                                matrix: gl_matrix_1.mat4.create()
                            };
                            track.node.transformations.push(scaleTransformation);
                        }
                        if (track.path === 'rotation') {
                            let pivotMatrix, pivotMatrixInverse;
                            if (track.pivot) {
                                pivotMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(track.pivot[0], track.pivot[1], track.pivot[2]));
                                pivotMatrixInverse = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(-track.pivot[0], -track.pivot[1], -track.pivot[2]));
                            }
                            let quaternion;
                            if (track.interpolation === 'step') {
                                quaternion = gl_matrix_1.quat.fromValues(track.values[(k - 1) * 4 + 0], track.values[(k - 1) * 4 + 1], track.values[(k - 1) * 4 + 2], track.values[(k - 1) * 4 + 3]);
                            }
                            else {
                                quaternion = gl_matrix_1.quat.slerp(gl_matrix_1.vec4.create(), gl_matrix_1.vec4.fromValues(track.values[(k - 1) * 4 + 0], track.values[(k - 1) * 4 + 1], track.values[(k - 1) * 4 + 2], track.values[(k - 1) * 4 + 3]), gl_matrix_1.vec4.fromValues(track.values[(k) * 4 + 0], track.values[(k) * 4 + 1], track.values[(k) * 4 + 2], track.values[(k) * 4 + 3]), factor);
                            }
                            const rotationMatrix = gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), quaternion);
                            if (pivotMatrix && pivotMatrixInverse) {
                                rotationTransformation.matrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), pivotMatrix, rotationMatrix), pivotMatrixInverse);
                            }
                            else {
                                rotationTransformation.matrix = rotationMatrix;
                            }
                        }
                        else if (track.path === 'translation') {
                            let vector;
                            if (track.interpolation === 'step') {
                                vector = gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]);
                            }
                            else {
                                vector = gl_matrix_1.vec3.lerp(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]), gl_matrix_1.vec3.fromValues(track.values[(k) * 3 + 0], track.values[(k) * 3 + 1], track.values[(k) * 3 + 2]), factor);
                            }
                            translationTransformation.matrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), vector);
                        }
                        else if (track.path === 'scale') {
                            let pivotMatrix, pivotMatrixInverse;
                            if (track.pivot) {
                                pivotMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(track.pivot[0], track.pivot[1], track.pivot[2]));
                                pivotMatrixInverse = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(-track.pivot[0], -track.pivot[1], -track.pivot[2]));
                            }
                            let vector;
                            if (track.interpolation === 'step') {
                                vector = gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]);
                            }
                            else {
                                vector = gl_matrix_1.vec3.lerp(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]), gl_matrix_1.vec3.fromValues(track.values[(k) * 3 + 0], track.values[(k) * 3 + 1], track.values[(k) * 3 + 2]), factor);
                            }
                            const scalingMatrix = gl_matrix_1.mat4.fromScaling(gl_matrix_1.mat4.create(), vector);
                            if (pivotMatrix && pivotMatrixInverse) {
                                scaleTransformation.matrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), pivotMatrix, scalingMatrix), pivotMatrixInverse);
                            }
                            else {
                                scaleTransformation.matrix = scalingMatrix;
                            }
                        }
                        else if (track.path === 'weights') {
                            let weights = [];
                            const weightCount = track.values.length / track.times.length;
                            if (track.interpolation === 'step') {
                                for (let l = 0; l < weightCount; l++)
                                    weights.push(track.values[(k - 1) * weightCount + l]);
                            }
                            else {
                                for (let l = 0; l < weightCount; l++)
                                    weights.push(track.values[(k - 1) * weightCount + l] * (1.0 - factor) + (factor) * track.values[(k - 1) * weightCount + l]);
                            }
                            const applyWeights = (node) => {
                                for (let l = 0; l < node.data.length; l++)
                                    if (node.data[l] instanceof viewer_shared_types_1.GeometryData && node.data[l].morphWeights.length === weightCount)
                                        node.data[l].morphWeights = weights;
                                for (let l = 0; l < node.children.length; l++)
                                    applyWeights(node.children[l]);
                            };
                            applyWeights(track.node);
                        }
                        break;
                    }
                }
            }
        }
        return running;
    }
    updateAnimationData() {
        this._animations = {};
        const animationArray = this.gatherAnimations();
        const names = animationArray.map(a => a.name);
        for (let i = 0; i < animationArray.length; i++) {
            const animationName = animationArray[i].name;
            const nameIndices = [];
            for (let j = 0; j < names.length; j++)
                if (animationName === names[j])
                    nameIndices.push(j);
            let animationNameAdjusted = animationName;
            // name adjustement if the name occurs multiple times
            if (nameIndices.length > 1) {
                animationNameAdjusted = animationName + '_' + nameIndices.indexOf(i);
                // even further name adjustement if the name is even then the same after adjustements (probably will never happen)
                while (names.includes(animationNameAdjusted))
                    animationNameAdjusted += "_0";
            }
            this._animations[animationNameAdjusted] = animationArray[i];
        }
    }
    // #endregion Public Methods (3)
    // #region Private Methods (1)
    gatherAnimations(node = this._tree.root) {
        let out = [];
        for (let i = 0, len = node.data.length; i < len; i++)
            if (node.data[i] instanceof viewer_shared_types_1.AnimationData)
                out.push(node.data[i]);
        for (let i = 0, len = node.children.length; i < len; i++)
            out = out.concat(this.gatherAnimations(node.children[i]));
        return out;
    }
}
exports.AnimationEngine = AnimationEngine;
//# sourceMappingURL=AnimationEngine.js.map

/***/ }),

/***/ 46560:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnimationEngine = void 0;
const AnimationEngine_1 = __webpack_require__(21955);
Object.defineProperty(exports, "AnimationEngine", ({ enumerable: true, get: function () { return AnimationEngine_1.AnimationEngine; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 57502:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AnimationFrameEngine_animationEngine, _AnimationFrameEngine_uuidGenerator;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnimationFrameEngine = void 0;
const TWEEN = __importStar(__webpack_require__(21417));
const viewer_shared_services_1 = __webpack_require__(8389);
const viewer_rendering_engine_animation_engine_1 = __webpack_require__(46560);
class AnimationFrameEngine {
    // #endregion Properties (5)
    // #region Constructors (1)
    constructor() {
        // #region Properties (5)
        _AnimationFrameEngine_animationEngine.set(this, viewer_rendering_engine_animation_engine_1.AnimationEngine.instance);
        _AnimationFrameEngine_uuidGenerator.set(this, viewer_shared_services_1.UuidGenerator.instance);
        this._animationFrameCallbacks = {};
        this._lastTime = 0;
        this.animate(0);
    }
    // #endregion Constructors (1)
    // #region Public Static Accessors (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    // #endregion Public Static Accessors (1)
    // #region Public Methods (2)
    addAnimationFrameCallback(cb) {
        const token = __classPrivateFieldGet(this, _AnimationFrameEngine_uuidGenerator, "f").create();
        this._animationFrameCallbacks[token] = cb;
        return token;
    }
    removeAnimationFrameCallback(token) {
        if (!this._animationFrameCallbacks[token])
            return false;
        delete this._animationFrameCallbacks[token];
        this._animationFrameCallbacks[token] = undefined;
        return true;
    }
    // #endregion Public Methods (2)
    // #region Private Methods (1)
    animate(time) {
        // animation loop - part 2: requesting and timings
        requestAnimationFrame((time) => this.animate(time));
        TWEEN.update(time);
        const deltaTime = time - this._lastTime < 0 ? 0 : time - this._lastTime;
        this._lastTime = time;
        const runningAnimation = __classPrivateFieldGet(this, _AnimationFrameEngine_animationEngine, "f").update(deltaTime);
        for (let a in this._animationFrameCallbacks)
            this._animationFrameCallbacks[a](time, deltaTime, runningAnimation);
    }
}
exports.AnimationFrameEngine = AnimationFrameEngine;
_AnimationFrameEngine_animationEngine = new WeakMap(), _AnimationFrameEngine_uuidGenerator = new WeakMap();
//# sourceMappingURL=AnimationFrameEngine.js.map

/***/ }),

/***/ 98476:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnimationFrameEngine = void 0;
const AnimationFrameEngine_1 = __webpack_require__(57502);
Object.defineProperty(exports, "AnimationFrameEngine", ({ enumerable: true, get: function () { return AnimationFrameEngine_1.AnimationFrameEngine; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 28839:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CameraEngine = void 0;
const AbstractCamera_1 = __webpack_require__(26153);
const viewer_shared_math_1 = __webpack_require__(67275);
const ICameraEngine_1 = __webpack_require__(23564);
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const IOrthographicCamera_1 = __webpack_require__(49578);
const OrthographicCamera_1 = __webpack_require__(36817);
const PerspectiveCamera_1 = __webpack_require__(80187);
const gl_matrix_1 = __webpack_require__(61961);
const viewer_shared_services_1 = __webpack_require__(8389);
class CameraEngine {
    // #endregion Properties (11)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (11)
        this._cameraNode = new viewer_shared_node_tree_1.TreeNode('cameras');
        this._cameras = {};
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._logger = viewer_shared_services_1.Logger.instance;
        this._stateEngine = viewer_shared_services_1.StateEngine.instance;
        this._tree = viewer_shared_node_tree_1.Tree.instance;
        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;
        this._camera = null;
        this._settingsApplied = false;
        this._boundingBox = new viewer_shared_math_1.Box();
        this._tree.root.addChild(this._cameraNode);
        this._cameraNode.restrictViewports = [this._renderingEngine.id];
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => {
            const viewerEvent = e;
            if (viewerEvent.viewportId === this._renderingEngine.id) {
                this._boundingBox = new viewer_shared_math_1.Box(viewerEvent.boundingBox.min, viewerEvent.boundingBox.max);
                const cameras = this.cameras;
                for (const c in cameras)
                    cameras[c].boundingBox = this._boundingBox.clone();
            }
        });
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.VIEWPORT.VIEWPORT_UPDATED, (e) => {
            const viewerEvent = e;
            if (viewerEvent.viewportId === this._renderingEngine.id) {
                this.searchForNewCameras();
            }
        });
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (4)
    get camera() {
        return this._camera;
    }
    get cameras() {
        return this._cameras;
    }
    get update() {
        return this._update;
    }
    set update(value) {
        this._update = value;
    }
    // #endregion Public Getters And Setters (4)
    // #region Public Methods (8)
    activateCameraEvents() {
        const cameras = this.cameras;
        for (const c in cameras)
            cameras[c].controls.cameraControlsEventDistribution.activateCameraEvents();
    }
    applySettings(settingsEngine) {
        const cameras = this.cameras;
        for (const c in cameras)
            this.removeCamera(c);
        for (const id in settingsEngine.settings.camera.cameras) {
            const cameraSetting = settingsEngine.settings.camera.cameras[id];
            if (cameraSetting.type === 'perspective') {
                this.createCamera(ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE, id);
            }
            else {
                const camera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, id);
                camera.direction = cameraSetting.type;
            }
        }
        for (const c in cameras)
            cameras[c].applySettings(settingsEngine);
        const cameraKeys = Object.keys(settingsEngine.settings.camera.cameras);
        if (cameraKeys.length > 0) {
            if (!settingsEngine.settings.camera.cameraId) {
                this.assignCamera(cameraKeys[0]);
            }
            else {
                this.assignCamera(settingsEngine.settings.camera.cameraId);
            }
        }
        else {
            this.createDefaultCameras();
            this.camera.applySettings(settingsEngine);
        }
        this._settingsApplied = true;
        if (this._update)
            this._update();
    }
    assignCamera(id) {
        const camera = this.cameras[id];
        if (!camera)
            return false;
        for (const c in this.cameras)
            this.cameras[c].active = false;
        this._camera = camera;
        this._camera.active = true;
        return true;
    }
    createCamera(type, id, isDefault = false) {
        const cameras = this.cameras;
        const cameraId = id || this._uuidGenerator.create();
        if (cameras[cameraId])
            throw new viewer_shared_services_1.ShapeDiverViewerCameraError(`CameraEngine.createCamera: Camera (${type}) with this id (${cameraId}) already exists.`);
        const initialAspectRatio = this._renderingEngine.canvas.parentNode.clientWidth / this._renderingEngine.canvas.parentNode.clientHeight;
        const camera = ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE === type ? new PerspectiveCamera_1.PerspectiveCamera(cameraId, undefined, initialAspectRatio, isDefault) : new OrthographicCamera_1.OrthographicCamera(cameraId, undefined, isDefault);
        camera.assignViewer(this._renderingEngine);
        cameras[cameraId] = camera;
        if (this._settingsApplied && this._renderingEngine.settingsEngine) {
            camera.applySettings(this._renderingEngine.settingsEngine);
        }
        else {
            camera.zoomTo(undefined, { duration: 0 });
        }
        this._cameraNode.addData(camera);
        if (this._update)
            this._update();
        return camera;
    }
    createDefaultCameras() {
        const topCamera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, 'top', true);
        topCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP;
        const bottomCamera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, 'bottom', true);
        bottomCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM;
        const leftCamera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, 'left', true);
        leftCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT;
        const rightCamera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, 'right', true);
        rightCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT;
        const frontCamera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, 'front', true);
        frontCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT;
        const backCamera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, 'back', true);
        backCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK;
        this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, 'orthographic');
        const camera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE, 'perspective');
        this.assignCamera(camera.id);
    }
    deactivateCameraEvents() {
        const cameras = this.cameras;
        for (const c in cameras)
            cameras[c].controls.cameraControlsEventDistribution.deactivateCameraEvents();
    }
    removeCamera(id) {
        const cameras = this.cameras;
        const camera = cameras[id];
        if (!camera)
            return false;
        if (camera.domEventListenerToken)
            this._renderingEngine.domEventEngine.removeDomEventListener(camera.domEventListenerToken);
        if (this._camera && this._camera.id === id)
            this._camera = null;
        delete cameras[id];
        this._cameraNode.removeData(camera);
        if (this._update)
            this._update();
        return true;
    }
    saveSettings(settingsEngine) {
        settingsEngine.settings.camera.cameraId = this._camera ? this._camera.id : 'perspective';
        settingsEngine.settings.camera.cameras = {};
        for (const c in this.cameras) {
            const camera = this.cameras[c];
            if (camera.type === ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE) {
                const controls = camera.controls;
                settingsEngine.camera.cameras[camera.id] = {
                    name: camera.name,
                    autoAdjust: camera.autoAdjust,
                    cameraMovementDuration: camera.cameraMovementDuration,
                    enableCameraControls: camera.enableCameraControls,
                    revertAtMouseUp: camera.revertAtMouseUp,
                    revertAtMouseUpDuration: camera.revertAtMouseUpDuration,
                    zoomExtentsFactor: camera.zoomExtentsFactor,
                    position: { x: camera.defaultPosition[0], y: camera.defaultPosition[1], z: camera.defaultPosition[2] },
                    target: { x: camera.defaultTarget[0], y: camera.defaultTarget[1], z: camera.defaultTarget[2] },
                    type: camera.type,
                    fov: camera.fov,
                    sceneRotation: { x: camera.sceneRotation[0], y: camera.sceneRotation[1] },
                    controls: {
                        autoRotationSpeed: controls.autoRotationSpeed,
                        damping: controls.damping,
                        enableAutoRotation: controls.enableAutoRotation,
                        enableKeyPan: controls.enableKeyPan,
                        enablePan: controls.enablePan,
                        enableRotation: controls.enableRotation,
                        enableZoom: controls.enableZoom,
                        input: controls.input,
                        keyPanSpeed: controls.keyPanSpeed,
                        movementSmoothness: controls.movementSmoothness,
                        rotationSpeed: controls.rotationSpeed,
                        panSpeed: controls.panSpeed,
                        zoomSpeed: controls.zoomSpeed,
                        restrictions: {
                            position: {
                                cube: {
                                    min: { x: controls.cubePositionRestriction.min[0], y: controls.cubePositionRestriction.min[1], z: controls.cubePositionRestriction.min[2] },
                                    max: { x: controls.cubePositionRestriction.max[0], y: controls.cubePositionRestriction.max[1], z: controls.cubePositionRestriction.max[2] },
                                },
                                sphere: {
                                    center: { x: controls.spherePositionRestriction.center[0], y: controls.spherePositionRestriction.center[1], z: controls.spherePositionRestriction.center[2] },
                                    radius: controls.spherePositionRestriction.radius,
                                },
                            },
                            target: {
                                cube: {
                                    min: { x: controls.cubeTargetRestriction.min[0], y: controls.cubeTargetRestriction.min[1], z: controls.cubeTargetRestriction.min[2] },
                                    max: { x: controls.cubeTargetRestriction.max[0], y: controls.cubeTargetRestriction.max[1], z: controls.cubeTargetRestriction.max[2] },
                                },
                                sphere: {
                                    center: { x: controls.sphereTargetRestriction.center[0], y: controls.sphereTargetRestriction.center[1], z: controls.sphereTargetRestriction.center[2] },
                                    radius: controls.sphereTargetRestriction.radius,
                                },
                            },
                            rotation: controls.rotationRestriction,
                            zoom: controls.zoomRestriction,
                        },
                        enableAzimuthRotation: controls.enableAzimuthRotation,
                        enablePolarRotation: controls.enablePolarRotation,
                        enableObjectControls: controls.enableObjectControls,
                        enableTurntableControls: controls.enableTurntableControls,
                        turntableCenter: { x: controls.turntableCenter[0], y: controls.turntableCenter[1], z: controls.turntableCenter[2] },
                        objectControlsCenter: { x: controls.objectControlsCenter[0], y: controls.objectControlsCenter[1], z: controls.objectControlsCenter[2] },
                    }
                };
            }
            else {
                if (settingsEngine.camera.cameras[camera.id]) {
                    const previousDirection = settingsEngine.camera.cameras[camera.id].type;
                    // if the direction changed, but the default position & target did not, there is an issue
                    if (previousDirection !== camera.type && (settingsEngine.camera.cameras[camera.id].position.x === camera.defaultPosition[0] &&
                        settingsEngine.camera.cameras[camera.id].position.y === camera.defaultPosition[1] &&
                        settingsEngine.camera.cameras[camera.id].position.z === camera.defaultPosition[2] &&
                        settingsEngine.camera.cameras[camera.id].target.x === camera.defaultTarget[0] &&
                        settingsEngine.camera.cameras[camera.id].target.y === camera.defaultTarget[1] &&
                        settingsEngine.camera.cameras[camera.id].target.z === camera.defaultTarget[2])) {
                        camera.defaultPosition = gl_matrix_1.vec3.clone(camera.position);
                        camera.defaultTarget = gl_matrix_1.vec3.clone(camera.target);
                    }
                }
                const controls = camera.controls;
                settingsEngine.camera.cameras[camera.id] = {
                    name: camera.name,
                    autoAdjust: camera.autoAdjust,
                    cameraMovementDuration: camera.cameraMovementDuration,
                    enableCameraControls: camera.enableCameraControls,
                    revertAtMouseUp: camera.revertAtMouseUp,
                    revertAtMouseUpDuration: camera.revertAtMouseUpDuration,
                    zoomExtentsFactor: camera.zoomExtentsFactor,
                    position: { x: camera.defaultPosition[0], y: camera.defaultPosition[1], z: camera.defaultPosition[2] },
                    target: { x: camera.defaultTarget[0], y: camera.defaultTarget[1], z: camera.defaultTarget[2] },
                    type: camera.direction,
                    sceneRotation: { x: camera.sceneRotation[0], y: camera.sceneRotation[1] },
                    controls: {
                        autoRotationSpeed: controls.autoRotationSpeed,
                        damping: controls.damping,
                        enableAutoRotation: controls.enableAutoRotation,
                        enableKeyPan: controls.enableKeyPan,
                        enablePan: controls.enablePan,
                        enableRotation: controls.enableRotation,
                        enableZoom: controls.enableZoom,
                        input: controls.input,
                        keyPanSpeed: controls.keyPanSpeed,
                        movementSmoothness: controls.movementSmoothness,
                        rotationSpeed: controls.rotationSpeed,
                        panSpeed: controls.panSpeed,
                        zoomSpeed: controls.zoomSpeed,
                        restrictions: {
                            position: {
                                cube: {
                                    min: { x: controls.cubePositionRestriction.min[0], y: controls.cubePositionRestriction.min[1], z: controls.cubePositionRestriction.min[2] },
                                    max: { x: controls.cubePositionRestriction.max[0], y: controls.cubePositionRestriction.max[1], z: controls.cubePositionRestriction.max[2] },
                                },
                                sphere: {
                                    center: { x: controls.spherePositionRestriction.center[0], y: controls.spherePositionRestriction.center[1], z: controls.spherePositionRestriction.center[2] },
                                    radius: controls.spherePositionRestriction.radius,
                                },
                            },
                            target: {
                                cube: {
                                    min: { x: controls.cubeTargetRestriction.min[0], y: controls.cubeTargetRestriction.min[1], z: controls.cubeTargetRestriction.min[2] },
                                    max: { x: controls.cubeTargetRestriction.max[0], y: controls.cubeTargetRestriction.max[1], z: controls.cubeTargetRestriction.max[2] },
                                },
                                sphere: {
                                    center: { x: controls.sphereTargetRestriction.center[0], y: controls.sphereTargetRestriction.center[1], z: controls.sphereTargetRestriction.center[2] },
                                    radius: controls.sphereTargetRestriction.radius,
                                },
                            },
                            rotation: controls.rotationRestriction,
                            zoom: controls.zoomRestriction,
                        },
                        enableAzimuthRotation: controls.enableAzimuthRotation,
                        enablePolarRotation: controls.enablePolarRotation,
                        enableObjectControls: controls.enableObjectControls,
                        enableTurntableControls: controls.enableTurntableControls,
                        turntableCenter: { x: controls.turntableCenter[0], y: controls.turntableCenter[1], z: controls.turntableCenter[2] },
                        objectControlsCenter: { x: controls.objectControlsCenter[0], y: controls.objectControlsCenter[1], z: controls.objectControlsCenter[2] },
                    }
                };
            }
        }
    }
    // #endregion Public Methods (8)
    // #region Private Methods (1)
    searchForNewCameras() {
        const getCameraData = (node) => {
            for (let i = 0; i < node.data.length; i++)
                if ((node.data[i] instanceof AbstractCamera_1.AbstractCamera) && !this._cameras[node.data[i].id]) {
                    const camera = node.data[i];
                    if (camera.viewportId === this._renderingEngine.id)
                        this._cameras[camera.id] = camera;
                }
            for (let i = 0; i < node.children.length; i++)
                getCameraData(node.children[i]);
        };
        getCameraData(this._tree.root);
        if (this._update)
            this._update();
    }
}
exports.CameraEngine = CameraEngine;
//# sourceMappingURL=CameraEngine.js.map

/***/ }),

/***/ 26153:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _AbstractCamera_active, _AbstractCamera_autoAdjust, _AbstractCamera_cameraMovementDuration, _AbstractCamera_defaultPosition, _AbstractCamera_defaultTarget, _AbstractCamera_domEventListenerToken, _AbstractCamera_enableCameraControls, _AbstractCamera_far, _AbstractCamera_name, _AbstractCamera_near, _AbstractCamera_node, _AbstractCamera_order, _AbstractCamera_revertAtMouseUp, _AbstractCamera_revertAtMouseUpDuration, _AbstractCamera_sceneRotation, _AbstractCamera_useNodeData, _AbstractCamera_zoomExtentsFactor;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractCamera = void 0;
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const viewer_shared_math_1 = __webpack_require__(67275);
const gl_matrix_1 = __webpack_require__(61961);
const viewer_shared_services_1 = __webpack_require__(8389);
class AbstractCamera extends viewer_shared_node_tree_1.AbstractTreeNodeData {
    // #endregion Properties (24)
    // #region Constructors (1)
    constructor(_id, _type, version, _isDefault = false) {
        super(_id, version);
        this._id = _id;
        this._type = _type;
        this._isDefault = _isDefault;
        // #region Properties (24)
        _AbstractCamera_active.set(this, false);
        _AbstractCamera_autoAdjust.set(this, true);
        _AbstractCamera_cameraMovementDuration.set(this, 800);
        _AbstractCamera_defaultPosition.set(this, gl_matrix_1.vec3.create());
        _AbstractCamera_defaultTarget.set(this, gl_matrix_1.vec3.create());
        _AbstractCamera_domEventListenerToken.set(this, void 0);
        _AbstractCamera_enableCameraControls.set(this, true);
        _AbstractCamera_far.set(this, 1000);
        _AbstractCamera_name.set(this, void 0);
        _AbstractCamera_near.set(this, 1);
        _AbstractCamera_node.set(this, void 0);
        _AbstractCamera_order.set(this, void 0);
        _AbstractCamera_revertAtMouseUp.set(this, false);
        _AbstractCamera_revertAtMouseUpDuration.set(this, 800);
        _AbstractCamera_sceneRotation.set(this, gl_matrix_1.vec2.create());
        _AbstractCamera_useNodeData.set(this, false);
        _AbstractCamera_zoomExtentsFactor.set(this, 1);
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._stateEngine = viewer_shared_services_1.StateEngine.instance;
        this._boundingBox = new viewer_shared_math_1.Box();
        this._position = gl_matrix_1.vec3.create();
        this._target = gl_matrix_1.vec3.create();
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (43)
    get active() {
        return __classPrivateFieldGet(this, _AbstractCamera_active, "f");
    }
    set active(value) {
        __classPrivateFieldSet(this, _AbstractCamera_active, value, "f");
    }
    get autoAdjust() {
        return __classPrivateFieldGet(this, _AbstractCamera_autoAdjust, "f");
    }
    set autoAdjust(value) {
        __classPrivateFieldSet(this, _AbstractCamera_autoAdjust, value, "f");
    }
    set boundingBox(value) {
        this._boundingBox = value;
    }
    get cameraMovementDuration() {
        return __classPrivateFieldGet(this, _AbstractCamera_cameraMovementDuration, "f");
    }
    set cameraMovementDuration(value) {
        __classPrivateFieldSet(this, _AbstractCamera_cameraMovementDuration, value, "f");
    }
    get controls() {
        return this._controls;
    }
    get defaultPosition() {
        return __classPrivateFieldGet(this, _AbstractCamera_defaultPosition, "f");
    }
    set defaultPosition(value) {
        __classPrivateFieldSet(this, _AbstractCamera_defaultPosition, value, "f");
    }
    get defaultTarget() {
        return __classPrivateFieldGet(this, _AbstractCamera_defaultTarget, "f");
    }
    set defaultTarget(value) {
        __classPrivateFieldSet(this, _AbstractCamera_defaultTarget, value, "f");
    }
    get domEventListenerToken() {
        return __classPrivateFieldGet(this, _AbstractCamera_domEventListenerToken, "f");
    }
    set domEventListenerToken(value) {
        __classPrivateFieldSet(this, _AbstractCamera_domEventListenerToken, value, "f");
    }
    get enableCameraControls() {
        return __classPrivateFieldGet(this, _AbstractCamera_enableCameraControls, "f");
    }
    set enableCameraControls(value) {
        __classPrivateFieldSet(this, _AbstractCamera_enableCameraControls, value, "f");
    }
    get far() {
        return __classPrivateFieldGet(this, _AbstractCamera_far, "f");
    }
    set far(value) {
        __classPrivateFieldSet(this, _AbstractCamera_far, value, "f");
    }
    get id() {
        return this._id;
    }
    get isDefault() {
        return this._isDefault;
    }
    get name() {
        return __classPrivateFieldGet(this, _AbstractCamera_name, "f");
    }
    set name(value) {
        __classPrivateFieldSet(this, _AbstractCamera_name, value, "f");
    }
    get near() {
        return __classPrivateFieldGet(this, _AbstractCamera_near, "f");
    }
    set near(value) {
        __classPrivateFieldSet(this, _AbstractCamera_near, value, "f");
    }
    get node() {
        return __classPrivateFieldGet(this, _AbstractCamera_node, "f");
    }
    set node(value) {
        __classPrivateFieldSet(this, _AbstractCamera_node, value, "f");
    }
    get order() {
        return __classPrivateFieldGet(this, _AbstractCamera_order, "f");
    }
    set order(value) {
        __classPrivateFieldSet(this, _AbstractCamera_order, value, "f");
    }
    get position() {
        return this._position;
    }
    set position(value) {
        this._position = value;
        this._controls.position = value;
    }
    get revertAtMouseUp() {
        return __classPrivateFieldGet(this, _AbstractCamera_revertAtMouseUp, "f");
    }
    set revertAtMouseUp(value) {
        __classPrivateFieldSet(this, _AbstractCamera_revertAtMouseUp, value, "f");
    }
    get revertAtMouseUpDuration() {
        return __classPrivateFieldGet(this, _AbstractCamera_revertAtMouseUpDuration, "f");
    }
    set revertAtMouseUpDuration(value) {
        __classPrivateFieldSet(this, _AbstractCamera_revertAtMouseUpDuration, value, "f");
    }
    get sceneRotation() {
        return __classPrivateFieldGet(this, _AbstractCamera_sceneRotation, "f");
    }
    set sceneRotation(value) {
        __classPrivateFieldSet(this, _AbstractCamera_sceneRotation, value, "f");
    }
    get target() {
        return this._target;
    }
    set target(value) {
        this._target = value;
        this._controls.target = value;
    }
    get type() {
        return this._type;
    }
    get useNodeData() {
        return __classPrivateFieldGet(this, _AbstractCamera_useNodeData, "f");
    }
    set useNodeData(value) {
        __classPrivateFieldSet(this, _AbstractCamera_useNodeData, value, "f");
    }
    get viewportId() {
        return this._viewportId;
    }
    get zoomExtentsFactor() {
        return __classPrivateFieldGet(this, _AbstractCamera_zoomExtentsFactor, "f");
    }
    set zoomExtentsFactor(value) {
        __classPrivateFieldSet(this, _AbstractCamera_zoomExtentsFactor, value, "f");
    }
    // #endregion Public Getters And Setters (43)
    // #region Public Methods (5)
    animate(path, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (path.length === 0)
                return Promise.resolve(false);
            if (!options)
                options = {};
            options.duration = options.duration >= 0 ? options.duration : this.cameraMovementDuration;
            const res = yield this._controls.animate(path, options);
            if (res) {
                this._position = this._controls.position;
                this._target = this._controls.target;
            }
            return res;
        });
    }
    reset(options) {
        if ((this.defaultPosition[0] === 0 && this.defaultPosition[1] === 0 && this.defaultPosition[2] === 0) && (this.defaultTarget[0] === 0 && this.defaultTarget[1] === 0 && this.defaultTarget[2] === 0)) {
            return this.zoomTo(undefined, options);
        }
        else {
            return this.set(gl_matrix_1.vec3.clone(this.defaultPosition), gl_matrix_1.vec3.clone(this.defaultTarget), options);
        }
    }
    set(position, target, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options)
                options = {};
            options.duration = options.duration >= 0 ? options.duration : this.cameraMovementDuration;
            const res = yield this._controls.animate([
                { position: gl_matrix_1.vec3.clone(this.position), target: gl_matrix_1.vec3.clone(this.target) },
                { position, target }
            ], options);
            if (res) {
                this._position = this._controls.position;
                this._target = this._controls.target;
            }
            return res;
        });
    }
    update(time) {
        if (this.useNodeData && this.node && this._viewportId) {
            return true;
        }
        else {
            const { position, target, sceneRotation } = this._controls.update(time);
            let changed = true;
            if (gl_matrix_1.vec3.equals(position, this.position) && gl_matrix_1.vec3.equals(target, this.target))
                changed = false;
            this.position = gl_matrix_1.vec3.clone(position);
            this.target = gl_matrix_1.vec3.clone(target);
            this.sceneRotation = gl_matrix_1.vec2.clone(sceneRotation);
            return changed;
        }
    }
    zoomTo(zoomTarget, options) {
        const { position, target } = this.calculateZoomTo(zoomTarget);
        return this.set(position, target, options);
    }
    // #endregion Public Abstract Methods (5)
    // #region Protected Methods (1)
    assignViewerInternal(viewportId) {
        this._viewportId = viewportId;
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.SESSION.SESSION_CUSTOMIZED, () => __awaiter(this, void 0, void 0, function* () {
            if (__classPrivateFieldGet(this, _AbstractCamera_autoAdjust, "f") === true) {
                const innerListenerToken = this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.VIEWPORT.VIEWPORT_UPDATED, () => __awaiter(this, void 0, void 0, function* () {
                    this.zoomTo();
                    this._eventEngine.removeListener(innerListenerToken);
                }));
            }
        }));
    }
}
exports.AbstractCamera = AbstractCamera;
_AbstractCamera_active = new WeakMap(), _AbstractCamera_autoAdjust = new WeakMap(), _AbstractCamera_cameraMovementDuration = new WeakMap(), _AbstractCamera_defaultPosition = new WeakMap(), _AbstractCamera_defaultTarget = new WeakMap(), _AbstractCamera_domEventListenerToken = new WeakMap(), _AbstractCamera_enableCameraControls = new WeakMap(), _AbstractCamera_far = new WeakMap(), _AbstractCamera_name = new WeakMap(), _AbstractCamera_near = new WeakMap(), _AbstractCamera_node = new WeakMap(), _AbstractCamera_order = new WeakMap(), _AbstractCamera_revertAtMouseUp = new WeakMap(), _AbstractCamera_revertAtMouseUpDuration = new WeakMap(), _AbstractCamera_sceneRotation = new WeakMap(), _AbstractCamera_useNodeData = new WeakMap(), _AbstractCamera_zoomExtentsFactor = new WeakMap();
//# sourceMappingURL=AbstractCamera.js.map

/***/ }),

/***/ 36817:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _OrthographicCamera_converter, _OrthographicCamera_logger, _OrthographicCamera_tree, _OrthographicCamera_bottom, _OrthographicCamera_direction, _OrthographicCamera_domEventEngine, _OrthographicCamera_left, _OrthographicCamera_right, _OrthographicCamera_top, _OrthographicCamera_up;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrthographicCamera = void 0;
const AbstractCamera_1 = __webpack_require__(26153);
const ICameraEngine_1 = __webpack_require__(23564);
const IOrthographicCamera_1 = __webpack_require__(49578);
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const gl_matrix_1 = __webpack_require__(61961);
const OrthographicCameraControls_1 = __webpack_require__(45080);
const viewer_shared_services_1 = __webpack_require__(8389);
class OrthographicCamera extends AbstractCamera_1.AbstractCamera {
    // #endregion Properties (11)
    // #region Constructors (1)
    constructor(id, version, isDefault = false) {
        super(id, ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, version, isDefault);
        // #region Properties (11)
        _OrthographicCamera_converter.set(this, viewer_shared_services_1.Converter.instance);
        _OrthographicCamera_logger.set(this, viewer_shared_services_1.Logger.instance);
        _OrthographicCamera_tree.set(this, viewer_shared_node_tree_1.Tree.instance);
        _OrthographicCamera_bottom.set(this, -100);
        _OrthographicCamera_direction.set(this, IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.CUSTOM);
        _OrthographicCamera_domEventEngine.set(this, void 0);
        _OrthographicCamera_left.set(this, -100);
        _OrthographicCamera_right.set(this, 100);
        _OrthographicCamera_top.set(this, 100);
        _OrthographicCamera_up.set(this, gl_matrix_1.vec3.fromValues(0, 0, 1));
        this._controls = new OrthographicCameraControls_1.OrthographicCameraControls(this, true);
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (14)
    get bottom() {
        return __classPrivateFieldGet(this, _OrthographicCamera_bottom, "f");
    }
    set bottom(value) {
        __classPrivateFieldSet(this, _OrthographicCamera_bottom, value, "f");
    }
    get controls() {
        return this._controls;
    }
    set controls(value) {
        this._controls = value;
    }
    get direction() {
        return __classPrivateFieldGet(this, _OrthographicCamera_direction, "f");
    }
    set direction(value) {
        const changedDirection = __classPrivateFieldGet(this, _OrthographicCamera_direction, "f") !== value;
        __classPrivateFieldSet(this, _OrthographicCamera_direction, value, "f");
        switch (__classPrivateFieldGet(this, _OrthographicCamera_direction, "f")) {
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP:
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM:
                this.up = gl_matrix_1.vec3.fromValues(0, 1, 0);
                break;
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT:
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT:
                this.up = gl_matrix_1.vec3.fromValues(0, 0, 1);
                break;
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK:
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT:
                this.up = gl_matrix_1.vec3.fromValues(0, 0, 1);
                break;
            default:
                this.up = gl_matrix_1.vec3.fromValues(0, 0, 1);
        }
        if (changedDirection) {
            const { position, target } = this.calculateZoomTo(undefined);
            this.defaultPosition = gl_matrix_1.vec3.clone(position);
            this.defaultTarget = gl_matrix_1.vec3.clone(target);
            this.position = gl_matrix_1.vec3.clone(position);
            this.target = gl_matrix_1.vec3.clone(target);
        }
    }
    get left() {
        return __classPrivateFieldGet(this, _OrthographicCamera_left, "f");
    }
    set left(value) {
        __classPrivateFieldSet(this, _OrthographicCamera_left, value, "f");
    }
    get right() {
        return __classPrivateFieldGet(this, _OrthographicCamera_right, "f");
    }
    set right(value) {
        __classPrivateFieldSet(this, _OrthographicCamera_right, value, "f");
    }
    get top() {
        return __classPrivateFieldGet(this, _OrthographicCamera_top, "f");
    }
    set top(value) {
        __classPrivateFieldSet(this, _OrthographicCamera_top, value, "f");
    }
    get up() {
        return __classPrivateFieldGet(this, _OrthographicCamera_up, "f");
    }
    set up(value) {
        __classPrivateFieldSet(this, _OrthographicCamera_up, value, "f");
    }
    // #endregion Public Getters And Setters (14)
    // #region Public Methods (6)
    applySettings(settingsEngine) {
        var _a;
        const cameraSetting = settingsEngine.camera.cameras[this.id];
        if (cameraSetting) {
            this.name = cameraSetting.name;
            this.autoAdjust = cameraSetting.autoAdjust;
            this.cameraMovementDuration = cameraSetting.cameraMovementDuration;
            this.enableCameraControls = cameraSetting.enableCameraControls;
            this.revertAtMouseUp = cameraSetting.revertAtMouseUp;
            this.revertAtMouseUpDuration = cameraSetting.revertAtMouseUpDuration;
            this.sceneRotation = gl_matrix_1.vec2.fromValues(cameraSetting.sceneRotation.x, cameraSetting.sceneRotation.y);
            this.zoomExtentsFactor = cameraSetting.zoomExtentsFactor;
            const position = __classPrivateFieldGet(this, _OrthographicCamera_converter, "f").toVec3(cameraSetting.position);
            const target = __classPrivateFieldGet(this, _OrthographicCamera_converter, "f").toVec3(cameraSetting.target);
            this.defaultPosition = gl_matrix_1.vec3.clone(position);
            this.defaultTarget = gl_matrix_1.vec3.clone(target);
            this.position = position;
            this.target = target;
        }
        if (this.position[0] === this.target[0] && this.position[1] === this.target[1] && this.position[2] === this.target[2]) {
            if (this._viewportId) {
                (_a = this._stateEngine.viewportEngines[this._viewportId]) === null || _a === void 0 ? void 0 : _a.boundingBoxCreated.then(() => __awaiter(this, void 0, void 0, function* () {
                    yield this.zoomTo(undefined, { duration: 0 });
                    this.defaultPosition = gl_matrix_1.vec3.clone(this._controls.position);
                    this.defaultTarget = gl_matrix_1.vec3.clone(this._controls.target);
                }));
            }
        }
        this._controls.applySettings(settingsEngine);
    }
    assignViewer(renderingEngine) {
        var _a;
        if (renderingEngine.closed)
            throw new viewer_shared_services_1.ShapeDiverViewerCameraError(`OrthographicCamera(${this.id}).assignViewer: Viewer with id ${renderingEngine.id} not found.`);
        this.assignViewerInternal(renderingEngine.id);
        this._controls.assignViewer(renderingEngine.id, renderingEngine.canvas);
        if (this.domEventListenerToken && __classPrivateFieldGet(this, _OrthographicCamera_domEventEngine, "f"))
            __classPrivateFieldGet(this, _OrthographicCamera_domEventEngine, "f").removeDomEventListener(this.domEventListenerToken);
        __classPrivateFieldSet(this, _OrthographicCamera_domEventEngine, renderingEngine.domEventEngine, "f");
        this.domEventListenerToken = __classPrivateFieldGet(this, _OrthographicCamera_domEventEngine, "f").addDomEventListener(this._controls.cameraControlsEventDistribution);
        this.boundingBox = __classPrivateFieldGet(this, _OrthographicCamera_tree, "f").root.boundingBox.clone();
        (_a = this._stateEngine.viewportEngines[renderingEngine.id]) === null || _a === void 0 ? void 0 : _a.boundingBoxCreated.then(() => __awaiter(this, void 0, void 0, function* () {
            if (this.position[0] === this.target[0] && this.position[1] === this.target[1] && this.position[2] === this.target[2])
                yield this.zoomTo(undefined, { duration: 0 });
        }));
    }
    calculateZoomTo(zoomTarget, startingPosition = this.position, startingTarget = this.target) {
        let box;
        // Part 1 - calculate the bounding box that we should zoom to
        if (!zoomTarget) {
            // complete scene
            box = this._boundingBox.clone();
        }
        else {
            // specified Box
            box = zoomTarget.clone();
        }
        if (box.isEmpty())
            return { position: gl_matrix_1.vec3.create(), target: gl_matrix_1.vec3.create() };
        const target = gl_matrix_1.vec3.fromValues((box.max[0] + box.min[0]) / 2, (box.max[1] + box.min[1]) / 2, (box.max[2] + box.min[2]) / 2);
        if (startingPosition[0] === startingTarget[0] && startingPosition[1] === startingTarget[1] && startingPosition[2] === startingTarget[2])
            startingPosition = gl_matrix_1.vec3.fromValues(target[0], target[1] - 7.5, target[2] + 5);
        const factor = 2 * box.boundingSphere.radius * this.zoomExtentsFactor;
        switch (__classPrivateFieldGet(this, _OrthographicCamera_direction, "f")) {
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP:
                return {
                    position: gl_matrix_1.vec3.fromValues(target[0], target[1], target[2] + factor),
                    target: gl_matrix_1.vec3.clone(target)
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM:
                return {
                    position: gl_matrix_1.vec3.fromValues(target[0], target[1], target[2] - factor),
                    target: gl_matrix_1.vec3.clone(target)
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT:
                return {
                    position: gl_matrix_1.vec3.fromValues(target[0] + factor, target[1], target[2]),
                    target: gl_matrix_1.vec3.clone(target)
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT:
                return {
                    position: gl_matrix_1.vec3.fromValues(target[0] - factor, target[1], target[2]),
                    target: gl_matrix_1.vec3.clone(target)
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK:
                return {
                    position: gl_matrix_1.vec3.fromValues(target[0], target[1] + factor, target[2]),
                    target: gl_matrix_1.vec3.clone(target)
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT:
                return {
                    position: gl_matrix_1.vec3.fromValues(target[0], target[1] - factor, target[2]),
                    target: gl_matrix_1.vec3.clone(target)
                };
            default:
                {
                    // get the direction from the starting position to the starting target
                    const direction = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), startingPosition, target);
                    // normalize the direction
                    gl_matrix_1.vec3.normalize(direction, direction);
                    // get the new position
                    return {
                        position: gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), target, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), direction, factor)),
                        target: gl_matrix_1.vec3.clone(target)
                    };
                }
        }
    }
    clone() {
        return new OrthographicCamera(this.id, this.version);
    }
    project(pos) {
        const m = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), this.position, this.target, this.up);
        const p = gl_matrix_1.mat4.ortho(gl_matrix_1.mat4.create(), this.left, this.right, this.bottom, this.top, this.near, this.far);
        let inverse = gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), m);
        if (!inverse)
            inverse = gl_matrix_1.mat4.create();
        gl_matrix_1.vec3.transformMat4(pos, pos, inverse);
        gl_matrix_1.vec3.transformMat4(pos, pos, p);
        return gl_matrix_1.vec2.fromValues(pos[0], pos[1]);
    }
    unproject(pos) {
        const m = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), this.position, this.target, this.up);
        const p = gl_matrix_1.mat4.ortho(gl_matrix_1.mat4.create(), this.left, this.right, this.bottom, this.top, this.near, this.far);
        let inverse = gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), p);
        if (!inverse)
            inverse = gl_matrix_1.mat4.create();
        gl_matrix_1.vec3.transformMat4(pos, pos, inverse);
        gl_matrix_1.vec3.transformMat4(pos, pos, m);
        return gl_matrix_1.vec3.clone(pos);
    }
}
exports.OrthographicCamera = OrthographicCamera;
_OrthographicCamera_converter = new WeakMap(), _OrthographicCamera_logger = new WeakMap(), _OrthographicCamera_tree = new WeakMap(), _OrthographicCamera_bottom = new WeakMap(), _OrthographicCamera_direction = new WeakMap(), _OrthographicCamera_domEventEngine = new WeakMap(), _OrthographicCamera_left = new WeakMap(), _OrthographicCamera_right = new WeakMap(), _OrthographicCamera_top = new WeakMap(), _OrthographicCamera_up = new WeakMap();
//# sourceMappingURL=OrthographicCamera.js.map

/***/ }),

/***/ 80187:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PerspectiveCamera_converter, _PerspectiveCamera_tree, _PerspectiveCamera_aspect, _PerspectiveCamera_domEventEngine, _PerspectiveCamera_fov;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PerspectiveCamera = void 0;
const AbstractCamera_1 = __webpack_require__(26153);
const viewer_shared_math_1 = __webpack_require__(67275);
const ICameraEngine_1 = __webpack_require__(23564);
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const gl_matrix_1 = __webpack_require__(61961);
const PerspectiveCameraControls_1 = __webpack_require__(85092);
const viewer_shared_services_1 = __webpack_require__(8389);
class PerspectiveCamera extends AbstractCamera_1.AbstractCamera {
    // #endregion Properties (6)
    // #region Constructors (1)
    constructor(id, version, initialAspect, isDefault = false) {
        super(id, ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE, version, isDefault);
        // #region Properties (6)
        _PerspectiveCamera_converter.set(this, viewer_shared_services_1.Converter.instance);
        _PerspectiveCamera_tree.set(this, viewer_shared_node_tree_1.Tree.instance);
        _PerspectiveCamera_aspect.set(this, void 0);
        _PerspectiveCamera_domEventEngine.set(this, void 0);
        _PerspectiveCamera_fov.set(this, 60);
        __classPrivateFieldSet(this, _PerspectiveCamera_aspect, initialAspect, "f");
        this._controls = new PerspectiveCameraControls_1.PerspectiveCameraControls(this, true);
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (6)
    get aspect() {
        return __classPrivateFieldGet(this, _PerspectiveCamera_aspect, "f");
    }
    set aspect(value) {
        __classPrivateFieldSet(this, _PerspectiveCamera_aspect, value, "f");
    }
    get controls() {
        return this._controls;
    }
    set controls(value) {
        this._controls = value;
    }
    get fov() {
        return __classPrivateFieldGet(this, _PerspectiveCamera_fov, "f");
    }
    set fov(value) {
        __classPrivateFieldSet(this, _PerspectiveCamera_fov, value, "f");
    }
    // #endregion Public Getters And Setters (6)
    // #region Public Methods (6)
    applySettings(settingsEngine) {
        var _a;
        const cameraSetting = settingsEngine.camera.cameras[this.id];
        if (cameraSetting) {
            this.name = cameraSetting.name;
            this.autoAdjust = cameraSetting.autoAdjust;
            this.cameraMovementDuration = cameraSetting.cameraMovementDuration;
            this.enableCameraControls = cameraSetting.enableCameraControls;
            this.revertAtMouseUp = cameraSetting.revertAtMouseUp;
            this.revertAtMouseUpDuration = cameraSetting.revertAtMouseUpDuration;
            this.sceneRotation = gl_matrix_1.vec2.fromValues(cameraSetting.sceneRotation.x, cameraSetting.sceneRotation.y);
            this.zoomExtentsFactor = cameraSetting.zoomExtentsFactor;
            const position = __classPrivateFieldGet(this, _PerspectiveCamera_converter, "f").toVec3(cameraSetting.position);
            const target = __classPrivateFieldGet(this, _PerspectiveCamera_converter, "f").toVec3(cameraSetting.target);
            this.defaultPosition = gl_matrix_1.vec3.clone(position);
            this.defaultTarget = gl_matrix_1.vec3.clone(target);
            this.position = position;
            this.target = target;
            this.fov = cameraSetting.fov;
        }
        if (this.position[0] === this.target[0] && this.position[1] === this.target[1] && this.position[2] === this.target[2]) {
            if (this._viewportId) {
                (_a = this._stateEngine.viewportEngines[this._viewportId]) === null || _a === void 0 ? void 0 : _a.boundingBoxCreated.then(() => __awaiter(this, void 0, void 0, function* () {
                    yield this.zoomTo(undefined, { duration: 0 });
                    this.defaultPosition = gl_matrix_1.vec3.clone(this._controls.position);
                    this.defaultTarget = gl_matrix_1.vec3.clone(this._controls.target);
                }));
            }
        }
        this._controls.applySettings(settingsEngine);
    }
    assignViewer(renderingEngine) {
        var _a;
        if (renderingEngine.closed)
            throw new viewer_shared_services_1.ShapeDiverViewerCameraError(`OrthographicCamera(${this.id}).assignViewer: Viewer with id ${renderingEngine.id} not found.`);
        this.assignViewerInternal(renderingEngine.id);
        this._controls.assignViewer(renderingEngine.id, renderingEngine.canvas);
        if (this.domEventListenerToken && __classPrivateFieldGet(this, _PerspectiveCamera_domEventEngine, "f"))
            __classPrivateFieldGet(this, _PerspectiveCamera_domEventEngine, "f").removeDomEventListener(this.domEventListenerToken);
        __classPrivateFieldSet(this, _PerspectiveCamera_domEventEngine, renderingEngine.domEventEngine, "f");
        this.domEventListenerToken = __classPrivateFieldGet(this, _PerspectiveCamera_domEventEngine, "f").addDomEventListener(this._controls.cameraControlsEventDistribution);
        this.boundingBox = __classPrivateFieldGet(this, _PerspectiveCamera_tree, "f").root.boundingBox.clone();
        (_a = this._stateEngine.viewportEngines[renderingEngine.id]) === null || _a === void 0 ? void 0 : _a.boundingBoxCreated.then(() => __awaiter(this, void 0, void 0, function* () {
            if (this.position[0] === this.target[0] && this.position[1] === this.target[1] && this.position[2] === this.target[2])
                yield this.zoomTo(undefined, { duration: 0 });
        }));
    }
    calculateZoomTo(zoomTarget, startingPosition = this.position, startingTarget = this.target) {
        let box;
        // Part 1 - calculate the bounding box that we should zoom to
        if (!zoomTarget) {
            // complete scene
            box = this._boundingBox.clone();
        }
        else {
            // specified Box
            box = zoomTarget.clone();
        }
        if (box.isEmpty())
            return { position: gl_matrix_1.vec3.create(), target: gl_matrix_1.vec3.create() };
        const samePosition = startingPosition[0] === startingTarget[0] && startingPosition[1] === startingTarget[1] && startingPosition[2] === startingTarget[2];
        const target = gl_matrix_1.vec3.fromValues((box.max[0] + box.min[0]) / 2, (box.max[1] + box.min[1]) / 2, (box.max[2] + box.min[2]) / 2);
        // if the camera position and the target are the same, we set a corner position
        if (startingPosition[0] === startingTarget[0] && startingPosition[1] === startingTarget[1] && startingPosition[2] === startingTarget[2])
            startingPosition = gl_matrix_1.vec3.fromValues(target[0], target[1] - 7.5, target[2] + 5);
        // extend box by the factor
        const boxDir = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), box.max, target);
        gl_matrix_1.vec3.multiply(boxDir, boxDir, samePosition ? gl_matrix_1.vec3.fromValues(2, 2, 2) : gl_matrix_1.vec3.fromValues(this.zoomExtentsFactor, this.zoomExtentsFactor, this.zoomExtentsFactor));
        box = new viewer_shared_math_1.Box(gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), target, boxDir), gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), target, boxDir));
        const direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), target, startingPosition));
        const cross = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(0, 0, 1), direction));
        const up = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), cross, direction));
        let position = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), target, gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), direction, gl_matrix_1.vec3.fromValues(-0.00000001, -0.00000001, -0.00000001)));
        const points = [];
        points.push(gl_matrix_1.vec3.fromValues(box.min[0], box.min[1], box.min[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.min[0], box.min[1], box.max[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.min[0], box.max[1], box.min[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.min[0], box.max[1], box.max[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.max[0], box.min[1], box.min[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.max[0], box.min[1], box.max[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.max[0], box.max[1], box.min[2]));
        points.push(gl_matrix_1.vec3.fromValues(box.max[0], box.max[1], box.max[2]));
        const fovDown = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.transformQuat(gl_matrix_1.vec3.create(), direction, gl_matrix_1.quat.setAxisAngle(gl_matrix_1.quat.create(), cross, (this.fov / 2) * (Math.PI / 180))));
        const fovUp = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.transformQuat(gl_matrix_1.vec3.create(), direction, gl_matrix_1.quat.setAxisAngle(gl_matrix_1.quat.create(), cross, -(this.fov / 2) * (Math.PI / 180))));
        const aspect = samePosition ? 1.5 : this.aspect || 1.5;
        const hFoV = 2 * Math.atan(Math.tan(this.fov * Math.PI / 180 / 2) * aspect);
        const fovRight = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.transformQuat(gl_matrix_1.vec3.create(), direction, gl_matrix_1.quat.setAxisAngle(gl_matrix_1.quat.create(), up, hFoV / 2)));
        const fovLeft = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.transformQuat(gl_matrix_1.vec3.create(), direction, gl_matrix_1.quat.setAxisAngle(gl_matrix_1.quat.create(), up, -hFoV / 2)));
        const planeCross = new viewer_shared_math_1.Plane(gl_matrix_1.vec3.clone(cross), 0);
        planeCross.setFromNormalAndCoplanarPoint(gl_matrix_1.vec3.clone(cross), gl_matrix_1.vec3.clone(target));
        const planeUp = new viewer_shared_math_1.Plane(gl_matrix_1.vec3.fromValues(0, 0, 1), 0);
        planeUp.setFromNormalAndCoplanarPoint(gl_matrix_1.vec3.clone(up), gl_matrix_1.vec3.clone(target));
        let distanceCamera = 0.0;
        for (let i = 0; i < points.length; i++) {
            let projected = planeCross.clampPoint(points[i]);
            let toP = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), projected, position));
            if (gl_matrix_1.vec3.dot(direction, fovDown) > gl_matrix_1.vec3.dot(direction, toP)) {
                const currentDir = gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.dot(fovDown, toP) > gl_matrix_1.vec3.dot(fovUp, toP) ? fovDown : fovUp, gl_matrix_1.vec3.fromValues(-1, -1, -1));
                const distance = planeUp.intersect(projected, currentDir);
                if (distance) {
                    const cameraPoint = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), currentDir, gl_matrix_1.vec3.fromValues(distance, distance, distance)), projected);
                    distanceCamera = Math.max(distanceCamera, gl_matrix_1.vec3.distance(target, cameraPoint));
                }
            }
            projected = planeUp.clampPoint(points[i]);
            toP = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), projected, position));
            if (gl_matrix_1.vec3.dot(direction, fovRight) > gl_matrix_1.vec3.dot(direction, toP)) {
                const currentDir = gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.dot(fovRight, toP) > gl_matrix_1.vec3.dot(fovLeft, toP) ? fovRight : fovLeft, gl_matrix_1.vec3.fromValues(-1, -1, -1));
                const distance = planeCross.intersect(projected, currentDir);
                if (distance) {
                    const cameraPoint = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), currentDir, gl_matrix_1.vec3.fromValues(distance, distance, distance)), projected);
                    distanceCamera = Math.max(distanceCamera, gl_matrix_1.vec3.distance(target, cameraPoint));
                }
            }
        }
        position = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), target, gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), direction, gl_matrix_1.vec3.fromValues(-distanceCamera, -distanceCamera, -distanceCamera)));
        return {
            position, target
        };
    }
    clone() {
        return new PerspectiveCamera(this.id, this.version, this.aspect);
    }
    project(pos, position = this.position, target = this.target) {
        const m = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), position, target, gl_matrix_1.vec3.fromValues(0, 0, 1));
        const aspect = this.aspect || 1.5;
        const p = gl_matrix_1.mat4.perspective(gl_matrix_1.mat4.create(), this.fov / (180 / Math.PI), aspect, this.near, this.far);
        let inverse = gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), m);
        if (!inverse)
            inverse = gl_matrix_1.mat4.create();
        gl_matrix_1.vec3.transformMat4(pos, pos, inverse);
        gl_matrix_1.vec3.transformMat4(pos, pos, p);
        return gl_matrix_1.vec2.fromValues(pos[0], pos[1]);
    }
    unproject(pos, position = this.position, target = this.target) {
        const m = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), position, target, gl_matrix_1.vec3.fromValues(0, 0, 1));
        const aspect = this.aspect || 1.5;
        const p = gl_matrix_1.mat4.perspective(gl_matrix_1.mat4.create(), this.fov / (180 / Math.PI), aspect, this.near, this.far);
        let inverse = gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), p);
        if (!inverse)
            inverse = gl_matrix_1.mat4.create();
        gl_matrix_1.vec3.transformMat4(pos, pos, inverse);
        gl_matrix_1.vec3.transformMat4(pos, pos, m);
        return gl_matrix_1.vec3.clone(pos);
    }
}
exports.PerspectiveCamera = PerspectiveCamera;
_PerspectiveCamera_converter = new WeakMap(), _PerspectiveCamera_tree = new WeakMap(), _PerspectiveCamera_aspect = new WeakMap(), _PerspectiveCamera_domEventEngine = new WeakMap(), _PerspectiveCamera_fov = new WeakMap();
//# sourceMappingURL=PerspectiveCamera.js.map

/***/ }),

/***/ 81600:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractCameraControls = void 0;
const CameraInterpolationManager_1 = __webpack_require__(72639);
const viewer_shared_services_1 = __webpack_require__(8389);
const gl_matrix_1 = __webpack_require__(61961);
class AbstractCameraControls {
    // #endregion Properties (38)
    // #region Constructors (1)
    constructor(_camera, _enabled) {
        this._camera = _camera;
        this._enabled = _enabled;
        this._converter = viewer_shared_services_1.Converter.instance;
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._autoRotationSpeed = 0;
        this._cubePositionRestriction = { min: gl_matrix_1.vec3.fromValues(-Infinity, -Infinity, -Infinity), max: gl_matrix_1.vec3.fromValues(Infinity, Infinity, Infinity) };
        this._cubeTargetRestriction = { min: gl_matrix_1.vec3.fromValues(-Infinity, -Infinity, -Infinity), max: gl_matrix_1.vec3.fromValues(Infinity, Infinity, Infinity) };
        this._damping = 0.1;
        this._enableAutoRotation = false;
        this._enableAzimuthRotation = true;
        this._enableKeyPan = false;
        this._enableObjectControls = false;
        this._enablePan = true;
        this._enablePolarRotation = true;
        this._enableRotation = true;
        this._enableTurntableControls = false;
        this._enableZoom = true;
        this._input = { keys: { up: 38, down: 40, left: 37, right: 39 }, mouse: { rotate: 0, zoom: 1, pan: 2 }, touch: { rotate: 1, zoom: 2, pan: 2 }, };
        this._keyPanSpeed = 0.5;
        this._manualInteraction = false;
        this._movementSmoothness = 0.5;
        this._moving = false;
        this._movingDuration = 0;
        this._nonmanualInteraction = false;
        this._objectControlsCenter = gl_matrix_1.vec3.create();
        this._panSpeed = 0.5;
        this._position = gl_matrix_1.vec3.create();
        this._rotationRestriction = { minPolarAngle: 0, maxPolarAngle: 180, minAzimuthAngle: -Infinity, maxAzimuthAngle: Infinity };
        this._rotationSpeed = 0.5;
        this._sceneRotation = gl_matrix_1.vec2.create();
        this._spherePositionRestriction = { center: gl_matrix_1.vec3.create(), radius: Infinity };
        this._sphereTargetRestriction = { center: gl_matrix_1.vec3.create(), radius: Infinity };
        this._target = gl_matrix_1.vec3.create();
        this._turntableCenter = gl_matrix_1.vec3.create();
        this._zoomRestriction = { minDistance: 0, maxDistance: Infinity };
        this._zoomSpeed = 0.5;
        this._cameraInterpolationManager = new CameraInterpolationManager_1.CameraInterpolationManager(this._camera, this);
        this._manualInteractionTransformations = { position: [], target: [], sceneRotation: [] };
        this._nonmanualInteractionTransformations = { position: [], target: [], sceneRotation: [] };
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (59)
    get autoRotationSpeed() {
        return this._autoRotationSpeed;
    }
    set autoRotationSpeed(value) {
        this._autoRotationSpeed = value;
    }
    get camera() {
        return this._camera;
    }
    set camera(value) {
        this._camera = value;
    }
    get cameraControlsEventDistribution() {
        return this._cameraControlsEventDistribution;
    }
    get canvas() {
        return this._canvas;
    }
    set canvas(value) {
        this._canvas = value;
    }
    get cubePositionRestriction() {
        return this._cubePositionRestriction;
    }
    set cubePositionRestriction(value) {
        this._cubePositionRestriction = value;
    }
    get cubeTargetRestriction() {
        return this._cubeTargetRestriction;
    }
    set cubeTargetRestriction(value) {
        this._cubeTargetRestriction = value;
    }
    get damping() {
        return this._damping;
    }
    set damping(value) {
        this._damping = value;
    }
    get enableAutoRotation() {
        return this._enableAutoRotation;
    }
    set enableAutoRotation(value) {
        this._enableAutoRotation = value;
    }
    get enableAzimuthRotation() {
        return this._enableAzimuthRotation;
    }
    set enableAzimuthRotation(value) {
        this._enableAzimuthRotation = value;
    }
    get enableKeyPan() {
        return this._enableKeyPan;
    }
    set enableKeyPan(value) {
        this._enableKeyPan = value;
    }
    get enableObjectControls() {
        return this._enableObjectControls;
    }
    set enableObjectControls(value) {
        this._enableObjectControls = value;
    }
    get enablePan() {
        return this._enablePan;
    }
    set enablePan(value) {
        this._enablePan = value;
    }
    get enablePolarRotation() {
        return this._enablePolarRotation;
    }
    set enablePolarRotation(value) {
        this._enablePolarRotation = value;
    }
    get enableRotation() {
        return this._enableRotation;
    }
    set enableRotation(value) {
        this._enableRotation = value;
    }
    get enableTurntableControls() {
        return this._enableTurntableControls;
    }
    set enableTurntableControls(value) {
        this._enableTurntableControls = value;
    }
    get enableZoom() {
        return this._enableZoom;
    }
    set enableZoom(value) {
        this._enableZoom = value;
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(value) {
        if (!value) {
            this._manualInteraction = false;
            this._manualInteractionTransformations = { position: [], target: [], sceneRotation: [] };
            this._nonmanualInteraction = false;
            this._nonmanualInteractionTransformations = { position: [], target: [], sceneRotation: [] };
            this._cameraControlsEventDistribution.reset();
            this._cameraLogic.reset();
        }
        this._enabled = value;
    }
    get input() {
        return this._input;
    }
    set input(value) {
        this._input = value;
    }
    get keyPanSpeed() {
        return this._keyPanSpeed;
    }
    set keyPanSpeed(value) {
        this._keyPanSpeed = value;
    }
    get movementSmoothness() {
        return this._movementSmoothness;
    }
    set movementSmoothness(value) {
        this._movementSmoothness = value;
    }
    get objectControlsCenter() {
        return this._objectControlsCenter;
    }
    set objectControlsCenter(value) {
        this._objectControlsCenter = value;
    }
    get panSpeed() {
        return this._panSpeed;
    }
    set panSpeed(value) {
        this._panSpeed = value;
    }
    get position() {
        return this._position;
    }
    set position(value) {
        this._position = value;
    }
    get rotationRestriction() {
        return this._rotationRestriction;
    }
    set rotationRestriction(value) {
        this._rotationRestriction = value;
    }
    get rotationSpeed() {
        return this._rotationSpeed;
    }
    set rotationSpeed(value) {
        this._rotationSpeed = value;
    }
    get sceneRotation() {
        return this._sceneRotation;
    }
    set sceneRotation(value) {
        this._sceneRotation = value;
    }
    get spherePositionRestriction() {
        return this._spherePositionRestriction;
    }
    set spherePositionRestriction(value) {
        this._spherePositionRestriction = value;
    }
    get sphereTargetRestriction() {
        return this._sphereTargetRestriction;
    }
    set sphereTargetRestriction(value) {
        this._sphereTargetRestriction = value;
    }
    get target() {
        return this._target;
    }
    set target(value) {
        this._target = value;
    }
    get turntableCenter() {
        return this._turntableCenter;
    }
    set turntableCenter(value) {
        this._turntableCenter = value;
    }
    get zoomRestriction() {
        return this._zoomRestriction;
    }
    set zoomRestriction(value) {
        this._zoomRestriction = value;
    }
    get zoomSpeed() {
        return this._zoomSpeed;
    }
    set zoomSpeed(value) {
        this._zoomSpeed = value;
    }
    // #endregion Public Getters And Setters (59)
    // #region Public Methods (16)
    animate(path, options) {
        if (options && options.duration === 0) {
            this._position = path[path.length - 1].position;
            this._target = path[path.length - 1].target;
            return new Promise(resolve => resolve(true));
        }
        this._manualInteraction = false;
        this._manualInteractionTransformations = { position: [], target: [], sceneRotation: [] };
        return this._cameraInterpolationManager.interpolate(path, options);
    }
    applyPositionMatrix(matrix, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.position.push({ matrix });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.position.push({ matrix });
        }
    }
    applyPositionVector(vector, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.position.push({ vector });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.position.push({ vector });
        }
    }
    applyRotation(vector, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.sceneRotation.push({ theta: vector[0], phi: vector[1] });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.sceneRotation.push({ theta: vector[0], phi: vector[1] });
        }
    }
    applySettings(settingsEngine) {
        const cameraSetting = settingsEngine.camera.cameras[this.camera.id];
        if (!cameraSetting)
            return;
        this.reset();
        const controlsSettings = cameraSetting.controls;
        this.autoRotationSpeed = controlsSettings.autoRotationSpeed;
        this.damping = controlsSettings.damping;
        this.enableAutoRotation = controlsSettings.enableAutoRotation;
        this.enableKeyPan = controlsSettings.enableKeyPan;
        this.enablePan = controlsSettings.enablePan;
        this.enableRotation = controlsSettings.enableRotation;
        this.enableZoom = controlsSettings.enableZoom;
        // this.input = controlsSettings.input;
        this.keyPanSpeed = controlsSettings.keyPanSpeed;
        this.movementSmoothness = controlsSettings.movementSmoothness;
        this.rotationSpeed = controlsSettings.rotationSpeed;
        this.panSpeed = controlsSettings.panSpeed;
        this.zoomSpeed = controlsSettings.zoomSpeed;
        this.enableAzimuthRotation = controlsSettings.enableAzimuthRotation;
        this.enablePolarRotation = controlsSettings.enablePolarRotation;
        this.enableTurntableControls = controlsSettings.enableTurntableControls;
        this.enableObjectControls = controlsSettings.enableObjectControls;
        this.turntableCenter = this._converter.toVec3(controlsSettings.turntableCenter);
        this.objectControlsCenter = this._converter.toVec3(controlsSettings.objectControlsCenter);
        if (controlsSettings.restrictions.position.cube.min.x === null)
            controlsSettings.restrictions.position.cube.min.x = -Infinity;
        if (controlsSettings.restrictions.position.cube.min.y === null)
            controlsSettings.restrictions.position.cube.min.y = -Infinity;
        if (controlsSettings.restrictions.position.cube.min.z === null)
            controlsSettings.restrictions.position.cube.min.z = -Infinity;
        if (controlsSettings.restrictions.position.cube.max.x === null)
            controlsSettings.restrictions.position.cube.max.x = Infinity;
        if (controlsSettings.restrictions.position.cube.max.y === null)
            controlsSettings.restrictions.position.cube.max.y = Infinity;
        if (controlsSettings.restrictions.position.cube.max.z === null)
            controlsSettings.restrictions.position.cube.max.z = Infinity;
        if (controlsSettings.restrictions.position.sphere.radius === null)
            controlsSettings.restrictions.position.sphere.radius = Infinity;
        if (controlsSettings.restrictions.target.cube.min.x === null)
            controlsSettings.restrictions.target.cube.min.x = -Infinity;
        if (controlsSettings.restrictions.target.cube.min.y === null)
            controlsSettings.restrictions.target.cube.min.y = -Infinity;
        if (controlsSettings.restrictions.target.cube.min.z === null)
            controlsSettings.restrictions.target.cube.min.z = -Infinity;
        if (controlsSettings.restrictions.target.cube.max.x === null)
            controlsSettings.restrictions.target.cube.max.x = Infinity;
        if (controlsSettings.restrictions.target.cube.max.y === null)
            controlsSettings.restrictions.target.cube.max.y = Infinity;
        if (controlsSettings.restrictions.target.cube.max.z === null)
            controlsSettings.restrictions.target.cube.max.z = Infinity;
        if (controlsSettings.restrictions.target.sphere.radius === null)
            controlsSettings.restrictions.target.sphere.radius = Infinity;
        if (controlsSettings.restrictions.rotation.minAzimuthAngle === null)
            controlsSettings.restrictions.rotation.minAzimuthAngle = -Infinity;
        if (controlsSettings.restrictions.rotation.maxAzimuthAngle === null)
            controlsSettings.restrictions.rotation.maxAzimuthAngle = Infinity;
        if (controlsSettings.restrictions.zoom.maxDistance === null)
            controlsSettings.restrictions.zoom.maxDistance = Infinity;
        this.cubePositionRestriction = {
            min: this._converter.toVec3(controlsSettings.restrictions.position.cube.min),
            max: this._converter.toVec3(controlsSettings.restrictions.position.cube.max)
        };
        this.spherePositionRestriction = {
            center: this._converter.toVec3(controlsSettings.restrictions.position.sphere.center),
            radius: controlsSettings.restrictions.position.sphere.radius
        };
        this.cubeTargetRestriction = {
            min: this._converter.toVec3(controlsSettings.restrictions.target.cube.min),
            max: this._converter.toVec3(controlsSettings.restrictions.target.cube.max)
        };
        this.sphereTargetRestriction = {
            center: this._converter.toVec3(controlsSettings.restrictions.target.sphere.center),
            radius: controlsSettings.restrictions.target.sphere.radius
        };
        this.rotationRestriction = controlsSettings.restrictions.rotation;
        this.zoomRestriction = controlsSettings.restrictions.zoom;
    }
    applyTargetMatrix(matrix, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.target.push({ matrix });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.target.push({ matrix });
        }
    }
    applyTargetVector(vector, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.target.push({ vector });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.target.push({ vector });
        }
    }
    applyUpMatrix(matrix, manualInteraction) {
        // https://shapediver.atlassian.net/browse/SS-2949
        throw new Error('Method not implemented.');
    }
    assignViewer(viewportId, canvas) {
        this._canvas = canvas;
        this._viewportId = viewportId;
    }
    getPositionWithManualUpdates() {
        let position = gl_matrix_1.vec3.clone(this._position);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.position.length - 1; i >= 0; i--) {
                if (this._manualInteractionTransformations.position[i].matrix) {
                    position = gl_matrix_1.vec3.transformMat4(position, position, this._manualInteractionTransformations.position[i].matrix);
                }
                else {
                    position = gl_matrix_1.vec3.add(position, position, this._manualInteractionTransformations.position[i].vector);
                }
            }
        }
        return position;
    }
    getPositionWithUpdates() {
        return this.getPosition();
    }
    getTargetWithManualUpdates() {
        let target = gl_matrix_1.vec3.clone(this._target);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.target.length - 1; i >= 0; i--) {
                if (this._manualInteractionTransformations.target[i].matrix) {
                    target = gl_matrix_1.vec3.transformMat4(target, target, this._manualInteractionTransformations.target[i].matrix);
                }
                else {
                    target = gl_matrix_1.vec3.add(target, target, this._manualInteractionTransformations.target[i].vector);
                }
            }
        }
        return target;
    }
    getTargetWithUpdates() {
        return this.getTarget();
    }
    isMoving() {
        return this._manualInteraction || this._nonmanualInteraction;
    }
    isWithinRestrictions(position, target) {
        return this._cameraLogic.isWithinRestrictions(position, target);
    }
    reset() {
        this._cameraControlsEventDistribution.reset();
        this._cameraLogic.reset();
    }
    update(time) {
        if (!this._enabled)
            return { position: gl_matrix_1.vec3.clone(this._position), target: gl_matrix_1.vec3.clone(this._target), sceneRotation: gl_matrix_1.vec2.clone(this._sceneRotation) };
        // reset all values
        if (this._manualInteraction === true && this._cameraInterpolationManager.active())
            this._cameraInterpolationManager.stop();
        const { position, target, sceneRotation } = this._cameraLogic.restrict(this.getPosition(), this.getTarget(), this.getSceneRotation());
        this._position = gl_matrix_1.vec3.clone(position);
        this._target = gl_matrix_1.vec3.clone(target);
        this._sceneRotation = sceneRotation ? gl_matrix_1.vec2.clone(sceneRotation) : gl_matrix_1.vec2.create();
        this._manualInteraction = false;
        this._manualInteractionTransformations = { position: [], target: [], sceneRotation: [] };
        this._nonmanualInteraction = this._cameraInterpolationManager.active();
        this._nonmanualInteractionTransformations = { position: [], target: [], sceneRotation: [] };
        this._cameraLogic.update(time, this._nonmanualInteraction);
        const oldMovement = this._moving;
        const cameraDefinition = {
            position: gl_matrix_1.vec3.clone(this._position),
            target: gl_matrix_1.vec3.clone(this._target),
            sceneRotation: gl_matrix_1.vec2.clone(this._sceneRotation)
        };
        this._movingDuration += time;
        this._moving = (this._manualInteraction || this._nonmanualInteraction);
        switch (true) {
            case oldMovement !== this._moving && this._moving === true:
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_START, { viewportId: this._viewportId, cameraId: this.camera.id });
                break;
            case oldMovement !== this._moving && this._moving === false:
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_END, { viewportId: this._viewportId, cameraId: this.camera.id });
                break;
            default:
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_MOVE, { viewportId: this._viewportId, cameraId: this.camera.id });
        }
        if (!this._moving)
            this._movingDuration = 0;
        return cameraDefinition;
    }
    // #endregion Public Methods (16)
    // #region Private Methods (3)
    getPosition() {
        let position = gl_matrix_1.vec3.clone(this._position);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.position.length - 1; i >= 0; i--) {
                if (this._manualInteractionTransformations.position[i].matrix) {
                    position = gl_matrix_1.vec3.transformMat4(position, position, this._manualInteractionTransformations.position[i].matrix);
                }
                else {
                    position = gl_matrix_1.vec3.add(position, position, this._manualInteractionTransformations.position[i].vector);
                }
            }
        }
        else if (this._nonmanualInteraction) {
            for (let i = this._nonmanualInteractionTransformations.position.length - 1; i >= 0; i--) {
                if (this._nonmanualInteractionTransformations.position[i].matrix) {
                    position = gl_matrix_1.vec3.transformMat4(position, position, this._nonmanualInteractionTransformations.position[i].matrix);
                }
                else {
                    position = gl_matrix_1.vec3.add(position, position, this._nonmanualInteractionTransformations.position[i].vector);
                }
            }
        }
        return position;
    }
    getSceneRotation() {
        let sceneRotation = gl_matrix_1.vec2.clone(this._sceneRotation);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.sceneRotation.length - 1; i >= 0; i--) {
                sceneRotation = gl_matrix_1.vec2.add(sceneRotation, sceneRotation, gl_matrix_1.vec2.fromValues(this._manualInteractionTransformations.sceneRotation[i].theta, this._manualInteractionTransformations.sceneRotation[i].phi));
            }
        }
        else if (this._nonmanualInteraction) {
            for (let i = this._nonmanualInteractionTransformations.sceneRotation.length - 1; i >= 0; i--) {
                sceneRotation = gl_matrix_1.vec2.add(sceneRotation, sceneRotation, gl_matrix_1.vec2.fromValues(this._nonmanualInteractionTransformations.sceneRotation[i].theta, this._nonmanualInteractionTransformations.sceneRotation[i].phi));
            }
        }
        return sceneRotation;
    }
    getTarget() {
        let target = gl_matrix_1.vec3.clone(this._target);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.target.length - 1; i >= 0; i--) {
                if (this._manualInteractionTransformations.target[i].matrix) {
                    target = gl_matrix_1.vec3.transformMat4(target, target, this._manualInteractionTransformations.target[i].matrix);
                }
                else {
                    target = gl_matrix_1.vec3.add(target, target, this._manualInteractionTransformations.target[i].vector);
                }
            }
        }
        else if (this._nonmanualInteraction) {
            for (let i = this._nonmanualInteractionTransformations.target.length - 1; i >= 0; i--) {
                if (this._nonmanualInteractionTransformations.target[i].matrix) {
                    target = gl_matrix_1.vec3.transformMat4(target, target, this._nonmanualInteractionTransformations.target[i].matrix);
                }
                else {
                    target = gl_matrix_1.vec3.add(target, target, this._nonmanualInteractionTransformations.target[i].vector);
                }
            }
        }
        return target;
    }
}
exports.AbstractCameraControls = AbstractCameraControls;
//# sourceMappingURL=AbstractCameraControls.js.map

/***/ }),

/***/ 68410:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CameraControlsEventDistribution = void 0;
class CameraControlsEventDistribution {
    // #endregion Properties (7)
    // #region Constructors (1)
    constructor(controls, cameraLogic) {
        this._active = {
            rotation: false,
            zoom: false,
            pan: false
        };
        this._activeEvents = true;
        this._controls = controls;
        this._cameraLogic = cameraLogic;
    }
    // #endregion Constructors (1)
    // #region Public Methods (16)
    activateCameraEvents() {
        this._activeEvents = true;
    }
    deactivateCameraEvents() {
        this._activeEvents = false;
        this.reset();
    }
    onDown(event) {
        if (this._controls.camera.active === false)
            return;
        const { x, y } = this.convertInput(event);
        const touchEvent = event.pointerType === 'touch';
        const input = this.getInput(event);
        const mapping = event.pointerType === 'touch' ? this._controls.input.touch : this._controls.input.mouse;
        if (input === mapping.rotate && this._controls.enableRotation) {
            this._cameraLogic.rotate(x, y, this._active.rotation, touchEvent);
            this._active.rotation = true;
        }
        else {
            this._active.rotation = false;
        }
        if (input === mapping.pan && this._controls.enablePan) {
            this._cameraLogic.pan(x, y, this._active.pan, touchEvent);
            this._active.pan = true;
        }
        else {
            this._active.pan = false;
        }
        if (input === mapping.zoom && this._controls.enableZoom) {
            let x1 = x, y1 = y;
            if (touchEvent && this._controls.input.touch.zoom === 2 && this._primaryPointerEvent && this._secondaryPointerEvent) {
                x1 = (this._primaryPointerEvent.pageX - this._secondaryPointerEvent.pageX) / window.innerWidth * (window.innerWidth / window.innerHeight);
                y1 = (this._primaryPointerEvent.pageY - this._secondaryPointerEvent.pageY) / window.innerHeight;
            }
            this._cameraLogic.zoom(x1, y1, this._active.zoom, touchEvent);
            this._active.zoom = true;
        }
        else {
            this._active.zoom = false;
        }
    }
    onKey(event) {
        if (this._controls.camera.active === false)
            return;
        if (!this._controls.enableKeyPan)
            return;
        switch (event.keyCode) {
            case this._controls.input.keys.up:
                this._cameraLogic.pan(0, 0, false, false);
                this._cameraLogic.pan(0, this._controls.keyPanSpeed * 0.05, true, false);
                event.preventDefault();
                event.stopPropagation();
                break;
            case this._controls.input.keys.down:
                this._cameraLogic.pan(0, 0, false, false);
                this._cameraLogic.pan(0, -this._controls.keyPanSpeed * 0.05, true, false);
                event.preventDefault();
                event.stopPropagation();
                break;
            case this._controls.input.keys.left:
                this._cameraLogic.pan(0, 0, false, false);
                this._cameraLogic.pan(this._controls.keyPanSpeed * 0.05, 0, true, false);
                event.preventDefault();
                event.stopPropagation();
                break;
            case this._controls.input.keys.right:
                this._cameraLogic.pan(0, 0, false, false);
                this._cameraLogic.pan(-this._controls.keyPanSpeed * 0.05, 0, true, false);
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    }
    onKeyDown(event) {
        if (this._controls.camera.active === false)
            return;
        if (!this._activeEvents)
            return;
        this.onKey(event);
    }
    onKeyUp(event) { }
    onMouseWheel(event) {
        if (this._controls.camera.active === false)
            return;
        if (!this._activeEvents)
            return;
        this.onWheel(event);
    }
    onMove(event) {
        if (this._controls.camera.active === false)
            return;
        const { x, y } = this.convertInput(event);
        const touchEvent = event.pointerType === 'touch';
        if (this._controls.enableRotation && this._active.rotation)
            this._cameraLogic.rotate(x, y, this._active.rotation, touchEvent);
        if (this._controls.enablePan && this._active.pan)
            this._cameraLogic.pan(x, y, this._active.pan, touchEvent);
        if (this._controls.enableZoom && this._active.zoom) {
            let x1 = x, y1 = y;
            if (touchEvent && this._controls.input.touch.zoom === 2 && this._primaryPointerEvent && this._secondaryPointerEvent) {
                x1 = (this._primaryPointerEvent.pageX - this._secondaryPointerEvent.pageX) / window.innerWidth * (window.innerWidth / window.innerHeight);
                y1 = (this._primaryPointerEvent.pageY - this._secondaryPointerEvent.pageY) / window.innerHeight;
            }
            this._cameraLogic.zoom(x1, y1, this._active.zoom, touchEvent);
        }
    }
    onPointerDown(event) {
        if (this._controls.camera.active === false)
            return;
        if (!this._activeEvents)
            return;
        if (event.isPrimary === true)
            this._primaryPointerEvent = event;
        else if (event.isPrimary === false)
            this._secondaryPointerEvent = event;
        this.onDown(event);
    }
    onPointerEnd(event) {
        if (this._controls.camera.active === false)
            return;
        if (!this._activeEvents)
            return;
        if (event.isPrimary === true)
            this._primaryPointerEvent = undefined;
        else if (event.isPrimary === false)
            this._secondaryPointerEvent = undefined;
        this.onUp(event);
    }
    onPointerMove(event) {
        if (this._controls.camera.active === false)
            return;
        if (!this._activeEvents)
            return;
        if (event.isPrimary === true)
            this._primaryPointerEvent = event;
        else if (event.isPrimary === false)
            this._secondaryPointerEvent = event;
        this.onMove(event);
    }
    onPointerOut(event) {
        if (this._controls.camera.active === false)
            return;
        this.revert();
        if (event.isPrimary === true)
            this._primaryPointerEvent = undefined;
        else if (event.isPrimary === false)
            this._secondaryPointerEvent = undefined;
    }
    onPointerUp(event) {
        if (this._controls.camera.active === false)
            return;
        if (event.isPrimary === true)
            this._primaryPointerEvent = undefined;
        else if (event.isPrimary === false)
            this._secondaryPointerEvent = undefined;
    }
    onUp(event) {
        if (this._controls.camera.active === false)
            return;
        this.revert();
        this._active.rotation = false;
        this._active.zoom = false;
        this._active.pan = false;
    }
    onWheel(event) {
        if (this._controls.camera.active === false)
            return;
        if (!this._activeEvents)
            return;
        if (!this._controls.enableZoom)
            return;
        if (this._controls.camera.revertAtMouseUp === true) {
            clearTimeout(this._zoomResizeTimeout);
            this._zoomResizeTimeout = setTimeout(this.revert.bind(this), 300);
        }
        let delta = 0;
        if (event.deltaY !== undefined) {
            // WebKit / Opera / Explorer 9
            delta = -event.deltaY;
        }
        else if (event.detail !== undefined) {
            // Firefox
            delta = -event.detail;
        }
        // convert to 2 screen coordinates that are far enough
        if (Math.sign(delta) > 0) {
            this._cameraLogic.zoom(0, 0, false, false);
            this._cameraLogic.zoom(1, 0, true, false);
        }
        else {
            this._cameraLogic.zoom(1, 0, false, false);
            this._cameraLogic.zoom(0, 0, true, false);
        }
    }
    reset() {
        this._active = {
            rotation: false,
            zoom: false,
            pan: false
        };
    }
    // #endregion Public Methods (16)
    // #region Protected Methods (2)
    convertInput(event) {
        if (this._primaryPointerEvent && this._secondaryPointerEvent) {
            return {
                x: (this._primaryPointerEvent.pageX + this._secondaryPointerEvent.pageX) / 2,
                y: (this._primaryPointerEvent.pageY + this._secondaryPointerEvent.pageY) / 2
            };
        }
        else {
            return {
                x: event.clientX,
                y: event.clientY
            };
        }
    }
    getInput(event) {
        if (event.pointerType === 'touch') {
            if (this._secondaryPointerEvent) {
                return 2;
            }
            else {
                return 1;
            }
        }
        else {
            return event.button;
        }
    }
    // #endregion Protected Methods (2)
    // #region Private Methods (1)
    revert() {
        if (this._controls.camera.revertAtMouseUp === true) {
            this._controls.camera.reset({ duration: this._controls.camera.revertAtMouseUpDuration });
        }
    }
}
exports.CameraControlsEventDistribution = CameraControlsEventDistribution;
//# sourceMappingURL=CameraControlsEventDistribution.js.map

/***/ }),

/***/ 92658:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CameraControlsLogic = void 0;
const viewer_shared_math_1 = __webpack_require__(67275);
const gl_matrix_1 = __webpack_require__(61961);
const OrthographicCamera_1 = __webpack_require__(36817);
const ICameraEngine_1 = __webpack_require__(23564);
const IOrthographicCamera_1 = __webpack_require__(49578);
class CameraControlsLogic {
    // #endregion Properties (13)
    // #region Constructors (1)
    constructor(_controls, _settingsAdjustments, _touchAdjustments) {
        this._controls = _controls;
        this._settingsAdjustments = _settingsAdjustments;
        this._touchAdjustments = _touchAdjustments;
        // #region Properties (13)
        this._adjustedSettings = {
            autoRotationSpeed: () => this._controls.autoRotationSpeed * this._settingsAdjustments.autoRotationSpeed,
            damping: () => this._controls.damping * this._settingsAdjustments.damping,
            movementSmoothness: () => this._controls.movementSmoothness * this._settingsAdjustments.movementSmoothness,
            panSpeed: () => this._controls.panSpeed * this._settingsAdjustments.panSpeed,
            rotationSpeed: () => this._controls.rotationSpeed * this._settingsAdjustments.rotationSpeed,
            zoomSpeed: () => this._controls.zoomSpeed * this._settingsAdjustments.zoomSpeed,
        };
        this._damping = {
            rotation: {
                time: 0,
                duration: 0,
                theta: 0,
                phi: 0
            },
            zoom: {
                time: 0,
                duration: 0,
                delta: 0
            },
            pan: {
                time: 0,
                duration: 0,
                offset: gl_matrix_1.vec3.create()
            },
        };
        this._dollyDelta = 0;
        this._dollyEnd = 0;
        this._dollyStart = 0;
        this._panDelta = gl_matrix_1.vec2.create();
        this._panEnd = gl_matrix_1.vec2.create();
        this._panStart = gl_matrix_1.vec2.create();
        this._rotateDelta = gl_matrix_1.vec2.create();
        this._rotateEnd = gl_matrix_1.vec2.create();
        this._rotateStart = gl_matrix_1.vec2.create();
        this._quat = gl_matrix_1.quat.fromValues(-Math.sin(Math.PI / 4), 0, 0, Math.sin(Math.PI / 4));
        this._quatInverse = gl_matrix_1.quat.fromValues(Math.sin(Math.PI / 4), 0, 0, Math.sin(Math.PI / 4));
    }
    // #endregion Constructors (1)
    // #region Public Methods (7)
    isWithinRestrictions(position, target) {
        const pBox = new viewer_shared_math_1.Box(this._controls.cubePositionRestriction.min, this._controls.cubePositionRestriction.max), pSphere = new viewer_shared_math_1.Sphere(this._controls.spherePositionRestriction.center, this._controls.spherePositionRestriction.radius), tBox = new viewer_shared_math_1.Box(this._controls.cubeTargetRestriction.min, this._controls.cubeTargetRestriction.max), tSphere = new viewer_shared_math_1.Sphere(this._controls.sphereTargetRestriction.center, this._controls.sphereTargetRestriction.radius);
        if (!(pBox.containsPoint(position) && pSphere.containsPoint(position)))
            return false;
        if (!(tBox.containsPoint(target) && tSphere.containsPoint(target)))
            return false;
        const currentDistance = gl_matrix_1.vec3.distance(position, target);
        if (currentDistance > this._controls.zoomRestriction.maxDistance || currentDistance < this._controls.zoomRestriction.minDistance)
            return false;
        const minPolarAngle = this._controls.rotationRestriction.minPolarAngle * (Math.PI / 180), maxPolarAngle = this._controls.rotationRestriction.maxPolarAngle * (Math.PI / 180), minAzimuthAngle = this._controls.rotationRestriction.minAzimuthAngle * (Math.PI / 180), maxAzimuthAngle = this._controls.rotationRestriction.maxAzimuthAngle * (Math.PI / 180);
        if (minAzimuthAngle !== -Infinity ||
            maxAzimuthAngle !== Infinity ||
            minPolarAngle !== 0 ||
            maxPolarAngle !== 180) {
            const offset = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), position, target);
            gl_matrix_1.vec3.transformQuat(offset, offset, this._quat);
            const spherical = new viewer_shared_math_1.Spherical().fromVec3(offset);
            if (spherical.theta < minAzimuthAngle ||
                spherical.theta > maxAzimuthAngle ||
                spherical.phi < minPolarAngle ||
                spherical.phi > maxPolarAngle) {
                return false;
            }
        }
        return true;
    }
    pan(x, y, active, touch) {
        if (!active) {
            this._panStart = gl_matrix_1.vec2.fromValues(x, y);
        }
        else {
            this._panEnd = gl_matrix_1.vec2.fromValues(x, y);
            gl_matrix_1.vec2.sub(this._panDelta, this._panEnd, this._panStart);
            if (this._panDelta[0] === 0 && this._panDelta[1] === 0)
                return;
            gl_matrix_1.vec2.copy(this._panStart, this._panEnd);
            const adjustedPanSpeed = this._adjustedSettings.panSpeed() * (touch ? this._touchAdjustments.panSpeed : 1.0);
            const offset = this.panDeltaToOffset(gl_matrix_1.vec2.mul(gl_matrix_1.vec2.create(), this._panDelta, gl_matrix_1.vec2.fromValues(adjustedPanSpeed, adjustedPanSpeed)));
            if (this._damping.pan.duration > 0) {
                if (offset[0] < 0) {
                    offset[0] = Math.min(offset[0], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[0]);
                }
                else {
                    offset[0] = Math.max(offset[0], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[0]);
                }
                if (offset[1] < 0) {
                    offset[1] = Math.min(offset[1], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[1]);
                }
                else {
                    offset[1] = Math.max(offset[1], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[1]);
                }
                if (offset[2] < 0) {
                    offset[2] = Math.min(offset[2], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[2]);
                }
                else {
                    offset[2] = Math.max(offset[2], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[2]);
                }
            }
            const damping = 1 - Math.max(0.01, Math.min(0.99, this._adjustedSettings.damping()));
            const framesOffsetX = (Math.log(1 / Math.abs(offset[0])) - 5 * Math.log(10)) / (Math.log(damping));
            const framesOffsetY = (Math.log(1 / Math.abs(offset[1])) - 5 * Math.log(10)) / (Math.log(damping));
            const framesOffsetZ = (Math.log(1 / Math.abs(offset[2])) - 5 * Math.log(10)) / (Math.log(damping));
            this._damping.pan.time = 0;
            this._damping.pan.duration = Math.max(framesOffsetX, Math.max(framesOffsetY, framesOffsetZ)) * 16.6666;
            this._damping.pan.offset = gl_matrix_1.vec3.clone(offset);
            this._damping.rotation.duration = 0;
            this._damping.zoom.duration = 0;
            this._controls.applyTargetVector(offset, true);
            this._controls.applyPositionVector(offset, true);
        }
    }
    reset() {
        this._damping = {
            rotation: {
                time: 0,
                duration: 0,
                theta: 0,
                phi: 0
            },
            zoom: {
                time: 0,
                duration: 0,
                delta: 0
            },
            pan: {
                time: 0,
                duration: 0,
                offset: gl_matrix_1.vec3.create()
            },
        };
        this._dollyDelta = 0;
        this._dollyEnd = 0;
        this._dollyStart = 0;
        this._panDelta = gl_matrix_1.vec2.create();
        this._panEnd = gl_matrix_1.vec2.create();
        this._panStart = gl_matrix_1.vec2.create();
        this._rotateDelta = gl_matrix_1.vec2.create();
        this._rotateEnd = gl_matrix_1.vec2.create();
        this._rotateStart = gl_matrix_1.vec2.create();
    }
    restrict(position, target, sceneRotation) {
        const pBox = new viewer_shared_math_1.Box(this._controls.cubePositionRestriction.min, this._controls.cubePositionRestriction.max), pSphere = new viewer_shared_math_1.Sphere(this._controls.spherePositionRestriction.center, this._controls.spherePositionRestriction.radius), tBox = new viewer_shared_math_1.Box(this._controls.cubeTargetRestriction.min, this._controls.cubeTargetRestriction.max), tSphere = new viewer_shared_math_1.Sphere(this._controls.sphereTargetRestriction.center, this._controls.sphereTargetRestriction.radius);
        if (!pBox.containsPoint(position))
            position = pBox.clampPoint(position);
        if (!pSphere.containsPoint(position))
            position = pSphere.clampPoint(position);
        if (!tBox.containsPoint(target))
            target = tBox.clampPoint(target);
        if (!tSphere.containsPoint(target))
            target = tSphere.clampPoint(target);
        // zoom restrictions
        const currentDistance = gl_matrix_1.vec3.distance(position, target);
        if (currentDistance > this._controls.zoomRestriction.maxDistance || currentDistance < this._controls.zoomRestriction.minDistance) {
            const direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), position, target));
            const distance = Math.max(this._controls.zoomRestriction.minDistance, Math.min(this._controls.zoomRestriction.maxDistance, currentDistance));
            gl_matrix_1.vec3.add(position, gl_matrix_1.vec3.multiply(position, direction, gl_matrix_1.vec3.fromValues(distance, distance, distance)), target);
        }
        // angle restrictions
        const minPolarAngle = this._controls.rotationRestriction.minPolarAngle * (Math.PI / 180), maxPolarAngle = this._controls.rotationRestriction.maxPolarAngle * (Math.PI / 180), minAzimuthAngle = this._controls.rotationRestriction.minAzimuthAngle * (Math.PI / 180), maxAzimuthAngle = this._controls.rotationRestriction.maxAzimuthAngle * (Math.PI / 180);
        if (minAzimuthAngle !== -Infinity ||
            maxAzimuthAngle !== Infinity ||
            minPolarAngle !== 0 ||
            maxPolarAngle !== 180 ||
            this._controls.enableAzimuthRotation === false ||
            this._controls.enablePolarRotation === false ||
            this._controls.enableObjectControls === true) {
            let offset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), position, target);
            gl_matrix_1.vec3.transformQuat(offset, offset, this._quat);
            const spherical = new viewer_shared_math_1.Spherical().fromVec3(offset);
            if (spherical.theta < minAzimuthAngle ||
                spherical.theta > maxAzimuthAngle ||
                spherical.phi < minPolarAngle ||
                spherical.phi > maxPolarAngle ||
                this._controls.enableAzimuthRotation === false ||
                this._controls.enablePolarRotation === false ||
                this._controls.enableObjectControls === true) {
                spherical.theta = Math.max(minAzimuthAngle, Math.min(maxAzimuthAngle, spherical.theta));
                spherical.phi = Math.max(minPolarAngle, Math.min(maxPolarAngle, spherical.phi));
                if (this._controls.enableAzimuthRotation === false || this._controls.enablePolarRotation === false || this._controls.enableObjectControls === true) {
                    const defaultOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), this._controls.camera.defaultPosition, this._controls.camera.defaultTarget);
                    gl_matrix_1.vec3.transformQuat(defaultOffset, defaultOffset, this._quat);
                    const defaultSpherical = new viewer_shared_math_1.Spherical().fromVec3(defaultOffset);
                    if (this._controls.enableAzimuthRotation === false)
                        spherical.theta = defaultSpherical.theta;
                    if (this._controls.enablePolarRotation === false)
                        spherical.phi = defaultSpherical.phi;
                    if (this._controls.enableObjectControls) {
                        spherical.theta = defaultSpherical.theta;
                        spherical.phi = defaultSpherical.phi;
                    }
                }
                spherical.makeSafe();
                offset = spherical.toVec3();
                gl_matrix_1.vec3.transformQuat(offset, offset, this._quatInverse);
                gl_matrix_1.vec3.add(position, offset, target);
            }
            if ((sceneRotation[1] < minAzimuthAngle ||
                sceneRotation[1] > maxAzimuthAngle ||
                sceneRotation[0] < minPolarAngle ||
                sceneRotation[0] > maxPolarAngle ||
                this._controls.enableAzimuthRotation === false ||
                this._controls.enablePolarRotation === false) &&
                this._controls.enableObjectControls === false) {
                sceneRotation[1] = this._controls.enableAzimuthRotation === false ? 0 : Math.max(minAzimuthAngle, Math.min(maxAzimuthAngle, sceneRotation[1]));
                sceneRotation[0] = this._controls.enablePolarRotation === false ? 0 : Math.max(minPolarAngle, Math.min(maxPolarAngle, sceneRotation[0]));
            }
        }
        return { position, target, sceneRotation };
    }
    rotate(x, y, active, touch) {
        if (this._controls.camera.type === ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC && this._controls.camera.direction !== IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.CUSTOM)
            return;
        if (!active) {
            this._rotateStart = gl_matrix_1.vec2.fromValues(x, y);
        }
        else {
            this._rotateEnd = gl_matrix_1.vec2.fromValues(x, y);
            gl_matrix_1.vec2.subtract(this._rotateDelta, this._rotateEnd, this._rotateStart);
            gl_matrix_1.vec2.copy(this._rotateStart, this._rotateEnd);
            if (!this._controls.canvas)
                return;
            if (this._controls.canvas.clientWidth == 0 || this._controls.canvas.clientHeight == 0)
                return;
            const spherical = new viewer_shared_math_1.Spherical();
            const rotationSpeed = this._adjustedSettings.rotationSpeed() * (touch ? this._touchAdjustments.rotationSpeed : 1.0);
            spherical.theta -= rotationSpeed * this._rotateDelta[0] / this._controls.canvas.clientHeight;
            spherical.phi -= rotationSpeed * this._rotateDelta[1] / this._controls.canvas.clientHeight;
            if (this._damping.rotation.duration > 0) {
                const thetaDelta = this._damping.rotation.theta - spherical.theta;
                spherical.theta += thetaDelta * this._adjustedSettings.movementSmoothness();
                const phiDelta = this._damping.rotation.phi - spherical.phi;
                spherical.phi += phiDelta * this._adjustedSettings.movementSmoothness();
            }
            let sphericalForOffset = spherical;
            if (this._controls.enableTurntableControls)
                sphericalForOffset = new viewer_shared_math_1.Spherical(1.0, spherical.phi, 0);
            const offset = this.rotationSphericalToOffset(sphericalForOffset);
            const damping = 1 - Math.max(0.01, Math.min(1, this._adjustedSettings.damping()));
            const framesTheta = (Math.log(1 / Math.abs(spherical.theta)) - 5 * Math.log(10)) / (Math.log(damping));
            const framesPhi = (Math.log(1 / Math.abs(spherical.phi)) - 5 * Math.log(10)) / (Math.log(damping));
            this._damping.rotation.time = 0;
            this._damping.rotation.duration = Math.max(framesTheta, framesPhi) * 16.6666;
            this._damping.rotation.theta = spherical.theta;
            this._damping.rotation.phi = spherical.phi;
            this._damping.pan.duration = 0;
            this._damping.zoom.duration = 0;
            this._controls.applyPositionVector(offset, true);
            if (this._controls.enableTurntableControls)
                this._controls.applyRotation([0, spherical.theta], true);
            if (this._controls.enableObjectControls)
                this._controls.applyRotation([spherical.phi, spherical.theta], true);
        }
    }
    update(time, manualInteraction) {
        if (manualInteraction === true) {
            this._damping.zoom.duration = 0;
            this._damping.pan.duration = 0;
            this._damping.rotation.duration = 0;
        }
        const damping = 1 - Math.max(0.01, Math.min(1, this._adjustedSettings.damping()));
        if (this._damping.pan.duration > 0) {
            if (this._damping.pan.time + time > this._damping.pan.duration) {
                this._damping.pan.time = this._damping.pan.duration;
                this._damping.pan.duration = 0;
            }
            else {
                this._damping.pan.time += time;
                const frameSinceStart = this._damping.pan.time / 16.6666;
                const dampingFrames = Math.pow(damping, frameSinceStart);
                const offset = gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), this._damping.pan.offset, gl_matrix_1.vec3.fromValues(dampingFrames, dampingFrames, dampingFrames));
                this._controls.applyTargetVector(offset);
                this._controls.applyPositionVector(offset);
            }
        }
        else {
            this._damping.pan.time = 0;
        }
        if (this._damping.rotation.duration > 0) {
            if (this._damping.rotation.time + time > this._damping.rotation.duration) {
                this._damping.rotation.time = this._damping.rotation.duration;
                this._damping.rotation.duration = 0;
            }
            else {
                this._damping.rotation.time += time;
                const frameSinceStart = this._damping.rotation.time / 16.6666;
                const spherical = new viewer_shared_math_1.Spherical();
                spherical.theta = this._damping.rotation.theta * Math.pow(damping, frameSinceStart);
                spherical.phi = this._damping.rotation.phi * Math.pow(damping, frameSinceStart);
                let sphericalForOffset = spherical;
                if (this._controls.enableTurntableControls)
                    sphericalForOffset = new viewer_shared_math_1.Spherical(1.0, spherical.phi, 0);
                const offset = this.rotationSphericalToOffset(sphericalForOffset);
                this._controls.applyPositionVector(offset);
                if (this._controls.enableTurntableControls)
                    this._controls.applyRotation([0, spherical.theta]);
                if (this._controls.enableObjectControls)
                    this._controls.applyRotation([spherical.phi, spherical.theta]);
            }
        }
        else {
            this._damping.rotation.time = 0;
        }
        if (this._damping.zoom.duration > 0) {
            if (this._damping.zoom.time + time > this._damping.zoom.duration) {
                this._damping.zoom.time = this._damping.zoom.duration;
                this._damping.zoom.duration = 0;
            }
            else {
                this._damping.zoom.time += time;
                const frameSinceStart = this._damping.zoom.time / 16.6666;
                const delta = this._damping.zoom.delta * Math.pow(damping, frameSinceStart);
                const offset = this.zoomDistanceToOffset(delta);
                this._controls.applyPositionVector(offset);
            }
        }
        else {
            this._damping.zoom.time = 0;
        }
        if (this._controls.enableAutoRotation) {
            const spherical = new viewer_shared_math_1.Spherical(1.0, 0.0, -this._adjustedSettings.autoRotationSpeed());
            let sphericalForOffset = spherical;
            if (this._controls.enableTurntableControls)
                sphericalForOffset = new viewer_shared_math_1.Spherical(1.0, spherical.phi, 0);
            const offset = this.rotationSphericalToOffset(sphericalForOffset);
            this._controls.applyPositionVector(offset);
            if (this._controls.enableTurntableControls)
                this._controls.applyRotation([0, spherical.theta]);
            if (this._controls.enableObjectControls)
                this._controls.applyRotation([spherical.phi, spherical.theta]);
        }
    }
    zoom(x, y, active, touch) {
        const distance = Math.sqrt(x * x + y * y);
        if (!active) {
            this._dollyStart = distance;
        }
        else {
            this._dollyEnd = distance;
            this._dollyDelta = this._dollyEnd - this._dollyStart;
            this._dollyStart = this._dollyEnd;
            if (this._damping.zoom.duration > 0) {
                if (this._dollyDelta < 0) {
                    this._dollyDelta = Math.min(this._dollyDelta, this._adjustedSettings.movementSmoothness() * this._damping.zoom.delta);
                }
                else {
                    this._dollyDelta = Math.max(this._dollyDelta, this._adjustedSettings.movementSmoothness() * this._damping.zoom.delta);
                }
            }
            const delta = -this._dollyDelta * this._adjustedSettings.zoomSpeed() * (touch ? this._touchAdjustments.zoomSpeed : 1.0);
            const damping = 1 - Math.max(0.01, Math.min(1, this._adjustedSettings.damping()));
            const framesDelta = (Math.log(1 / Math.abs(this._dollyDelta)) - 5 * Math.log(10)) / (Math.log(damping));
            this._damping.zoom.time = 0;
            this._damping.zoom.duration = framesDelta * 16.6666;
            this._damping.zoom.delta = delta;
            this._damping.rotation.duration = 0;
            this._damping.pan.duration = 0;
            const offset = this.zoomDistanceToOffset(delta);
            this._controls.applyPositionVector(offset, true);
        }
    }
    // #endregion Public Methods (7)
    // #region Private Methods (3)
    panDeltaToOffset(panDelta) {
        var _a, _b, _c, _d;
        const offset = gl_matrix_1.vec3.create();
        const panOffset = gl_matrix_1.vec3.create();
        if (!this._controls.canvas)
            return offset;
        if (this._controls.canvas.clientWidth == 0 || this._controls.canvas.clientHeight == 0)
            return offset;
        // perspective
        gl_matrix_1.vec3.subtract(offset, this._controls.getPositionWithManualUpdates(), this._controls.getTargetWithManualUpdates());
        if (this._controls.camera instanceof OrthographicCamera_1.OrthographicCamera) {
            const orthographicCamera = this._controls.camera;
            const mat = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), orthographicCamera.position, orthographicCamera.target, orthographicCamera.up);
            // // we use only clientHeight here so aspect ratio does not distort speed
            // // left
            const v1 = gl_matrix_1.vec3.fromValues(mat[0], mat[1], mat[2]);
            const scalar1 = -(panDelta[0] * (orthographicCamera.right - orthographicCamera.left) * 0.5 / ((_a = this._controls.canvas) === null || _a === void 0 ? void 0 : _a.clientHeight) /** orthographicCamera.zoom */);
            gl_matrix_1.vec3.multiply(v1, v1, gl_matrix_1.vec3.fromValues(scalar1, scalar1, scalar1));
            gl_matrix_1.vec3.add(panOffset, panOffset, v1);
            // // up
            const v2 = gl_matrix_1.vec3.fromValues(mat[4], mat[5], mat[6]);
            const scalar2 = panDelta[1] * (orthographicCamera.right - orthographicCamera.left) * 0.5 / ((_b = this._controls.canvas) === null || _b === void 0 ? void 0 : _b.clientHeight) /** orthographicCamera.zoom */;
            gl_matrix_1.vec3.multiply(v2, v2, gl_matrix_1.vec3.fromValues(scalar2, scalar2, scalar2));
            gl_matrix_1.vec3.add(panOffset, panOffset, v2);
        }
        else {
            let targetDistance = gl_matrix_1.vec3.length(offset);
            // half of the fov is center to top of screen
            targetDistance *= Math.tan(((this._controls.camera.fov / 2) * Math.PI) / 180.0);
            // we use only clientHeight here so aspect ratio does not distort speed
            // left
            const mat = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), this._controls.camera.position, this._controls.camera.target, gl_matrix_1.vec3.fromValues(0, 0, 1));
            const v1 = gl_matrix_1.vec3.fromValues(mat[0], mat[1], mat[2]);
            const scalar1 = -(2 * panDelta[0] * targetDistance / ((_c = this._controls.canvas) === null || _c === void 0 ? void 0 : _c.clientHeight));
            gl_matrix_1.vec3.multiply(v1, v1, gl_matrix_1.vec3.fromValues(scalar1, scalar1, scalar1));
            gl_matrix_1.vec3.add(panOffset, panOffset, v1);
            // // up
            const v2 = gl_matrix_1.vec3.fromValues(mat[4], mat[5], mat[6]);
            const scalar2 = 2 * panDelta[1] * targetDistance / ((_d = this._controls.canvas) === null || _d === void 0 ? void 0 : _d.clientHeight);
            gl_matrix_1.vec3.multiply(v2, v2, gl_matrix_1.vec3.fromValues(scalar2, scalar2, scalar2));
            gl_matrix_1.vec3.add(panOffset, panOffset, v2);
        }
        return gl_matrix_1.vec3.clone(panOffset);
    }
    rotationSphericalToOffset(s) {
        let offset = gl_matrix_1.vec3.create();
        gl_matrix_1.vec3.subtract(offset, this._controls.getPositionWithManualUpdates(), this._controls.getTargetWithManualUpdates());
        gl_matrix_1.vec3.transformQuat(offset, offset, this._quat);
        const spherical = new viewer_shared_math_1.Spherical().fromVec3(offset);
        spherical.theta += s.theta;
        spherical.phi += s.phi;
        const minAzimuthAngle = this._controls.rotationRestriction.minAzimuthAngle * (Math.PI / 180), maxAzimuthAngle = this._controls.rotationRestriction.maxAzimuthAngle * (Math.PI / 180);
        if (spherical.theta > Math.PI) {
            spherical.theta -= 2 * Math.PI;
            if (minAzimuthAngle > spherical.theta) {
                spherical.theta += 2 * Math.PI;
            }
        }
        else if (spherical.theta < -Math.PI) {
            spherical.theta += 2 * Math.PI;
            if (maxAzimuthAngle < spherical.theta) {
                spherical.theta -= 2 * Math.PI;
            }
        }
        spherical.makeSafe();
        offset = spherical.toVec3();
        offset = gl_matrix_1.vec3.transformQuat(gl_matrix_1.vec3.create(), offset, this._quatInverse);
        offset = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), offset, this._controls.getTargetWithManualUpdates());
        offset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), offset, this._controls.getPositionWithManualUpdates());
        return gl_matrix_1.vec3.clone(offset);
    }
    zoomDistanceToOffset(distance) {
        const offset = gl_matrix_1.vec3.create();
        gl_matrix_1.vec3.subtract(offset, this._controls.getPositionWithManualUpdates(), this._controls.getTargetWithManualUpdates());
        return gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), offset, gl_matrix_1.vec3.fromValues(distance, distance, distance));
    }
}
exports.CameraControlsLogic = CameraControlsLogic;
//# sourceMappingURL=CameraControlsLogic.js.map

/***/ }),

/***/ 45080:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrthographicCameraControls = void 0;
const AbstractCameraControls_1 = __webpack_require__(81600);
const CameraControlsLogic_1 = __webpack_require__(92658);
const CameraControlsEventDistribution_1 = __webpack_require__(68410);
class OrthographicCameraControls extends AbstractCameraControls_1.AbstractCameraControls {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(camera, enabled) {
        super(camera, enabled);
        // #region Properties (2)
        this._settingsAdjustments = {
            autoRotationSpeed: 2 * Math.PI / 60 / 60,
            damping: 1.0,
            movementSmoothness: 1.0,
            panSpeed: 1.75,
            rotationSpeed: Math.PI,
            zoomSpeed: 0.025,
        };
        this._touchAdjustments = {
            autoRotationSpeed: 1.0,
            damping: 1.0,
            movementSmoothness: 1.0,
            panSpeed: 4.0 / 1.75,
            rotationSpeed: 1.5,
            zoomSpeed: 100.0,
        };
        this._cameraLogic = new CameraControlsLogic_1.CameraControlsLogic(this, this._settingsAdjustments, this._touchAdjustments);
        this._cameraControlsEventDistribution = new CameraControlsEventDistribution_1.CameraControlsEventDistribution(this, this._cameraLogic);
    }
}
exports.OrthographicCameraControls = OrthographicCameraControls;
//# sourceMappingURL=OrthographicCameraControls.js.map

/***/ }),

/***/ 85092:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PerspectiveCameraControls = void 0;
const AbstractCameraControls_1 = __webpack_require__(81600);
const CameraControlsLogic_1 = __webpack_require__(92658);
const CameraControlsEventDistribution_1 = __webpack_require__(68410);
class PerspectiveCameraControls extends AbstractCameraControls_1.AbstractCameraControls {
    // #endregion Properties (3)
    // #region Constructors (1)
    constructor(camera, enabled) {
        super(camera, enabled);
        // #region Properties (3)
        this._settingsAdjustments = {
            autoRotationSpeed: 2 * Math.PI / 60 / 60,
            damping: 1.0,
            movementSmoothness: 1.0,
            panSpeed: 1.75,
            rotationSpeed: Math.PI,
            zoomSpeed: 0.025,
        };
        this._touchAdjustments = {
            autoRotationSpeed: 1.0,
            damping: 1.0,
            movementSmoothness: 1.0,
            panSpeed: 1.0 / 1.75,
            rotationSpeed: 1.5,
            zoomSpeed: 100.0,
        };
        this._cameraLogic = new CameraControlsLogic_1.CameraControlsLogic(this, this._settingsAdjustments, this._touchAdjustments);
        this._cameraControlsEventDistribution = new CameraControlsEventDistribution_1.CameraControlsEventDistribution(this, this._cameraLogic);
    }
}
exports.PerspectiveCameraControls = PerspectiveCameraControls;
//# sourceMappingURL=PerspectiveCameraControls.js.map

/***/ }),

/***/ 72639:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CameraInterpolationManager = void 0;
const TWEEN = __importStar(__webpack_require__(21417));
const CameraCylindricalInterpolation_1 = __webpack_require__(95125);
const CameraLinearInterpolation_1 = __webpack_require__(63246);
const CameraMultipleInterpolation_1 = __webpack_require__(56657);
const CameraSphericalInterpolation_1 = __webpack_require__(5484);
class CameraInterpolationManager {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(_camera, _cameraControls) {
        this._camera = _camera;
        this._cameraControls = _cameraControls;
        // #region Properties (2)
        this.TweenWrapper = class {
            constructor(options, cb, onComplete) {
                this._properties = { delta: 0 };
                this._tween = new TWEEN.Tween(this._properties);
                this._tween.easing(options.easing);
                this._tween.to({ delta: 1.0 }, options.duration);
                this._tween.onUpdate((v) => {
                    cb.onUpdate(v);
                });
                this._tween.onStop((v) => {
                    if (cb.onStop)
                        cb.onStop(v);
                    this._resolve(true);
                });
                this._tween.onComplete((v) => {
                    if (cb.onComplete)
                        cb.onComplete(v);
                    onComplete();
                    this._resolve(true);
                });
            }
            start() {
                return new Promise((resolve) => {
                    this._resolve = resolve;
                    this._tween.start();
                });
            }
            stop() {
                this._tween.stop();
            }
        };
    }
    // #endregion Constructors (1)
    // #region Public Methods (3)
    active() {
        return this._tween ? true : false;
    }
    /**
     * cameraTween
     */
    interpolate(path, options = {}) {
        const newPath = [];
        for (let i = 0; i < path.length; i++)
            newPath.push({
                position: path[i].position,
                target: path[i].target,
            });
        if (this._tween) {
            this._tween.stop();
            this._tween = null;
        }
        const parsedOptions = this.optionsParser(options);
        this._tween = new this.TweenWrapper(parsedOptions, newPath.length === 2 ?
            this.getCameraInterpolation(newPath[0], newPath[1], parsedOptions.coordinates) :
            new CameraMultipleInterpolation_1.CameraMultipleInterpolation(this._camera, this._cameraControls, newPath, parsedOptions.interpolation), () => { this._tween = null; });
        return this._tween.start();
    }
    stop() {
        if (this._tween)
            this._tween.stop();
        this._tween = null;
    }
    // #endregion Public Methods (3)
    // #region Private Methods (2)
    getCameraInterpolation(from, to, type) {
        switch (type) {
            case 'linear':
                return new CameraLinearInterpolation_1.CameraLinearInterpolation(this._camera, this._cameraControls, from, to);
            case 'spherical':
                return new CameraSphericalInterpolation_1.CameraSphericalInterpolation(this._camera, this._cameraControls, from, to);
            case 'cylindrical':
                return new CameraCylindricalInterpolation_1.CameraCylindricalInterpolation(this._camera, this._cameraControls, from, to);
            default:
                return new CameraMultipleInterpolation_1.CameraMultipleInterpolation(this._camera, this._cameraControls, [from, to], TWEEN.Interpolation.CatmullRom);
        }
    }
    optionsParser(options) {
        let easing = TWEEN.Easing.Quartic.InOut;
        if (typeof options.easing === 'string') {
            const keys = options.easing.split('.');
            const easingFamily = TWEEN.Easing[keys[0]];
            if (easingFamily) {
                const easingFunction = easingFamily[keys[1]];
                if (easingFunction)
                    easing = easingFunction;
            }
        }
        else if (typeof options.easing === 'function') {
            easing = options.easing;
        }
        let interpolation = TWEEN.Interpolation.CatmullRom;
        if (typeof options.interpolation === 'string') {
            const interpolationFunction = TWEEN.Interpolation[options.interpolation];
            if (interpolationFunction && interpolationFunction !== TWEEN.Interpolation.Utils)
                interpolation = interpolationFunction;
        }
        else if (typeof options.interpolation === 'function') {
            interpolation = options.interpolation;
        }
        return {
            duration: options.duration && options.duration >= 0 ? options.duration : 0,
            easing,
            coordinates: options.coordinates !== 'spherical' && options.coordinates !== 'linear' && options.coordinates !== 'cylindrical' ? 'cylindrical' : options.coordinates,
            interpolation
        };
    }
}
exports.CameraInterpolationManager = CameraInterpolationManager;
//# sourceMappingURL=CameraInterpolationManager.js.map

/***/ }),

/***/ 95125:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CameraCylindricalInterpolation = void 0;
const gl_matrix_1 = __webpack_require__(61961);
class CameraCylindricalInterpolation {
    // #endregion Properties (10)
    // #region Constructors (1)
    constructor(_camera, _cameraControls, _from, _to) {
        this._camera = _camera;
        this._cameraControls = _cameraControls;
        this._from = _from;
        this._to = _to;
        this._h_from = this._from.position[2] - this._from.target[2];
        this._from_position_heightAdjusted = gl_matrix_1.vec3.fromValues(this._from.position[0], this._from.position[1], this._from.target[2]);
        this._r_from = gl_matrix_1.vec3.distance(this._from_position_heightAdjusted, this._from.target);
        this._dir_from = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), this._from_position_heightAdjusted, this._from.target));
        this._h_to = this._to.position[2] - this._to.target[2];
        this._to_position_heightAdjusted = gl_matrix_1.vec3.fromValues(this._to.position[0], this._to.position[1], this._to.target[2]);
        this._r_to = gl_matrix_1.vec3.distance(this._to_position_heightAdjusted, this._to.target);
        this._dir_to = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), this._to_position_heightAdjusted, this._to.target));
        if (this._dir_from[0] === 0 && this._dir_from[1] === 0 && this._dir_from[2] === 0)
            this._dir_from = gl_matrix_1.vec3.fromValues(1, 0, 0);
        if (this._dir_to[0] === 0 && this._dir_to[1] === 0 && this._dir_to[2] === 0)
            this._dir_to = gl_matrix_1.vec3.fromValues(1, 0, 0);
        this._lorr = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), this._dir_to, this._dir_from);
        // This is why people hate JavaScript. The dot product of two normalized vector is larger than 1 on occasion due to precision errors...
        const dot1 = Math.min(1, Math.max(-1, gl_matrix_1.vec3.dot(this._dir_to, this._dir_from)));
        const dot2 = Math.min(1, Math.max(-1, gl_matrix_1.vec3.dot(this._lorr, gl_matrix_1.vec3.fromValues(0, 0, 1))));
        this._shortest_angle = dot2 > 0 ? -Math.acos(dot1) : Math.acos(dot1);
    }
    // #endregion Constructors (1)
    // #region Public Methods (3)
    onComplete(value) {
        const positionOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this._to.position[0], this._to.position[1], this._to.position[2]), this._cameraControls.getPositionWithUpdates());
        this._cameraControls.applyPositionVector(positionOffset);
        const targetOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this._to.target[0], this._to.target[1], this._to.target[2]), this._cameraControls.getTargetWithUpdates());
        this._cameraControls.applyTargetVector(targetOffset);
    }
    onStop(value) {
    }
    onUpdate(value) {
        const t = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), this._from.target, gl_matrix_1.vec3.fromValues(1 - value.delta, 1 - value.delta, 1 - value.delta)), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), this._to.target, gl_matrix_1.vec3.fromValues(value.delta, value.delta, value.delta)));
        const targetOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), t, this._cameraControls.getTargetWithUpdates());
        this._cameraControls.applyTargetVector(targetOffset);
        const angle = this._shortest_angle * value.delta;
        const dir = gl_matrix_1.vec3.transformQuat(gl_matrix_1.vec3.create(), this._dir_from, gl_matrix_1.quat.setAxisAngle(gl_matrix_1.quat.create(), gl_matrix_1.vec3.fromValues(0, 0, 1), angle));
        const scalar = this._r_from * (1 - value.delta) + this._r_to * value.delta;
        const p = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), t, gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), dir, gl_matrix_1.vec3.fromValues(scalar, scalar, scalar)));
        gl_matrix_1.vec3.add(p, p, gl_matrix_1.vec3.fromValues(0, 0, (this._h_from * (1 - value.delta) + this._h_to * value.delta)));
        const positionOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), p, this._cameraControls.getPositionWithUpdates());
        this._cameraControls.applyPositionVector(positionOffset);
    }
}
exports.CameraCylindricalInterpolation = CameraCylindricalInterpolation;
//# sourceMappingURL=CameraCylindricalInterpolation.js.map

/***/ }),

/***/ 63246:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CameraLinearInterpolation = void 0;
const gl_matrix_1 = __webpack_require__(61961);
class CameraLinearInterpolation {
    // #region Constructors (1)
    constructor(_camera, _cameraControls, _from, _to) {
        this._camera = _camera;
        this._cameraControls = _cameraControls;
        this._from = _from;
        this._to = _to;
    }
    // #endregion Constructors (1)
    // #region Public Methods (3)
    onComplete(value) {
        const positionOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), this._to.position, this._cameraControls.getPositionWithUpdates());
        this._cameraControls.applyPositionVector(positionOffset);
        const targetOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), this._to.target, this._cameraControls.getTargetWithUpdates());
        this._cameraControls.applyTargetVector(targetOffset);
    }
    onStop(value) {
    }
    onUpdate(value) {
        const p = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), this._from.position, gl_matrix_1.vec3.fromValues(1 - value.delta, 1 - value.delta, 1 - value.delta)), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), this._to.position, gl_matrix_1.vec3.fromValues(value.delta, value.delta, value.delta)));
        const positionOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), p, this._cameraControls.getPositionWithUpdates());
        this._cameraControls.applyPositionVector(positionOffset);
        const t = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), this._from.target, gl_matrix_1.vec3.fromValues(1 - value.delta, 1 - value.delta, 1 - value.delta)), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), this._to.target, gl_matrix_1.vec3.fromValues(value.delta, value.delta, value.delta)));
        const targetOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), t, this._cameraControls.getTargetWithUpdates());
        this._cameraControls.applyTargetVector(targetOffset);
    }
}
exports.CameraLinearInterpolation = CameraLinearInterpolation;
//# sourceMappingURL=CameraLinearInterpolation.js.map

/***/ }),

/***/ 56657:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CameraMultipleInterpolation = void 0;
const gl_matrix_1 = __webpack_require__(61961);
class CameraMultipleInterpolation {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(_camera, _cameraControls, _path, _interpolationFunction) {
        this._camera = _camera;
        this._cameraControls = _cameraControls;
        this._path = _path;
        this._interpolationFunction = _interpolationFunction;
        // #region Properties (1)
        this.end = {
            position: { x: [], y: [], z: [] },
            target: { x: [], y: [], z: [] }
        };
        for (let i = 0; i < this._path.length; i++) {
            this.end.position.x.push(this._path[i].position[0]);
            this.end.position.y.push(this._path[i].position[1]);
            this.end.position.z.push(this._path[i].position[2]);
            this.end.target.x.push(this._path[i].target[0]);
            this.end.target.y.push(this._path[i].target[1]);
            this.end.target.z.push(this._path[i].target[2]);
        }
    }
    // #endregion Constructors (1)
    // #region Public Methods (3)
    onComplete(value) {
        const positionOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this._path[this._path.length - 1].position[0], this._path[this._path.length - 1].position[1], this._path[this._path.length - 1].position[2]), this._cameraControls.getPositionWithUpdates());
        this._cameraControls.applyPositionVector(positionOffset);
        const targetOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this._path[this._path.length - 1].target[0], this._path[this._path.length - 1].target[1], this._path[this._path.length - 1].target[2]), this._cameraControls.getTargetWithUpdates());
        this._cameraControls.applyTargetVector(targetOffset);
    }
    onStop(value) {
    }
    onUpdate(value) {
        const p = gl_matrix_1.vec3.fromValues(this._interpolationFunction(this.end.position.x, value.delta), this._interpolationFunction(this.end.position.y, value.delta), this._interpolationFunction(this.end.position.z, value.delta));
        const positionOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), p, this._cameraControls.getPositionWithUpdates());
        this._cameraControls.applyPositionVector(positionOffset);
        const t = gl_matrix_1.vec3.fromValues(this._interpolationFunction(this.end.target.x, value.delta), this._interpolationFunction(this.end.target.y, value.delta), this._interpolationFunction(this.end.target.z, value.delta));
        const targetOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), t, this._cameraControls.getTargetWithUpdates());
        this._cameraControls.applyTargetVector(targetOffset);
    }
}
exports.CameraMultipleInterpolation = CameraMultipleInterpolation;
//# sourceMappingURL=CameraMultipleInterpolation.js.map

/***/ }),

/***/ 5484:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CameraSphericalInterpolation = void 0;
const gl_matrix_1 = __webpack_require__(61961);
class CameraSphericalInterpolation {
    // #endregion Properties (6)
    // #region Constructors (1)
    constructor(_camera, _cameraControls, _from, _to) {
        this._camera = _camera;
        this._cameraControls = _cameraControls;
        this._from = _from;
        this._to = _to;
        this._radius_from = gl_matrix_1.vec3.distance(this._from.position, this._from.target);
        this._direction_from = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), this._from.position, this._from.target));
        this._radius_to = gl_matrix_1.vec3.distance(this._to.position, this._to.target);
        this._direction_to = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), this._to.position, this._to.target));
        this._axis = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), this._direction_to, this._direction_from));
        this._c_angle = -Math.acos(Math.min(1, Math.max(-1, gl_matrix_1.vec3.dot(this._direction_to, this._direction_from))));
    }
    // #endregion Constructors (1)
    // #region Public Methods (3)
    onComplete(value) {
        const positionOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this._to.position[0], this._to.position[1], this._to.position[2]), this._cameraControls.getPositionWithUpdates());
        this._cameraControls.applyPositionVector(positionOffset);
        const targetOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this._to.target[0], this._to.target[1], this._to.target[2]), this._cameraControls.getTargetWithUpdates());
        this._cameraControls.applyTargetVector(targetOffset);
    }
    onStop(value) {
    }
    onUpdate(value) {
        const t = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), this._from.target, gl_matrix_1.vec3.fromValues(1 - value.delta, 1 - value.delta, 1 - value.delta)), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), this._to.target, gl_matrix_1.vec3.fromValues(value.delta, value.delta, value.delta)));
        const targetOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), t, this._cameraControls.getTargetWithUpdates());
        this._cameraControls.applyTargetVector(targetOffset);
        const angle = this._c_angle * value.delta;
        const dir = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.transformQuat(gl_matrix_1.vec3.create(), this._direction_from, gl_matrix_1.quat.setAxisAngle(gl_matrix_1.quat.create(), this._axis, angle)));
        const scalar = (this._radius_from * (1 - value.delta) + this._radius_to * value.delta);
        const p = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), t, gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), dir, gl_matrix_1.vec3.fromValues(scalar, scalar, scalar)));
        const positionOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), p, this._cameraControls.getPositionWithUpdates());
        this._cameraControls.applyPositionVector(positionOffset);
    }
}
exports.CameraSphericalInterpolation = CameraSphericalInterpolation;
//# sourceMappingURL=CameraSphericalInterpolation.js.map

/***/ }),

/***/ 17989:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrthographicCameraControls = exports.PerspectiveCameraControls = exports.OrthographicCamera = exports.PerspectiveCamera = exports.ORTHOGRAPHIC_CAMERA_DIRECTION = exports.CAMERA_TYPE = exports.AbstractCamera = exports.CameraEngine = void 0;
const AbstractCamera_1 = __webpack_require__(26153);
Object.defineProperty(exports, "AbstractCamera", ({ enumerable: true, get: function () { return AbstractCamera_1.AbstractCamera; } }));
const ICameraEngine_1 = __webpack_require__(23564);
Object.defineProperty(exports, "CAMERA_TYPE", ({ enumerable: true, get: function () { return ICameraEngine_1.CAMERA_TYPE; } }));
const CameraEngine_1 = __webpack_require__(28839);
Object.defineProperty(exports, "CameraEngine", ({ enumerable: true, get: function () { return CameraEngine_1.CameraEngine; } }));
const IOrthographicCamera_1 = __webpack_require__(49578);
Object.defineProperty(exports, "ORTHOGRAPHIC_CAMERA_DIRECTION", ({ enumerable: true, get: function () { return IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION; } }));
const OrthographicCamera_1 = __webpack_require__(36817);
Object.defineProperty(exports, "OrthographicCamera", ({ enumerable: true, get: function () { return OrthographicCamera_1.OrthographicCamera; } }));
const OrthographicCameraControls_1 = __webpack_require__(45080);
Object.defineProperty(exports, "OrthographicCameraControls", ({ enumerable: true, get: function () { return OrthographicCameraControls_1.OrthographicCameraControls; } }));
const PerspectiveCamera_1 = __webpack_require__(80187);
Object.defineProperty(exports, "PerspectiveCamera", ({ enumerable: true, get: function () { return PerspectiveCamera_1.PerspectiveCamera; } }));
const PerspectiveCameraControls_1 = __webpack_require__(85092);
Object.defineProperty(exports, "PerspectiveCameraControls", ({ enumerable: true, get: function () { return PerspectiveCameraControls_1.PerspectiveCameraControls; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 23564:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CAMERA_TYPE = void 0;
// #endregion Interfaces (1)
// #region Enums (1)
var CAMERA_TYPE;
(function (CAMERA_TYPE) {
    CAMERA_TYPE["PERSPECTIVE"] = "perspective";
    CAMERA_TYPE["ORTHOGRAPHIC"] = "orthographic";
})(CAMERA_TYPE = exports.CAMERA_TYPE || (exports.CAMERA_TYPE = {}));
// #endregion Enums (1)
//# sourceMappingURL=ICameraEngine.js.map

/***/ }),

/***/ 49578:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ORTHOGRAPHIC_CAMERA_DIRECTION = void 0;
// #endregion Interfaces (1)
// #region Enums (1)
var ORTHOGRAPHIC_CAMERA_DIRECTION;
(function (ORTHOGRAPHIC_CAMERA_DIRECTION) {
    ORTHOGRAPHIC_CAMERA_DIRECTION["TOP"] = "top";
    ORTHOGRAPHIC_CAMERA_DIRECTION["BOTTOM"] = "bottom";
    ORTHOGRAPHIC_CAMERA_DIRECTION["LEFT"] = "left";
    ORTHOGRAPHIC_CAMERA_DIRECTION["RIGHT"] = "right";
    ORTHOGRAPHIC_CAMERA_DIRECTION["FRONT"] = "front";
    ORTHOGRAPHIC_CAMERA_DIRECTION["BACK"] = "back";
    ORTHOGRAPHIC_CAMERA_DIRECTION["CUSTOM"] = "custom";
})(ORTHOGRAPHIC_CAMERA_DIRECTION = exports.ORTHOGRAPHIC_CAMERA_DIRECTION || (exports.ORTHOGRAPHIC_CAMERA_DIRECTION = {}));
// #endregion Enums (1)
//# sourceMappingURL=IOrthographicCamera.js.map

/***/ }),

/***/ 7037:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Canvas = void 0;
class Canvas {
    // #region Constructors (1)
    constructor(_id, _originalDefinition, _canvasElement) {
        this._id = _id;
        this._originalDefinition = _originalDefinition;
        this._canvasElement = _canvasElement;
        if (this._originalDefinition && this._originalDefinition instanceof HTMLCanvasElement)
            this._originalDefinition = this._originalDefinition.cloneNode(true);
        if (!_canvasElement) {
            this._canvasElement = document.createElement('canvas');
            this._canvasElement.id = this._id;
        }
        else {
            this._canvasElement = _canvasElement;
        }
        this._canvasElement.style.touchAction = 'none';
    }
    // #endregion Constructors (1)
    // #region Public Accessors (2)
    get canvasElement() {
        return this._canvasElement;
    }
    get id() {
        return this._id;
    }
    // #endregion Public Accessors (2)
    // #region Public Methods (1)
    reset() {
        var _a;
        const parent = (_a = this._canvasElement) === null || _a === void 0 ? void 0 : _a.parentElement;
        parent === null || parent === void 0 ? void 0 : parent.removeChild(this._canvasElement);
        if (this._originalDefinition instanceof HTMLCanvasElement) {
            parent === null || parent === void 0 ? void 0 : parent.appendChild(this._canvasElement);
        }
    }
}
exports.Canvas = Canvas;
//# sourceMappingURL=Canvas.js.map

/***/ }),

/***/ 20551:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CanvasEngine = void 0;
const viewer_shared_services_1 = __webpack_require__(8389);
const Canvas_1 = __webpack_require__(7037);
class CanvasEngine {
    constructor() {
        // #region Properties (3)
        this._canvasDictionary = {};
        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;
        // #endregion Public Methods (2)
    }
    // #endregion Properties (3)
    // #region Public Static Accessors (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    // #endregion Public Static Accessors (1)
    // #region Public Methods (2)
    /**
     * Creates a canvas object that could in the future be expanded to hold more information
     * The definition of the canvas can be:
     * - empty: A canvas is created with an unique ID.
     * - string:
     *      - If a canvas with this ID was created, this canvas is returned.
     *      - If there is an HTMLCanvasElement in the document with this ID, this is used.
     *      - If there is no HTMLElement found in the document with this ID, a canvas with ID will be created.
     * - HTMLCanvasElement: A Canvas Object will be created with this element. If there is no ID, one will be generated.
     *
     * @param canvasDefinition the definition of this canvas
     */
    createCanvasObject(canvasDefinition, storageId) {
        storageId = storageId !== undefined && this._uuidGenerator.validate(storageId) ? storageId : this._uuidGenerator.create();
        if (canvasDefinition instanceof HTMLCanvasElement) {
            // a canvas was provided
            const canvasElement = canvasDefinition;
            if (!canvasElement.id)
                canvasElement.id = this._uuidGenerator.create();
            this._canvasDictionary[storageId] = new Canvas_1.Canvas(canvasElement.id, canvasDefinition, canvasElement);
            return storageId;
        }
        if (canvasDefinition) {
            const id = canvasDefinition;
            const canvasElement = document.getElementById(id);
            for (let canvasId in this._canvasDictionary)
                if (this._canvasDictionary[canvasId].id === id)
                    return canvasId;
            if (canvasElement instanceof HTMLCanvasElement) {
                // id of a canvas was provided
                this._canvasDictionary[storageId] = new Canvas_1.Canvas(id, canvasDefinition, canvasElement);
                return storageId;
            }
            else if (!canvasElement) {
                // no HTMLElement could be found, create Canvas with the id
                this._canvasDictionary[storageId] = new Canvas_1.Canvas(id, canvasDefinition);
                return storageId;
            }
        }
        this._canvasDictionary[storageId] = new Canvas_1.Canvas(storageId, canvasDefinition);
        return storageId;
    }
    getCanvas(storageId) {
        return this._canvasDictionary[storageId];
    }
}
exports.CanvasEngine = CanvasEngine;
//# sourceMappingURL=CanvasEngine.js.map

/***/ }),

/***/ 46614:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Canvas = exports.CanvasEngine = void 0;
const Canvas_1 = __webpack_require__(7037);
Object.defineProperty(exports, "Canvas", ({ enumerable: true, get: function () { return Canvas_1.Canvas; } }));
const CanvasEngine_1 = __webpack_require__(20551);
Object.defineProperty(exports, "CanvasEngine", ({ enumerable: true, get: function () { return CanvasEngine_1.CanvasEngine; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 44055:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntersectionEngine = void 0;
const THREE = __importStar(__webpack_require__(39437));
const viewer_shared_services_1 = __webpack_require__(8389);
const viewer_shared_types_1 = __webpack_require__(64766);
const viewer_shared_node_tree_1 = __webpack_require__(41652);
class IntersectionEngine {
    // #endregion Properties (5)
    // #region Constructors (1)
    constructor() {
        // #region Properties (5)
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._raycaster = new THREE.Raycaster();
        this._tree = viewer_shared_node_tree_1.Tree.instance;
        this._intersectNodes = [];
        this.gatherNodes();
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.VIEWPORT.VIEWPORT_UPDATED, () => {
            this.gatherNodes();
        });
    }
    // #endregion Constructors (1)
    // #region Public Static Getters And Setters (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    // #endregion Public Static Getters And Setters (1)
    // #region Public Methods (2)
    intersect(ray, viewportId, filterCriteria, rayCasterParams) {
        let intersections = [];
        this._intersectNodes.forEach(i => {
            const currentIntersections = this.intersectNode(ray, i.node, i.geometryData, viewportId, filterCriteria, rayCasterParams);
            if (currentIntersections)
                intersections = intersections.concat(currentIntersections);
        });
        intersections.sort((a, b) => a.distance - b.distance);
        return intersections;
    }
    intersectNode(ray, node, geometryData, viewportId, filterCriteria, rayCasterParams) {
        if (node.visible === false)
            return;
        if (viewportId !== undefined) {
            if (node.excludeViewports.includes(viewportId))
                return;
            if (node.restrictViewports.length > 0 && !node.restrictViewports.includes(viewportId))
                return;
        }
        if (filterCriteria) {
            for (let i = 0; i < filterCriteria.length; i++) {
                if (filterCriteria[i](node))
                    return this.intersectionTest(ray, node, geometryData, viewportId, rayCasterParams);
            }
        }
        else {
            return this.intersectionTest(ray, node, geometryData, viewportId, rayCasterParams);
        }
    }
    // #endregion Public Methods (2)
    // #region Private Methods (2)
    /**
     * Gather all nodes that contain geometry data.
     */
    gatherNodes() {
        this._intersectNodes = [];
        this._tree.root.traverse(node => {
            if (node.visible === false)
                return;
            for (let i = 0; i < node.data.length; i++) {
                if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {
                    const geometryData = node.data[i];
                    let tempNode = node;
                    let visible = true, restrictViewports = [], excludeViewports = [];
                    while (tempNode.parent) {
                        visible = tempNode.visible && visible;
                        restrictViewports = restrictViewports.concat(tempNode.restrictViewports);
                        excludeViewports = excludeViewports.concat(tempNode.excludeViewports);
                        tempNode = tempNode.parent;
                    }
                    this._intersectNodes.push({
                        node,
                        geometryData: { [`${geometryData.id}_${geometryData.version}`]: geometryData },
                        visible,
                        restrictViewports: [...new Set(restrictViewports)],
                        excludeViewports: [...new Set(excludeViewports)]
                    });
                }
            }
        });
    }
    /**
     * Do the intersection test with the ray and the node.
     *
     * @param ray the ray to test
     * @param node the node to test
     * @param geometryData the geometry data of the node
     * @param viewportId the viewport id
     * @returns
     */
    intersectionTest(ray, node, geometryData, viewportId, rayCasterParams) {
        if (rayCasterParams)
            this._raycaster.params = rayCasterParams;
        this._raycaster.ray.direction.set(ray.direction[0], ray.direction[1], ray.direction[2]);
        this._raycaster.ray.origin.set(ray.origin[0], ray.origin[1], ray.origin[2]);
        let intersections = [];
        const threeJsObject = node.convertedObject[viewportId];
        if (threeJsObject) {
            const intersectionThree = this._raycaster.intersectObject(threeJsObject);
            const intersection = intersectionThree.map(i => {
                const intersection = {
                    distance: i.distance,
                    point: [i.point.x, i.point.y, i.point.z],
                    node: node,
                    geometryData: geometryData[`${i.object.parent.SDid}_${i.object.parent.SDversion}`]
                };
                return intersection;
            });
            intersections = intersections.concat(intersection);
        }
        intersections.sort((a, b) => a.distance - b.distance);
        return intersections;
    }
}
exports.IntersectionEngine = IntersectionEngine;
//# sourceMappingURL=IntersectionEngine.js.map

/***/ }),

/***/ 11579:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntersectionEngine = void 0;
const IntersectionEngine_1 = __webpack_require__(44055);
Object.defineProperty(exports, "IntersectionEngine", ({ enumerable: true, get: function () { return IntersectionEngine_1.IntersectionEngine; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 27159:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractLight_type, _AbstractLight_color, _AbstractLight_intensity, _AbstractLight_name, _AbstractLight_order, _AbstractLight_parentNode, _AbstractLight_useNodeData;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractLight = void 0;
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const viewer_shared_services_1 = __webpack_require__(8389);
class AbstractLight extends viewer_shared_node_tree_1.AbstractTreeNodeData {
    // #endregion Properties (8)
    // #region Constructors (1)
    constructor(properties) {
        super(properties.id, properties.version);
        // #region Properties (8)
        _AbstractLight_type.set(this, void 0);
        _AbstractLight_color.set(this, void 0);
        _AbstractLight_intensity.set(this, void 0);
        _AbstractLight_name.set(this, void 0);
        _AbstractLight_order.set(this, void 0);
        _AbstractLight_parentNode.set(this, void 0);
        _AbstractLight_useNodeData.set(this, false);
        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;
        __classPrivateFieldSet(this, _AbstractLight_color, properties.color, "f");
        __classPrivateFieldSet(this, _AbstractLight_intensity, properties.intensity, "f");
        __classPrivateFieldSet(this, _AbstractLight_type, properties.type, "f");
        __classPrivateFieldSet(this, _AbstractLight_name, properties.name, "f");
        __classPrivateFieldSet(this, _AbstractLight_order, properties.order, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (13)
    get color() {
        return __classPrivateFieldGet(this, _AbstractLight_color, "f");
    }
    set color(value) {
        __classPrivateFieldSet(this, _AbstractLight_color, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get intensity() {
        return __classPrivateFieldGet(this, _AbstractLight_intensity, "f");
    }
    set intensity(value) {
        __classPrivateFieldSet(this, _AbstractLight_intensity, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get name() {
        return __classPrivateFieldGet(this, _AbstractLight_name, "f");
    }
    set name(value) {
        __classPrivateFieldSet(this, _AbstractLight_name, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get order() {
        return __classPrivateFieldGet(this, _AbstractLight_order, "f");
    }
    set order(value) {
        __classPrivateFieldSet(this, _AbstractLight_order, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get parentNode() {
        return __classPrivateFieldGet(this, _AbstractLight_parentNode, "f");
    }
    set parentNode(value) {
        __classPrivateFieldSet(this, _AbstractLight_parentNode, value, "f");
    }
    get type() {
        return __classPrivateFieldGet(this, _AbstractLight_type, "f");
    }
    get useNodeData() {
        return __classPrivateFieldGet(this, _AbstractLight_useNodeData, "f");
    }
    set useNodeData(value) {
        __classPrivateFieldSet(this, _AbstractLight_useNodeData, value, "f");
    }
}
exports.AbstractLight = AbstractLight;
_AbstractLight_type = new WeakMap(), _AbstractLight_color = new WeakMap(), _AbstractLight_intensity = new WeakMap(), _AbstractLight_name = new WeakMap(), _AbstractLight_order = new WeakMap(), _AbstractLight_parentNode = new WeakMap(), _AbstractLight_useNodeData = new WeakMap();
//# sourceMappingURL=AbstractLight.js.map

/***/ }),

/***/ 59199:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LightEngine = void 0;
const AmbientLight_1 = __webpack_require__(3363);
const viewer_shared_services_1 = __webpack_require__(8389);
const DirectionalLight_1 = __webpack_require__(62143);
const HemisphereLight_1 = __webpack_require__(65475);
const ILight_1 = __webpack_require__(7029);
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const LightScene_1 = __webpack_require__(17093);
const PointLight_1 = __webpack_require__(43725);
const SpotLight_1 = __webpack_require__(44723);
const gl_matrix_1 = __webpack_require__(61961);
class LightEngine {
    // #endregion Properties (7)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (7)
        this._converter = viewer_shared_services_1.Converter.instance;
        this._lightNode = new viewer_shared_node_tree_1.TreeNode('lights');
        this._tree = viewer_shared_node_tree_1.Tree.instance;
        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;
        this._lightScenes = {};
        this._tree.root.addChild(this._lightNode);
        this._lightNode.restrictViewports = [this._renderingEngine.id];
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (4)
    get lightScene() {
        return this._lightScene;
    }
    get lightScenes() {
        return this._lightScenes;
    }
    get update() {
        return this._update;
    }
    set update(value) {
        this._update = value;
    }
    // #endregion Public Getters And Setters (4)
    // #region Public Methods (6)
    applySettings(settingsEngine) {
        this._lightScenes = {};
        for (const lightSceneId in settingsEngine.light.lightScenes) {
            const lightSceneUUID = this._uuidGenerator.validate(lightSceneId) ? lightSceneId : this._uuidGenerator.create();
            const lightSceneName = settingsEngine.light.lightScenes[lightSceneId].name ? settingsEngine.light.lightScenes[lightSceneId].name : lightSceneId;
            const ls = new LightScene_1.LightScene(this._renderingEngine, { id: lightSceneUUID, name: lightSceneName });
            for (const lightId in settingsEngine.light.lightScenes[lightSceneId].lights) {
                const lightUUID = this._uuidGenerator.validate(lightId) ? lightId : this._uuidGenerator.create();
                const light = settingsEngine.light.lightScenes[lightSceneId].lights[lightId];
                let l;
                switch (light.type) {
                    case ILight_1.LIGHT_TYPE.DIRECTIONAL:
                        l = new DirectionalLight_1.DirectionalLight({
                            color: this._converter.toHexColor(light.properties.color),
                            intensity: light.properties.intensity,
                            direction: this._converter.toVec3(light.properties.direction),
                            castShadow: light.properties.castShadow,
                            shadowMapResolution: light.properties.shadowMapResolution,
                            shadowMapBias: light.properties.shadowMapBias,
                            name: light.name ? light.name : lightId,
                            order: light.order,
                            id: lightUUID
                        });
                        break;
                    case ILight_1.LIGHT_TYPE.HEMISPHERE:
                        l = new HemisphereLight_1.HemisphereLight({
                            color: this._converter.toHexColor(light.properties.skyColor),
                            intensity: light.properties.intensity,
                            groundColor: this._converter.toHexColor(light.properties.groundColor),
                            name: light.name ? light.name : lightId,
                            order: light.order,
                            id: lightUUID
                        });
                        break;
                    case ILight_1.LIGHT_TYPE.POINT:
                        l = new PointLight_1.PointLight({
                            color: this._converter.toHexColor(light.properties.color),
                            intensity: light.properties.intensity,
                            position: this._converter.toVec3(light.properties.position),
                            distance: light.properties.distance,
                            decay: light.properties.decay,
                            name: light.name ? light.name : lightId,
                            order: light.order,
                            id: lightUUID
                        });
                        break;
                    case ILight_1.LIGHT_TYPE.SPOT:
                        l = new SpotLight_1.SpotLight({
                            color: this._converter.toHexColor(light.properties.color),
                            intensity: light.properties.intensity,
                            position: this._converter.toVec3(light.properties.position),
                            target: this._converter.toVec3(light.properties.target),
                            distance: light.properties.distance,
                            decay: light.properties.decay,
                            angle: light.properties.angle,
                            penumbra: light.properties.penumbra,
                            name: light.name ? light.name : lightId,
                            order: light.order,
                            id: lightUUID
                        });
                        break;
                    case ILight_1.LIGHT_TYPE.AMBIENT:
                    default:
                        l = new AmbientLight_1.AmbientLight({
                            color: this._converter.toHexColor(light.properties.color),
                            intensity: light.properties.intensity,
                            name: light.name ? light.name : lightId,
                            order: light.order,
                            id: lightUUID
                        });
                }
                ls.addLight(l);
            }
            this._lightScenes[ls.id] = ls;
        }
        // there is a light scene but no id is saved (old viewer)
        if (settingsEngine.light.lightSceneId === undefined && Object.values(settingsEngine.light.lightScenes).length > 0) {
            const res = this.assignLightScene(Object.keys(settingsEngine.light.lightScenes)[0]);
            if (res === false) {
                const ls = this.createLightScene({ name: settingsEngine.light.lightSceneId === 'default' ? 'default' : 'standard' });
                ls.addLight(new AmbientLight_1.AmbientLight({ color: '#ffffff', intensity: 0.5, name: 'ambient0' }));
                ls.addLight(new DirectionalLight_1.DirectionalLight({ color: '#ffffff', intensity: 0.75, direction: gl_matrix_1.vec3.fromValues(.5774, -.5774, .5774), castShadow: true, name: 'directional0' }));
                ls.addLight(new DirectionalLight_1.DirectionalLight({ color: '#ffffff', intensity: 0.35, direction: gl_matrix_1.vec3.fromValues(.25, -1, 1), castShadow: false, name: 'directional1' }));
                this._lightScenes[ls.id] = ls;
            }
        } // there is no standard light scene in the light scenes, but a light scene name is specified (old viewer)
        else if (settingsEngine.light.lightSceneId) {
            const res = this.assignLightScene(settingsEngine.light.lightSceneId);
            if (res === false) {
                const ls = this.createLightScene({ name: settingsEngine.light.lightSceneId === 'default' ? 'default' : 'standard' });
                ls.addLight(new AmbientLight_1.AmbientLight({ color: '#ffffff', intensity: 0.5, name: 'ambient0' }));
                ls.addLight(new DirectionalLight_1.DirectionalLight({ color: '#ffffff', intensity: 0.75, direction: gl_matrix_1.vec3.fromValues(.5774, -.5774, .5774), castShadow: true, name: 'directional0' }));
                ls.addLight(new DirectionalLight_1.DirectionalLight({ color: '#ffffff', intensity: 0.35, direction: gl_matrix_1.vec3.fromValues(.25, -1, 1), castShadow: false, name: 'directional1' }));
                this._lightScenes[ls.id] = ls;
            }
        }
        // this can only be the case if the settings were completely empty, therefore we assign the new light scene
        else if (JSON.stringify(settingsEngine.settingsJson) == JSON.stringify({})) {
            const ls = this.createLightScene({ name: 'standard', standard: true });
            this._lightScenes[ls.id] = ls;
        }
        if (this._update)
            this._update();
    }
    assignLightScene(id) {
        if (!this._lightScenes[id]) {
            for (const lightSceneId in this._lightScenes) {
                const lightScene = this._lightScenes[lightSceneId];
                const lightSceneName = lightScene.name || lightSceneId;
                if (lightSceneName === id) {
                    const res = this.assignLightScene(lightSceneId);
                    return res;
                }
            }
            return false;
        }
        this._lightScene = this._lightScenes[id];
        while (this._lightNode.children.length > 0)
            this._lightNode.removeChild(this._lightNode.children[0]);
        this._lightNode.addChild(this._lightScene.node);
        this._lightNode.updateVersion();
        return true;
    }
    close() {
        this._tree.root.removeChild(this._lightNode);
    }
    createLightScene(properties) {
        const lightSceneId = this._uuidGenerator.create();
        const lightScene = new LightScene_1.LightScene(this._renderingEngine, { id: lightSceneId, name: properties.name });
        if (properties.standard === true) {
            lightScene.addLight(new DirectionalLight_1.DirectionalLight({ color: '#ffffff', intensity: 2.5, direction: gl_matrix_1.vec3.fromValues(.5774, -.5774, .5774), castShadow: true, name: 'directional0' }));
            lightScene.addLight(new AmbientLight_1.AmbientLight({ color: '#ffffff', intensity: 0.3, name: 'ambient0' }));
        }
        this._lightScenes[lightSceneId] = lightScene;
        this._lightScene = lightScene;
        while (this._lightNode.children.length > 0)
            this._lightNode.removeChild(this._lightNode.children[0]);
        this._lightNode.addChild(this._lightScene.node);
        this._lightNode.updateVersion();
        if (this._update)
            this._update();
        return lightScene;
    }
    removeLightScene(id) {
        if (!this._lightScenes[id]) {
            for (const lightSceneId in this._lightScenes) {
                const lightScene = this._lightScenes[lightSceneId];
                const lightSceneName = lightScene.name || lightSceneId;
                if (lightSceneName === id) {
                    const res = this.removeLightScene(lightSceneId);
                    return res;
                }
            }
            return false;
        }
        if (this._lightScene && this._lightScene.id === id) {
            this._lightScene = undefined;
            while (this._lightNode.children.length > 0)
                this._lightNode.removeChild(this._lightNode.children[0]);
            this._lightNode.updateVersion();
        }
        delete this._lightScenes[id];
        if (this._update)
            this._update();
        return true;
    }
    saveSettings(settingsEngine) {
        settingsEngine.light.lightSceneId = this.lightScene ? this.lightScene.id : undefined;
        const converted = {};
        for (const lightSceneId in this._lightScenes) {
            const lightScene = this._lightScenes[lightSceneId];
            const lightSceneName = lightScene.name || lightSceneId;
            converted[lightSceneId] = {
                name: lightSceneName,
                lights: {}
            };
            for (const lightId in lightScene.lights) {
                const light = lightScene.lights[lightId];
                let properties;
                switch (light.type) {
                    case ILight_1.LIGHT_TYPE.DIRECTIONAL:
                        properties = {
                            color: this._converter.toHexColor(light.color),
                            intensity: light.intensity,
                            direction: { x: light.direction[0], y: light.direction[1], z: light.direction[2] },
                            castShadow: light.castShadow,
                            shadowMapResolution: light.shadowMapResolution,
                            shadowMapBias: light.shadowMapBias
                        };
                        break;
                    case ILight_1.LIGHT_TYPE.HEMISPHERE:
                        properties = {
                            skyColor: this._converter.toHexColor(light.color),
                            intensity: light.intensity,
                            groundColor: this._converter.toHexColor(light.groundColor)
                        };
                        break;
                    case ILight_1.LIGHT_TYPE.POINT:
                        properties = {
                            color: this._converter.toHexColor(light.color),
                            intensity: light.intensity,
                            position: { x: light.position[0], y: light.position[1], z: light.position[2] },
                            distance: light.distance,
                            decay: light.decay
                        };
                        break;
                    case ILight_1.LIGHT_TYPE.SPOT:
                        properties = {
                            color: this._converter.toHexColor(light.color),
                            intensity: light.intensity,
                            position: { x: light.position[0], y: light.position[1], z: light.position[2] },
                            target: { x: light.target[0], y: light.target[1], z: light.target[2] },
                            distance: light.distance,
                            decay: light.decay,
                            angle: light.angle,
                            penumbra: light.penumbra
                        };
                        break;
                    case ILight_1.LIGHT_TYPE.AMBIENT:
                    default:
                        properties = {
                            color: this._converter.toHexColor(light.color),
                            intensity: light.intensity
                        };
                }
                converted[lightSceneId].lights[lightId] = {
                    name: light.name,
                    type: light.type,
                    properties
                };
                if (light.order !== undefined)
                    converted[lightSceneId].lights[lightId].order = light.order;
            }
        }
        settingsEngine.light.lightScenes = converted;
    }
}
exports.LightEngine = LightEngine;
//# sourceMappingURL=LightEngine.js.map

/***/ }),

/***/ 17093:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LightScene = void 0;
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const AmbientLight_1 = __webpack_require__(3363);
const DirectionalLight_1 = __webpack_require__(62143);
const HemisphereLight_1 = __webpack_require__(65475);
const PointLight_1 = __webpack_require__(43725);
const SpotLight_1 = __webpack_require__(44723);
class LightScene {
    // #endregion Properties (5)
    // #region Constructors (1)
    constructor(_renderingEngine, properties) {
        this._renderingEngine = _renderingEngine;
        this._lights = {};
        this._id = properties.id;
        this._name = properties.name;
        this._node = new viewer_shared_node_tree_1.TreeNode(properties.name || properties.id);
    }
    // #endregion Constructors (1)
    // #region Public Accessors (5)
    get id() {
        return this._id;
    }
    get lights() {
        return this._lights;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get node() {
        return this._node;
    }
    get update() {
        return this._update;
    }
    set update(value) {
        this._update = value;
    }
    // #endregion Public Accessors (5)
    // #region Public Methods (8)
    addAmbientLight(properties) {
        const light = new AmbientLight_1.AmbientLight(properties);
        this.addLight(light);
        return light;
    }
    addDirectionalLight(properties) {
        const light = new DirectionalLight_1.DirectionalLight(properties);
        this.addLight(light);
        return light;
    }
    addHemisphereLight(properties) {
        const light = new HemisphereLight_1.HemisphereLight(properties);
        this.addLight(light);
        return light;
    }
    addLight(light) {
        const node = new viewer_shared_node_tree_1.TreeNode(light.id);
        light.parentNode = node;
        node.data.push(light);
        this._node.addChild(node);
        this._lights[light.id] = light;
        this._node.updateVersion();
        if (this._update)
            this._update();
    }
    addPointLight(properties) {
        const light = new PointLight_1.PointLight(properties);
        this.addLight(light);
        return light;
    }
    addSpotLight(properties) {
        const light = new SpotLight_1.SpotLight(properties);
        this.addLight(light);
        return light;
    }
    removeLight(id) {
        if (!this._lights[id])
            return false;
        for (let i = 0; i < this._node.children.length; i++) {
            const node = this._node.children[i];
            if (node && node.name === id) {
                this._node.removeChild(node);
                break;
            }
        }
        delete this._lights[id];
        this._node.updateVersion();
        if (this._update)
            this._update();
        return true;
    }
}
exports.LightScene = LightScene;
//# sourceMappingURL=LightScene.js.map

/***/ }),

/***/ 3363:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AmbientLight = void 0;
const AbstractLight_1 = __webpack_require__(27159);
const ILight_1 = __webpack_require__(7029);
class AmbientLight extends AbstractLight_1.AbstractLight {
    // #region Constructors (1)
    constructor(properties) {
        super({
            color: properties.color || '#ffffff',
            intensity: properties.intensity !== undefined ? properties.intensity : 1,
            type: ILight_1.LIGHT_TYPE.AMBIENT,
            name: properties.name,
            order: properties.order,
            id: properties.id,
            version: properties.version
        });
    }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    clone() {
        return new AmbientLight({
            color: this.color || '#ffffff',
            intensity: this.intensity || 0.5,
            name: this.name,
            order: this.order,
            id: this.id,
            version: this.version
        });
    }
}
exports.AmbientLight = AmbientLight;
//# sourceMappingURL=AmbientLight.js.map

/***/ }),

/***/ 62143:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DirectionalLight_castShadow, _DirectionalLight_direction, _DirectionalLight_shadowMapBias, _DirectionalLight_shadowMapResolution;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirectionalLight = void 0;
const AbstractLight_1 = __webpack_require__(27159);
const ILight_1 = __webpack_require__(7029);
const gl_matrix_1 = __webpack_require__(61961);
class DirectionalLight extends AbstractLight_1.AbstractLight {
    // #endregion Properties (4)
    // #region Constructors (1)
    constructor(properties) {
        super({
            color: properties.color || '#ffffff',
            intensity: properties.intensity !== undefined ? properties.intensity : 1,
            type: ILight_1.LIGHT_TYPE.DIRECTIONAL,
            name: properties.name,
            order: properties.order,
            id: properties.id,
            version: properties.version
        });
        // #region Properties (4)
        _DirectionalLight_castShadow.set(this, true);
        _DirectionalLight_direction.set(this, gl_matrix_1.vec3.fromValues(-1, 0, 1));
        _DirectionalLight_shadowMapBias.set(this, -0.003);
        _DirectionalLight_shadowMapResolution.set(this, 1024);
        if (properties.direction)
            __classPrivateFieldSet(this, _DirectionalLight_direction, properties.direction, "f");
        if (properties.castShadow !== undefined)
            __classPrivateFieldSet(this, _DirectionalLight_castShadow, properties.castShadow, "f");
        if (properties.shadowMapResolution)
            __classPrivateFieldSet(this, _DirectionalLight_shadowMapResolution, properties.shadowMapResolution, "f");
        if (properties.shadowMapBias)
            __classPrivateFieldSet(this, _DirectionalLight_shadowMapBias, properties.shadowMapBias, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (8)
    get castShadow() {
        return __classPrivateFieldGet(this, _DirectionalLight_castShadow, "f");
    }
    set castShadow(value) {
        __classPrivateFieldSet(this, _DirectionalLight_castShadow, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get direction() {
        return __classPrivateFieldGet(this, _DirectionalLight_direction, "f");
    }
    set direction(value) {
        __classPrivateFieldSet(this, _DirectionalLight_direction, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get shadowMapBias() {
        return __classPrivateFieldGet(this, _DirectionalLight_shadowMapBias, "f");
    }
    set shadowMapBias(value) {
        __classPrivateFieldSet(this, _DirectionalLight_shadowMapBias, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get shadowMapResolution() {
        return __classPrivateFieldGet(this, _DirectionalLight_shadowMapResolution, "f");
    }
    set shadowMapResolution(value) {
        __classPrivateFieldSet(this, _DirectionalLight_shadowMapResolution, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    // #endregion Public Getters And Setters (8)
    // #region Public Methods (1)
    clone() {
        return new DirectionalLight({
            color: this.color,
            intensity: this.intensity,
            direction: this.direction,
            castShadow: this.castShadow,
            shadowMapResolution: this.shadowMapResolution,
            shadowMapBias: this.shadowMapBias,
            name: this.name,
            order: this.order,
            id: this.id,
            version: this.version
        });
    }
}
exports.DirectionalLight = DirectionalLight;
_DirectionalLight_castShadow = new WeakMap(), _DirectionalLight_direction = new WeakMap(), _DirectionalLight_shadowMapBias = new WeakMap(), _DirectionalLight_shadowMapResolution = new WeakMap();
//# sourceMappingURL=DirectionalLight.js.map

/***/ }),

/***/ 65475:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HemisphereLight_groundColor;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HemisphereLight = void 0;
const AbstractLight_1 = __webpack_require__(27159);
const ILight_1 = __webpack_require__(7029);
class HemisphereLight extends AbstractLight_1.AbstractLight {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(properties) {
        super({
            color: properties.color || '#ffffff',
            intensity: properties.intensity !== undefined ? properties.intensity : 1,
            type: ILight_1.LIGHT_TYPE.HEMISPHERE,
            name: properties.name,
            order: properties.order,
            id: properties.id,
            version: properties.version
        });
        // #region Properties (1)
        _HemisphereLight_groundColor.set(this, '#000000');
        if (properties.groundColor)
            __classPrivateFieldSet(this, _HemisphereLight_groundColor, properties.groundColor, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (2)
    get groundColor() {
        return __classPrivateFieldGet(this, _HemisphereLight_groundColor, "f");
    }
    set groundColor(value) {
        __classPrivateFieldSet(this, _HemisphereLight_groundColor, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    // #endregion Public Getters And Setters (2)
    // #region Public Methods (1)
    clone() {
        return new HemisphereLight({
            color: this.color,
            groundColor: this.groundColor,
            intensity: this.intensity,
            name: this.name,
            order: this.order,
            id: this.id,
            version: this.version
        });
    }
}
exports.HemisphereLight = HemisphereLight;
_HemisphereLight_groundColor = new WeakMap();
//# sourceMappingURL=HemisphereLight.js.map

/***/ }),

/***/ 43725:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PointLight_decay, _PointLight_distance, _PointLight_position;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PointLight = void 0;
const AbstractLight_1 = __webpack_require__(27159);
const ILight_1 = __webpack_require__(7029);
const gl_matrix_1 = __webpack_require__(61961);
class PointLight extends AbstractLight_1.AbstractLight {
    // #endregion Properties (3)
    // #region Constructors (1)
    constructor(properties) {
        super({
            color: properties.color || '#ffffff',
            intensity: properties.intensity !== undefined ? properties.intensity : 1,
            type: ILight_1.LIGHT_TYPE.POINT,
            name: properties.name,
            order: properties.order,
            id: properties.id,
            version: properties.version
        });
        // #region Properties (3)
        _PointLight_decay.set(this, 0);
        _PointLight_distance.set(this, 0);
        _PointLight_position.set(this, gl_matrix_1.vec3.fromValues(0, 0, 0));
        if (properties.position)
            __classPrivateFieldSet(this, _PointLight_position, properties.position, "f");
        if (properties.distance)
            __classPrivateFieldSet(this, _PointLight_distance, properties.distance, "f");
        if (properties.decay)
            __classPrivateFieldSet(this, _PointLight_decay, properties.decay, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (6)
    get decay() {
        return __classPrivateFieldGet(this, _PointLight_decay, "f");
    }
    set decay(value) {
        __classPrivateFieldSet(this, _PointLight_decay, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get distance() {
        return __classPrivateFieldGet(this, _PointLight_distance, "f");
    }
    set distance(value) {
        __classPrivateFieldSet(this, _PointLight_distance, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get position() {
        return __classPrivateFieldGet(this, _PointLight_position, "f");
    }
    set position(value) {
        __classPrivateFieldSet(this, _PointLight_position, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    // #endregion Public Getters And Setters (6)
    // #region Public Methods (1)
    clone() {
        return new PointLight({
            color: this.color,
            position: this.position,
            distance: this.distance,
            decay: this.decay,
            intensity: this.intensity,
            name: this.name,
            order: this.order,
            id: this.id,
            version: this.version
        });
    }
}
exports.PointLight = PointLight;
_PointLight_decay = new WeakMap(), _PointLight_distance = new WeakMap(), _PointLight_position = new WeakMap();
//# sourceMappingURL=PointLight.js.map

/***/ }),

/***/ 44723:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SpotLight_angle, _SpotLight_decay, _SpotLight_distance, _SpotLight_penumbra, _SpotLight_position, _SpotLight_target;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpotLight = void 0;
const AbstractLight_1 = __webpack_require__(27159);
const ILight_1 = __webpack_require__(7029);
const gl_matrix_1 = __webpack_require__(61961);
class SpotLight extends AbstractLight_1.AbstractLight {
    // #endregion Properties (6)
    // #region Constructors (1)
    constructor(properties) {
        super({
            color: properties.color || '#ffffff',
            intensity: properties.intensity !== undefined ? properties.intensity : 1,
            type: ILight_1.LIGHT_TYPE.SPOT,
            name: properties.name,
            order: properties.order,
            id: properties.id,
            version: properties.version
        });
        // #region Properties (6)
        _SpotLight_angle.set(this, Math.PI / 4.0);
        _SpotLight_decay.set(this, 0);
        _SpotLight_distance.set(this, 0);
        _SpotLight_penumbra.set(this, 0.5);
        _SpotLight_position.set(this, gl_matrix_1.vec3.fromValues(-1, 0, 1));
        _SpotLight_target.set(this, gl_matrix_1.vec3.fromValues(0, 0, 0));
        if (properties.position)
            __classPrivateFieldSet(this, _SpotLight_position, properties.position, "f");
        if (properties.target)
            __classPrivateFieldSet(this, _SpotLight_target, properties.target, "f");
        if (properties.distance)
            __classPrivateFieldSet(this, _SpotLight_distance, properties.distance, "f");
        if (properties.decay)
            __classPrivateFieldSet(this, _SpotLight_decay, properties.decay, "f");
        if (properties.angle)
            __classPrivateFieldSet(this, _SpotLight_angle, properties.angle, "f");
        if (properties.penumbra)
            __classPrivateFieldSet(this, _SpotLight_penumbra, properties.penumbra, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (12)
    get angle() {
        return __classPrivateFieldGet(this, _SpotLight_angle, "f");
    }
    set angle(value) {
        __classPrivateFieldSet(this, _SpotLight_angle, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get decay() {
        return __classPrivateFieldGet(this, _SpotLight_decay, "f");
    }
    set decay(value) {
        __classPrivateFieldSet(this, _SpotLight_decay, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get distance() {
        return __classPrivateFieldGet(this, _SpotLight_distance, "f");
    }
    set distance(value) {
        __classPrivateFieldSet(this, _SpotLight_distance, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get penumbra() {
        return __classPrivateFieldGet(this, _SpotLight_penumbra, "f");
    }
    set penumbra(value) {
        __classPrivateFieldSet(this, _SpotLight_penumbra, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get position() {
        return __classPrivateFieldGet(this, _SpotLight_position, "f");
    }
    set position(value) {
        __classPrivateFieldSet(this, _SpotLight_position, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    get target() {
        return __classPrivateFieldGet(this, _SpotLight_target, "f");
    }
    set target(value) {
        __classPrivateFieldSet(this, _SpotLight_target, value, "f");
        this.updateVersion();
        if (this.parentNode)
            this.parentNode.updateVersion();
    }
    // #endregion Public Getters And Setters (12)
    // #region Public Methods (1)
    clone() {
        return new SpotLight({
            color: this.color,
            position: this.position,
            target: this.target,
            distance: this.distance,
            decay: this.decay,
            angle: this.angle,
            penumbra: this.penumbra,
            intensity: this.intensity,
            name: this.name,
            order: this.order,
            id: this.id,
            version: this.version
        });
    }
}
exports.SpotLight = SpotLight;
_SpotLight_angle = new WeakMap(), _SpotLight_decay = new WeakMap(), _SpotLight_distance = new WeakMap(), _SpotLight_penumbra = new WeakMap(), _SpotLight_position = new WeakMap(), _SpotLight_target = new WeakMap();
//# sourceMappingURL=SpotLight.js.map

/***/ }),

/***/ 9454:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpotLight = exports.PointLight = exports.HemisphereLight = exports.DirectionalLight = exports.AmbientLight = exports.AbstractLight = exports.LightScene = exports.LIGHT_TYPE = exports.LightEngine = void 0;
const AbstractLight_1 = __webpack_require__(27159);
Object.defineProperty(exports, "AbstractLight", ({ enumerable: true, get: function () { return AbstractLight_1.AbstractLight; } }));
const LightEngine_1 = __webpack_require__(59199);
Object.defineProperty(exports, "LightEngine", ({ enumerable: true, get: function () { return LightEngine_1.LightEngine; } }));
const LightScene_1 = __webpack_require__(17093);
Object.defineProperty(exports, "LightScene", ({ enumerable: true, get: function () { return LightScene_1.LightScene; } }));
const AmbientLight_1 = __webpack_require__(3363);
Object.defineProperty(exports, "AmbientLight", ({ enumerable: true, get: function () { return AmbientLight_1.AmbientLight; } }));
const DirectionalLight_1 = __webpack_require__(62143);
Object.defineProperty(exports, "DirectionalLight", ({ enumerable: true, get: function () { return DirectionalLight_1.DirectionalLight; } }));
const HemisphereLight_1 = __webpack_require__(65475);
Object.defineProperty(exports, "HemisphereLight", ({ enumerable: true, get: function () { return HemisphereLight_1.HemisphereLight; } }));
const PointLight_1 = __webpack_require__(43725);
Object.defineProperty(exports, "PointLight", ({ enumerable: true, get: function () { return PointLight_1.PointLight; } }));
const SpotLight_1 = __webpack_require__(44723);
Object.defineProperty(exports, "SpotLight", ({ enumerable: true, get: function () { return SpotLight_1.SpotLight; } }));
const ILight_1 = __webpack_require__(7029);
Object.defineProperty(exports, "LIGHT_TYPE", ({ enumerable: true, get: function () { return ILight_1.LIGHT_TYPE; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7029:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LIGHT_TYPE = void 0;
var LIGHT_TYPE;
(function (LIGHT_TYPE) {
    LIGHT_TYPE["AMBIENT"] = "ambient";
    LIGHT_TYPE["DIRECTIONAL"] = "directional";
    LIGHT_TYPE["HEMISPHERE"] = "hemisphere";
    LIGHT_TYPE["POINT"] = "point";
    LIGHT_TYPE["RECTANGLE"] = "rectangle";
    LIGHT_TYPE["SPOT"] = "spot";
})(LIGHT_TYPE = exports.LIGHT_TYPE || (exports.LIGHT_TYPE = {}));
//# sourceMappingURL=ILight.js.map

/***/ }),

/***/ 16458:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _RenderingEngine_defaultLogo, _RenderingEngine_defaultLogoStatic, _RenderingEngine_defaultSpinner, _RenderingEngine_animations, _RenderingEngine_flags;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenderingEngine = void 0;
const THREE = __importStar(__webpack_require__(39437));
const MaterialLoader_1 = __webpack_require__(65993);
const viewer_rendering_engine_animation_engine_1 = __webpack_require__(46560);
const CameraManager_1 = __webpack_require__(58767);
const viewer_rendering_engine_canvas_engine_1 = __webpack_require__(46614);
const EnvironmentGeometryManager_1 = __webpack_require__(42057);
const EnvironmentMapLoader_1 = __webpack_require__(83445);
const GeometryLoader_1 = __webpack_require__(66296);
const HTMLElementAnchorLoader_1 = __webpack_require__(2642);
const viewer_rendering_engine_intersection_engine_1 = __webpack_require__(11579);
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const viewer_rendering_engine_light_engine_1 = __webpack_require__(9454);
const LightLoader_1 = __webpack_require__(88708);
const PostProcessingManager_1 = __webpack_require__(30265);
const gl_matrix_1 = __webpack_require__(61961);
const RenderingManager_1 = __webpack_require__(1042);
const SceneTracingManager_1 = __webpack_require__(27028);
const SceneTreeManager_1 = __webpack_require__(68198);
const SDColor_1 = __webpack_require__(1161);
const viewer_rendering_engine_camera_engine_1 = __webpack_require__(17989);
const viewer_rendering_engine_rendering_engine_1 = __webpack_require__(45850);
const viewer_shared_services_1 = __webpack_require__(8389);
const viewer_shared_types_1 = __webpack_require__(64766);
const viewport_css_1 = __webpack_require__(31349);
class RenderingEngine {
    // #endregion Properties (75)
    // #region Constructors (1)
    constructor(properties) {
        // #region Properties (75)
        _RenderingEngine_defaultLogo.set(this, 'https://viewer.shapediver.com/v3/graphics/logo_animated_breath.svg');
        _RenderingEngine_defaultLogoStatic.set(this, 'https://viewer.shapediver.com/v3/graphics/logo.png');
        _RenderingEngine_defaultSpinner.set(this, 'https://viewer.shapediver.com/v3/graphics/spinner_ripple.svg');
        this._animationEngine = viewer_rendering_engine_animation_engine_1.AnimationEngine.instance;
        this._canvasEngine = viewer_rendering_engine_canvas_engine_1.CanvasEngine.instance;
        this._colorCache = [];
        // utils
        this._converter = viewer_shared_services_1.Converter.instance;
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._intersectionManager = viewer_rendering_engine_intersection_engine_1.IntersectionEngine.instance;
        this._logger = viewer_shared_services_1.Logger.instance;
        this._stateEngine = viewer_shared_services_1.StateEngine.instance;
        this._systemInfo = viewer_shared_services_1.SystemInfo.instance;
        this._tree = viewer_shared_node_tree_1.Tree.instance;
        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;
        _RenderingEngine_animations.set(this, {});
        _RenderingEngine_flags.set(this, {
            [viewer_rendering_engine_rendering_engine_1.FLAG_TYPE.CAMERA_FREEZE]: [],
            [viewer_rendering_engine_rendering_engine_1.FLAG_TYPE.CONTINUOUS_RENDERING]: [],
            [viewer_rendering_engine_rendering_engine_1.FLAG_TYPE.CONTINUOUS_SHADOW_MAP_UPDATE]: [],
        });
        // settings
        this._arRotation = gl_matrix_1.vec3.create();
        this._arScale = gl_matrix_1.vec3.fromValues(1, 1, 1);
        this._arTranslation = gl_matrix_1.vec3.create();
        this._automaticColorAdjustment = true;
        this._automaticResizing = true;
        this._beautyRenderBlendingDuration = 1500;
        this._beautyRenderDelay = 50;
        this._busy = false;
        this._busyModeDisplay = viewer_rendering_engine_rendering_engine_1.BUSY_MODE_DISPLAY.SPINNER;
        this._clearAlpha = 1.0;
        this._clearColor = '#ffffff';
        // viewer global vars
        this._closed = false;
        this._enableAR = true;
        this._environmentMap = 'null';
        this._environmentMapAsBackground = false;
        this._environmentMapBlurriness = 0;
        this._environmentMapForUnlitMaterials = false;
        this._environmentMapIntensity = 1;
        this._environmentMapResolution = '1024';
        this._environmentMapRotation = gl_matrix_1.quat.create();
        this._gridVisibility = true;
        this._groundPlaneShadowVisibility = false;
        this._groundPlaneVisibility = true;
        this._lights = true;
        this._maximumRenderingSize = this._systemInfo.isMobile ? { width: 1280, height: 720 } : { width: 1920, height: 1080 };
        this._pause = false;
        this._shadows = true;
        this._show = false;
        this._showStatistics = false;
        this._softShadows = true;
        this._type = viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.STANDARD;
        // THREE object has default Y, we change that (although it doesn't work everywhere)
        THREE.Object3D.DEFAULT_UP = new THREE.Vector3(0, 0, 1);
        THREE.ColorManagement.enabled = false;
        // adapt some of the three.js shaders according to our needs
        (0, MaterialLoader_1.adaptShaders)();
        // add css to the document
        const style = document.createElement('style');
        style.innerHTML = viewport_css_1.css;
        document.head.appendChild(style);
        const prop = Object.assign({}, properties);
        const branding = Object.assign({}, prop.branding);
        // setting some of the provided properties
        this._id = prop.id || (viewer_shared_services_1.UuidGenerator.instance).create();
        this._visibility = prop.visibility || viewer_rendering_engine_rendering_engine_1.VISIBILITY_MODE.SESSION;
        this._sessionSettingsMode = prop.sessionSettingsMode || viewer_shared_services_1.SESSION_SETTINGS_MODE.FIRST;
        this._sessionSettingsId = prop.sessionSettingsId;
        this._branding = {
            logo: branding.logo === undefined ? __classPrivateFieldGet(this, _RenderingEngine_defaultLogo, "f") : branding.logo,
            backgroundColor: branding.backgroundColor || '#393a45FF',
            busyModeSpinner: branding.busyModeSpinner === undefined ? __classPrivateFieldGet(this, _RenderingEngine_defaultSpinner, "f") : branding.busyModeSpinner,
            busyModeDisplay: branding.busyModeDisplay || viewer_rendering_engine_rendering_engine_1.BUSY_MODE_DISPLAY.SPINNER,
            spinnerPositioning: branding.spinnerPositioning || viewer_rendering_engine_rendering_engine_1.SPINNER_POSITIONING.BOTTOM_RIGHT
        };
        // creation of viewer essentials
        this._canvas = this._canvasEngine.getCanvas(this._canvasEngine.createCanvasObject(prop.canvas));
        // creation of the engines (all singleton engines were created already)
        this._domEventEngine = new viewer_shared_services_1.DomEventEngine(this._canvas.canvasElement);
        this._cameraEngine = new viewer_rendering_engine_camera_engine_1.CameraEngine(this);
        this._lightEngine = new viewer_rendering_engine_light_engine_1.LightEngine(this);
        // creation of the managers (all singleton engines were created already)
        this._cameraManager = new CameraManager_1.CameraManager(this);
        this._environmentGeometryManager = new EnvironmentGeometryManager_1.EnvironmentGeometryManager(this);
        this._sceneTracingManager = new SceneTracingManager_1.SceneTracingManager(this);
        this._sceneTreeManager = new SceneTreeManager_1.SceneTreeManager(this);
        this._renderingManager = new RenderingManager_1.RenderingManager(this);
        this._postProcessingManager = new PostProcessingManager_1.PostProcessingManager(this);
        // loaders
        this._environmentMapLoader = new EnvironmentMapLoader_1.EnvironmentMapLoader(this);
        this._materialLoader = new MaterialLoader_1.MaterialLoader(this);
        this._geometryLoader = new GeometryLoader_1.GeometryLoader(this);
        this._htmlElementAnchorLoader = new HTMLElementAnchorLoader_1.HTMLElementAnchorLoader(this);
        this._lightLoader = new LightLoader_1.LightLoader(this);
        // start the creation and initialization process 
        this._renderer = this.renderingManager.createRenderer(this._canvas.canvasElement);
        this._spinnerDivElement = this.renderingManager.addSpinner(this._canvas.canvasElement, this._branding);
        this._logoDivElement = this.renderingManager.addLogo(this._canvas.canvasElement, this._branding);
        // creation of the managers (all singleton engines were created already)
        this._cameraManager.init();
        this._environmentGeometryManager.init();
        this._sceneTracingManager.init();
        this._sceneTreeManager.init();
        this._renderingManager.init();
        this._postProcessingManager.init();
        // loaders
        this._environmentMapLoader.init();
        this._materialLoader.init();
        this._geometryLoader.init();
        this._htmlElementAnchorLoader.init();
        this._lightLoader.init();
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (133)
    get arRotation() {
        return this._arRotation;
    }
    set arRotation(value) {
        this._arRotation = value;
    }
    get arScale() {
        return this._arScale;
    }
    set arScale(value) {
        this._arScale = value;
    }
    get arTranslation() {
        return this._arTranslation;
    }
    set arTranslation(value) {
        this._arTranslation = value;
    }
    get automaticColorAdjustment() {
        return this._automaticColorAdjustment;
    }
    set automaticColorAdjustment(value) {
        if (this._automaticColorAdjustment === value)
            return;
        this._automaticColorAdjustment = value;
        this._colorCache.forEach(c => c.colorCorrection(value));
        this._materialLoader.assignColorCorrection(value);
    }
    get automaticResizing() {
        return this._automaticResizing;
    }
    set automaticResizing(value) {
        this._automaticResizing = value;
    }
    get beautyRenderBlendingDuration() {
        return this._beautyRenderBlendingDuration;
    }
    set beautyRenderBlendingDuration(value) {
        this._beautyRenderBlendingDuration = value;
    }
    get beautyRenderDelay() {
        return this._beautyRenderDelay;
    }
    set beautyRenderDelay(value) {
        this._beautyRenderDelay = value;
    }
    get branding() {
        return this._branding;
    }
    get busy() {
        return this._busy;
    }
    set busy(value) {
        this._busy = value;
    }
    get busyModeDisplay() {
        return this._busyModeDisplay;
    }
    set busyModeDisplay(value) {
        this._busyModeDisplay = value;
    }
    get camera() {
        return this._cameraManager.camera;
    }
    get cameraEngine() {
        return this._cameraEngine;
    }
    get cameraManager() {
        return this._cameraManager;
    }
    get canvas() {
        return this._canvas.canvasElement;
    }
    get canvasEngine() {
        return this._canvasEngine;
    }
    get clearAlpha() {
        return this._clearAlpha;
    }
    set clearAlpha(value) {
        this._clearAlpha = value;
    }
    get clearColor() {
        return this._clearColor;
    }
    set clearColor(value) {
        this._clearColor = value;
    }
    get closed() {
        return this._closed;
    }
    get colorCache() {
        return this._colorCache;
    }
    get continuousRendering() {
        return this._renderingManager.continuousRendering;
    }
    set continuousRendering(value) {
        this._renderingManager.continuousRendering = value;
    }
    get continuousShadowMapUpdate() {
        return this._renderingManager.continuousShadowMapUpdate;
    }
    set continuousShadowMapUpdate(value) {
        this._renderingManager.continuousShadowMapUpdate = value;
    }
    get defaultLineMaterial() {
        return this.materialLoader.defaultLineMaterialData;
    }
    set defaultLineMaterial(value) {
        this.materialLoader.defaultLineMaterialData = value;
    }
    get defaultMaterial() {
        return this.materialLoader.defaultMaterialData;
    }
    set defaultMaterial(value) {
        this.materialLoader.defaultMaterialData = value;
    }
    get defaultMaterialColor() {
        return this.materialLoader.defaultMaterialData.color;
    }
    set defaultMaterialColor(value) {
        this.materialLoader.defaultMaterialData.color = value;
        this.materialLoader.assignDefaultMaterial();
        this.materialLoader.defaultLineMaterialData.color = value;
        this.materialLoader.assignDefaultLineMaterial();
        this.materialLoader.defaultPointMaterialData.color = value;
        this.materialLoader.assignDefaultPointMaterial();
    }
    get defaultPointMaterial() {
        return this.materialLoader.defaultPointMaterialData;
    }
    set defaultPointMaterial(value) {
        this.materialLoader.defaultPointMaterialData = value;
    }
    get domEventEngine() {
        return this._domEventEngine;
    }
    get enableAR() {
        return this._enableAR;
    }
    set enableAR(value) {
        this._enableAR = value;
    }
    get environmentMap() {
        return this._environmentMap;
    }
    set environmentMap(value) {
        this._environmentMap = value;
        this._environmentMapLoader.load(this.environmentMap);
    }
    get environmentMapAsBackground() {
        return this._environmentMapAsBackground;
    }
    set environmentMapAsBackground(value) {
        this._environmentMapAsBackground = value;
    }
    get environmentMapBlurriness() {
        return this._environmentMapBlurriness;
    }
    set environmentMapBlurriness(value) {
        this._environmentMapBlurriness = value;
        this._sceneTreeManager.scene.backgroundBlurriness = this._environmentMapBlurriness;
    }
    get environmentMapForUnlitMaterials() {
        return this._environmentMapForUnlitMaterials;
    }
    set environmentMapForUnlitMaterials(value) {
        this._environmentMapForUnlitMaterials = value;
        this._materialLoader.assignEnvironmentMapForUnlitMaterials(value);
    }
    get environmentMapIntensity() {
        return this._environmentMapIntensity;
    }
    set environmentMapIntensity(value) {
        this._environmentMapIntensity = value;
        this._sceneTreeManager.scene.backgroundIntensity = value;
        this._materialLoader.assignEnvironmentMapIntensity(value);
    }
    get environmentMapLoader() {
        return this._environmentMapLoader;
    }
    get environmentMapResolution() {
        return this._environmentMapResolution;
    }
    set environmentMapResolution(value) {
        this._environmentMapResolution = value;
        this._environmentMapLoader.load(this.environmentMap);
    }
    get environmentMapRotation() {
        return this._environmentMapRotation;
    }
    set environmentMapRotation(value) {
        this._environmentMapRotation = value;
        this._materialLoader.assignEnvironmentMapRotation(value);
    }
    get eventEngine() {
        return this._eventEngine;
    }
    get geometryLoader() {
        return this._geometryLoader;
    }
    get gridColor() {
        return this._environmentGeometryManager.gridColor;
    }
    set gridColor(value) {
        this._environmentGeometryManager.gridColor = value;
    }
    get gridVisibility() {
        return this._gridVisibility;
    }
    set gridVisibility(value) {
        if (this._environmentGeometryManager.grid)
            this._environmentGeometryManager.grid.visible = value;
        this._gridVisibility = value;
    }
    get groundPlaneColor() {
        return this._environmentGeometryManager.groundPlaneColor;
    }
    set groundPlaneColor(value) {
        this._environmentGeometryManager.groundPlaneColor = value;
    }
    get groundPlaneShadowColor() {
        return this._environmentGeometryManager.groundPlaneShadowColor;
    }
    set groundPlaneShadowColor(value) {
        this._environmentGeometryManager.groundPlaneShadowColor = value;
    }
    get groundPlaneShadowVisibility() {
        return this._groundPlaneShadowVisibility;
    }
    set groundPlaneShadowVisibility(value) {
        if (this._environmentGeometryManager.groundPlaneShadow)
            this._environmentGeometryManager.groundPlaneShadow.visible = value;
        this._groundPlaneShadowVisibility = value;
    }
    get groundPlaneVisibility() {
        return this._groundPlaneVisibility;
    }
    set groundPlaneVisibility(value) {
        if (this._environmentGeometryManager.groundPlane)
            this._environmentGeometryManager.groundPlane.visible = value;
        this._groundPlaneVisibility = value;
    }
    get htmlElementAnchorLoader() {
        return this._htmlElementAnchorLoader;
    }
    get id() {
        return this._id;
    }
    get lightEngine() {
        return this._lightEngine;
    }
    get lightLoader() {
        return this._lightLoader;
    }
    get lightScene() {
        return this.lightEngine.lightScene ? this.lightEngine.lightScene.id : '';
    }
    get lightSceneId() {
        return this.lightEngine.lightScene ? this.lightEngine.lightScene.id : '';
    }
    get lights() {
        return this._lights;
    }
    set lights(value) {
        this._lights = value;
    }
    get logoDivElement() {
        return this._logoDivElement;
    }
    get materialLoader() {
        return this._materialLoader;
    }
    get maximumRenderingSize() {
        return this._maximumRenderingSize;
    }
    set maximumRenderingSize(value) {
        this._maximumRenderingSize = value;
    }
    get minimalRendering() {
        return this.renderingManager.minimalRendering;
    }
    get outputEncoding() {
        switch (this._renderer.outputColorSpace) {
            case (THREE.SRGBColorSpace):
                return viewer_rendering_engine_rendering_engine_1.TEXTURE_ENCODING.SRGB;
            case (THREE.LinearSRGBColorSpace):
            default:
                return viewer_rendering_engine_rendering_engine_1.TEXTURE_ENCODING.LINEAR;
        }
    }
    set outputEncoding(value) {
        switch (value) {
            case (viewer_rendering_engine_rendering_engine_1.TEXTURE_ENCODING.SRGB):
                this._renderer.outputColorSpace = THREE.SRGBColorSpace;
                break;
            case (viewer_rendering_engine_rendering_engine_1.TEXTURE_ENCODING.LINEAR):
            default:
                this._renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
                break;
        }
    }
    get pause() {
        return this._pause;
    }
    set pause(value) {
        this._pause = value;
    }
    get physicallyCorrectLights() {
        return !this._renderer.useLegacyLights;
    }
    set physicallyCorrectLights(value) {
        this._renderer.useLegacyLights = !value;
    }
    get pointSize() {
        return this.materialLoader.defaultPointMaterialData.size || 1;
    }
    set pointSize(value) {
        this.materialLoader.defaultPointMaterialData.size = value;
        this.materialLoader.assignDefaultPointMaterial();
    }
    get postProcessingManager() {
        return this._postProcessingManager;
    }
    get postRenderingCallback() {
        return this._postRenderingCallback;
    }
    set postRenderingCallback(value) {
        this._postRenderingCallback = value;
    }
    get preRenderingCallback() {
        return this._preRenderingCallback;
    }
    set preRenderingCallback(value) {
        this._preRenderingCallback = value;
    }
    get renderer() {
        return this._renderer;
    }
    get renderingManager() {
        return this._renderingManager;
    }
    get scene() {
        return this._sceneTreeManager.scene;
    }
    get sceneTracingManager() {
        return this._sceneTracingManager;
    }
    get sceneTreeManager() {
        return this._sceneTreeManager;
    }
    get sessionSettingsId() {
        return this._sessionSettingsId;
    }
    set sessionSettingsId(value) {
        this._sessionSettingsId = value;
    }
    get sessionSettingsMode() {
        return this._sessionSettingsMode;
    }
    set sessionSettingsMode(value) {
        this._sessionSettingsMode = value;
    }
    get settingsEngine() {
        return this._settingsEngine;
    }
    set settingsEngine(value) {
        this._settingsEngine = value;
    }
    get shadows() {
        return this._shadows;
    }
    set shadows(value) {
        this._shadows = value;
    }
    get show() {
        return this._show;
    }
    set show(value) {
        this._show = value;
    }
    get showStatistics() {
        return this._showStatistics;
    }
    set showStatistics(value) {
        this._showStatistics = value;
    }
    get softShadows() {
        return this._softShadows;
    }
    set softShadows(value) {
        this._softShadows = value;
    }
    get spinnerDivElement() {
        return this._spinnerDivElement;
    }
    get stateEngine() {
        return this._stateEngine;
    }
    get textureEncoding() {
        switch (this.materialLoader.textureEncoding) {
            case (THREE.SRGBColorSpace):
                return viewer_rendering_engine_rendering_engine_1.TEXTURE_ENCODING.SRGB;
            case (THREE.LinearSRGBColorSpace):
            default:
                return viewer_rendering_engine_rendering_engine_1.TEXTURE_ENCODING.LINEAR;
        }
    }
    set textureEncoding(value) {
        switch (value) {
            case (viewer_rendering_engine_rendering_engine_1.TEXTURE_ENCODING.SRGB):
                this.environmentMapLoader.textureEncoding = THREE.SRGBColorSpace;
                this.materialLoader.textureEncoding = THREE.SRGBColorSpace;
                break;
            case (viewer_rendering_engine_rendering_engine_1.TEXTURE_ENCODING.LINEAR):
            default:
                this.environmentMapLoader.textureEncoding = THREE.LinearSRGBColorSpace;
                this.materialLoader.textureEncoding = THREE.LinearSRGBColorSpace;
        }
    }
    get toneMapping() {
        switch (this._renderer.toneMapping) {
            case (THREE.LinearToneMapping):
                return viewer_rendering_engine_rendering_engine_1.TONE_MAPPING.LINEAR;
            case (THREE.ReinhardToneMapping):
                return viewer_rendering_engine_rendering_engine_1.TONE_MAPPING.REINHARD;
            case (THREE.CineonToneMapping):
                return viewer_rendering_engine_rendering_engine_1.TONE_MAPPING.CINEON;
            case (THREE.ACESFilmicToneMapping):
                return viewer_rendering_engine_rendering_engine_1.TONE_MAPPING.ACES_FILMIC;
            case (THREE.NoToneMapping):
            default:
                return viewer_rendering_engine_rendering_engine_1.TONE_MAPPING.NONE;
        }
    }
    set toneMapping(value) {
        switch (value) {
            case (viewer_rendering_engine_rendering_engine_1.TONE_MAPPING.LINEAR):
                this._renderer.toneMapping = THREE.LinearToneMapping;
                break;
            case (viewer_rendering_engine_rendering_engine_1.TONE_MAPPING.REINHARD):
                this._renderer.toneMapping = THREE.ReinhardToneMapping;
                break;
            case (viewer_rendering_engine_rendering_engine_1.TONE_MAPPING.CINEON):
                this._renderer.toneMapping = THREE.CineonToneMapping;
                break;
            case (viewer_rendering_engine_rendering_engine_1.TONE_MAPPING.ACES_FILMIC):
                this._renderer.toneMapping = THREE.ACESFilmicToneMapping;
                break;
            case (viewer_rendering_engine_rendering_engine_1.TONE_MAPPING.NONE):
            default:
                this._renderer.toneMapping = THREE.NoToneMapping;
        }
        this.materialLoader.updateMaterials();
    }
    get toneMappingExposure() {
        return this._renderer.toneMappingExposure;
    }
    set toneMappingExposure(value) {
        this._renderer.toneMappingExposure = value;
    }
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
    }
    get usingSwiftShader() {
        return this.renderingManager.usingSwiftShader;
    }
    get visibility() {
        return this._visibility;
    }
    get visualizeAttributes() {
        return this._visualizeAttributes;
    }
    set visualizeAttributes(value) {
        this._visualizeAttributes = value;
    }
    // #endregion Public Getters And Setters (133)
    // #region Public Methods (25)
    addFlag(flag) {
        var _a;
        const token = this._uuidGenerator.create();
        if (flag === viewer_rendering_engine_rendering_engine_1.FLAG_TYPE.BUSY_MODE) {
            (_a = this.stateEngine.viewportEngines[this.id]) === null || _a === void 0 ? void 0 : _a.busy.push(token);
        }
        else {
            __classPrivateFieldGet(this, _RenderingEngine_flags, "f")[flag].push(token);
        }
        this.evaluateFlagState();
        return token;
    }
    applySettings(sections = {
        ar: true,
        scene: true,
        camera: true,
        light: true,
        environment: true,
        general: true,
        postprocessing: true
    }, settingsEngine, updateViewport = true) {
        return __awaiter(this, void 0, void 0, function* () {
            settingsEngine = settingsEngine || this._settingsEngine;
            if (!settingsEngine)
                return;
            if (sections.environment) {
                // as the environment map is the only thing that needs time to load, load it first
                yield new Promise((resolve, reject) => {
                    var _a;
                    (_a = this._stateEngine.viewportEngines[this.id]) === null || _a === void 0 ? void 0 : _a.environmentMapLoaded.then(() => {
                        try {
                            if (!settingsEngine)
                                return;
                            this.environmentMapAsBackground = settingsEngine.environment.mapAsBackground;
                            this.clearAlpha = settingsEngine.environment.clearAlpha;
                            this.clearColor = this._converter.toHexColor(settingsEngine.environment.clearColor);
                            this.environmentMapRotation = [settingsEngine.environment.rotation.x, settingsEngine.environment.rotation.y, settingsEngine.environment.rotation.z, settingsEngine.environment.rotation.w];
                            this.environmentMapBlurriness = settingsEngine.environment.blurriness;
                            this.environmentMapIntensity = settingsEngine.environment.intensity;
                            this.applySyncSettings(sections, settingsEngine, updateViewport);
                            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE_VIEWPORT.VIEWPORT_SETTINGS_LOADED, { viewportId: this.id });
                            resolve();
                        }
                        catch (e) {
                            reject(e);
                        }
                    }).catch(e => reject(e));
                    // set it like this to not trigger the loading
                    this.environmentMap = settingsEngine.environment.map;
                });
            }
            else {
                this.applySyncSettings(sections, settingsEngine, updateViewport);
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE_VIEWPORT.VIEWPORT_SETTINGS_LOADED, { viewportId: this.id });
            }
        });
    }
    assignSettingsEngine(settingsEngine) {
        this._settingsEngine = settingsEngine;
    }
    close() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            this._closed = true;
            this._lightEngine.close();
            this._renderer.clear(true, true, true);
            this._renderer.dispose();
            this._domEventEngine.removeAllDomEventListener();
            this._domEventEngine.dispose();
            (_a = this._canvas.canvasElement.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._logoDivElement);
            (_b = this._canvas.canvasElement.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(this._spinnerDivElement);
            (_c = this._canvas.canvasElement.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(this._htmlElementAnchorLoader.parentDiv);
            this._canvas.reset();
        });
    }
    continueRendering() {
        this._pause = false;
    }
    convert3Dto2D(p) {
        return this.sceneTracingManager.convert3Dto2D(p);
    }
    createSDTFOverview(node) {
        const out = new viewer_shared_types_1.SDTFOverviewData({});
        for (let i = 0, len = node.data.length; i < len; i++)
            if (node.data[i] instanceof viewer_shared_types_1.SDTFOverviewData)
                out.merge(node.data[i]);
        for (let i = 0, len = node.children.length; i < len; i++)
            out.merge(new viewer_shared_types_1.SDTFOverviewData(this.createSDTFOverview(node.children[i])));
        return out.overview;
    }
    createThreeJsColor(color) {
        const sdColor = new SDColor_1.SDColor(this._converter.toThreeJsColorInput(color), color);
        sdColor.colorCorrection(this.automaticColorAdjustment);
        this._colorCache.push(sdColor);
        return sdColor;
    }
    displayErrorMessage(message) {
        for (let i = 0; i < this.logoDivElement.children.length; i++)
            this.logoDivElement.children[i].style.visibility = 'hidden';
        const d = document.createElement('div');
        d.classList.add('sdv-error-message-container');
        this.logoDivElement.appendChild(d);
        const p = document.createElement('p');
        p.textContent = message;
        p.classList.add('sdv-error-message');
        p.style.color = this.logoDivElement.style.backgroundColor;
        d.appendChild(p);
    }
    evaluateFlagState() {
        // busy
        {
            const currentBusyState = this.busy;
            if (this.stateEngine.viewportEngines[this.id] && this.stateEngine.viewportEngines[this.id].busy.length > 0) {
                if (!currentBusyState) {
                    this.busy = true;
                    this._renderingManager.render();
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.VIEWPORT.BUSY_MODE_ON, { viewportId: this.id });
                }
            }
            else {
                if (currentBusyState) {
                    this.busy = false;
                    this._renderingManager.render();
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.VIEWPORT.BUSY_MODE_OFF, { viewportId: this.id });
                }
            }
        }
        // camera freeze
        {
            if (__classPrivateFieldGet(this, _RenderingEngine_flags, "f")[viewer_rendering_engine_rendering_engine_1.FLAG_TYPE.CAMERA_FREEZE].length > 0) {
                this.cameraEngine.deactivateCameraEvents();
            }
            else {
                this.cameraEngine.activateCameraEvents();
            }
        }
        // continuous rendering
        {
            const currentContinuousRenderingState = this.continuousRendering;
            if (__classPrivateFieldGet(this, _RenderingEngine_flags, "f")[viewer_rendering_engine_rendering_engine_1.FLAG_TYPE.CONTINUOUS_RENDERING].length > 0) {
                if (!currentContinuousRenderingState) {
                    this.continuousRendering = true;
                    this._renderingManager.render();
                }
            }
            else {
                if (currentContinuousRenderingState) {
                    this.continuousRendering = false;
                }
            }
        }
        // continuous shadow map update
        {
            const currentShadowMapUpdateState = this.continuousShadowMapUpdate;
            if (__classPrivateFieldGet(this, _RenderingEngine_flags, "f")[viewer_rendering_engine_rendering_engine_1.FLAG_TYPE.CONTINUOUS_SHADOW_MAP_UPDATE].length > 0) {
                if (!currentShadowMapUpdateState) {
                    this.continuousShadowMapUpdate = true;
                    this._renderingManager.render();
                }
            }
            else {
                if (currentShadowMapUpdateState) {
                    this.continuousShadowMapUpdate = false;
                }
            }
        }
    }
    getEnvironmentMapImageUrl() {
        return this._environmentMapLoader.getEnvironmentMapImageUrl(this.environmentMap);
    }
    getScreenshot(type, encoderOptions) {
        return this._renderingManager.getScreenshot(type, encoderOptions);
    }
    isMobileDeviceWithoutBrowserARSupport() {
        // has to be a mobile device (duh)
        if (this._systemInfo.isIOS === false && this._systemInfo.isAndroid === false)
            return false;
        // no Firefox on Android
        if (this._systemInfo.isAndroid === true && this._systemInfo.isFirefox === true)
            return true;
        // no Instagram on iOS
        if (this._systemInfo.isIOS === true && this._systemInfo.isInstagram === true)
            return true;
        return false;
    }
    pauseRendering() {
        this._pause = true;
    }
    pointerEventToRay(event) {
        return this._sceneTracingManager.pointerEventToRay(event);
    }
    raytraceScene(origin, direction) {
        const intersect = this._intersectionManager.intersect({ origin, direction }, this.id);
        return intersect.map(i => {
            return {
                distance: i.distance,
                node: i.node,
                data: i.geometryData
            };
        });
    }
    removeFlag(token) {
        let success = false;
        const Flags = Object.values(viewer_rendering_engine_rendering_engine_1.FLAG_TYPE);
        for (const f of Flags) {
            if (f === viewer_rendering_engine_rendering_engine_1.FLAG_TYPE.BUSY_MODE) {
                if (this.stateEngine.viewportEngines[this.id] && this.stateEngine.viewportEngines[this.id].busy.includes(token)) {
                    this.stateEngine.viewportEngines[this.id].busy.splice(this.stateEngine.viewportEngines[this.id].busy.indexOf(token), 1);
                    success = true;
                    break;
                }
            }
            else {
                if (__classPrivateFieldGet(this, _RenderingEngine_flags, "f")[f].includes(token)) {
                    __classPrivateFieldGet(this, _RenderingEngine_flags, "f")[f].splice(__classPrivateFieldGet(this, _RenderingEngine_flags, "f")[f].indexOf(token), 1);
                    success = true;
                    break;
                }
            }
        }
        this.evaluateFlagState();
        return success;
    }
    reset() {
        var _a, _b, _c, _d;
        (_a = this._stateEngine.viewportEngines[this.id]) === null || _a === void 0 ? void 0 : _a.settingsAssigned.reset();
        (_b = this._stateEngine.viewportEngines[this.id]) === null || _b === void 0 ? void 0 : _b.boundingBoxCreated.reset();
        (_c = this._stateEngine.viewportEngines[this.id]) === null || _c === void 0 ? void 0 : _c.environmentMapLoaded.reset();
        (_d = this._stateEngine.viewportEngines[this.id]) === null || _d === void 0 ? void 0 : _d.boundingBoxCreated.then(() => {
            this._environmentGeometryManager.changeSceneExtents(this._sceneTreeManager.boundingBox);
        });
    }
    resize(width, height) {
        this._renderingManager.resize(width, height);
        this._renderingManager.render();
    }
    saveSettings(settingsEngine) {
        settingsEngine = settingsEngine || this._settingsEngine;
        if (!settingsEngine)
            return;
        this.lightEngine.saveSettings(settingsEngine);
        this.cameraEngine.saveSettings(settingsEngine);
        this.postProcessingManager.saveSettings(settingsEngine);
        settingsEngine.ar.enable = this.enableAR;
        settingsEngine.environment.mapResolution = this.environmentMapResolution;
        settingsEngine.environment.map = Array.isArray(this.environmentMap) ? JSON.stringify(this.environmentMap) : this.environmentMap;
        settingsEngine.environment.mapAsBackground = this.environmentMapAsBackground;
        settingsEngine.environment.clearAlpha = this.clearAlpha;
        settingsEngine.environment.clearColor = this._converter.toHexColor(this.clearColor);
        settingsEngine.environment.rotation = { x: this.environmentMapRotation[0], y: this.environmentMapRotation[1], z: this.environmentMapRotation[2], w: this.environmentMapRotation[3] };
        settingsEngine.environment.blurriness = this.environmentMapBlurriness;
        settingsEngine.environment.intensity = this.environmentMapIntensity;
        settingsEngine.environmentGeometry.gridVisibility = this.gridVisibility;
        settingsEngine.environmentGeometry.groundPlaneVisibility = this.groundPlaneVisibility;
        settingsEngine.environmentGeometry.groundPlaneShadowVisibility = this.groundPlaneShadowVisibility;
        settingsEngine.environmentGeometry.gridColor = this._converter.toHexColor(this.gridColor);
        settingsEngine.environmentGeometry.groundPlaneColor = this._converter.toHexColor(this.groundPlaneColor);
        settingsEngine.environmentGeometry.groundPlaneShadowColor = this._converter.toHexColor(this.groundPlaneShadowColor);
        settingsEngine.general.pointSize = this.pointSize;
        settingsEngine.general.transformation.rotation = { x: this.arRotation[0], y: this.arRotation[1], z: this.arRotation[2] };
        settingsEngine.general.transformation.translation = { x: this.arTranslation[0], y: this.arTranslation[1], z: this.arTranslation[2] };
        settingsEngine.general.transformation.scale = { x: this.arScale[0], y: this.arScale[1], z: this.arScale[2] };
        settingsEngine.general.defaultMaterialColor = this._converter.toHexColor(this.defaultMaterialColor);
        settingsEngine.rendering.automaticColorAdjustment = this.automaticColorAdjustment;
        settingsEngine.rendering.lights = this.lights;
        settingsEngine.rendering.outputEncoding = this.outputEncoding;
        settingsEngine.rendering.physicallyCorrectLights = this.physicallyCorrectLights;
        settingsEngine.rendering.textureEncoding = this.textureEncoding;
        settingsEngine.rendering.toneMapping = this.toneMapping;
        settingsEngine.rendering.toneMappingExposure = this.toneMappingExposure;
        settingsEngine.rendering.beautyRenderBlendingDuration = this.beautyRenderBlendingDuration;
        settingsEngine.rendering.beautyRenderDelay = this.beautyRenderDelay;
        settingsEngine.rendering.shadows = this.shadows;
        settingsEngine.rendering.softShadows = this.softShadows;
    }
    start() {
        var _a;
        this._renderingManager.start();
        (_a = this._stateEngine.viewportEngines[this.id]) === null || _a === void 0 ? void 0 : _a.boundingBoxCreated.then(() => {
            this._environmentGeometryManager.changeSceneExtents(this._sceneTreeManager.boundingBox);
        });
        if (this._sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.NONE) {
            this.environmentMap = 'photo_studio';
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    update(id) {
        if (this.closed)
            return;
        this._sceneTreeManager.updateSceneTree(this._tree.root);
        this._renderingManager.updateShadowMap();
        this._animationEngine.updateAnimationData();
        this._renderingManager.render();
        this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE_VIEWPORT.VIEWPORT_UPDATED, { viewportId: this.id });
    }
    updateEnvironmentGeometry() {
        this._environmentGeometryManager.updateEnvironmentGeometryPosition();
    }
    viewInAR(file, options = { arScale: 'auto', arPlacement: 'floor', xrEnvironment: false }) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = this._uuidGenerator.create();
            const event = { type: viewer_shared_types_1.TASK_TYPE.AR_LOADING, id: eventId, progress: 0, status: 'Loading AR scene' };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, event);
            // if this is not a supported device, throw an error
            if (this.viewableInAR() === false) {
                const event = { type: viewer_shared_types_1.TASK_TYPE.AR_LOADING, id: eventId, progress: 1, status: 'Stopped AR loading due to an error' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, event);
                throw new viewer_shared_services_1.ShapeDiverViewerArError('Api.viewInAR: The device or browser is not supported for this functionality, please call "viewableInAR" for more information.');
            }
            const arScale = options.arScale !== 'auto' ? 'fixed' : 'auto';
            // const arPlacement = options.arPlacement !== 'wall' ? 'floor' : 'wall';
            // const xrEnvironment = options.xrEnvironment !== true ? false : true;
            // let arEnvironment = '';
            // const envMapUrl = this.getEnvironmentMapImageUrl();
            // if (envMapUrl !== '') {
            //   if (envMapUrl.endsWith('.hdr')) {
            //     arEnvironment = 'skybox-image=' + envMapUrl;
            //   } else {
            //     arEnvironment = 'environment-image=' + envMapUrl;
            //   }
            // }
            if (this._systemInfo.isIOS) {
                // create the link and click it
                const a = document.createElement('a');
                a.href = file + (arScale === 'fixed' ? '.usdz_allowsContentScaling=0' : '.usdz');
                a.rel = 'ar';
                const img = document.createElement('img');
                img.src = __classPrivateFieldGet(this, _RenderingEngine_defaultLogoStatic, "f");
                a.appendChild(img);
                a.click();
            }
            else {
                const a = document.createElement('a');
                a.href = `intent://arvr.google.com/scene-viewer/1.0?resizable=${arScale === 'fixed' ? 'false' : 'true'}&file=${file}&mode=ar_only#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;end;`;
                a.click();
            }
            const event2 = { type: viewer_shared_types_1.TASK_TYPE.AR_LOADING, id: eventId, progress: 1, status: 'Done loading AR scene, launching AR' };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, event2);
        });
    }
    viewableInAR() {
        // has to be a mobile device (duh)
        if (this._systemInfo.isIOS === false && this._systemInfo.isAndroid === false)
            return false;
        // no Firefox on Android
        if (this._systemInfo.isAndroid === true && this._systemInfo.isFirefox === true)
            return false;
        // no Firefox on iOS
        if (this._systemInfo.isIOS === true && this._systemInfo.isFirefox === true)
            return false;
        // no Instagram on iOS
        if (this._systemInfo.isIOS === true && this._systemInfo.isInstagram === true)
            return false;
        return true;
    }
    // #endregion Public Methods (25)
    // #region Private Methods (1)
    applySyncSettings(sections = {
        ar: true,
        scene: true,
        camera: true,
        light: true,
        environment: true,
        general: true,
        postprocessing: true
    }, settingsEngine, updateViewport = true) {
        var _a;
        settingsEngine = settingsEngine || this._settingsEngine;
        if (!settingsEngine)
            return;
        if (sections.ar) {
            this.enableAR = settingsEngine.ar.enable;
            this.arScale = [settingsEngine.general.transformation.scale.x, settingsEngine.general.transformation.scale.y, settingsEngine.general.transformation.scale.z];
            this.arTranslation = [settingsEngine.general.transformation.translation.x, settingsEngine.general.transformation.translation.y, settingsEngine.general.transformation.translation.z];
            this.arRotation = [settingsEngine.general.transformation.rotation.x, settingsEngine.general.transformation.rotation.y, settingsEngine.general.transformation.rotation.z];
        }
        if (sections.scene) {
            this.gridColor = settingsEngine.environmentGeometry.gridColor;
            this.gridVisibility = settingsEngine.environmentGeometry.gridVisibility;
            this.groundPlaneColor = settingsEngine.environmentGeometry.groundPlaneColor;
            this.groundPlaneVisibility = settingsEngine.environmentGeometry.groundPlaneVisibility;
            this.groundPlaneShadowColor = settingsEngine.environmentGeometry.groundPlaneShadowColor;
            this.groundPlaneShadowVisibility = settingsEngine.environmentGeometry.groundPlaneShadowVisibility;
            this.shadows = settingsEngine.rendering.shadows;
            this.softShadows = settingsEngine.rendering.softShadows;
            this.lights = settingsEngine.rendering.lights;
            this.automaticColorAdjustment = settingsEngine.rendering.automaticColorAdjustment;
            this.textureEncoding = settingsEngine.rendering.textureEncoding;
            this.outputEncoding = settingsEngine.rendering.outputEncoding;
            this.physicallyCorrectLights = settingsEngine.rendering.physicallyCorrectLights;
            this.toneMapping = settingsEngine.rendering.toneMapping;
            this.toneMappingExposure = settingsEngine.rendering.toneMappingExposure;
        }
        if (sections.general) {
            this.defaultMaterialColor = settingsEngine.general.defaultMaterialColor;
            this.pointSize = settingsEngine.general.pointSize;
        }
        if (sections.light)
            this.lightEngine.applySettings(settingsEngine);
        if (sections.camera)
            this.cameraEngine.applySettings(settingsEngine);
        if (sections.postprocessing)
            this.postProcessingManager.applySettings(settingsEngine);
        // call adjust camera to load the three.js camera objects
        this.cameraManager.adjustCamera(1);
        (_a = this._stateEngine.viewportEngines[this.id]) === null || _a === void 0 ? void 0 : _a.settingsAssigned.resolve(true);
        if (updateViewport)
            this.update('RenderingEngine.applySyncSettings');
    }
}
exports.RenderingEngine = RenderingEngine;
_RenderingEngine_defaultLogo = new WeakMap(), _RenderingEngine_defaultLogoStatic = new WeakMap(), _RenderingEngine_defaultSpinner = new WeakMap(), _RenderingEngine_animations = new WeakMap(), _RenderingEngine_flags = new WeakMap();
//# sourceMappingURL=RenderingEngine.js.map

/***/ }),

/***/ 27068:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Resolution = exports.PredicationMode = exports.EdgeDetectionMode = exports.SMAAPreset = exports.KernelSize = exports.VignetteTechnique = exports.BlendFunction = exports.VignetteEffect = exports.TiltShiftEffect = exports.SepiaEffect = exports.SelectiveBloomEffect = exports.ScanlineEffect = exports.SSAOEffect = exports.SMAAEffect = exports.PixelationEffect = exports.OutlineEffect = exports.NoiseEffect = exports.HueSaturationEffect = exports.GridEffect = exports.GodRaysEffect = exports.FXAAEffect = exports.DotScreenEffect = exports.DepthOfFieldEffect = exports.ChromaticAberrationEffect = exports.BloomEffect = exports.EffectComposer = exports.Effect = exports.POST_PROCESSING_EFFECT_TYPE = exports.ANTI_ALIASING_TECHNIQUE = exports.PostProcessingManager = exports.MultiPointsMaterial = exports.ENVIRONMENT_MAP_EMPTY = exports.ENVIRONMENT_MAP_CUBE = exports.ENVIRONMENT_MAP = exports.ThreejsData = exports.RenderingEngine = void 0;
const IPostProcessingEffectDefinitions_1 = __webpack_require__(63506);
Object.defineProperty(exports, "ANTI_ALIASING_TECHNIQUE", ({ enumerable: true, get: function () { return IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE; } }));
Object.defineProperty(exports, "POST_PROCESSING_EFFECT_TYPE", ({ enumerable: true, get: function () { return IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE; } }));
const postprocessing_1 = __webpack_require__(66739);
Object.defineProperty(exports, "BlendFunction", ({ enumerable: true, get: function () { return postprocessing_1.BlendFunction; } }));
Object.defineProperty(exports, "BloomEffect", ({ enumerable: true, get: function () { return postprocessing_1.BloomEffect; } }));
Object.defineProperty(exports, "ChromaticAberrationEffect", ({ enumerable: true, get: function () { return postprocessing_1.ChromaticAberrationEffect; } }));
Object.defineProperty(exports, "DepthOfFieldEffect", ({ enumerable: true, get: function () { return postprocessing_1.DepthOfFieldEffect; } }));
Object.defineProperty(exports, "DotScreenEffect", ({ enumerable: true, get: function () { return postprocessing_1.DotScreenEffect; } }));
Object.defineProperty(exports, "EdgeDetectionMode", ({ enumerable: true, get: function () { return postprocessing_1.EdgeDetectionMode; } }));
Object.defineProperty(exports, "Effect", ({ enumerable: true, get: function () { return postprocessing_1.Effect; } }));
Object.defineProperty(exports, "EffectComposer", ({ enumerable: true, get: function () { return postprocessing_1.EffectComposer; } }));
Object.defineProperty(exports, "FXAAEffect", ({ enumerable: true, get: function () { return postprocessing_1.FXAAEffect; } }));
Object.defineProperty(exports, "GodRaysEffect", ({ enumerable: true, get: function () { return postprocessing_1.GodRaysEffect; } }));
Object.defineProperty(exports, "GridEffect", ({ enumerable: true, get: function () { return postprocessing_1.GridEffect; } }));
Object.defineProperty(exports, "HueSaturationEffect", ({ enumerable: true, get: function () { return postprocessing_1.HueSaturationEffect; } }));
Object.defineProperty(exports, "KernelSize", ({ enumerable: true, get: function () { return postprocessing_1.KernelSize; } }));
Object.defineProperty(exports, "NoiseEffect", ({ enumerable: true, get: function () { return postprocessing_1.NoiseEffect; } }));
Object.defineProperty(exports, "OutlineEffect", ({ enumerable: true, get: function () { return postprocessing_1.OutlineEffect; } }));
Object.defineProperty(exports, "PixelationEffect", ({ enumerable: true, get: function () { return postprocessing_1.PixelationEffect; } }));
Object.defineProperty(exports, "PredicationMode", ({ enumerable: true, get: function () { return postprocessing_1.PredicationMode; } }));
Object.defineProperty(exports, "Resolution", ({ enumerable: true, get: function () { return postprocessing_1.Resolution; } }));
Object.defineProperty(exports, "ScanlineEffect", ({ enumerable: true, get: function () { return postprocessing_1.ScanlineEffect; } }));
Object.defineProperty(exports, "SelectiveBloomEffect", ({ enumerable: true, get: function () { return postprocessing_1.SelectiveBloomEffect; } }));
Object.defineProperty(exports, "SepiaEffect", ({ enumerable: true, get: function () { return postprocessing_1.SepiaEffect; } }));
Object.defineProperty(exports, "SMAAEffect", ({ enumerable: true, get: function () { return postprocessing_1.SMAAEffect; } }));
Object.defineProperty(exports, "SMAAPreset", ({ enumerable: true, get: function () { return postprocessing_1.SMAAPreset; } }));
Object.defineProperty(exports, "SSAOEffect", ({ enumerable: true, get: function () { return postprocessing_1.SSAOEffect; } }));
Object.defineProperty(exports, "TiltShiftEffect", ({ enumerable: true, get: function () { return postprocessing_1.TiltShiftEffect; } }));
Object.defineProperty(exports, "VignetteEffect", ({ enumerable: true, get: function () { return postprocessing_1.VignetteEffect; } }));
Object.defineProperty(exports, "VignetteTechnique", ({ enumerable: true, get: function () { return postprocessing_1.VignetteTechnique; } }));
const EnvironmentMapLoader_1 = __webpack_require__(83445);
Object.defineProperty(exports, "ENVIRONMENT_MAP", ({ enumerable: true, get: function () { return EnvironmentMapLoader_1.ENVIRONMENT_MAP; } }));
Object.defineProperty(exports, "ENVIRONMENT_MAP_CUBE", ({ enumerable: true, get: function () { return EnvironmentMapLoader_1.ENVIRONMENT_MAP_CUBE; } }));
Object.defineProperty(exports, "ENVIRONMENT_MAP_EMPTY", ({ enumerable: true, get: function () { return EnvironmentMapLoader_1.ENVIRONMENT_MAP_EMPTY; } }));
const viewer_shared_global_access_objects_1 = __webpack_require__(50069);
const MultiPointsMaterial_1 = __webpack_require__(3382);
Object.defineProperty(exports, "MultiPointsMaterial", ({ enumerable: true, get: function () { return MultiPointsMaterial_1.MultiPointsMaterial; } }));
const PostProcessingManager_1 = __webpack_require__(30265);
Object.defineProperty(exports, "PostProcessingManager", ({ enumerable: true, get: function () { return PostProcessingManager_1.PostProcessingManager; } }));
const RenderingEngine_1 = __webpack_require__(16458);
Object.defineProperty(exports, "RenderingEngine", ({ enumerable: true, get: function () { return RenderingEngine_1.RenderingEngine; } }));
const Tag3dGeometryCreationInjector_1 = __webpack_require__(90836);
const TextureUnifierInjector_1 = __webpack_require__(59669);
const ThreejsData_1 = __webpack_require__(54609);
Object.defineProperty(exports, "ThreejsData", ({ enumerable: true, get: function () { return ThreejsData_1.ThreejsData; } }));
const tag3dGeometryCreationInjector = new Tag3dGeometryCreationInjector_1.Tag3dGeometryCreationInjector();
viewer_shared_global_access_objects_1.GlobalAccessObjects.instance.loadTag3D = tag3dGeometryCreationInjector.convertTag3dToGeometry.bind(tag3dGeometryCreationInjector);
const textureUnifierInjector = new TextureUnifierInjector_1.TextureUnifierInjector();
viewer_shared_global_access_objects_1.GlobalAccessObjects.instance.combineTextures = textureUnifierInjector.combineTextures.bind(textureUnifierInjector);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 90836:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Tag3dGeometryCreationInjector_stateEngine;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tag3dGeometryCreationInjector = void 0;
const THREE = __importStar(__webpack_require__(39437));
const viewer_shared_types_1 = __webpack_require__(64766);
const FontLoader_1 = __webpack_require__(97328);
const font_1 = __webpack_require__(10566);
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const viewer_shared_services_1 = __webpack_require__(8389);
const TextGeometry_1 = __webpack_require__(6009);
class Tag3dGeometryCreationInjector {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor() {
        // #region Properties (2)
        _Tag3dGeometryCreationInjector_stateEngine.set(this, viewer_shared_services_1.StateEngine.instance);
        this._font = new FontLoader_1.Font(font_1.font);
        __classPrivateFieldGet(this, _Tag3dGeometryCreationInjector_stateEngine, "f").fontLoaded.resolve(true);
    }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    convertTag3dToGeometry(tag3dInfo) {
        const node = new viewer_shared_node_tree_1.TreeNode('tag3d_' + tag3dInfo.version);
        tag3dInfo.size = tag3dInfo.size ? +tag3dInfo.size : 1;
        if (tag3dInfo.text === undefined || tag3dInfo.text === '' || /^[ \t\n\r]*$/.test(tag3dInfo.text))
            return;
        const tagLines = tag3dInfo.text.split(/\r\n|\r|\n/g);
        const lineArray = [];
        for (let lineIndex = 0; lineIndex < tagLines.length; ++lineIndex) {
            if (tagLines[lineIndex] === '')
                continue;
            // create tag mesh object
            const tag = new TextGeometry_1.TextGeometry(tagLines[lineIndex], { size: tag3dInfo.size, height: tag3dInfo.size / 10, font: this._font });
            lineArray.push(tag);
        }
        // create temporary object
        const parentObject = new THREE.Object3D();
        for (const line of lineArray) {
            parentObject.add(new THREE.Mesh(line, new THREE.MeshPhongMaterial()));
        }
        // align lines
        let bb, tempExtentsY, lineHeight = 0;
        {
            lineHeight = 0;
            for (const child of parentObject.children) {
                bb = new THREE.Box3().setFromObject(child);
                tempExtentsY = bb.max.y - bb.min.y;
                lineHeight = Math.max(lineHeight, tempExtentsY);
            }
        }
        lineHeight *= 1.15;
        lineArray.forEach((line, i) => {
            line.translate(0, (-i - 1) * lineHeight, 0);
        });
        // justification
        bb = new THREE.Box3().setFromObject(parentObject);
        const extentsX = bb.max.x - bb.min.x;
        const extentsY = bb.max.y - bb.min.y;
        const tagJustTranslation = new THREE.Vector3(0, 0, 0);
        switch (tag3dInfo.justification) {
            case 'TL':
                break;
            case 'TC':
                tagJustTranslation.x = -extentsX * 0.5;
                break;
            case 'TR':
                tagJustTranslation.x = -extentsX;
                break;
            case 'ML':
                tagJustTranslation.y = extentsY * 0.5;
                break;
            case 'MC':
                tagJustTranslation.x = -extentsX * 0.5;
                tagJustTranslation.y = extentsY * 0.5;
                break;
            case 'MR':
                tagJustTranslation.x = -extentsX;
                tagJustTranslation.y = extentsY * 0.5;
                break;
            case 'BL':
                tagJustTranslation.y = extentsY;
                break;
            case 'BC':
                tagJustTranslation.x = -extentsX * 0.5;
                tagJustTranslation.y = extentsY;
                break;
            case 'BR':
                tagJustTranslation.x = -extentsX;
                tagJustTranslation.y = extentsY;
                break;
        }
        for (const line of lineArray) {
            line.translate(tagJustTranslation.x, tagJustTranslation.y, tagJustTranslation.z);
        }
        // rotation
        if (tag3dInfo.location.xAxis !== undefined) {
            const rotMatrix = new THREE.Matrix4();
            rotMatrix.set(tag3dInfo.location.xAxis.X, tag3dInfo.location.yAxis.X, tag3dInfo.location.normal.X, 0, tag3dInfo.location.xAxis.Y, tag3dInfo.location.yAxis.Y, tag3dInfo.location.normal.Y, 0, tag3dInfo.location.xAxis.Z, tag3dInfo.location.yAxis.Z, tag3dInfo.location.normal.Z, 0, 0, 0, 0, 1);
            for (const line of lineArray) {
                line.applyMatrix4(rotMatrix);
                line.translate(tag3dInfo.location.origin.X, tag3dInfo.location.origin.Y, tag3dInfo.location.origin.Z);
            }
        }
        for (const line of lineArray) {
            const attributes = {};
            for (const attribute in line.attributes) {
                let attributeName = attribute.toUpperCase();
                if (/\d/.test(attributeName) && !attributeName.includes('_')) {
                    const index = attributeName.search(/\d/);
                    attributeName = attributeName.substring(0, index) + '_' + attributeName.substring(index, attributeName.length);
                }
                else if (attributeName === 'TEXCOORD' || attributeName === 'COLOR' || attributeName === 'JOINTS' || attributeName === 'WEIGHTS') {
                    attributeName += '_0';
                }
                else if (attributeName === 'UV') {
                    attributeName = 'TEXCOORD_0';
                }
                attributes[attributeName] = new viewer_shared_types_1.AttributeData(line.attributes[attribute].array, line.attributes[attribute].itemSize, 0, 0, 0, false, line.attributes[attribute].array.length / line.attributes[attribute].itemSize);
            }
            const child = new viewer_shared_node_tree_1.TreeNode('tag3d_' + line);
            child.data.push(new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, null), viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES, new viewer_shared_types_1.MaterialStandardData({ color: tag3dInfo.color, metalness: 0, roughness: 1 })));
            node.children.push(child);
        }
        return node;
    }
}
exports.Tag3dGeometryCreationInjector = Tag3dGeometryCreationInjector;
_Tag3dGeometryCreationInjector_stateEngine = new WeakMap();
//# sourceMappingURL=Tag3dGeometryCreationInjector.js.map

/***/ }),

/***/ 59669:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextureUnifierInjector = void 0;
const THREE = __importStar(__webpack_require__(39437));
class TextureUnifierInjector {
    // #endregion Properties (5)
    // #region Constructors (1)
    constructor() { }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    combineTextures(red, green, blue) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!red && !green && !blue)
                throw new Error('No maps supplied.');
            if (red && red instanceof ArrayBuffer)
                return { image: red, blob: new Blob([new Uint8Array(red)], { type: 'image/jpeg' }) };
            if (green && green instanceof ArrayBuffer)
                return { image: green, blob: new Blob([new Uint8Array(green)], { type: 'image/jpeg' }) };
            if (blue && blue instanceof ArrayBuffer)
                return { image: blue, blob: new Blob([new Uint8Array(blue)], { type: 'image/jpeg' }) };
            if (!this._renderer)
                this.createThreeJsUtils();
            let width = 0, height = 0;
            const textures = [red, green, blue];
            for (const t of textures) {
                if (t) {
                    if (width === 0 && height === 0) {
                        width = t.width;
                        height = t.height;
                    }
                    else if (t.width !== width && t.height !== height) {
                        throw new Error('Maps have different sizes. Combining not supported.');
                    }
                }
            }
            if (red) {
                const redTexture = new THREE.Texture(red);
                redTexture.needsUpdate = true;
                this._mergeShader.uniforms.tRed.value = redTexture;
                this._mergeShader.uniforms.activeRed.value = true;
            }
            else {
                this._mergeShader.uniforms.activeRed.value = false;
            }
            if (green) {
                const greenTexture = new THREE.Texture(green);
                greenTexture.needsUpdate = true;
                this._mergeShader.uniforms.tGreen.value = greenTexture;
                this._mergeShader.uniforms.activeGreen.value = true;
            }
            else {
                this._mergeShader.uniforms.activeGreen.value = false;
            }
            if (blue) {
                const blueTexture = new THREE.Texture(blue);
                blueTexture.needsUpdate = true;
                this._mergeShader.uniforms.tBlue.value = blueTexture;
                this._mergeShader.uniforms.activeBlue.value = true;
            }
            else {
                this._mergeShader.uniforms.activeBlue.value = false;
            }
            // The different render targets that are used by the passes
            const renderTarget = new THREE.WebGLRenderTarget(width, height, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            });
            renderTarget.texture.name = 'target.rt';
            this._renderer.setRenderTarget(renderTarget);
            this._renderer.render(this._quadScene, this._quadCamera);
            const buffer = new Uint8ClampedArray(4 * width * height);
            this._renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, buffer);
            const imageData = new ImageData(buffer, width, height);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            ctx.putImageData(imageData, 0, 0);
            const imageOut = new Image();
            const promises = [];
            promises.push(new Promise((resolve, reject) => {
                imageOut.onload = () => resolve();
                imageOut.onerror = reject;
            }));
            imageOut.crossOrigin = 'anonymous';
            const mimeType = 'image/jpeg';
            imageOut.src = canvas.toDataURL(mimeType, 1.0);
            let blob;
            promises.push(new Promise((resolve, reject) => {
                canvas.toBlob((b) => {
                    if (!b) {
                        reject('Could not create blob.');
                    }
                    else {
                        blob = b;
                    }
                    resolve();
                }, mimeType, 1.0);
            }));
            yield Promise.all(promises);
            return { image: imageOut, blob };
        });
    }
    // #endregion Public Methods (1)
    // #region Private Methods (1)
    createThreeJsUtils() {
        this._mergeShader = new THREE.ShaderMaterial({
            uniforms: {
                tRed: { value: null },
                activeRed: { value: false },
                defaultRed: { value: 1.0 },
                tGreen: { value: null },
                activeGreen: { value: false },
                defaultGreen: { value: 1.0 },
                tBlue: { value: null },
                activeBlue: { value: false },
                defaultBlue: { value: 1.0 },
            },
            vertexShader: `// @author Michael Oppitz 
        
            uniform sampler2D tRed;
            uniform bool activeRed;
            uniform float defaultRed;
            
            uniform sampler2D tGreen;		
            uniform bool activeGreen;
            uniform float defaultGreen;
            
            uniform sampler2D tBlue;		
            uniform bool activeBlue;
            uniform float defaultBlue;
        
            varying vec2 vUv;
            
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }`,
            fragmentShader: `// @author Michael Oppitz 
        
            uniform sampler2D tRed;
            uniform bool activeRed;
            uniform float defaultRed;
            
            uniform sampler2D tGreen;		
            uniform bool activeGreen;
            uniform float defaultGreen;
            
            uniform sampler2D tBlue;		
            uniform bool activeBlue;
            uniform float defaultBlue;
            
            varying vec2 vUv;
            
            void main() {
                vec4 outColor = vec4(0.0, 0.0, 0.0, 1.0);
        
                if(activeRed == true) {
                    outColor.r = texture2D(tRed, vUv).r;
                } else {
                    outColor.r = defaultRed;
                }
            
                if(activeGreen == true) {
                    outColor.g = texture2D(tGreen, vUv).g;
                } else {
                    outColor.g = defaultGreen;
                }
            
                if(activeBlue == true) {
                    outColor.b = texture2D(tBlue, vUv).b;
                } else {
                    outColor.b = defaultBlue;
                }
            
                gl_FragColor = outColor;
            }`
        });
        this._quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this._quadScene = new THREE.Scene();
        this._quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), this._mergeShader);
        this._quadScene.add(this._quad);
        this._renderer = new THREE.WebGLRenderer();
    }
}
exports.TextureUnifierInjector = TextureUnifierInjector;
//# sourceMappingURL=TextureUnifierInjector.js.map

/***/ }),

/***/ 63506:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ANTI_ALIASING_TECHNIQUE = exports.POST_PROCESSING_EFFECT_TYPE = void 0;
var POST_PROCESSING_EFFECT_TYPE;
(function (POST_PROCESSING_EFFECT_TYPE) {
    POST_PROCESSING_EFFECT_TYPE["BLOOM"] = "bloom";
    POST_PROCESSING_EFFECT_TYPE["CHROMATIC_ABERRATION"] = "chromatic_aberration";
    POST_PROCESSING_EFFECT_TYPE["DEPTH_OF_FIELD"] = "depth_of_field";
    POST_PROCESSING_EFFECT_TYPE["DOT_SCREEN"] = "dot_screen";
    POST_PROCESSING_EFFECT_TYPE["GOD_RAYS"] = "god_rays";
    POST_PROCESSING_EFFECT_TYPE["GRID"] = "grid";
    POST_PROCESSING_EFFECT_TYPE["HBAO"] = "hbao";
    POST_PROCESSING_EFFECT_TYPE["HUE_SATURATION"] = "hue_saturation";
    POST_PROCESSING_EFFECT_TYPE["NOISE"] = "noise";
    POST_PROCESSING_EFFECT_TYPE["OUTLINE"] = "outline";
    POST_PROCESSING_EFFECT_TYPE["PIXELATION"] = "pixelation";
    POST_PROCESSING_EFFECT_TYPE["SSAO"] = "ssao";
    POST_PROCESSING_EFFECT_TYPE["SCANLINE"] = "scanline";
    POST_PROCESSING_EFFECT_TYPE["SELECTIVE_BLOOM"] = "selective_bloom";
    POST_PROCESSING_EFFECT_TYPE["SEPIA"] = "sepia";
    POST_PROCESSING_EFFECT_TYPE["TILT_SHIFT"] = "tilt_shift";
    POST_PROCESSING_EFFECT_TYPE["VIGNETTE"] = "vignette";
})(POST_PROCESSING_EFFECT_TYPE = exports.POST_PROCESSING_EFFECT_TYPE || (exports.POST_PROCESSING_EFFECT_TYPE = {}));
var ANTI_ALIASING_TECHNIQUE;
(function (ANTI_ALIASING_TECHNIQUE) {
    ANTI_ALIASING_TECHNIQUE["FXAA"] = "fxaa";
    ANTI_ALIASING_TECHNIQUE["NONE"] = "none";
    ANTI_ALIASING_TECHNIQUE["SMAA"] = "smaa";
    ANTI_ALIASING_TECHNIQUE["SSAA"] = "ssaa";
})(ANTI_ALIASING_TECHNIQUE = exports.ANTI_ALIASING_TECHNIQUE || (exports.ANTI_ALIASING_TECHNIQUE = {}));
//# sourceMappingURL=IPostProcessingEffectDefinitions.js.map

/***/ }),

/***/ 83445:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvironmentMapLoader = exports.ENVIRONMENT_MAP_TYPE = exports.ENVIRONMENT_MAP_EMPTY = exports.ENVIRONMENT_MAP = exports.ENVIRONMENT_MAP_CUBE = void 0;
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable no-async-promise-executor */
const THREE = __importStar(__webpack_require__(39437));
const viewer_shared_services_1 = __webpack_require__(8389);
const RGBELoader_1 = __webpack_require__(10183);
const viewer_shared_types_1 = __webpack_require__(64766);
var ENVIRONMENT_MAP_CUBE;
(function (ENVIRONMENT_MAP_CUBE) {
    ENVIRONMENT_MAP_CUBE["DEFAULT"] = "default";
    ENVIRONMENT_MAP_CUBE["DEFAULT_BW"] = "default_bw";
    ENVIRONMENT_MAP_CUBE["BLURRED_LIGHTS"] = "blurred_lights";
    ENVIRONMENT_MAP_CUBE["GEORGENTOR"] = "georgentor";
    ENVIRONMENT_MAP_CUBE["GEORGENTOR_BLUR"] = "georgentor_blur";
    ENVIRONMENT_MAP_CUBE["GEORGENTOR_BLUE_BLUR"] = "georgentor_blue_blur";
    ENVIRONMENT_MAP_CUBE["GEORGENTOR_BW_BLUR"] = "georgentor_bw_blur";
    ENVIRONMENT_MAP_CUBE["LEVELSETS"] = "levelsets";
    ENVIRONMENT_MAP_CUBE["LYTHWOOD_FIELD"] = "lythwood_field";
    ENVIRONMENT_MAP_CUBE["MOUNTAINS"] = "mountains";
    ENVIRONMENT_MAP_CUBE["OCEAN"] = "ocean";
    ENVIRONMENT_MAP_CUBE["PIAZZA_SAN_MARCO"] = "piazza_san_marco";
    ENVIRONMENT_MAP_CUBE["RESIDENTIAL_GARDEN"] = "residential_garden";
    ENVIRONMENT_MAP_CUBE["ROOM_ABSTRACT_1"] = "room_abstract_1";
    ENVIRONMENT_MAP_CUBE["SKY"] = "sky";
    ENVIRONMENT_MAP_CUBE["STORAGE_ROOM"] = "storage_room";
    ENVIRONMENT_MAP_CUBE["STORM"] = "storm";
    ENVIRONMENT_MAP_CUBE["SUBWAY_ENTRANCE"] = "subway_entrance";
    ENVIRONMENT_MAP_CUBE["SUBWAY_ENTRANCE_BW_BLUR"] = "subway_entrance_bw_blur";
    ENVIRONMENT_MAP_CUBE["WHITE"] = "white";
    ENVIRONMENT_MAP_CUBE["YOKOHAMA"] = "yokohama";
})(ENVIRONMENT_MAP_CUBE = exports.ENVIRONMENT_MAP_CUBE || (exports.ENVIRONMENT_MAP_CUBE = {}));
var ENVIRONMENT_MAP;
(function (ENVIRONMENT_MAP) {
    ENVIRONMENT_MAP["ANNIVERSARY_LOUNGE"] = "anniversary_lounge";
    ENVIRONMENT_MAP["BALLROOM"] = "ballroom";
    ENVIRONMENT_MAP["CANNON_EXTERIOR"] = "cannon_exterior";
    ENVIRONMENT_MAP["CAPE_HILL"] = "cape_hill";
    ENVIRONMENT_MAP["CHRISTMAS_PHOTO_STUDIO"] = "christmas_photo_studio";
    ENVIRONMENT_MAP["CIRCUS_MAXIMUS"] = "circus_maximus";
    ENVIRONMENT_MAP["COLORFUL_STUDIO"] = "colorful_studio";
    ENVIRONMENT_MAP["COMBINATION_ROOM"] = "combination_room";
    ENVIRONMENT_MAP["GREEN_POINT_PARK"] = "green_point_park";
    ENVIRONMENT_MAP["HILLTOP_CONSTRUCTION"] = "hilltop_construction";
    ENVIRONMENT_MAP["LARGE_CORRIDOR"] = "large_corridor";
    ENVIRONMENT_MAP["LYTHWOOD_LOUNGE"] = "lythwood_lounge";
    ENVIRONMENT_MAP["NEUTRAL"] = "neutral";
    ENVIRONMENT_MAP["OBERER_KUHBERG"] = "oberer_kuhberg";
    ENVIRONMENT_MAP["OLD_HALL"] = "old_hall";
    ENVIRONMENT_MAP["PAUL_LOBE_HAUS"] = "paul_lobe_haus";
    ENVIRONMENT_MAP["PHOTO_STUDIO"] = "photo_studio";
    ENVIRONMENT_MAP["PHOTO_STUDIO_BROADWAY_HALL"] = "photo_studio_broadway_hall";
    ENVIRONMENT_MAP["SNOWY_FIELD"] = "snowy_field";
    ENVIRONMENT_MAP["STUDIO_SMALL"] = "studio_small";
    ENVIRONMENT_MAP["SUNFLOWERS"] = "sunflowers";
    ENVIRONMENT_MAP["TABLE_MOUNTAIN"] = "table_mountain";
    ENVIRONMENT_MAP["VENICE_SUNSET"] = "venice_sunset";
    ENVIRONMENT_MAP["WIDE_STREET"] = "wide_street";
})(ENVIRONMENT_MAP = exports.ENVIRONMENT_MAP || (exports.ENVIRONMENT_MAP = {}));
var ENVIRONMENT_MAP_EMPTY;
(function (ENVIRONMENT_MAP_EMPTY) {
    ENVIRONMENT_MAP_EMPTY["NONE"] = "none";
    ENVIRONMENT_MAP_EMPTY["NULL"] = "null";
})(ENVIRONMENT_MAP_EMPTY = exports.ENVIRONMENT_MAP_EMPTY || (exports.ENVIRONMENT_MAP_EMPTY = {}));
var ENVIRONMENT_MAP_TYPE;
(function (ENVIRONMENT_MAP_TYPE) {
    ENVIRONMENT_MAP_TYPE["LDR"] = "ldr";
    ENVIRONMENT_MAP_TYPE["HDR"] = "hdr";
    ENVIRONMENT_MAP_TYPE["NONE"] = "none";
    ENVIRONMENT_MAP_TYPE["NULL"] = "null";
})(ENVIRONMENT_MAP_TYPE = exports.ENVIRONMENT_MAP_TYPE || (exports.ENVIRONMENT_MAP_TYPE = {}));
class EnvironmentMapLoader {
    // #endregion Properties (15)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (15)
        this._environmentMapFilenames = ['px', 'nx', 'pz', 'nz', 'py', 'ny'];
        this._environmentMapHDR = [];
        this._environmentMapNamesHDR = Object.values(ENVIRONMENT_MAP).filter(value => typeof value === 'string');
        this._environmentMapNamesHDRKhronos = ['cannon_exterior', 'colorful_studio', 'neutral', 'wide_street'];
        this._environmentMapNamesJPG = ['default', 'default_bw', 'blurred_lights', 'georgentor', 'georgentor_blur', 'georgentor_blue_blur', 'georgentor_bw_blur', 'levelsets', 'lythwood_field', 'mountains', 'ocean', 'piazza_san_marco', 'residential_garden', 'room_abstract_1', 'sky', 'storage_room', 'storm', 'subway_entrance', 'subway_entrance_bw_blur', 'white', 'yokohama'];
        this._environmentMaps = {};
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._httpClient = viewer_shared_services_1.HttpClient.instance;
        this._stateEngine = viewer_shared_services_1.StateEngine.instance;
        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;
        this._envMap = null;
        this._isHDRMap = false;
        this._textureEncoding = THREE.SRGBColorSpace;
        this._type = ENVIRONMENT_MAP_TYPE.NULL;
    }
    // #endregion Constructors (1)
    // #region Public Accessors (4)
    get environmentMap() {
        return this._envMap;
    }
    get isHDRMap() {
        return this._isHDRMap;
    }
    get textureEncoding() {
        return this._textureEncoding;
    }
    set textureEncoding(value) {
        this._textureEncoding = value;
        this.assignTextureEncoding();
    }
    // #endregion Public Accessors (4)
    // #region Public Methods (4)
    getEnvironmentMapImageUrl(name) {
        if (Array.isArray(name))
            return '';
        if (this._environmentMapNamesHDR.indexOf(name) >= 0) {
            let url_hdr = 'https://viewer.shapediver.com/v3/envmaps/1k/' + name + '_1k.hdr';
            if (this._environmentMapNamesHDRKhronos.indexOf(name) >= 0)
                url_hdr = 'https://viewer.shapediver.com/v3/envmaps/khronos/' + name + '.hdr';
            return url_hdr;
        }
        else if (name.startsWith('https://') || name.startsWith('http://')) {
            if (name.endsWith('.hdr') || name.endsWith('.jpg') || name.endsWith('.png')) {
                return name;
            }
        }
        return '';
    }
    init() {
        this._environmentMaps['null'] = {
            name: 'null',
            map: Promise.resolve(null),
            type: ENVIRONMENT_MAP_TYPE.NULL
        };
        this._environmentMaps['none'] = {
            name: 'none',
            map: Promise.resolve(null),
            type: ENVIRONMENT_MAP_TYPE.NONE
        };
        this._pmremGenerator = new THREE.PMREMGenerator(this._renderingEngine.renderer);
        this._pmremGenerator.compileEquirectangularShader();
    }
    load(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = this._uuidGenerator.create();
            const res = this.loadEnvMap(name, eventId);
            yield this.assignEnvironmentMap(res.name, res.type, eventId);
            return Promise.resolve(true);
        });
    }
    loadEnvMap(name, eId) {
        const eventId = eId || this._uuidGenerator.create();
        const event = { type: viewer_shared_types_1.TASK_TYPE.ENVIRONMENT_MAP_LOADING, id: eventId, data: { input: name }, progress: 0, status: 'Loading EnvironmentMap' };
        this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, event);
        if (name === 'none' || name === 'null')
            return this._environmentMaps[name];
        let name_internal, name_caching, url;
        // check if name is a JSON.stringified version of an array of urls
        if (!Array.isArray(name) && (name.startsWith('["https') && name.endsWith('"]')))
            try {
                name = JSON.parse(name);
            }
            catch (e) {
                this.notify(eventId, true);
                throw new viewer_shared_services_1.ShapeDiverViewerEnvironmentMapError('EnvironmentMapLoader.load: Was not able to load environment map.', name);
            }
        // deal with string or array, define names for loading and caching
        if (!Array.isArray(name)) {
            name_internal = name.toLowerCase().replace(/ /g, '_');
            name_caching = name_internal + this._renderingEngine.environmentMapResolution;
        }
        else {
            if (name.length !== 6) {
                this.notify(eventId, true);
                throw new viewer_shared_services_1.ShapeDiverViewerEnvironmentMapError('EnvironmentMapLoader.load: Was not able to load environment map, exactly 6 files are needed in the array.', name);
            }
            name_internal = JSON.stringify(name, null, 0);
            name_caching = name_internal;
        }
        // check if environment map is already cached
        for (const environmentMap in this._environmentMaps)
            if (environmentMap === name_caching)
                return this._environmentMaps[environmentMap];
        try {
            // define urls for 6 cube images ourselves
            if (!Array.isArray(name)) {
                url = [];
                let i;
                if (this._environmentMapNamesHDR.indexOf(name_internal) >= 0) {
                    let url_hdr = 'https://viewer.shapediver.com/v3/envmaps/1k/' + name_internal + '_1k.hdr';
                    if (this._environmentMapNamesHDRKhronos.indexOf(name_internal) >= 0)
                        url_hdr = 'https://viewer.shapediver.com/v3/envmaps/khronos/' + name_internal + '.hdr';
                    this._environmentMapHDR.push(url_hdr);
                    return this.loadEnvironmentMap(name_caching, url_hdr, eventId);
                }
                else if (this._environmentMapNamesJPG.indexOf(name_internal) >= 0) {
                    // found in list of available environment maps with file type jpg
                    for (i = 0; i < this._environmentMapFilenames.length; i++)
                        url.push('https://viewer.shapediver.com/v2/envmaps/' + this._renderingEngine.environmentMapResolution + '/' + name_internal + '/' + this._environmentMapFilenames[i] + '.jpg');
                }
                else if (name.startsWith('https://') || name.startsWith('http://')) {
                    if (name.endsWith('.hdr')) {
                        this._environmentMapHDR.push(name);
                        return this.loadEnvironmentMap(name_caching, name, eventId);
                    }
                    else {
                        if (!name.endsWith('/'))
                            name += '/';
                        for (i = 0; i < this._environmentMapFilenames.length; i++)
                            url.push(name + this._environmentMapFilenames[i] + '.jpg');
                    }
                }
                else {
                    this.notify(eventId, true);
                    throw new viewer_shared_services_1.ShapeDiverViewerEnvironmentMapError('EnvironmentMapLoader.load: Was not able to load environment map, format not supported.', name);
                }
            }
            else {
                url = name;
            }
            return this.loadEnvironmentMap(name_caching, url, eventId);
        }
        catch (e) {
            this.notify(eventId, true);
            throw e;
        }
    }
    // #endregion Public Methods (4)
    // #region Private Methods (4)
    assignEnvironmentMap(name, type, eventId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (name in this._environmentMaps === false)
                return;
            this._type = type;
            const map = yield this._environmentMaps[name].map;
            this._renderingEngine.materialLoader.assignEnvironmentMap(map, type);
            this._envMap = map;
            this.notify(eventId);
        });
    }
    assignTextureEncoding() {
        for (const e in this._environmentMaps) {
            if (this._environmentMaps[e]) {
                if (this._environmentMaps[e].resolved === true) {
                    this._environmentMaps[e].map.then(m => {
                        if (m instanceof THREE.Texture) {
                            m.dispose();
                            m.colorSpace = this._textureEncoding;
                            m.needsUpdate = true;
                        }
                    });
                }
            }
        }
    }
    loadEnvironmentMap(name, url, eventId) {
        this._environmentMaps[name] = {
            name,
            type: !Array.isArray(url) ? ENVIRONMENT_MAP_TYPE.HDR : ENVIRONMENT_MAP_TYPE.LDR,
            map: new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!Array.isArray(url)) {
                        const response = yield this._httpClient.get(url, undefined, true);
                        const arrayBufferView = new Uint8Array(response.data);
                        const blob = new Blob([arrayBufferView], { type: response.headers['content-type'] });
                        const blobUrl = URL.createObjectURL(blob);
                        new RGBELoader_1.RGBELoader().load(blobUrl, (texture) => {
                            const map = this._pmremGenerator.fromEquirectangular(texture).texture;
                            this._pmremGenerator.dispose();
                            map;
                            URL.revokeObjectURL(blobUrl);
                            this._environmentMaps[name].resolved = true;
                            resolve(map);
                        }, () => { }, (error) => reject(error));
                    }
                    else {
                        const promises = [];
                        url.forEach(u => promises.push(this._httpClient.get(u, undefined, true)));
                        const responses = yield Promise.all(promises);
                        const urls = responses.map(response => {
                            const arrayBufferView = new Uint8Array(response.data);
                            const blob = new Blob([arrayBufferView], { type: response.headers['content-type'] });
                            return URL.createObjectURL(blob);
                        });
                        new THREE.CubeTextureLoader().load(urls, (map) => {
                            map.colorSpace = THREE.SRGBColorSpace;
                            map.format = THREE.RGBAFormat;
                            map.mapping = THREE.CubeReflectionMapping;
                            urls.forEach(u => URL.revokeObjectURL(u));
                            this._environmentMaps[name].resolved = true;
                            resolve(map);
                        }, () => { }, (error) => reject(error));
                    }
                }
                catch (e) {
                    this.notify(eventId, true);
                    throw e;
                }
            }))
        };
        return this._environmentMaps[name];
    }
    notify(eventId, failed = false) {
        let event;
        if (failed) {
            event = { type: viewer_shared_types_1.TASK_TYPE.ENVIRONMENT_MAP_LOADING, id: eventId, progress: 1, status: 'Loading of EnvironmentMap failed' };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, event);
        }
        else {
            event = { type: viewer_shared_types_1.TASK_TYPE.ENVIRONMENT_MAP_LOADING, id: eventId, progress: 1, status: 'Loaded EnvironmentMap' };
            if (this._stateEngine.viewportEngines[this._renderingEngine.id]) {
                this._stateEngine.viewportEngines[this._renderingEngine.id].environmentMapLoaded.resolve(true);
                this._stateEngine.viewportEngines[this._renderingEngine.id].environmentMapLoaded = new viewer_shared_services_1.StatePromise();
            }
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, event);
        }
    }
}
exports.EnvironmentMapLoader = EnvironmentMapLoader;
//# sourceMappingURL=EnvironmentMapLoader.js.map

/***/ }),

/***/ 66296:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeometryLoader = void 0;
const THREE = __importStar(__webpack_require__(39437));
const viewer_shared_types_1 = __webpack_require__(64766);
const GemMaterial_1 = __webpack_require__(75655);
const viewer_shared_services_1 = __webpack_require__(8389);
const viewer_rendering_engine_rendering_engine_1 = __webpack_require__(45850);
const SDData_1 = __webpack_require__(85284);
const gl_matrix_1 = __webpack_require__(61961);
class GeometryLoader {
    // #endregion Properties (8)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        this._gemSphericalMapsCache = {};
        this._geometryCache = {};
        this._logger = viewer_shared_services_1.Logger.instance;
        this._primitiveCache = {};
    }
    // #endregion Constructors (1)
    // #region Public Methods (6)
    emptyGeometryCache() {
        for (const key in this._geometryCache)
            this.removeFromGeometryCache(key);
        this._geometryCache = {};
        for (const key in this._primitiveCache)
            this.removeFromPrimitiveCache(key);
        this._primitiveCache = {};
    }
    init() { }
    /**
     * Create a geometry object with the provided geometry data.
     *
     * @param geometry the geometry data
     * @returns the geometry object
     */
    load(geometry, parent, newChild, skeleton) {
        const threeGeometry = (() => {
            if (!this._primitiveCache[geometry.primitive.id + '_' + geometry.primitive.version]) {
                return this.loadPrimitive(geometry.primitive);
            }
            else {
                this._primitiveCache[geometry.primitive.id + '_' + geometry.primitive.version].counter++;
                const clone = this._primitiveCache[geometry.primitive.id + '_' + geometry.primitive.version].threeGeometry.clone();
                this._primitiveCache[geometry.primitive.id + '_' + geometry.primitive.version].clones.push(clone);
                return clone;
            }
        })();
        let incomingMaterialData;
        if (geometry.effectMaterials.length > 0) {
            incomingMaterialData = geometry.effectMaterials[geometry.effectMaterials.length - 1].material;
        }
        else if (this._renderingEngine.type === viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.ATTRIBUTES) {
            incomingMaterialData = geometry.attributeMaterial;
        }
        else {
            incomingMaterialData = geometry.material;
        }
        const materialSettings = {
            mode: geometry.mode,
            useVertexTangents: threeGeometry.attributes.tangent !== undefined,
            useVertexColors: threeGeometry.attributes.color !== undefined && this._renderingEngine.type !== viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.ATTRIBUTES,
            useFlatShading: threeGeometry.attributes.normal === undefined,
            useMorphTargets: Object.keys(threeGeometry.morphAttributes).length > 0,
            useMorphNormals: Object.keys(threeGeometry.morphAttributes).length > 0 && threeGeometry.morphAttributes.normal !== undefined
        };
        if (incomingMaterialData instanceof viewer_shared_types_1.MaterialGemData) {
            const gemMaterialData = incomingMaterialData;
            threeGeometry.computeBoundingSphere();
            const sphericalNormalMap = this.createCubeNormalMap(geometry, threeGeometry);
            const center = threeGeometry.boundingSphere.center, radius = threeGeometry.boundingSphere.radius;
            gemMaterialData.side = viewer_shared_types_1.MATERIAL_SIDE.FRONT;
            gemMaterialData.center = gl_matrix_1.vec3.fromValues(center.x, center.y, center.z);
            gemMaterialData.radius = radius;
            gemMaterialData.sphericalNormalMap = sphericalNormalMap;
        }
        while (parent.children.length !== 0)
            parent.remove(parent.children[0]);
        const material = this._renderingEngine.materialLoader.load(incomingMaterialData || geometry, materialSettings);
        let obj;
        if (this._geometryCache[geometry.id + '_' + geometry.version] && !skeleton) {
            this._geometryCache[geometry.id + '_' + geometry.version].counter++;
            obj = this._geometryCache[geometry.id + '_' + geometry.version].obj;
            // case 1: in case the geometry data was cloned and this is a different object
            // case 2: it is a new child
            if (newChild === false && obj.parent !== parent || newChild === true) {
                obj = obj.cloneObject();
                this._geometryCache[geometry.id + '_' + geometry.version].clones.push(obj);
                parent.add(obj);
            }
            obj.traverse(o => {
                if (o instanceof THREE.Points ||
                    o instanceof THREE.LineSegments ||
                    o instanceof THREE.LineLoop ||
                    o instanceof THREE.Line ||
                    o instanceof THREE.Mesh)
                    o.material = material;
            });
        }
        else {
            obj = new SDData_1.SDData(geometry.id, geometry.version);
            this.createMesh(obj, geometry, threeGeometry, material, skeleton);
            this._geometryCache[geometry.id + '_' + geometry.version] = { obj, counter: 1, clones: [], primitiveCacheId: geometry.primitive.id + '_' + geometry.primitive.version };
            parent.add(obj);
        }
        obj.children.forEach(m => m.castShadow = true);
        if (material instanceof GemMaterial_1.GemMaterial) {
            obj.children.forEach(m => m.receiveShadow = false);
        }
        else {
            obj.children.forEach(m => m.receiveShadow = true);
        }
        return geometry.boundingBox.clone();
    }
    loadPrimitive(primitive) {
        const geometry = new THREE.BufferGeometry();
        if (primitive.indices)
            geometry.setIndex(new THREE.BufferAttribute(primitive.indices.array, primitive.indices.itemSize));
        for (const attributeId in primitive.attributes) {
            const buffer = this.loadAttribute(primitive.attributes[attributeId], attributeId);
            const attributeName = this.getAttributeName(attributeId);
            if (attributeId === 'NORMAL')
                if (this.checkNormals(primitive, attributeId, buffer, geometry))
                    continue;
            geometry.setAttribute(attributeName, buffer);
            const morphAttributeData = primitive.attributes[attributeId].morphAttributeData;
            if (morphAttributeData.length > 0) {
                geometry.morphTargetsRelative = true;
                const buffers = [];
                for (let i = 0; i < morphAttributeData.length; i++)
                    buffers.push(this.loadAttribute(morphAttributeData[i], attributeId));
                geometry.morphAttributes[attributeName] = buffers;
            }
            // we copy the uv coordinates into the second set of uv coordinates if there are none
            // this allows for the usage of AO and light maps that share this coordinate set
            const attributeIdUV2 = 'TEXCOORD_1', attributeNameUV2 = 'uv1';
            if (attributeName === 'uv' && !primitive.attributes[attributeIdUV2]) {
                geometry.setAttribute(attributeNameUV2, buffer);
                const morphAttributeData = primitive.attributes[attributeId].morphAttributeData;
                if (morphAttributeData.length > 0) {
                    geometry.morphTargetsRelative = true;
                    const buffers = [];
                    for (let i = 0; i < morphAttributeData.length; i++)
                        buffers.push(this.loadAttribute(morphAttributeData[i], attributeId));
                    geometry.morphAttributes[attributeNameUV2] = buffers;
                }
            }
        }
        primitive.convertedObject[this._renderingEngine.id] = geometry;
        this._primitiveCache[primitive.id + '_' + primitive.version] = { threeGeometry: geometry, counter: 1, clones: [] };
        return geometry;
    }
    removeFromGemSphericalMapsCache(id) {
        if (this._gemSphericalMapsCache[id]) {
            if (this._gemSphericalMapsCache[id].counter === 1) {
                this._gemSphericalMapsCache[id].renderTarget.dispose();
                this._gemSphericalMapsCache[id].texture.dispose();
                delete this._gemSphericalMapsCache[id];
            }
            else {
                this._gemSphericalMapsCache[id].counter--;
            }
        }
    }
    removeFromGeometryCache(id) {
        if (this._geometryCache[id]) {
            if (this._geometryCache[id].counter === 1) {
                this.removeFromPrimitiveCache(this._geometryCache[id].primitiveCacheId);
                this._geometryCache[id].clones.forEach(c => {
                    this.removeFromPrimitiveCache(this._geometryCache[id].primitiveCacheId);
                });
                delete this._geometryCache[id];
            }
            else {
                this._geometryCache[id].counter--;
            }
        }
    }
    // #endregion Public Methods (6)
    // #region Private Methods (7)
    checkNormals(primitive, attributeId, buffer, geometry) {
        let blnNormalsOk = false;
        for (let index = 0; index < 10; ++index) {
            if (Math.abs(buffer.array[index * 3]) > 0.001) {
                blnNormalsOk = true;
                break;
            }
            if (Math.abs(buffer.array[index * 3 + 1]) > 0.001) {
                blnNormalsOk = true;
                break;
            }
            if (Math.abs(buffer.array[index * 3 + 2]) > 0.001) {
                blnNormalsOk = true;
                break;
            }
        }
        if (!blnNormalsOk) {
            geometry.computeVertexNormals();
            const computedNormalAttribute = geometry.getAttribute('normal');
            // store the computed normals in the attribute data
            primitive.attributes[attributeId] = new viewer_shared_types_1.AttributeData(new Float32Array(computedNormalAttribute.array), computedNormalAttribute.itemSize, 0, 0, 3, computedNormalAttribute.normalized, computedNormalAttribute.array.length / 3);
            return true;
        }
        return false;
    }
    convertToTriangleMode(geometry, drawMode) {
        let index = geometry.getIndex();
        // generate index if not present
        if (index === null) {
            const indices = [];
            const position = geometry.getAttribute('position');
            if (position !== undefined) {
                for (let i = 0; i < position.count; i++)
                    indices.push(i);
                geometry.setIndex(indices);
                index = geometry.getIndex();
            }
            else {
                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GeometryLoader.convertToTriangleMode: Undefined position attribute. Processing not possible.');
            }
        }
        if (index === null)
            throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GeometryLoader.convertToTriangleMode: Undefined index. Processing not possible.');
        const numberOfTriangles = index.count - 2;
        const newIndices = [];
        if (drawMode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_FAN) {
            for (let i = 1; i <= numberOfTriangles; i++) {
                newIndices.push(index.getX(0));
                newIndices.push(index.getX(i));
                newIndices.push(index.getX(i + 1));
            }
        }
        else {
            for (let i = 0; i < numberOfTriangles; i++) {
                if (i % 2 === 0) {
                    newIndices.push(index.getX(i));
                    newIndices.push(index.getX(i + 1));
                    newIndices.push(index.getX(i + 2));
                }
                else {
                    newIndices.push(index.getX(i + 2));
                    newIndices.push(index.getX(i + 1));
                    newIndices.push(index.getX(i));
                }
            }
        }
        if ((newIndices.length / 3) !== numberOfTriangles)
            throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GeometryLoader.convertToTriangleMode: Unable to generate correct amount of triangle.');
        geometry.setIndex(newIndices);
    }
    createCubeNormalMap(geometryData, geometry, resolution = 1024) {
        if (this._gemSphericalMapsCache[geometryData.primitive.id + '_' + geometryData.primitive.version]) {
            this._gemSphericalMapsCache[geometryData.primitive.id + '_' + geometryData.primitive.version].counter++;
            return this._gemSphericalMapsCache[geometryData.primitive.id + '_' + geometryData.primitive.version].texture;
        }
        if (!this._gemScene) {
            this._gemScene = new THREE.Scene();
            this._gemCubeCameraRenderTarget = new THREE.WebGLCubeRenderTarget(resolution, { format: THREE.RGBAFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter });
            this._gemCubeCameraRenderTarget.texture.generateMipmaps = false;
            this._gemCubeCameraRenderTarget.texture.minFilter = THREE.NearestFilter;
            this._gemCubeCameraRenderTarget.texture.magFilter = THREE.NearestFilter;
            this._gemCubeCameraRenderTarget.texture.format = THREE.RGBAFormat;
            this._gemCubeCamera = new THREE.CubeCamera(0.001, 10000, this._gemCubeCameraRenderTarget);
            this._gemScene.add(this._gemCubeCamera);
        }
        else {
            this._gemCubeCameraRenderTarget = new THREE.WebGLCubeRenderTarget(resolution, { format: THREE.RGBAFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter });
            this._gemCubeCameraRenderTarget.texture.generateMipmaps = false;
            this._gemCubeCameraRenderTarget.texture.minFilter = THREE.NearestFilter;
            this._gemCubeCameraRenderTarget.texture.magFilter = THREE.NearestFilter;
            this._gemCubeCameraRenderTarget.texture.format = THREE.RGBAFormat;
            this._gemCubeCamera.renderTarget = this._gemCubeCameraRenderTarget;
        }
        if (!this._gemNormalMaterial) {
            const _normalShader = {
                defines: {},
                uniforms: THREE.UniformsUtils.merge([
                    THREE.UniformsLib.common
                ]),
                vertexShader: `
                varying vec3 vNormal;

                void main() {
                  vNormal = normal;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
                `,
                fragmentShader: `
                varying highp vec3 vNormal;

                float decodeFloat(float f) {
                    float r = mod(f, 1.0/255.0);
                    return /*r > 0.5/256.0 ? f + (1.0/256.0) - r : */f - r;
                }
                
                vec3 decodeVec3(vec3 v) {
                    return vec3(decodeFloat(v.x), decodeFloat(v.y), decodeFloat(v.z));
                }
                
                float signEncoding(vec3 v) {
                    float code = 1.0;
                     if(v.x < 0.0 && v.y < 0.0 && v.z < 0.0) {
                        code = 0.0;
                    } else if (v.x < 0.0 && v.y < 0.0) {
                        code = 2.0/256.0;
                    } else if (v.x < 0.0 && v.z < 0.0) {
                        code = 4.0/256.0;
                    } else if (v.y < 0.0 && v.z < 0.0) {
                        code = 6.0/256.0;
                    } else if (v.x < 0.0) {
                        code = 8.0/256.0;
                    } else if (v.y < 0.0) {
                        code = 10.0/256.0;
                    } else if (v.z < 0.0) {
                        code = 12.0/256.0;
                    }
                    return code;
                }
                
                void main() {
                    vec3 n = normalize(vNormal);
                    gl_FragColor = vec4(decodeVec3(abs(n)), signEncoding(n));
                }
                `
            };
            this._gemNormalMaterial = new THREE.ShaderMaterial({
                uniforms: THREE.UniformsUtils.clone(_normalShader.uniforms),
                defines: _normalShader.defines,
                vertexShader: _normalShader.vertexShader,
                fragmentShader: _normalShader.fragmentShader
            });
            this._gemNormalMaterial.blending = THREE.NoBlending;
            this._gemNormalMaterial.side = THREE.DoubleSide;
            this._gemScene.overrideMaterial = this._gemNormalMaterial;
        }
        const mesh = new THREE.Mesh(geometry.clone(), this._gemNormalMaterial);
        mesh.geometry.center();
        this._gemScene.add(mesh);
        this._gemCubeCamera.update(this._renderingEngine.renderer, this._gemScene);
        this._gemScene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
        this._gemCubeCamera.renderTarget.texture.userData = {
            SDid: geometryData.primitive.id,
            SDversion: geometryData.primitive.version
        };
        this._gemSphericalMapsCache[geometryData.primitive.id + '_' + geometryData.primitive.version] = { texture: this._gemCubeCameraRenderTarget.texture, renderTarget: this._gemCubeCameraRenderTarget, counter: 1 };
        return this._gemSphericalMapsCache[geometryData.primitive.id + '_' + geometryData.primitive.version].texture;
    }
    createMesh(obj, geometry, threeGeometry, material, skeleton) {
        if (geometry.mode === viewer_shared_types_1.PRIMITIVE_MODE.POINTS) {
            const points = new THREE.Points(threeGeometry, material);
            geometry.convertedObject[this._renderingEngine.id] = points;
            obj.add(points);
        }
        else if (geometry.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINES) {
            const lineSegments = new THREE.LineSegments(threeGeometry, material);
            geometry.convertedObject[this._renderingEngine.id] = lineSegments;
            obj.add(lineSegments);
        }
        else if (geometry.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINE_LOOP) {
            const lineLoop = new THREE.LineLoop(threeGeometry, material);
            geometry.convertedObject[this._renderingEngine.id] = lineLoop;
            obj.add(lineLoop);
        }
        else if (geometry.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP) {
            const line = new THREE.Line(threeGeometry, material);
            geometry.convertedObject[this._renderingEngine.id] = line;
            obj.add(line);
        }
        else if (geometry.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES || geometry.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_STRIP || geometry.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_FAN) {
            const bufferGeometry = threeGeometry;
            if (geometry.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_STRIP || geometry.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_FAN)
                this.convertToTriangleMode(bufferGeometry, geometry.mode);
            if (skeleton) {
                const skinnedMesh = new THREE.SkinnedMesh(bufferGeometry, material);
                geometry.convertedObject[this._renderingEngine.id] = skinnedMesh;
                skinnedMesh.bind(skeleton, skinnedMesh.matrixWorld);
                if (bufferGeometry.attributes.skinWeight.normalized)
                    skinnedMesh.normalizeSkinWeights();
                obj.add(skinnedMesh);
            }
            else {
                const mesh = new THREE.Mesh(bufferGeometry, material);
                geometry.convertedObject[this._renderingEngine.id] = mesh;
                obj.add(mesh);
            }
        }
        else {
            throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError(`GeometryLoader.load: Unrecognized primitive mode ${geometry.mode}.`);
        }
        obj.traverse(m => {
            if (m instanceof THREE.Mesh || m instanceof THREE.Points || m instanceof THREE.LineSegments || m instanceof THREE.LineLoop || m instanceof THREE.Line) {
                m.geometry.userData = {
                    SDid: geometry.id,
                    SDversion: geometry.version,
                    primitiveSDid: geometry.primitive.id,
                    primitiveSDversion: geometry.primitive.version
                };
                m.renderOrder = geometry.renderOrder;
            }
            if (m instanceof THREE.Mesh && m.userData.transparencyPlaceholder !== true) {
                m.geometry.boundingBox = new THREE.Box3(new THREE.Vector3(geometry.boundingBox.min[0], geometry.boundingBox.min[1], geometry.boundingBox.min[2]), new THREE.Vector3(geometry.boundingBox.max[0], geometry.boundingBox.max[1], geometry.boundingBox.max[2]));
                m.geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(geometry.boundingBox.boundingSphere.center[0], geometry.boundingBox.boundingSphere.center[1], geometry.boundingBox.boundingSphere.center[2]), geometry.boundingBox.boundingSphere.radius);
                m.morphTargetInfluences = geometry.morphWeights;
            }
        });
    }
    getAttributeName(attributeId) {
        switch (attributeId) {
            case 'POSITION':
                return 'position';
            case 'NORMAL':
                return 'normal';
            case 'TEXCOORD_0':
            case 'TEXCOORD0':
            case 'TEXCOORD':
            case 'UV':
                return 'uv';
            case 'TEXCOORD_1':
                return 'uv1';
            case 'TEXCOORD_2':
                return 'uv2';
            case 'TEXCOORD_3':
                return 'uv3';
            case 'COLOR_0':
            case 'COLOR0':
            case 'COLOR':
                return 'color';
            case 'WEIGHT':
            case 'WEIGHTS_0':
                return 'skinWeight';
            case 'JOINT':
            case 'JOINTS_0':
                return 'skinIndex';
            case 'TANGENT':
                return 'tangent';
            case 'POSITION_INDEX':
                return 'positionIndex';
            default:
                this._logger.warn(`GeometryLoader.loadPrimitive: Unrecognized attribute id ${attributeId}.`);
        }
        return '';
    }
    loadAttribute(bufferAttribute, attributeId) {
        let buffer;
        if (bufferAttribute.byteStride && bufferAttribute.byteStride !== bufferAttribute.itemBytes) {
            // Integer parameters to IB/IBA are in array elements, not bytes.
            const ib = new THREE.InterleavedBuffer(bufferAttribute.array, bufferAttribute.byteStride / bufferAttribute.elementBytes);
            buffer = new THREE.InterleavedBufferAttribute(ib, bufferAttribute.itemSize, (bufferAttribute.byteOffset % bufferAttribute.byteStride) / bufferAttribute.elementBytes, bufferAttribute.normalized);
        }
        else {
            buffer = new THREE.BufferAttribute(bufferAttribute.array, bufferAttribute.itemSize, (attributeId === 'COLOR_0' || attributeId === 'COLOR0' || attributeId === 'COLOR') ? true : bufferAttribute.normalized);
        }
        if (bufferAttribute.sparse) {
            if (bufferAttribute.array !== null) {
                // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
                buffer = new THREE.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
            }
            for (let i = 0, il = bufferAttribute.sparseIndices.length; i < il; i++) {
                const index = bufferAttribute.sparseIndices[i];
                buffer.setX(index, bufferAttribute.sparseValues[i * bufferAttribute.itemSize]);
                if (bufferAttribute.itemSize >= 2)
                    buffer.setY(index, bufferAttribute.sparseValues[i * bufferAttribute.itemSize + 1]);
                if (bufferAttribute.itemSize >= 3)
                    buffer.setZ(index, bufferAttribute.sparseValues[i * bufferAttribute.itemSize + 2]);
                if (bufferAttribute.itemSize >= 4)
                    buffer.setW(index, bufferAttribute.sparseValues[i * bufferAttribute.itemSize + 3]);
                if (bufferAttribute.itemSize >= 5)
                    throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GeometryLoader.loadPrimitive: Unsupported itemSize in sparse BufferAttribute.');
            }
        }
        return buffer;
    }
    removeFromPrimitiveCache(id) {
        if (this._primitiveCache[id]) {
            if (this._primitiveCache[id].counter === 1) {
                this._primitiveCache[id].threeGeometry.dispose();
                for (const key in this._primitiveCache[id].threeGeometry.attributes)
                    this._primitiveCache[id].threeGeometry.deleteAttribute(key);
                this._primitiveCache[id].threeGeometry.setIndex(null);
                this._primitiveCache[id].clones.forEach(c => {
                    c.dispose();
                    for (const key in c.attributes)
                        c.deleteAttribute(key);
                    c.setIndex(null);
                });
                delete this._primitiveCache[id];
            }
            else {
                this._primitiveCache[id].counter--;
            }
        }
    }
}
exports.GeometryLoader = GeometryLoader;
//# sourceMappingURL=GeometryLoader.js.map

/***/ }),

/***/ 2642:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTMLElementAnchorLoader = void 0;
const viewer_rendering_engine_rendering_engine_1 = __webpack_require__(45850);
const gl_matrix_1 = __webpack_require__(61961);
class HTMLElementAnchorLoader {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (2)
        this._htmlElements = {};
        this._parentDiv = document.createElement('div');
        this._parentDiv.classList.add('sdv-anchor-container');
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (1)
    get parentDiv() {
        return this._parentDiv;
    }
    // #endregion Public Getters And Setters (1)
    // #region Public Methods (5)
    adjustPositions(scaleWidth, scaleHeight) {
        for (const anchorId in this._htmlElements) {
            const anchor = this._htmlElements[anchorId].anchor;
            const { page, container, client, hidden } = this._renderingEngine.sceneTracingManager.convert3Dto2D(gl_matrix_1.vec3.clone(anchor.location));
            const htmlElement = anchor.createViewerHtmlElement(this._renderingEngine.id);
            if (!htmlElement)
                continue;
            let node = this._htmlElements[anchorId].node;
            let visible = node.visible;
            while (node.parent) {
                node = node.parent;
                visible = node.visible && visible;
            }
            if (this._renderingEngine.show === false)
                visible = false;
            anchor.update({ anchor, htmlElement, page, container, client, scale: gl_matrix_1.vec2.fromValues(scaleWidth, scaleHeight), hidden, visible });
        }
    }
    init() {
        var _a;
        (_a = this._renderingEngine.canvas.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(this._parentDiv);
    }
    load(node, anchor, isVisibleInHierarchy) {
        const htmlElement = anchor.createViewerHtmlElement(this._renderingEngine.id);
        if (!htmlElement)
            return;
        // set the display property to "none" if the viewport is not shown or the node is not visible
        if (this._renderingEngine.show === false || isVisibleInHierarchy === false)
            htmlElement.style.display = 'none';
        // if the node is not visible return
        if (isVisibleInHierarchy === false)
            return;
        this._parentDiv.appendChild(htmlElement);
        this._htmlElements[anchor.id + '_' + anchor.version] = {
            node,
            anchor
        };
    }
    removeData(id, version) {
        // since the data object might be there, but no data is loaded for this viewport
        // this check is needed
        if (!this._htmlElements[id + '_' + version])
            return;
        const anchor = this._htmlElements[id + '_' + version].anchor;
        if (anchor && anchor.getViewerHtmlElement(this._renderingEngine.id)) {
            this._parentDiv.removeChild(anchor.getViewerHtmlElement(this._renderingEngine.id));
            delete this._htmlElements[id + '_' + version];
        }
    }
    toggleBusyMode(toggle) {
        if (toggle && this._renderingEngine.busyModeDisplay === viewer_rendering_engine_rendering_engine_1.BUSY_MODE_DISPLAY.BLUR) {
            if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 && navigator.userAgent.toLowerCase().indexOf('android') > -1)
                return;
            this._parentDiv.style.filter = 'blur(3px)';
        }
        else {
            this._parentDiv.style.filter = '';
        }
    }
}
exports.HTMLElementAnchorLoader = HTMLElementAnchorLoader;
//# sourceMappingURL=HTMLElementAnchorLoader.js.map

/***/ }),

/***/ 88708:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LightLoader = void 0;
const THREE = __importStar(__webpack_require__(39437));
const viewer_rendering_engine_light_engine_1 = __webpack_require__(9454);
class LightLoader {
    // #endregion Properties (3)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (3)
        this._forceDisabledShadows = false;
        this._shadowMapCount = 0;
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (4)
    get forceDisabledShadows() {
        return this._forceDisabledShadows;
    }
    set forceDisabledShadows(value) {
        this._forceDisabledShadows = value;
    }
    get shadowMapCount() {
        return this._shadowMapCount;
    }
    set shadowMapCount(value) {
        this._shadowMapCount = value;
    }
    // #endregion Public Getters And Setters (4)
    // #region Public Methods (3)
    adjustToBoundingBox(light, dataChild, boundingBox) {
        const threeLight = dataChild.children[0];
        if (light instanceof viewer_rendering_engine_light_engine_1.DirectionalLight) {
            const threeDirectionalLight = threeLight;
            const bs = boundingBox.boundingSphere;
            threeDirectionalLight.position.set(bs.center[0] + light.direction[0] * bs.radius * 2.35, bs.center[1] + light.direction[1] * bs.radius * 2.35, bs.center[2] + light.direction[2] * bs.radius * 2.35);
            threeDirectionalLight.target.position.set(bs.center[0], bs.center[1], bs.center[2]);
            if (light.castShadow === true && this.forceDisabledShadows === false) {
                threeDirectionalLight.castShadow = true;
                threeDirectionalLight.shadow.camera.up.set(0, 0, 1);
                threeDirectionalLight.shadow.camera.far = 8 * bs.radius;
                threeDirectionalLight.shadow.camera.right = 1.5 * bs.radius;
                threeDirectionalLight.shadow.camera.left = -1.5 * bs.radius;
                threeDirectionalLight.shadow.camera.top = 1.5 * bs.radius;
                threeDirectionalLight.shadow.camera.bottom = -1.5 * bs.radius;
                threeDirectionalLight.shadow.mapSize.width = light.shadowMapResolution;
                threeDirectionalLight.shadow.mapSize.height = light.shadowMapResolution;
                threeDirectionalLight.shadow.bias = light.shadowMapBias;
                threeDirectionalLight.shadow.camera.updateProjectionMatrix();
                this._shadowMapCount++;
            }
            else {
                threeDirectionalLight.castShadow = false;
            }
        }
    }
    init() { }
    load(light, dataChild) {
        let threeLight = dataChild.children[0] instanceof THREE.Light ? dataChild.children[0] : null;
        if (light instanceof viewer_rendering_engine_light_engine_1.AmbientLight) {
            if (!threeLight) {
                threeLight = new THREE.AmbientLight();
                light.convertedObject[this._renderingEngine.id] = threeLight;
                dataChild.add(threeLight);
            }
            const threeAmbientLight = threeLight;
            threeAmbientLight.color = this._renderingEngine.createThreeJsColor(light.color);
            threeAmbientLight.intensity = light.intensity;
        }
        if (light instanceof viewer_rendering_engine_light_engine_1.DirectionalLight) {
            if (!threeLight) {
                threeLight = new THREE.DirectionalLight();
                dataChild.add(threeLight);
                dataChild.add(threeLight.target);
                light.convertedObject[this._renderingEngine.id] = threeLight;
            }
            const threeDirectionalLight = threeLight;
            threeDirectionalLight.color = this._renderingEngine.createThreeJsColor(light.color);
            threeDirectionalLight.intensity = light.intensity;
            if (light.useNodeData) {
                threeDirectionalLight.position.set(0, 0, 0);
                threeDirectionalLight.target.position.set(0, 0, -1);
            }
        }
        if (light instanceof viewer_rendering_engine_light_engine_1.HemisphereLight) {
            if (!threeLight) {
                threeLight = new THREE.HemisphereLight();
                dataChild.add(threeLight);
                light.convertedObject[this._renderingEngine.id] = threeLight;
            }
            const threeHemisphereLight = threeLight;
            threeHemisphereLight.color = this._renderingEngine.createThreeJsColor(light.color);
            threeHemisphereLight.intensity = light.intensity;
            threeHemisphereLight.groundColor = this._renderingEngine.createThreeJsColor(light.groundColor);
        }
        if (light instanceof viewer_rendering_engine_light_engine_1.PointLight) {
            if (!threeLight) {
                threeLight = new THREE.PointLight();
                dataChild.add(threeLight);
                light.convertedObject[this._renderingEngine.id] = threeLight;
            }
            const threePointLight = threeLight;
            threePointLight.color = this._renderingEngine.createThreeJsColor(light.color);
            threePointLight.intensity = light.intensity;
            threePointLight.distance = light.distance;
            threePointLight.decay = light.decay;
            threePointLight.position.set(light.position[0], light.position[1], light.position[2]);
        }
        if (light instanceof viewer_rendering_engine_light_engine_1.SpotLight) {
            if (!threeLight) {
                threeLight = new THREE.SpotLight(this._renderingEngine.createThreeJsColor(light.color), light.intensity, light.distance, light.angle, light.penumbra, light.decay);
                dataChild.add(threeLight);
                dataChild.add(threeLight.target);
                light.convertedObject[this._renderingEngine.id] = threeLight;
            }
            const threeSpotLight = threeLight;
            threeSpotLight.color = this._renderingEngine.createThreeJsColor(light.color);
            threeSpotLight.intensity = light.intensity;
            threeSpotLight.distance = light.distance;
            threeSpotLight.angle = light.angle;
            threeSpotLight.penumbra = light.penumbra;
            threeSpotLight.decay = light.decay;
            threeSpotLight.position.set(light.position[0], light.position[1], light.position[2]);
            threeSpotLight.target.position.set(light.target[0], light.target[1], light.target[2]);
        }
    }
}
exports.LightLoader = LightLoader;
//# sourceMappingURL=LightLoader.js.map

/***/ }),

/***/ 65993:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.adaptShaders = exports.MATERIAL_TYPE = exports.MaterialLoader = void 0;
const THREE = __importStar(__webpack_require__(39437));
const viewer_shared_services_1 = __webpack_require__(8389);
const PCSS_1 = __webpack_require__(65642);
const EnvironmentMapLoader_1 = __webpack_require__(83445);
const GemMaterial_1 = __webpack_require__(75655);
const viewer_shared_types_1 = __webpack_require__(64766);
const gl_matrix_1 = __webpack_require__(61961);
const MultiPointsMaterial_1 = __webpack_require__(3382);
const SDColor_1 = __webpack_require__(1161);
const SpecularGlossinessMaterial_1 = __webpack_require__(16871);
// #endregion Type aliases (6)
// #region Classes (1)
class MaterialLoader {
    // #endregion Properties (16)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (16)
        this._converter = viewer_shared_services_1.Converter.instance;
        this._blending = 0.0;
        this._defaultLineMaterialData = new viewer_shared_types_1.MaterialBasicLineData({ color: '#199b9b' });
        this._defaultMaterialData = new viewer_shared_types_1.MaterialStandardData({ color: '#199b9b', side: viewer_shared_types_1.MATERIAL_SIDE.DOUBLE, metalness: 0.0 });
        this._defaultPointMaterialData = new viewer_shared_types_1.MaterialPointData({ color: '#199b9b' });
        this._envMap = null;
        this._envMapIntensity = 1;
        this._envMapType = EnvironmentMapLoader_1.ENVIRONMENT_MAP_TYPE.NULL;
        this._environmentMapRotationEuler = new THREE.Euler();
        this._height = 1020;
        this._lightSizeUV = 0.025;
        this._materialCache = {};
        this._maxMapCount = 0;
        this._pointSize = 1.0;
        this._textureEncoding = THREE.SRGBColorSpace;
        this._threeJsTextureCache = {};
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (12)
    get defaultLineMaterialData() {
        return this._defaultLineMaterialData;
    }
    set defaultLineMaterialData(value) {
        this._defaultLineMaterialData = value;
        this.assignDefaultLineMaterial();
    }
    get defaultMaterialData() {
        return this._defaultMaterialData;
    }
    set defaultMaterialData(value) {
        this._defaultMaterialData = value;
        this.assignDefaultMaterial();
    }
    get defaultPointMaterialData() {
        return this._defaultPointMaterialData;
    }
    set defaultPointMaterialData(value) {
        this._defaultPointMaterialData = value;
        this.assignDefaultPointMaterial();
    }
    get maxMapCount() {
        return this._maxMapCount;
    }
    set maxMapCount(value) {
        this._maxMapCount = value;
    }
    get textureEncoding() {
        return this._textureEncoding;
    }
    set textureEncoding(value) {
        this._textureEncoding = value;
        this.assignTextureEncoding();
    }
    get threeJsTextureCache() {
        return this._threeJsTextureCache;
    }
    set threeJsTextureCache(value) {
        this._threeJsTextureCache = value;
    }
    // #endregion Public Getters And Setters (12)
    // #region Public Methods (18)
    assignColorCorrection(value) {
        const convertColor = (c, toggle) => {
            if (!c)
                return;
            if (c instanceof SDColor_1.SDColor) {
                c.colorCorrection(toggle);
                return c;
            }
            else {
                const sdColor = this._renderingEngine.colorCache.find(color => color.equals(c));
                if (sdColor) {
                    sdColor.colorCorrection(toggle);
                    return sdColor;
                }
                else {
                    // we check in this case if the converted color has been stored already
                    const clone = c.clone();
                    toggle === true ? clone.convertSRGBToLinear() : clone.convertLinearToSRGB();
                    const sdColorClone = this._renderingEngine.colorCache.find(color => color.equals(clone));
                    if (sdColorClone) {
                        sdColorClone.colorCorrection(toggle);
                        return sdColorClone;
                    }
                    else {
                        // some colors may not have been set by us, but have been set automatically
                        // in this case we expect the color to be linear either way and therefore omit a color correction
                        return c;
                    }
                }
            }
        };
        for (const cacheKey in this._materialCache) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const material = this._materialCache[cacheKey].material;
            if (material.color)
                material.color = convertColor(material.color, value);
            if (material.specular)
                material.specular = convertColor(material.specular, value);
            if (material.emissive)
                material.emissive = convertColor(material.emissive, value);
            if (material.colorTransferBegin)
                material.colorTransferBegin = convertColor(material.colorTransferBegin, value);
            if (material.colorTransferEnd)
                material.colorTransferEnd = convertColor(material.colorTransferEnd, value);
            if (material.attenuationColor)
                material.attenuationColor = convertColor(material.attenuationColor, value);
            if (material.sheencolor)
                material.sheencolor = convertColor(material.sheencolor, value);
            if (material.specularColor)
                material.specularColor = convertColor(material.specularColor, value);
            material.needsUpdate = true;
        }
    }
    assignDefaultLineMaterial() {
        for (const cacheKey in this._materialCache) {
            if (this._materialCache[cacheKey].material instanceof THREE.LineBasicMaterial && this._materialCache[cacheKey].materialData === null) {
                const material = this._materialCache[cacheKey].material;
                const { properties, mapCount } = this.getMaterialProperties(this._defaultLineMaterialData, MATERIAL_TYPE.LINE, undefined);
                this.maxMapCount = Math.max(this.maxMapCount, mapCount);
                material.copy(new THREE.LineBasicMaterial(properties));
                material.needsUpdate = true;
            }
        }
    }
    assignDefaultMaterial() {
        for (const cacheKey in this._materialCache) {
            if (this._materialCache[cacheKey].material instanceof THREE.MeshPhysicalMaterial && this._materialCache[cacheKey].materialData === null) {
                const material = this._materialCache[cacheKey].material;
                const { properties, mapCount } = this.getMaterialProperties(this._defaultMaterialData, MATERIAL_TYPE.MESH, this._materialCache[cacheKey].materialSettings);
                this.maxMapCount = Math.max(this.maxMapCount, mapCount);
                material.copy(new THREE.MeshPhysicalMaterial(properties));
                material.needsUpdate = true;
            }
        }
    }
    assignDefaultPointMaterial() {
        for (const cacheKey in this._materialCache) {
            if (this._materialCache[cacheKey].material instanceof THREE.PointsMaterial && this._materialCache[cacheKey].materialData === null) {
                const material = this._materialCache[cacheKey].material;
                const { properties, mapCount } = this.getMaterialProperties(this._defaultPointMaterialData, MATERIAL_TYPE.POINT, undefined);
                this.maxMapCount = Math.max(this.maxMapCount, mapCount);
                material.copy(new THREE.PointsMaterial(properties));
                material.needsUpdate = true;
            }
        }
    }
    assignEnvironmentMap(e, type) {
        this._envMap = e;
        this._envMapType = type;
        for (const cacheKey in this._materialCache) {
            if ((this._materialCache[cacheKey].material instanceof THREE.MeshPhysicalMaterial || this._materialCache[cacheKey].material instanceof THREE.MeshStandardMaterial || this._materialCache[cacheKey].material instanceof THREE.MeshBasicMaterial)) {
                const material = this._materialCache[cacheKey].material;
                if (this._materialCache[cacheKey].materialData &&
                    (this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialStandardData ||
                        this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialGemData ||
                        this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialSpecularGlossinessData ||
                        this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialUnlitData) &&
                    this._materialCache[cacheKey].materialData.envMap !== undefined)
                    continue;
                if (this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialUnlitData && this._renderingEngine.environmentMapForUnlitMaterials === false)
                    return;
                material.envMap = e;
                material.needsUpdate = true;
                for (const d in material.defines) {
                    if (d.startsWith('ENVMAP_TYPE_'))
                        delete material.defines[d];
                }
                if (material.defines)
                    material.defines['ENVMAP_TYPE_' + this._envMapType.toUpperCase()] = '';
                this.assignEnvironmentMapRotation(this._renderingEngine.environmentMapRotation);
            }
        }
    }
    assignEnvironmentMapForUnlitMaterials(toggle) {
        for (const cacheKey in this._materialCache) {
            if (this._materialCache[cacheKey].material instanceof THREE.MeshBasicMaterial) {
                const material = this._materialCache[cacheKey].material;
                if (this._materialCache[cacheKey].materialData &&
                    this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialUnlitData &&
                    this._materialCache[cacheKey].materialData.envMap !== undefined)
                    continue;
                if (toggle) {
                    material.envMap = this._envMap;
                    material.needsUpdate = true;
                    for (const d in material.defines) {
                        if (d.startsWith('ENVMAP_TYPE_'))
                            delete material.defines[d];
                    }
                    if (material.defines)
                        material.defines['ENVMAP_TYPE_' + this._envMapType.toUpperCase()] = '';
                }
                else {
                    material.envMap = null;
                    material.needsUpdate = true;
                }
            }
        }
    }
    assignEnvironmentMapIntensity(value) {
        this._envMapIntensity = value;
        for (const cacheKey in this._materialCache) {
            if ((this._materialCache[cacheKey].material instanceof THREE.MeshPhysicalMaterial || this._materialCache[cacheKey].material instanceof THREE.MeshStandardMaterial)) {
                const material = this._materialCache[cacheKey].material;
                if (this._materialCache[cacheKey].materialData &&
                    (this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialStandardData ||
                        this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialGemData ||
                        this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialSpecularGlossinessData ||
                        this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialUnlitData) &&
                    this._materialCache[cacheKey].materialData.envMap !== undefined)
                    continue;
                material.envMapIntensity = value;
                material.needsUpdate = true;
            }
        }
    }
    assignEnvironmentMapRotation(value) {
        // we switch the y and z axis to match the three.js coordinate system
        const rotationMatrix = new THREE.Matrix4().fromArray(gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), gl_matrix_1.quat.fromValues(value[0], value[2], -value[1], value[3]))).transpose();
        this._environmentMapRotationEuler = new THREE.Euler().setFromRotationMatrix(rotationMatrix);
        this._renderingEngine.scene.backgroundRotation = this._environmentMapRotationEuler;
        for (const cacheKey in this._materialCache) {
            if ((this._materialCache[cacheKey].material instanceof THREE.MeshPhysicalMaterial || this._materialCache[cacheKey].material instanceof THREE.MeshStandardMaterial)) {
                const material = this._materialCache[cacheKey].material;
                if (this._materialCache[cacheKey].materialData &&
                    (this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialStandardData ||
                        this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialGemData ||
                        this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialSpecularGlossinessData ||
                        this._materialCache[cacheKey].materialData instanceof viewer_shared_types_1.MaterialUnlitData) &&
                    this._materialCache[cacheKey].materialData.envMap !== undefined)
                    continue;
                material.envMapRotation = this._environmentMapRotationEuler;
                material.needsUpdate = true;
            }
        }
    }
    assignPointSize(p) {
        const height = this._renderingEngine.renderer ? this._renderingEngine.renderer.getSize(new THREE.Vector2()).y : 1080;
        if (height === this._height && p * (this._height / 1080) === this._pointSize)
            return;
        this._height = height;
        this._pointSize = p * (this._height / 1080);
        for (const cacheKey in this._materialCache) {
            if (this._materialCache[cacheKey].material instanceof MultiPointsMaterial_1.MultiPointsMaterial) {
                const material = this._materialCache[cacheKey].material;
                if (this._materialCache[cacheKey].material.userData.customPointSize_0Enabled && this._materialCache[cacheKey].material.userData.customPointSize_0Enabled === true) {
                    material.size_0 = this._pointSize * this._materialCache[cacheKey].material.userData.customPointSize_0;
                    material.needsUpdate = true;
                }
                else {
                    material.size_0 = this._pointSize;
                    material.needsUpdate = true;
                }
                if (this._materialCache[cacheKey].material.userData.customPointSize_1Enabled && this._materialCache[cacheKey].material.userData.customPointSize_1Enabled === true) {
                    material.size_1 = this._pointSize * this._materialCache[cacheKey].material.userData.customPointSize_1;
                    material.needsUpdate = true;
                }
                else {
                    material.size_1 = this._pointSize;
                    material.needsUpdate = true;
                }
                if (this._materialCache[cacheKey].material.userData.customPointSize_2Enabled && this._materialCache[cacheKey].material.userData.customPointSize_2Enabled === true) {
                    material.size_2 = this._pointSize * this._materialCache[cacheKey].material.userData.customPointSize_2;
                    material.needsUpdate = true;
                }
                else {
                    material.size_2 = this._pointSize;
                    material.needsUpdate = true;
                }
                if (this._materialCache[cacheKey].material.userData.customPointSize_3Enabled && this._materialCache[cacheKey].material.userData.customPointSize_3Enabled === true) {
                    material.size_3 = this._pointSize * this._materialCache[cacheKey].material.userData.customPointSize_3;
                    material.needsUpdate = true;
                }
                else {
                    material.size_3 = this._pointSize;
                    material.needsUpdate = true;
                }
                if (this._materialCache[cacheKey].material.userData.customPointSize_4Enabled && this._materialCache[cacheKey].material.userData.customPointSize_4Enabled === true) {
                    material.size_4 = this._pointSize * this._materialCache[cacheKey].material.userData.customPointSize_4;
                    material.needsUpdate = true;
                }
                else {
                    material.size_4 = this._pointSize;
                    material.needsUpdate = true;
                }
                if (this._materialCache[cacheKey].material.userData.customPointSize_5Enabled && this._materialCache[cacheKey].material.userData.customPointSize_5Enabled === true) {
                    material.size_5 = this._pointSize * this._materialCache[cacheKey].material.userData.customPointSize_5;
                    material.needsUpdate = true;
                }
                else {
                    material.size_5 = this._pointSize;
                    material.needsUpdate = true;
                }
                if (this._materialCache[cacheKey].material.userData.customPointSize_6Enabled && this._materialCache[cacheKey].material.userData.customPointSize_6Enabled === true) {
                    material.size_6 = this._pointSize * this._materialCache[cacheKey].material.userData.customPointSize_6;
                    material.needsUpdate = true;
                }
                else {
                    material.size_6 = this._pointSize;
                    material.needsUpdate = true;
                }
                if (this._materialCache[cacheKey].material.userData.customPointSize_7Enabled && this._materialCache[cacheKey].material.userData.customPointSize_7Enabled === true) {
                    material.size_7 = this._pointSize * this._materialCache[cacheKey].material.userData.customPointSize_7;
                    material.needsUpdate = true;
                }
                else {
                    material.size_7 = this._pointSize;
                    material.needsUpdate = true;
                }
            }
            else if (this._materialCache[cacheKey].material instanceof THREE.PointsMaterial) {
                const material = this._materialCache[cacheKey].material;
                if (this._materialCache[cacheKey].material.userData.customPointSizeEnabled && this._materialCache[cacheKey].material.userData.customPointSizeEnabled === true) {
                    material.size = this._pointSize * this._materialCache[cacheKey].material.userData.customPointSize;
                    material.needsUpdate = true;
                }
                else {
                    material.size = this._pointSize;
                    material.needsUpdate = true;
                }
            }
        }
    }
    cacheSize() {
        return Object.entries(this._materialCache).length;
    }
    createMaterial(type, incomingData, materialData, materialSettings) {
        const { properties, mapCount } = this.getMaterialProperties(materialData, type, materialSettings);
        this.maxMapCount = Math.max(this.maxMapCount, mapCount);
        let material;
        if (type === MATERIAL_TYPE.POINT) {
            if (materialData instanceof viewer_shared_types_1.MaterialMultiPointData) {
                material = new MultiPointsMaterial_1.MultiPointsMaterial(properties);
            }
            else {
                material = new THREE.PointsMaterial(properties);
            }
        }
        else if (type === MATERIAL_TYPE.LINE) {
            material = new THREE.LineBasicMaterial(properties);
        }
        else {
            if (materialData instanceof viewer_shared_types_1.MaterialUnlitData) {
                material = new THREE.MeshBasicMaterial(properties);
            }
            else {
                if (materialData instanceof viewer_shared_types_1.MaterialShadowData) {
                    material = new THREE.ShadowMaterial({ opacity: properties.opacity, color: properties.color });
                }
                else if (materialData instanceof viewer_shared_types_1.MaterialSpecularGlossinessData) {
                    material = new SpecularGlossinessMaterial_1.SpecularGlossinessMaterial(properties);
                }
                else if (materialData instanceof viewer_shared_types_1.MaterialGemData) {
                    material = new GemMaterial_1.GemMaterial(properties);
                }
                else {
                    material = new THREE.MeshPhysicalMaterial(properties);
                }
                const before = material.onBeforeCompile;
                material.onBeforeCompile = (shader, renderer) => {
                    before(shader, renderer);
                    shader.uniforms.lightSizeUV = { value: this._lightSizeUV };
                    shader.uniforms.blending = { value: this._blending };
                    material.userData.shader = shader;
                };
                if (material instanceof SpecularGlossinessMaterial_1.SpecularGlossinessMaterial || material instanceof THREE.MeshPhysicalMaterial) {
                    material.defines['ENVMAP_TYPE_' + this._envMapType.toUpperCase()] = '';
                    if (materialSettings && materialSettings.useVertexTangents)
                        material.normalScale.y *= -1;
                    if (materialSettings && materialSettings.useVertexTangents && material instanceof THREE.MeshPhysicalMaterial)
                        material.clearcoatNormalScale.y *= -1;
                    if (materialSettings && materialSettings.useFlatShading)
                        material.flatShading = true;
                }
            }
        }
        if (materialSettings && materialSettings.useVertexColors)
            material.vertexColors = true;
        if (materialData instanceof viewer_shared_types_1.MaterialStandardData || materialData instanceof viewer_shared_types_1.MaterialGemData || materialData instanceof viewer_shared_types_1.MaterialSpecularGlossinessData || materialData instanceof viewer_shared_types_1.MaterialUnlitData) {
            if (materialData.envMap !== undefined) {
                const envMapInput = materialData.envMap;
                if (envMapInput !== undefined) {
                    const envMapResult = this._renderingEngine.environmentMapLoader.loadEnvMap(envMapInput);
                    envMapResult.map.then(envMap => {
                        if (material instanceof THREE.MeshBasicMaterial && this._renderingEngine.environmentMapForUnlitMaterials === false)
                            return;
                        material.envMap = envMap;
                        const envMapType = material.envMap instanceof THREE.CubeTexture ? EnvironmentMapLoader_1.ENVIRONMENT_MAP_TYPE.LDR : EnvironmentMapLoader_1.ENVIRONMENT_MAP_TYPE.HDR;
                        for (const d in material.defines) {
                            if (d.startsWith('ENVMAP_TYPE_'))
                                delete material.defines[d];
                        }
                        if (material.defines)
                            material.defines['ENVMAP_TYPE_' + envMapType.toUpperCase()] = '';
                        material.needsUpdate = true;
                    });
                }
            }
        }
        if (materialData)
            materialData.convertedObject[this._renderingEngine.id] = material;
        material.needsUpdate = true;
        if (material.userData) {
            material.userData.SDid = incomingData.id;
            material.userData.SDversion = incomingData.version;
        }
        else {
            material.userData = {
                SDid: incomingData.id,
                SDversion: incomingData.version
            };
        }
        return material;
    }
    emptyMaterialCache() {
        this._materialCache = {};
    }
    getMaterialProperties(materialData, type, materialSettings) {
        const generalProperties = {};
        let mapCount = 0;
        // if no MaterialStandardData is provided, we return our default
        if (!materialData) {
            if (type === MATERIAL_TYPE.POINT) {
                return this.getMaterialProperties(this._defaultPointMaterialData, type, materialSettings);
            }
            else if (type === MATERIAL_TYPE.LINE) {
                return this.getMaterialProperties(this._defaultLineMaterialData, type, materialSettings);
            }
            else {
                if (materialSettings !== undefined && materialSettings.useVertexColors) {
                    const currentDefaultMaterialColor = this._defaultMaterialData.color;
                    this._defaultMaterialData.color = '#d3d3d3';
                    const properties = this.getMaterialProperties(this._defaultMaterialData, type, materialSettings);
                    this._defaultMaterialData.color = currentDefaultMaterialColor;
                    return properties;
                }
                else {
                    return this.getMaterialProperties(this._defaultMaterialData, type, materialSettings);
                }
            }
        }
        /**
         * We know evaluate properties that can be applied to all materials
         */
        generalProperties.alphaTest = materialData.alphaCutoff;
        if (materialData.opacity !== undefined) {
            generalProperties.opacity = materialData.opacity;
            generalProperties.transparent = generalProperties.opacity < 1;
        }
        if (materialData.alphaMode === viewer_shared_types_1.MATERIAL_ALPHA.BLEND) {
            generalProperties.transparent = true;
            generalProperties.depthWrite = false;
        }
        else if (!generalProperties.transparent) {
            generalProperties.transparent = false;
        }
        if (materialData.depthTest !== undefined) {
            generalProperties.depthTest = materialData.depthTest;
        }
        if (materialData.depthWrite !== undefined) {
            generalProperties.depthWrite = materialData.depthWrite;
        }
        if (materialData.transparent !== undefined) {
            generalProperties.transparent = materialData.transparent;
        }
        if (materialData.color !== undefined)
            generalProperties.color = this._renderingEngine.createThreeJsColor(materialData.color);
        if (materialData.color === undefined && materialData.map !== undefined && materialData.map.color !== undefined)
            generalProperties.color = this._renderingEngine.createThreeJsColor(materialData.map.color);
        if (materialData.color === undefined && materialData.map !== undefined && materialData.map.color === undefined && !(materialSettings !== undefined && materialSettings.useVertexColors))
            generalProperties.color = this._renderingEngine.createThreeJsColor(this._renderingEngine.defaultMaterialColor);
        if ((materialSettings !== undefined && materialSettings.useVertexColors) && (materialData.color === this._converter.toHexColor(this._renderingEngine.defaultMaterialColor) || materialData.color + 'ff' === this._converter.toHexColor(this._renderingEngine.defaultMaterialColor) || materialData.color === this._renderingEngine.defaultMaterialColor || materialData.color === this._renderingEngine.defaultMaterialColor + 'ff' || materialData.color === undefined))
            generalProperties.color = this._renderingEngine.createThreeJsColor('#d3d3d3');
        if (materialData.side !== undefined)
            generalProperties.side = materialData.side === viewer_shared_types_1.MATERIAL_SIDE.BACK ? THREE.BackSide : materialData.side === viewer_shared_types_1.MATERIAL_SIDE.FRONT ? THREE.FrontSide : THREE.DoubleSide;
        /**
         *
         * First exit, lines ans points
         *
         */
        if (type === MATERIAL_TYPE.POINT) {
            if (materialData instanceof viewer_shared_types_1.MaterialPointData) {
                const pointMaterialProperties = generalProperties;
                pointMaterialProperties.size = materialData.size !== undefined ? materialData.size : this._pointSize;
                pointMaterialProperties.userData = {
                    customPointSizeEnabled: materialData.size !== undefined,
                    customPointSize: materialData.size
                };
                pointMaterialProperties.sizeAttenuation = materialData.sizeAttenuation !== undefined ? materialData.sizeAttenuation : true;
                if (materialData.map !== undefined) {
                    pointMaterialProperties.map = this.createTexture(materialData.map);
                    mapCount++;
                }
                if (materialData.alphaMap !== undefined) {
                    pointMaterialProperties.alphaMap = this.createTexture(materialData.alphaMap);
                    pointMaterialProperties.transparent = true;
                    pointMaterialProperties.depthWrite = false;
                    mapCount++;
                }
            }
            else if (materialData instanceof viewer_shared_types_1.MaterialMultiPointData) {
                const multiPointMaterialProperties = generalProperties;
                if (materialData.materialIndexDataMap) {
                    multiPointMaterialProperties.materialIndexDataTexture = this.createTexture(materialData.materialIndexDataMap);
                }
                else {
                    multiPointMaterialProperties.materialIndexDataTexture =
                        new THREE.DataTexture(new Uint8Array(multiPointMaterialProperties.materialIndexDataTextureSize || 1024), multiPointMaterialProperties.materialIndexDataTextureSize || 1024, 1, THREE.RedIntegerFormat, THREE.UnsignedIntType);
                    multiPointMaterialProperties.materialIndexDataTexture.internalFormat = 'R32UI';
                }
                multiPointMaterialProperties.size_0 = materialData.size_0 !== undefined ? materialData.size_0 : this._pointSize;
                multiPointMaterialProperties.size_1 = materialData.size_1 !== undefined ? materialData.size_1 : this._pointSize;
                multiPointMaterialProperties.size_2 = materialData.size_2 !== undefined ? materialData.size_2 : this._pointSize;
                multiPointMaterialProperties.size_3 = materialData.size_3 !== undefined ? materialData.size_3 : this._pointSize;
                multiPointMaterialProperties.size_4 = materialData.size_4 !== undefined ? materialData.size_4 : this._pointSize;
                multiPointMaterialProperties.size_5 = materialData.size_5 !== undefined ? materialData.size_5 : this._pointSize;
                multiPointMaterialProperties.size_6 = materialData.size_6 !== undefined ? materialData.size_6 : this._pointSize;
                multiPointMaterialProperties.size_7 = materialData.size_7 !== undefined ? materialData.size_7 : this._pointSize;
                multiPointMaterialProperties.userData = {
                    customPointSize_0Enabled: materialData.size_0 !== undefined,
                    customPointSize_1Enabled: materialData.size_1 !== undefined,
                    customPointSize_2Enabled: materialData.size_2 !== undefined,
                    customPointSize_3Enabled: materialData.size_3 !== undefined,
                    customPointSize_4Enabled: materialData.size_4 !== undefined,
                    customPointSize_5Enabled: materialData.size_5 !== undefined,
                    customPointSize_6Enabled: materialData.size_6 !== undefined,
                    customPointSize_7Enabled: materialData.size_7 !== undefined,
                    customPointSize_0: materialData.size_0,
                    customPointSize_1: materialData.size_1,
                    customPointSize_2: materialData.size_2,
                    customPointSize_3: materialData.size_3,
                    customPointSize_4: materialData.size_4,
                    customPointSize_5: materialData.size_5,
                    customPointSize_6: materialData.size_6,
                    customPointSize_7: materialData.size_7
                };
                multiPointMaterialProperties.sizeAttenuation_0 = materialData.sizeAttenuation_0 !== undefined ? materialData.sizeAttenuation_0 : false;
                multiPointMaterialProperties.sizeAttenuation_1 = materialData.sizeAttenuation_1 !== undefined ? materialData.sizeAttenuation_1 : false;
                multiPointMaterialProperties.sizeAttenuation_2 = materialData.sizeAttenuation_2 !== undefined ? materialData.sizeAttenuation_2 : false;
                multiPointMaterialProperties.sizeAttenuation_3 = materialData.sizeAttenuation_3 !== undefined ? materialData.sizeAttenuation_3 : false;
                multiPointMaterialProperties.sizeAttenuation_4 = materialData.sizeAttenuation_4 !== undefined ? materialData.sizeAttenuation_4 : false;
                multiPointMaterialProperties.sizeAttenuation_5 = materialData.sizeAttenuation_5 !== undefined ? materialData.sizeAttenuation_5 : false;
                multiPointMaterialProperties.sizeAttenuation_6 = materialData.sizeAttenuation_6 !== undefined ? materialData.sizeAttenuation_6 : false;
                multiPointMaterialProperties.sizeAttenuation_7 = materialData.sizeAttenuation_7 !== undefined ? materialData.sizeAttenuation_7 : false;
                if (materialData.map_0 !== undefined) {
                    multiPointMaterialProperties.map_0 = this.createTexture(materialData.map_0);
                    multiPointMaterialProperties.map = multiPointMaterialProperties.map_0;
                    mapCount++;
                }
                if (materialData.map_1 !== undefined) {
                    multiPointMaterialProperties.map_1 = this.createTexture(materialData.map_1);
                    multiPointMaterialProperties.map = multiPointMaterialProperties.map_0;
                    mapCount++;
                }
                if (materialData.map_2 !== undefined) {
                    multiPointMaterialProperties.map_2 = this.createTexture(materialData.map_2);
                    multiPointMaterialProperties.map = multiPointMaterialProperties.map_0;
                    mapCount++;
                }
                if (materialData.map_3 !== undefined) {
                    multiPointMaterialProperties.map_3 = this.createTexture(materialData.map_3);
                    multiPointMaterialProperties.map = multiPointMaterialProperties.map_0;
                    mapCount++;
                }
                if (materialData.map_4 !== undefined) {
                    multiPointMaterialProperties.map_4 = this.createTexture(materialData.map_4);
                    multiPointMaterialProperties.map = multiPointMaterialProperties.map_0;
                    mapCount++;
                }
                if (materialData.map_5 !== undefined) {
                    multiPointMaterialProperties.map_5 = this.createTexture(materialData.map_5);
                    multiPointMaterialProperties.map = multiPointMaterialProperties.map_0;
                    mapCount++;
                }
                if (materialData.map_6 !== undefined) {
                    multiPointMaterialProperties.map_6 = this.createTexture(materialData.map_6);
                    multiPointMaterialProperties.map = multiPointMaterialProperties.map_0;
                    mapCount++;
                }
                if (materialData.map_7 !== undefined) {
                    multiPointMaterialProperties.map_7 = this.createTexture(materialData.map_7);
                    multiPointMaterialProperties.map = multiPointMaterialProperties.map_0;
                    mapCount++;
                }
                if (materialData.alphaMap_0 !== undefined) {
                    multiPointMaterialProperties.alphaMap_0 = this.createTexture(materialData.alphaMap_0);
                    multiPointMaterialProperties.alphaMap = multiPointMaterialProperties.alphaMap_0;
                    multiPointMaterialProperties.transparent = true;
                    multiPointMaterialProperties.depthWrite = false;
                    mapCount++;
                }
                if (materialData.alphaMap_1 !== undefined) {
                    multiPointMaterialProperties.alphaMap_1 = this.createTexture(materialData.alphaMap_1);
                    multiPointMaterialProperties.alphaMap = multiPointMaterialProperties.alphaMap_0;
                    multiPointMaterialProperties.transparent = true;
                    multiPointMaterialProperties.depthWrite = false;
                    mapCount++;
                }
                if (materialData.alphaMap_2 !== undefined) {
                    multiPointMaterialProperties.alphaMap_2 = this.createTexture(materialData.alphaMap_2);
                    multiPointMaterialProperties.alphaMap = multiPointMaterialProperties.alphaMap_0;
                    multiPointMaterialProperties.transparent = true;
                    multiPointMaterialProperties.depthWrite = false;
                    mapCount++;
                }
                if (materialData.alphaMap_3 !== undefined) {
                    multiPointMaterialProperties.alphaMap_3 = this.createTexture(materialData.alphaMap_3);
                    multiPointMaterialProperties.alphaMap = multiPointMaterialProperties.alphaMap_0;
                    multiPointMaterialProperties.transparent = true;
                    multiPointMaterialProperties.depthWrite = false;
                    mapCount++;
                }
                if (materialData.alphaMap_4 !== undefined) {
                    multiPointMaterialProperties.alphaMap_4 = this.createTexture(materialData.alphaMap_4);
                    multiPointMaterialProperties.alphaMap = multiPointMaterialProperties.alphaMap_0;
                    multiPointMaterialProperties.transparent = true;
                    multiPointMaterialProperties.depthWrite = false;
                    mapCount++;
                }
                if (materialData.alphaMap_5 !== undefined) {
                    multiPointMaterialProperties.alphaMap_5 = this.createTexture(materialData.alphaMap_5);
                    multiPointMaterialProperties.alphaMap = multiPointMaterialProperties.alphaMap_0;
                    multiPointMaterialProperties.transparent = true;
                    multiPointMaterialProperties.depthWrite = false;
                    mapCount++;
                }
                if (materialData.alphaMap_6 !== undefined) {
                    multiPointMaterialProperties.alphaMap_6 = this.createTexture(materialData.alphaMap_6);
                    multiPointMaterialProperties.alphaMap = multiPointMaterialProperties.alphaMap_0;
                    multiPointMaterialProperties.transparent = true;
                    multiPointMaterialProperties.depthWrite = false;
                    mapCount++;
                }
                if (materialData.alphaMap_7 !== undefined) {
                    multiPointMaterialProperties.alphaMap_7 = this.createTexture(materialData.alphaMap_7);
                    multiPointMaterialProperties.alphaMap = multiPointMaterialProperties.alphaMap_0;
                    multiPointMaterialProperties.transparent = true;
                    multiPointMaterialProperties.depthWrite = false;
                    mapCount++;
                }
                if (materialData.color_0 !== undefined) {
                    multiPointMaterialProperties.color_0 = this._renderingEngine.createThreeJsColor(materialData.color_0);
                }
                if (materialData.color_1 !== undefined) {
                    multiPointMaterialProperties.color_1 = this._renderingEngine.createThreeJsColor(materialData.color_1);
                }
                if (materialData.color_2 !== undefined) {
                    multiPointMaterialProperties.color_2 = this._renderingEngine.createThreeJsColor(materialData.color_2);
                }
                if (materialData.color_3 !== undefined) {
                    multiPointMaterialProperties.color_3 = this._renderingEngine.createThreeJsColor(materialData.color_3);
                }
                if (materialData.color_4 !== undefined) {
                    multiPointMaterialProperties.color_4 = this._renderingEngine.createThreeJsColor(materialData.color_4);
                }
                if (materialData.color_5 !== undefined) {
                    multiPointMaterialProperties.color_5 = this._renderingEngine.createThreeJsColor(materialData.color_5);
                }
                if (materialData.color_6 !== undefined) {
                    multiPointMaterialProperties.color_6 = this._renderingEngine.createThreeJsColor(materialData.color_6);
                }
                if (materialData.color_7 !== undefined) {
                    multiPointMaterialProperties.color_7 = this._renderingEngine.createThreeJsColor(materialData.color_7);
                }
            }
            else {
                const pointMaterialProperties = generalProperties;
                pointMaterialProperties.size = this._pointSize;
            }
            return { properties: generalProperties, mapCount };
        }
        else if (type === MATERIAL_TYPE.LINE) {
            return { properties: generalProperties, mapCount };
        }
        /**
         *
         * Second exit, the shadow material
         *
         */
        if (materialData instanceof viewer_shared_types_1.MaterialShadowData)
            return { properties: generalProperties, mapCount };
        /**
         * We know evaluate properties that can be applied to basic mesh materials (and the ones extending from them)
         */
        const basicProperties = generalProperties;
        if (materialData.alphaMap !== undefined) {
            basicProperties.alphaMap = this.createTexture(materialData.alphaMap);
            basicProperties.transparent = true;
            basicProperties.depthWrite = false;
            mapCount++;
        }
        if (materialData.aoMap !== undefined) {
            basicProperties.aoMap = this.createTexture(materialData.aoMap);
            mapCount++;
        }
        if (materialData.aoMapIntensity !== undefined) {
            basicProperties.aoMapIntensity = materialData.aoMapIntensity;
        }
        if (materialData.map !== undefined) {
            basicProperties.map = this.createTexture(materialData.map);
            basicProperties.map.colorSpace = this._textureEncoding;
            mapCount++;
        }
        /**
         *
         * Third exit, the unlit material
         *
         */
        if (materialData instanceof viewer_shared_types_1.MaterialUnlitData)
            return { properties: basicProperties, mapCount };
        /**
         * We know evaluate properties that can be applied to MeshPhysicalMaterials, SpecularGlossinessMaterials and GemMaterialParameters
         */
        const standardProperties = basicProperties;
        if (materialData.shading !== undefined)
            standardProperties.flatShading = materialData.shading !== 'smooth';
        if (materialData.bumpMap !== undefined) {
            standardProperties.bumpMap = this.createTexture(materialData.bumpMap);
            mapCount++;
        }
        standardProperties.bumpScale = materialData.bumpScale;
        if (materialData.emissiveness !== undefined)
            standardProperties.emissive = this._renderingEngine.createThreeJsColor(materialData.emissiveness);
        if (materialData.emissiveMap !== undefined) {
            standardProperties.emissiveMap = this.createTexture(materialData.emissiveMap);
            standardProperties.emissiveMap.colorSpace = this._textureEncoding;
            mapCount++;
        }
        standardProperties.envMap = this._envMap;
        standardProperties.envMapIntensity = this._envMapIntensity;
        standardProperties.envMapRotation = this._environmentMapRotationEuler;
        if (materialData.normalMap !== undefined) {
            standardProperties.normalMap = this.createTexture(materialData.normalMap);
            mapCount++;
        }
        if (materialData.normalScale !== undefined)
            standardProperties.normalScale = new THREE.Vector2(materialData.normalScale, -materialData.normalScale);
        /**
         *
         * Fourth exit, the specular-glossiness material
         *
         */
        if (materialData instanceof viewer_shared_types_1.MaterialSpecularGlossinessData) {
            const specularGlossinessProperties = standardProperties;
            specularGlossinessProperties.specular = this._renderingEngine.createThreeJsColor(materialData.specular);
            specularGlossinessProperties.glossiness = materialData.glossiness;
            if (materialData.specularGlossinessMap !== undefined) {
                specularGlossinessProperties.specularMap2 = this.createTexture(materialData.specularGlossinessMap);
                specularGlossinessProperties.specularMap2.colorSpace = THREE.SRGBColorSpace;
                specularGlossinessProperties.glossinessMap = specularGlossinessProperties.specularMap2;
                mapCount++;
            }
            else {
                if (materialData.specularMap !== undefined) {
                    specularGlossinessProperties.specularMap2 = this.createTexture(materialData.specularMap);
                    specularGlossinessProperties.specularMap2.colorSpace = THREE.SRGBColorSpace;
                    mapCount++;
                }
                if (materialData.glossinessMap !== undefined) {
                    specularGlossinessProperties.glossinessMap = this.createTexture(materialData.glossinessMap);
                    mapCount++;
                }
            }
            return { properties: specularGlossinessProperties, mapCount };
        }
        /**
         *
         * Fourth exit, the gem material
         *
         */
        if (materialData instanceof viewer_shared_types_1.MaterialGemData) {
            const gemProperties = standardProperties;
            gemProperties.refractionIndex = materialData.refractionIndex;
            if (materialData.impurityMap !== undefined) {
                gemProperties.impurityMap = this.createTexture(materialData.impurityMap);
                mapCount++;
            }
            gemProperties.impurityScale = materialData.impurityScale;
            if (materialData.colorTransferBegin !== undefined) {
                gemProperties.colorTransferBegin = this._renderingEngine.createThreeJsColor(materialData.colorTransferBegin);
            }
            if (materialData.colorTransferEnd !== undefined) {
                gemProperties.colorTransferEnd = this._renderingEngine.createThreeJsColor(materialData.colorTransferEnd);
            }
            gemProperties.center = new THREE.Vector3(materialData.center[0], materialData.center[1], materialData.center[2]);
            gemProperties.tracingDepth = materialData.tracingDepth;
            gemProperties.radius = materialData.radius;
            gemProperties.sphericalNormalMap = materialData.sphericalNormalMap;
            gemProperties.gamma = materialData.gamma;
            gemProperties.contrast = materialData.contrast;
            gemProperties.brightness = materialData.brightness;
            gemProperties.dispersion = materialData.dispersion;
            gemProperties.tracingOpacity = materialData.tracingOpacity;
            gemProperties.roughness = 0;
            gemProperties.metalness = 1;
            gemProperties.transparent = true;
            gemProperties.opacity = 1.0;
            gemProperties.side = THREE.FrontSide;
            return { properties: gemProperties, mapCount };
        }
        /**
         *
         * the final exit, the MeshPhysicalMaterial
         *
         */
        if (materialData instanceof viewer_shared_types_1.MaterialStandardData) {
            const meshPhysicalProperties = standardProperties;
            meshPhysicalProperties.clearcoat = materialData.clearcoat;
            if (materialData.clearcoatMap !== undefined) {
                meshPhysicalProperties.clearcoatMap = this.createTexture(materialData.clearcoatMap);
                mapCount++;
            }
            if (materialData.clearcoatNormalMap !== undefined) {
                meshPhysicalProperties.clearcoatNormalMap = this.createTexture(materialData.clearcoatNormalMap);
                mapCount++;
            }
            meshPhysicalProperties.clearcoatRoughness = materialData.clearcoatRoughness;
            if (materialData.clearcoatRoughnessMap !== undefined) {
                meshPhysicalProperties.clearcoatRoughnessMap = this.createTexture(materialData.clearcoatRoughnessMap);
                mapCount++;
            }
            if (materialData.displacementMap !== undefined) {
                meshPhysicalProperties.displacementMap = this.createTexture(materialData.displacementMap);
                mapCount++;
            }
            meshPhysicalProperties.displacementScale = materialData.displacementScale;
            meshPhysicalProperties.displacementBias = materialData.displacementBias;
            meshPhysicalProperties.ior = materialData.ior;
            meshPhysicalProperties.transmission = materialData.transmission;
            if (materialData.transmissionMap !== undefined) {
                meshPhysicalProperties.transmissionMap = this.createTexture(materialData.transmissionMap);
                mapCount++;
            }
            meshPhysicalProperties.thickness = materialData.thickness;
            if (materialData.thicknessMap !== undefined) {
                meshPhysicalProperties.thicknessMap = this.createTexture(materialData.thicknessMap);
                mapCount++;
            }
            meshPhysicalProperties.attenuationDistance = materialData.attenuationDistance;
            meshPhysicalProperties.attenuationColor = this._renderingEngine.createThreeJsColor(materialData.attenuationColor);
            meshPhysicalProperties.sheen = materialData.sheen;
            meshPhysicalProperties.sheenColor = this._renderingEngine.createThreeJsColor(materialData.sheenColor);
            meshPhysicalProperties.sheenRoughness = materialData.sheenRoughness;
            if (materialData.sheenColorMap !== undefined) {
                meshPhysicalProperties.sheenColorMap = this.createTexture(materialData.sheenColorMap);
                mapCount++;
            }
            if (materialData.sheenRoughnessMap !== undefined) {
                meshPhysicalProperties.sheenRoughnessMap = this.createTexture(materialData.sheenRoughnessMap);
                mapCount++;
            }
            meshPhysicalProperties.specularIntensity = materialData.specularIntensity;
            if (materialData.specularIntensityMap !== undefined) {
                meshPhysicalProperties.specularIntensityMap = this.createTexture(materialData.specularIntensityMap);
                mapCount++;
            }
            meshPhysicalProperties.specularColor = this._renderingEngine.createThreeJsColor(materialData.specularColor);
            if (materialData.specularColorMap !== undefined) {
                meshPhysicalProperties.specularColorMap = this.createTexture(materialData.specularColorMap);
                mapCount++;
            }
            meshPhysicalProperties.metalness = materialData.metalness;
            meshPhysicalProperties.roughness = materialData.roughness;
            if (materialData.metalnessRoughnessMap !== undefined) {
                meshPhysicalProperties.metalnessMap = this.createTexture(materialData.metalnessRoughnessMap);
                meshPhysicalProperties.roughnessMap = meshPhysicalProperties.metalnessMap;
                mapCount++;
            }
            else {
                if (materialData.metalnessMap !== undefined) {
                    meshPhysicalProperties.metalnessMap = this.createTexture(materialData.metalnessMap);
                    mapCount++;
                }
                if (materialData.roughnessMap !== undefined) {
                    meshPhysicalProperties.roughnessMap = this.createTexture(materialData.roughnessMap);
                    mapCount++;
                }
            }
            return { properties: meshPhysicalProperties, mapCount };
        }
        // we should never get here
        throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('MaterialLoader.getMaterialProperties: No proper material properties were found.');
    }
    init() { }
    /**
       * Create a material object with the provided material data.
       *
       * @param material the material data
       * @returns the material object
       */
    load(incomingData, materialSettings) {
        let materialData = null;
        if (!(incomingData instanceof viewer_shared_types_1.GeometryData))
            materialData = incomingData;
        // evaluate which type of material properties we are constructing
        let type;
        if (materialSettings && materialSettings.mode === 0) {
            type = MATERIAL_TYPE.POINT;
        }
        else if (materialSettings && (materialSettings.mode === 1 || materialSettings.mode === 2 || materialSettings.mode === 3)) {
            type = MATERIAL_TYPE.LINE;
        }
        else {
            type = MATERIAL_TYPE.MESH;
        }
        const material = this.createMaterial(type, incomingData, materialData, materialSettings);
        const cacheKey = this.createDataKeyFromMaterial(incomingData, type, materialSettings);
        if (this._materialCache[cacheKey]) {
            this._materialCache[cacheKey].material.copy(material);
            return this._materialCache[cacheKey].material;
        }
        this._materialCache[cacheKey] = {
            material,
            materialData,
            materialSettings
        };
        return material;
    }
    removeFromMaterialCache(id) {
        for (const cacheKey in this._materialCache) {
            const decodedCacheKey = (0, viewer_shared_services_1.atobCustom)(cacheKey);
            if (decodedCacheKey.startsWith(id)) {
                this._materialCache[cacheKey].material.dispose();
                delete this._materialCache[cacheKey];
            }
        }
    }
    updateMaterials() {
        for (const cacheKey in this._materialCache)
            this._materialCache[cacheKey].material.needsUpdate = true;
    }
    updateSoftShadow(lightSizeUV, blending) {
        this._lightSizeUV = lightSizeUV;
        this._blending = blending;
        for (const cacheKey in this._materialCache) {
            if (this._materialCache[cacheKey].material.userData.shader) {
                this._materialCache[cacheKey].material.userData.shader.uniforms.lightSizeUV.value = lightSizeUV;
                this._materialCache[cacheKey].material.userData.shader.uniforms.blending.value = blending;
            }
        }
    }
    // #endregion Public Methods (18)
    // #region Private Methods (4)
    assignTextureEncoding() {
        for (const cacheKey in this._materialCache) {
            if (this._materialCache[cacheKey].material instanceof THREE.MeshPhysicalMaterial || this._materialCache[cacheKey].material instanceof THREE.MeshStandardMaterial) {
                const material = this._materialCache[cacheKey].material;
                if (material.emissiveMap) {
                    material.emissiveMap.colorSpace = this._textureEncoding;
                    material.emissiveMap.needsUpdate = true;
                }
                if (material.map) {
                    material.map.colorSpace = this._textureEncoding;
                    material.map.needsUpdate = true;
                }
                material.needsUpdate = true;
            }
        }
    }
    createDataKeyFromMap(map) {
        return (0, viewer_shared_services_1.btoaCustom)(`${map.image.src}_${map.center}_${map.color}_${map.flipY}_${map.magFilter}_${map.minFilter}_${map.offset}_${map.repeat}_${map.rotation}_${map.texCoord}_${map.wrapS}_${map.wrapT}`);
    }
    createDataKeyFromMaterial(data, type, materialSettings) {
        return data ? (0, viewer_shared_services_1.btoaCustom)(data.id + '_' + data.version + '_' + type + '_' + JSON.stringify(materialSettings)) : (0, viewer_shared_services_1.btoaCustom)(type + '_' + JSON.stringify(materialSettings));
    }
    createTexture(map) {
        if (map.image instanceof ArrayBuffer)
            return new THREE.Texture();
        const key = this.createDataKeyFromMap(map);
        // texture in this structure are only stored until the next scene tree update call
        // therefore no cache management is needed, as these textures need to be created either way
        // the cache is cleared in updateSceneTree
        if (this._threeJsTextureCache[key]) {
            this._threeJsTextureCache[key].usage++;
            return this._threeJsTextureCache[key].texture;
        }
        let texture;
        if (map.asData === true) {
            texture = new THREE.DataTexture(new Uint32Array(map.data), map.data.length, 1, THREE.RedIntegerFormat, THREE.UnsignedIntType);
            texture.internalFormat = 'R32UI';
        }
        else {
            texture = new THREE.Texture(map.image);
            texture.format = THREE.RGBAFormat;
            texture.minFilter = (() => {
                switch (map.minFilter) {
                    case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST:
                        return THREE.NearestFilter;
                    case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST_MIPMAP_NEAREST:
                        return THREE.NearestMipMapNearestFilter;
                    case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR_MIPMAP_NEAREST:
                        return THREE.LinearMipMapNearestFilter;
                    case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST_MIPMAP_LINEAR:
                        return THREE.NearestMipMapLinearFilter;
                    case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR:
                        return THREE.LinearFilter;
                    case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR_MIPMAP_LINEAR:
                    default:
                        return THREE.LinearMipMapLinearFilter;
                }
            })();
            texture.magFilter = (() => {
                switch (map.magFilter) {
                    case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST:
                        return THREE.NearestFilter;
                    case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR:
                    default:
                        return THREE.LinearFilter;
                }
            })();
            texture.wrapS = (() => {
                switch (map.wrapS) {
                    case viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE:
                        return THREE.ClampToEdgeWrapping;
                    case viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT:
                        return THREE.MirroredRepeatWrapping;
                    case viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT:
                    default:
                        return THREE.RepeatWrapping;
                }
            })();
            texture.wrapT = (() => {
                switch (map.wrapT) {
                    case viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE:
                        return THREE.ClampToEdgeWrapping;
                    case viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT:
                        return THREE.MirroredRepeatWrapping;
                    case viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT:
                    default:
                        return THREE.RepeatWrapping;
                }
            })();
            texture.center = new THREE.Vector2(map.center[0], map.center[1]);
            texture.offset = new THREE.Vector2(map.offset[0], map.offset[1]);
            texture.repeat = new THREE.Vector2(map.repeat[0], map.repeat[1]);
            texture.rotation = map.rotation;
            if (map.texCoord !== undefined)
                texture.channel = map.texCoord;
            texture.flipY = map.flipY;
        }
        texture.needsUpdate = true;
        texture.userData.cacheKey = key;
        this._threeJsTextureCache[key] = {
            texture,
            usage: 1,
            initialized: false
        };
        return this._threeJsTextureCache[key].texture;
    }
}
exports.MaterialLoader = MaterialLoader;
// #endregion Classes (1)
// #region Enums (1)
/* eslint-disable @typescript-eslint/no-empty-function */
var MATERIAL_TYPE;
(function (MATERIAL_TYPE) {
    MATERIAL_TYPE["POINT"] = "point";
    MATERIAL_TYPE["LINE"] = "line";
    MATERIAL_TYPE["MESH"] = "mesh";
})(MATERIAL_TYPE = exports.MATERIAL_TYPE || (exports.MATERIAL_TYPE = {}));
// #endregion Enums (1)
// #region Variables (1)
const adaptShaders = () => {
    let shader = THREE.ShaderChunk.shadowmap_pars_fragment;
    if (!shader.includes('PCSS implementation')) {
        shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP' + PCSS_1.main);
        shader = shader.replace(shader.substr(shader.indexOf('#if defined( SHADOWMAP_TYPE_PCF )'), shader.indexOf('#elif defined( SHADOWMAP_TYPE_PCF_SOFT )') - shader.indexOf('#if defined( SHADOWMAP_TYPE_PCF )')), '#if defined( SHADOWMAP_TYPE_PCF )\n' + PCSS_1.entry);
    }
    THREE.ShaderChunk.shadowmap_pars_fragment = shader;
    // here we replace in the background cube fragment shader the y component of the reflection vector with the negative y component and inverse the rotation in the case of a LDR environment map
    // console.log(THREE.ShaderChunk.backgroundCube_frag.includes('vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );'))
    THREE.ShaderChunk.backgroundCube_frag = THREE.ShaderChunk.backgroundCube_frag.replace('vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );', 'vec4 texColor = textureCube( envMap, inverse(backgroundRotation) * vec3( flipEnvMap * vWorldDirection.x, -vWorldDirection.y, vWorldDirection.z ) );');
    THREE.ShaderLib.backgroundCube.fragmentShader = THREE.ShaderChunk.backgroundCube_frag;
    // here we replace in the envmap_physical_pars_fragment the z component of the reflection vector with the negative z component in the case of a LDR environment map
    // console.log(THREE.ShaderChunk.envmap_physical_pars_fragment, THREE.ShaderChunk.envmap_physical_pars_fragment.includes('vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );'));
    THREE.ShaderChunk.envmap_physical_pars_fragment = THREE.ShaderChunk.envmap_physical_pars_fragment.replace('vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );', `
            #ifdef ENVMAP_TYPE_LDR
                vec3 rotatedReflectVec = vec3(envMapRotation * worldNormal).xzy;
                vec4 envMapColor = textureCubeUV( envMap, vec3(rotatedReflectVec.xy, -rotatedReflectVec.z), 1.0 );
            #else
                vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
            #endif
            `);
    // here we replace in the envmap_fragment the z component of the reflection vector with the negative z component in the case of a LDR environment map
    // console.log(THREE.ShaderChunk.envmap_physical_pars_fragment, THREE.ShaderChunk.envmap_physical_pars_fragment.includes('vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );'));
    THREE.ShaderChunk.envmap_physical_pars_fragment = THREE.ShaderChunk.envmap_physical_pars_fragment.replace('vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );', `
            #ifdef ENVMAP_TYPE_LDR
                vec3 rotatedReflectVec = vec3(envMapRotation * reflectVec).xzy;
                vec4 envMapColor = textureCubeUV( envMap, vec3(rotatedReflectVec.xy, -rotatedReflectVec.z), roughness );
            #else
                vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
            #endif
            `);
    // here we replace in the envmap_fragment the z component of the reflection vector with the negative z component in the case of a LDR environment map
    // console.log(THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.envmap_fragment.includes('vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );'));
    THREE.ShaderChunk.envmap_fragment = THREE.ShaderChunk.envmap_fragment.replace('vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );', `
        #ifdef ENVMAP_TYPE_LDR
            vec4 envColor = textureCube( envMap, envMapRotation * vec3(flipEnvMap * reflectVec.x, reflectVec.y, -reflectVec.z ) );
        #else
            vec4 envColor = textureCube( envMap, envMapRotation * vec3( -flipEnvMap * reflectVec.x, reflectVec.zy ) );
        #endif
        `);
    // here we replace the z and y component of the sampleDir in the cube_uv_reflection_fragment
    // console.log(THREE.ShaderChunk.cube_uv_reflection_fragment.includes('vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );'))
    THREE.ShaderChunk.cube_uv_reflection_fragment = THREE.ShaderChunk.cube_uv_reflection_fragment.replace('vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );', 'vec3 color0 = bilinearCubeUV( envMap, sampleDir.xzy, mipInt );');
    // here we replace the z and y component of the sampleDir in the cube_uv_reflection_fragment
    // console.log(THREE.ShaderChunk.cube_uv_reflection_fragment)
    THREE.ShaderChunk.cube_uv_reflection_fragment = THREE.ShaderChunk.cube_uv_reflection_fragment.replace('vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );', 'vec3 color1 = bilinearCubeUV( envMap, sampleDir.xzy, mipInt + 1.0 );');
    // here we create a new case in the lights_fragment_maps for the case of ENVMAP_TYPE_NONE
    if (!THREE.ShaderChunk.lights_fragment_maps.includes('vec3 reflectVec')) {
        const index = THREE.ShaderChunk.lights_fragment_maps.lastIndexOf('#endif');
        THREE.ShaderChunk.lights_fragment_maps = THREE.ShaderChunk.lights_fragment_maps.substring(0, index) +
            `#else
            #ifdef ENVMAP_TYPE_NONE
                vec3 reflectVec = reflect( -geometryViewDir, geometryNormal );
                reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
                vec4 adjustedEnvReflectVector = vec4(reflectVec, 1.0);
                radiance += (vec3((adjustedEnvReflectVector.z + 1.0) / 2.0) + 0.5) / 1.5;
            #endif
        #endif
        ` + THREE.ShaderChunk.lights_fragment_maps.substring(index + '#endif'.length);
    }
};
exports.adaptShaders = adaptShaders;
// #endregion Variables (1)
//# sourceMappingURL=MaterialLoader.js.map

/***/ }),

/***/ 58767:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _CameraManager_camera, _CameraManager_cameraCache;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CameraManager = void 0;
const THREE = __importStar(__webpack_require__(39437));
const gl_matrix_1 = __webpack_require__(61961);
const viewer_rendering_engine_camera_engine_1 = __webpack_require__(17989);
class CameraManager {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (2)
        _CameraManager_camera.set(this, new THREE.PerspectiveCamera());
        _CameraManager_cameraCache.set(this, {});
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (1)
    get camera() {
        return __classPrivateFieldGet(this, _CameraManager_camera, "f");
    }
    // #endregion Public Getters And Setters (1)
    // #region Public Methods (4)
    adjustCamera(aspect) {
        let cameraThree;
        let matrix;
        const camera = this._renderingEngine.cameraEngine.camera;
        if (camera.useNodeData) {
            const sdCameraNode = camera.convertedObject[this._renderingEngine.id];
            const sdCameraData = sdCameraNode.children[0];
            cameraThree = sdCameraData.children[0];
        }
        else {
            if (this._renderingEngine.cameraEngine.camera.type === viewer_rendering_engine_camera_engine_1.CAMERA_TYPE.ORTHOGRAPHIC) {
                const orthographicCameraData = camera;
                let orthographicCameraThreeJs = orthographicCameraData.convertedObject[this._renderingEngine.id];
                if (!orthographicCameraThreeJs)
                    this.load(orthographicCameraData);
                orthographicCameraThreeJs = orthographicCameraData.convertedObject[this._renderingEngine.id];
                const distance = gl_matrix_1.vec3.distance(orthographicCameraData.position, orthographicCameraData.target) / 2;
                orthographicCameraThreeJs.up.set(orthographicCameraData.up[0], orthographicCameraData.up[1], orthographicCameraData.up[2]);
                orthographicCameraThreeJs.left = orthographicCameraData.left = -distance * aspect;
                orthographicCameraThreeJs.bottom = orthographicCameraData.bottom = -distance;
                orthographicCameraThreeJs.right = orthographicCameraData.right = distance * aspect;
                orthographicCameraThreeJs.top = orthographicCameraData.top = distance;
                orthographicCameraThreeJs.near = orthographicCameraData.near = 0.01;
                orthographicCameraThreeJs.far = orthographicCameraData.far = 100 * distance;
                orthographicCameraThreeJs.position.set(orthographicCameraData.position[0], orthographicCameraData.position[1], orthographicCameraData.position[2]);
                orthographicCameraThreeJs.lookAt(orthographicCameraData.target[0], orthographicCameraData.target[1], orthographicCameraData.target[2]);
                orthographicCameraThreeJs.updateProjectionMatrix();
                if (orthographicCameraData.controls.enableTurntableControls === true) {
                    matrix = gl_matrix_1.mat4.create();
                    gl_matrix_1.mat4.rotateZ(matrix, matrix, -orthographicCameraData.sceneRotation[1]);
                    gl_matrix_1.mat4.translate(matrix, matrix, orthographicCameraData.controls.turntableCenter);
                }
                else if (orthographicCameraData.controls.enableObjectControls === true) {
                    matrix = gl_matrix_1.mat4.create();
                    gl_matrix_1.mat4.rotateX(matrix, matrix, -orthographicCameraData.sceneRotation[0]);
                    gl_matrix_1.mat4.rotateZ(matrix, matrix, -orthographicCameraData.sceneRotation[1]);
                    gl_matrix_1.mat4.translate(matrix, matrix, orthographicCameraData.controls.objectControlsCenter);
                }
                cameraThree = orthographicCameraThreeJs;
            }
            else {
                const perspectiveCameraData = camera;
                let perspectiveCameraThreeJs = perspectiveCameraData.convertedObject[this._renderingEngine.id];
                if (!perspectiveCameraThreeJs)
                    this.load(perspectiveCameraData);
                perspectiveCameraThreeJs = perspectiveCameraData.convertedObject[this._renderingEngine.id];
                perspectiveCameraThreeJs.up.set(0, 0, 1);
                const fov = this._renderingEngine.cameraEngine.camera.fov;
                const bs = this._renderingEngine.sceneTreeManager.boundingBox.boundingSphere;
                const radius = bs.radius > 0 ? bs.radius : 2;
                perspectiveCameraThreeJs.fov = perspectiveCameraData.fov = fov;
                perspectiveCameraThreeJs.aspect = perspectiveCameraData.aspect = aspect;
                perspectiveCameraThreeJs.far = perspectiveCameraData.far = (fov < 10 ? fov * 100.0 * 100 * radius : 100 * radius);
                perspectiveCameraThreeJs.near = perspectiveCameraData.near = (fov < 10 ? fov * 100.0 * 0.01 * radius : 0.01 * radius);
                perspectiveCameraThreeJs.position.set(perspectiveCameraData.position[0], perspectiveCameraData.position[1], perspectiveCameraData.position[2]);
                perspectiveCameraThreeJs.lookAt(perspectiveCameraData.target[0], perspectiveCameraData.target[1], perspectiveCameraData.target[2]);
                perspectiveCameraThreeJs.updateProjectionMatrix();
                if (perspectiveCameraData.controls.enableTurntableControls === true) {
                    matrix = gl_matrix_1.mat4.create();
                    gl_matrix_1.mat4.rotateZ(matrix, matrix, -perspectiveCameraData.sceneRotation[1]);
                    gl_matrix_1.mat4.translate(matrix, matrix, perspectiveCameraData.controls.turntableCenter);
                }
                else if (perspectiveCameraData.controls.enableObjectControls === true) {
                    matrix = gl_matrix_1.mat4.create();
                    gl_matrix_1.mat4.rotateX(matrix, matrix, -perspectiveCameraData.sceneRotation[0]);
                    gl_matrix_1.mat4.rotateZ(matrix, matrix, -perspectiveCameraData.sceneRotation[1]);
                    gl_matrix_1.mat4.translate(matrix, matrix, perspectiveCameraData.controls.objectControlsCenter);
                }
                cameraThree = perspectiveCameraThreeJs;
            }
        }
        __classPrivateFieldSet(this, _CameraManager_camera, cameraThree, "f");
        return { camera: cameraThree, matrix };
    }
    init() { }
    load(camera, dataChild) {
        let threeCamera = __classPrivateFieldGet(this, _CameraManager_cameraCache, "f")[camera.id];
        if (camera instanceof viewer_rendering_engine_camera_engine_1.PerspectiveCamera) {
            if (!threeCamera) {
                threeCamera = new THREE.PerspectiveCamera();
                __classPrivateFieldGet(this, _CameraManager_cameraCache, "f")[camera.id] = threeCamera;
                camera.convertedObject[this._renderingEngine.id] = threeCamera;
                if (dataChild)
                    dataChild.add(threeCamera);
            }
            else {
                camera.convertedObject[this._renderingEngine.id] = threeCamera;
                if (dataChild && !dataChild.children.find(t => t === threeCamera))
                    dataChild.add(threeCamera);
            }
            const perspectiveCamera = camera;
            const threePerspectiveCamera = threeCamera;
            threePerspectiveCamera.up.set(0, 0, 1);
            if (perspectiveCamera.useNodeData) {
                threePerspectiveCamera.fov = perspectiveCamera.fov;
                threePerspectiveCamera.aspect = perspectiveCamera.aspect;
                threePerspectiveCamera.far = perspectiveCamera.far;
                threePerspectiveCamera.near = perspectiveCamera.near;
                threePerspectiveCamera.updateProjectionMatrix();
            }
        }
        else {
            if (!threeCamera) {
                threeCamera = new THREE.OrthographicCamera(0, 0, 0, 0);
                __classPrivateFieldGet(this, _CameraManager_cameraCache, "f")[camera.id] = threeCamera;
                camera.convertedObject[this._renderingEngine.id] = threeCamera;
                if (dataChild)
                    dataChild.add(threeCamera);
            }
            else {
                camera.convertedObject[this._renderingEngine.id] = threeCamera;
                if (dataChild && !dataChild.children.find(t => t === threeCamera))
                    dataChild.add(threeCamera);
            }
            const orthographicCamera = camera;
            const threeOrthographicCamera = threeCamera;
            threeOrthographicCamera.up.set(orthographicCamera.up[0], orthographicCamera.up[1], orthographicCamera.up[2]);
            if (orthographicCamera.useNodeData) {
                threeOrthographicCamera.left = orthographicCamera.left;
                threeOrthographicCamera.bottom = orthographicCamera.bottom;
                threeOrthographicCamera.right = orthographicCamera.right;
                threeOrthographicCamera.top = orthographicCamera.top;
                threeOrthographicCamera.near = orthographicCamera.near;
                threeOrthographicCamera.far = orthographicCamera.far;
                threeOrthographicCamera.updateProjectionMatrix();
            }
        }
    }
    updateCamera(time, aspect) {
        var _a;
        if (((_a = this._renderingEngine.cameraEngine.camera) === null || _a === void 0 ? void 0 : _a.type) === 'perspective')
            this._renderingEngine.cameraEngine.camera.aspect = aspect;
        return this._renderingEngine.cameraEngine.camera.update(time);
    }
}
exports.CameraManager = CameraManager;
_CameraManager_camera = new WeakMap(), _CameraManager_cameraCache = new WeakMap();
//# sourceMappingURL=CameraManager.js.map

/***/ }),

/***/ 42057:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvironmentGeometryManager = void 0;
const THREE = __importStar(__webpack_require__(39437));
const viewer_shared_types_1 = __webpack_require__(64766);
const gl_matrix_1 = __webpack_require__(61961);
const viewer_shared_math_1 = __webpack_require__(67275);
const viewer_shared_services_1 = __webpack_require__(8389);
const SDData_1 = __webpack_require__(85284);
const SDObject_1 = __webpack_require__(93867);
class EnvironmentGeometryManager {
    // #endregion Properties (5)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (5)
        this._converter = viewer_shared_services_1.Converter.instance;
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._groundPlaneColor = '#d3d3d3ff';
        this._groundPlaneShadowColor = '#d3d3d3ff';
        this._gridColor = '#44444426';
        this._initialized = false;
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => {
            this.updateEnvironmentGeometryPosition();
        });
    }
    // #endregion Constructors (1)
    // #region Public Accessors (2)
    get gridColor() {
        return this._gridColor;
    }
    set gridColor(value) {
        this._gridColor = value;
        this._grid.material.opacity = typeof this._gridColor == 'string' && this._gridColor.length <= 8 ? 0.15 : this._converter.toAlpha(this._gridColor);
        this._grid.material.transparent = this._grid.material.opacity !== 1;
        this._grid.material.color = this._renderingEngine.createThreeJsColor(this._gridColor);
        this._grid.material.needsUpdate = true;
    }
    get groundPlaneColor() {
        return this._groundPlaneColor;
    }
    set groundPlaneColor(value) {
        this._groundPlaneColor = value;
        this.assignGroundPlaneColor(value);
    }
    get groundPlaneShadowColor() {
        return this._groundPlaneShadowColor;
    }
    set groundPlaneShadowColor(value) {
        this._groundPlaneShadowColor = value;
        this.assignGroundPlaneShadowColor(value);
    }
    get grid() {
        return this._grid;
    }
    get groundPlane() {
        return this._groundPlane;
    }
    get groundPlaneShadow() {
        return this._groundPlaneShadow;
    }
    // #endregion Public Accessors (2)
    // #region Public Methods (2)
    assignGroundPlaneColor(color) {
        this._groundPlane.material.opacity = this._converter.toAlpha(color);
        this._groundPlane.material.transparent = this._groundPlane.material.opacity !== 1;
        this._groundPlane.material.depthWrite = !this._groundPlane.material.transparent;
        this._groundPlane.material.color = this._renderingEngine.createThreeJsColor(color);
        this._groundPlane.material.needsUpdate = true;
    }
    assignGroundPlaneShadowColor(color) {
        this._groundPlaneShadow.material.opacity = this._converter.toAlpha(color);
        this._groundPlaneShadow.material.color = this._renderingEngine.createThreeJsColor(color);
        this._groundPlaneShadow.material.needsUpdate = true;
    }
    /**
     * Creates the grid extents and divisios with the specified scene extents.
     *
     * https://shapediver.atlassian.net/browse/SS-2961 evaluate this magic.
     */
    evaluateGridMeasurements(sceneExtents) {
        let divisions = 0.1;
        let gridExtents = 1.0;
        if (sceneExtents > 1) {
            let tmp = Math.floor(sceneExtents).toString();
            let temp = Math.pow(10, tmp.length - 1);
            gridExtents = Math.max(Math.ceil(sceneExtents / temp) * temp, 1);
            temp = temp / 10;
            divisions = gridExtents / temp;
        }
        else if (sceneExtents !== 0) {
            let zeros = 1 - Math.floor(Math.log(sceneExtents) / Math.log(10)) - 2;
            let r = sceneExtents.toFixed(zeros + 1);
            let firstDigit = parseInt(r.substr(r.length - 1)) + 1;
            let gridExtentsS = '0.';
            for (let i = 0; i < zeros; ++i)
                gridExtentsS = gridExtentsS + '0';
            gridExtents = parseFloat(gridExtentsS + firstDigit);
            divisions = firstDigit * 10;
        }
        return { divisions, gridExtents };
    }
    changeSceneExtents(bb) {
        if (((bb.min[0] === 0 && bb.min[1] === 0 && bb.min[2] === 0) && (bb.max[0] === 0 && bb.max[1] === 0 && bb.max[2] === 0)) || bb.isEmpty())
            return;
        this._initialized = true;
        let sceneExtents = gl_matrix_1.vec3.distance(bb.min, bb.max);
        const { divisions, gridExtents } = this.evaluateGridMeasurements(sceneExtents);
        this._gridObject.remove(this._grid);
        this._grid = new THREE.GridHelper(2 * gridExtents, divisions);
        this._grid.material.opacity = typeof this._gridColor == 'string' && this._gridColor.length <= 8 ? 0.15 : this._converter.toAlpha(this._gridColor);
        this._grid.material.transparent = this._grid.material.opacity !== 1;
        this._grid.material.color = this._renderingEngine.createThreeJsColor(this._gridColor);
        this._grid.rotateX(Math.PI / 2);
        this._grid.visible = this._renderingEngine.gridVisibility;
        this._gridObject.add(this._grid);
        this._groundPlane.geometry = new THREE.PlaneGeometry(2 * gridExtents, 2 * gridExtents, 2, 2);
        this._groundPlaneShadow.geometry = new THREE.PlaneGeometry(2 * gridExtents, 2 * gridExtents, 2, 2);
        let eps = 0.005;
        let bs = bb.boundingSphere;
        this._grid.position.set(bs.center[0], bs.center[1], bb.min[2] - eps);
        this._groundPlane.position.set(bs.center[0], bs.center[1], bb.min[2] - 2 * eps);
        this._groundPlaneShadow.position.set(bs.center[0], bs.center[1], bb.min[2] - 2 * eps);
    }
    init() {
        this._environmentGeometryObject = new SDObject_1.SDObject('environmentGeometry', '');
        this._renderingEngine.sceneTreeManager.scene.add(this._environmentGeometryObject);
        this._gridObject = new SDData_1.SDData('grid', '');
        this._grid = new THREE.GridHelper();
        this._grid.material.opacity = typeof this._gridColor == 'string' && this._gridColor.length <= 8 ? 0.15 : this._converter.toAlpha(this._gridColor);
        this._grid.material.transparent = this._grid.material.opacity !== 1;
        this._grid.material.color = this._renderingEngine.createThreeJsColor(this._gridColor);
        this._grid.rotateX(Math.PI / 2);
        this._grid.visible = this._renderingEngine.gridVisibility;
        this._gridObject.add(this._grid);
        this._environmentGeometryObject.add(this._gridObject);
        this._groundPlaneObject = new SDData_1.SDData('groundPlane', '');
        let mat = new viewer_shared_types_1.MaterialStandardData();
        mat.color = this._groundPlaneColor;
        mat.side = viewer_shared_types_1.MATERIAL_SIDE.FRONT;
        mat.opacity = this._converter.toAlpha(this._groundPlaneColor);
        mat.roughness = 1;
        mat.metalness = 0;
        this._groundPlane = new THREE.Mesh(new THREE.PlaneGeometry(), this._renderingEngine.materialLoader.load(mat));
        this._groundPlane.receiveShadow = true;
        this._groundPlane.visible = this._renderingEngine.groundPlaneVisibility;
        this._groundPlaneObject.add(this._groundPlane);
        this._environmentGeometryObject.add(this._groundPlaneObject);
        this._groundPlaneShadowObject = new SDData_1.SDData('groundPlaneShadow', '');
        let matShadow = new viewer_shared_types_1.MaterialShadowData();
        matShadow.color = this._groundPlaneShadowColor;
        matShadow.opacity = this._converter.toAlpha(this._groundPlaneShadowColor);
        this._groundPlaneShadow = new THREE.Mesh(new THREE.PlaneGeometry(), this._renderingEngine.materialLoader.load(matShadow));
        this._groundPlaneShadow.receiveShadow = true;
        this._groundPlaneShadow.visible = this._renderingEngine.groundPlaneShadowVisibility;
        this._groundPlaneShadowObject.add(this._groundPlaneShadow);
        this._groundPlaneShadowObject.userData.ambientOcclusion = false;
        this._environmentGeometryObject.add(this._groundPlaneShadowObject);
        let eps = 0.005;
        this._grid.position.set(0, 0, -eps);
        this._groundPlane.position.set(0, 0, -eps);
        this._groundPlaneShadow.position.set(0, 0, -eps);
    }
    updateEnvironmentGeometryPosition() {
        const bb = new viewer_shared_math_1.Box(this._renderingEngine.sceneTreeManager.boundingBox.min, this._renderingEngine.sceneTreeManager.boundingBox.max);
        if (((bb.min[0] === 0 && bb.min[1] === 0 && bb.min[2] === 0) && (bb.max[0] === 0 && bb.max[1] === 0 && bb.max[2] === 0)) || bb.isEmpty())
            return;
        if (!this._initialized) {
            this.changeSceneExtents(bb);
        }
        else {
            let eps = 0.005;
            let bs = bb.boundingSphere;
            let sceneExtents = gl_matrix_1.vec3.distance(bb.min, bb.max);
            const { divisions, gridExtents } = this.evaluateGridMeasurements(sceneExtents);
            this._groundPlaneShadow.geometry = new THREE.PlaneGeometry(2 * gridExtents, 2 * gridExtents, 2, 2);
            if (this._grid)
                this._grid.position.set(bs.center[0], bs.center[1], bb.min[2] - eps);
            if (this._groundPlane)
                this._groundPlane.position.set(bs.center[0], bs.center[1], bb.min[2] - 2 * eps);
            if (this._groundPlaneShadow)
                this._groundPlaneShadow.position.set(bs.center[0], bs.center[1], bb.min[2] - 2 * eps);
        }
    }
}
exports.EnvironmentGeometryManager = EnvironmentGeometryManager;
//# sourceMappingURL=EnvironmentGeometryManager.js.map

/***/ }),

/***/ 30265:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PostProcessingManager = void 0;
const THREE = __importStar(__webpack_require__(39437));
const postprocessing_1 = __webpack_require__(66739);
const viewer_shared_services_1 = __webpack_require__(8389);
const GodRaysManager_1 = __webpack_require__(79581);
const IPostProcessingEffectDefinitions_1 = __webpack_require__(63506);
const OutlineManager_1 = __webpack_require__(93654);
const SelectiveBloomManager_1 = __webpack_require__(26207);
const SSAARenderPass_1 = __webpack_require__(83982);
const SSAOEffect_1 = __webpack_require__(85120);
const HBAOEffect_1 = __webpack_require__(58140);
const gl_matrix_1 = __webpack_require__(61961);
class PostProcessingManager {
    // #endregion Properties (22)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (22)
        this._converter = viewer_shared_services_1.Converter.instance;
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._systemInfo = viewer_shared_services_1.SystemInfo.instance;
        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;
        this._antiAliasingTechnique = IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SMAA;
        this._antiAliasingTechniqueMobile = IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.FXAA;
        this._currentCameraId = '';
        this._effectDefinitions = [];
        this._effects = [];
        this._enablePostProcessingOnMobile = true;
        this._godRaysManagers = {};
        this._manualPostProcessing = false;
        this._outlineManagers = {};
        this._sceneExtents = 0;
        this._selectiveBloomManagers = {};
        this._suspendEffectPassUpdate = false;
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => {
            const viewerEvent = e;
            if (viewerEvent.viewportId === this._renderingEngine.id) {
                this._sceneExtents = gl_matrix_1.vec3.distance(viewerEvent.boundingBox.min, viewerEvent.boundingBox.max);
                this.changeEffectPass();
            }
        });
        // const token = this._uuidGenerator.create();
        // this._effectDefinitions.push({
        //     token,
        //     definition: {
        //         type: POST_PROCESSING_EFFECT_TYPE.SSAO,
        //         properties: this.getDefaultEffectProperties(POST_PROCESSING_EFFECT_TYPE.SSAO)
        //     }
        // });
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (15)
    get antiAliasingTechnique() {
        return this._antiAliasingTechnique;
    }
    set antiAliasingTechnique(value) {
        this._antiAliasingTechnique = value;
        this.changeEffectPass();
    }
    get antiAliasingTechniqueMobile() {
        return this._antiAliasingTechniqueMobile;
    }
    set antiAliasingTechniqueMobile(value) {
        this._antiAliasingTechniqueMobile = value;
        // we don't allow SSAA on mobile devices anymore as it is too slow
        if (this._antiAliasingTechniqueMobile === IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SSAA)
            this._antiAliasingTechniqueMobile = IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SMAA;
        this.changeEffectPass();
    }
    get effectComposer() {
        return this._composer;
    }
    get effects() {
        return this._effects;
    }
    get enablePostProcessingOnMobile() {
        return this._enablePostProcessingOnMobile;
    }
    set enablePostProcessingOnMobile(value) {
        this._enablePostProcessingOnMobile = value;
    }
    get godRaysManagers() {
        return this._godRaysManagers;
    }
    get manualPostProcessing() {
        return this._manualPostProcessing;
    }
    set manualPostProcessing(value) {
        this._manualPostProcessing = value;
        if (this._composer && this._manualPostProcessing === true)
            this._composer.removeAllPasses();
    }
    get outlineManagers() {
        return this._outlineManagers;
    }
    get selectiveBloomManagers() {
        return this._selectiveBloomManagers;
    }
    get ssaaSampleLevel() {
        return this._ssaaRenderPass ? this._ssaaRenderPass.sampleLevel : 2;
    }
    set ssaaSampleLevel(value) {
        if (this._ssaaRenderPass)
            this._ssaaRenderPass.sampleLevel = value;
    }
    // #endregion Public Getters And Setters (15)
    // #region Public Methods (13)
    addEffect(definition, t) {
        const token = t || this._uuidGenerator.create();
        this._effectDefinitions.push({ token, definition });
        switch (definition.type) {
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GOD_RAYS:
                if (!this._godRaysManagers[token])
                    this._godRaysManagers[token] = new GodRaysManager_1.GodRaysManager(this._renderingEngine);
                break;
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.OUTLINE:
                if (!this._outlineManagers[token])
                    this._outlineManagers[token] = new OutlineManager_1.OutlineManager(this._renderingEngine);
                break;
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SELECTIVE_BLOOM:
                if (!this._selectiveBloomManagers[token])
                    this._selectiveBloomManagers[token] = new SelectiveBloomManager_1.SelectiveBloomManager(this._renderingEngine);
                break;
            default:
        }
        this.changeEffectPass();
        return token;
    }
    applySettings(settingsEngine) {
        this._suspendEffectPassUpdate = true;
        this.antiAliasingTechnique = settingsEngine.settings.postprocessing.antiAliasingTechnique;
        this.antiAliasingTechniqueMobile = settingsEngine.settings.postprocessing.antiAliasingTechniqueMobile;
        // we don't allow SSAA on mobile devices anymore as it is too slow
        if (this._antiAliasingTechniqueMobile === IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SSAA)
            this._antiAliasingTechniqueMobile = IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SMAA;
        this.enablePostProcessingOnMobile = settingsEngine.settings.postprocessing.enablePostProcessingOnMobile;
        this.ssaaSampleLevel = settingsEngine.settings.postprocessing.ssaaSampleLevel;
        this._effectDefinitions = [];
        const effects = settingsEngine.settings.postprocessing.effects;
        for (let i = 0; i < effects.length; i++) {
            const token = this._uuidGenerator.create();
            this._effectDefinitions.push({
                token,
                definition: {
                    type: effects[i].type,
                    properties: effects[i].properties
                }
            });
        }
        this._suspendEffectPassUpdate = false;
        this.changeEffectPass();
    }
    changeEffectPass() {
        if (!this._composer)
            return;
        if (this._suspendEffectPassUpdate === true)
            return;
        if (this._systemInfo.isMobile === true && this._enablePostProcessingOnMobile === false)
            return;
        if (this._manualPostProcessing)
            return;
        for (let i = 0; i < this._composer.passes.length; i++)
            this._composer.passes[i].dispose();
        this._composer.removeAllPasses();
        const antiAliasingTechnique = this._systemInfo.isMobile === true ? this._antiAliasingTechniqueMobile : this._antiAliasingTechnique;
        if (antiAliasingTechnique === IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SSAA) {
            this.addPassToEffectComposer(this._ssaaRenderPass);
        }
        else {
            this.addPassToEffectComposer(this._renderPass);
        }
        // remove the effects where the tokens are not in the effectDefinitions
        this._effects.forEach(e => e.effect.dispose());
        this._effects = [];
        for (let i = 0; i < this._effectDefinitions.length; i++) {
            switch (this._effectDefinitions[i].definition.type) {
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.BLOOM:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.BloomEffect({
                                blendFunction: properties.blendFunction,
                                luminanceThreshold: properties.luminanceThreshold,
                                luminanceSmoothing: properties.luminanceSmoothing,
                                mipmapBlur: properties.mipmapBlur,
                                intensity: properties.intensity,
                                kernelSize: properties.kernelSize
                            })
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.CHROMATIC_ABERRATION:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        const offsetArray = properties.offset !== undefined ? Array.isArray(properties.offset) ? properties.offset : [properties.offset.x, properties.offset.y] : undefined;
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.ChromaticAberrationEffect({
                                blendFunction: properties.blendFunction,
                                offset: offsetArray ? new THREE.Vector2(...offsetArray) : undefined,
                                radialModulation: properties.radialModulation !== undefined ? properties.radialModulation : false,
                                modulationOffset: properties.modulationOffset !== undefined ? properties.modulationOffset : 0.15
                            })
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DEPTH_OF_FIELD:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        const depthOfFieldEffect = new postprocessing_1.DepthOfFieldEffect(this._renderingEngine.camera, {
                            blendFunction: properties.blendFunction,
                            focusDistance: properties.focusDistance !== undefined ? properties.focusDistance : 0,
                            focusRange: properties.focusRange !== undefined ? properties.focusRange : 0.01,
                            bokehScale: properties.bokehScale !== undefined ? properties.bokehScale : 5,
                            resolutionScale: 1
                        });
                        depthOfFieldEffect.resolution.height = 1080;
                        depthOfFieldEffect.blurPass.kernelSize = postprocessing_1.KernelSize.HUGE;
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: depthOfFieldEffect
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DOT_SCREEN:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.DotScreenEffect({
                                blendFunction: properties.blendFunction,
                                scale: properties.scale,
                                angle: properties.angle
                            })
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GOD_RAYS:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        const godRaysEffect = new postprocessing_1.GodRaysEffect(this._renderingEngine.camera, new THREE.Mesh(), {
                            blendFunction: properties.blendFunction,
                            density: properties.density,
                            decay: properties.decay,
                            weight: properties.weight,
                            exposure: properties.exposure,
                            clampMax: properties.clampMax,
                            kernelSize: properties.kernelSize,
                            blur: properties.blur
                        });
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: godRaysEffect
                        });
                        this._godRaysManagers[this._effectDefinitions[i].token].setEffect(godRaysEffect);
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GRID:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.GridEffect({
                                blendFunction: properties.blendFunction !== undefined ? properties.blendFunction : postprocessing_1.BlendFunction.MULTIPLY,
                                scale: properties.scale
                            })
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HBAO:
                    {
                        // we currently do not support devices with WebGL 1: https://shapediver.atlassian.net/browse/SS-7069
                        if (this._renderingEngine.renderer.capabilities.isWebGL2 === false)
                            break;
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        // we adjust the scene size slightly to make the factor fit our requirements
                        // with this adjusted factor, a distance value of 1 fits well as a default
                        const sceneSizeFactor = this._sceneExtents / 10.0;
                        const hbaoEffect = new HBAOEffect_1.HBAOEffect(this._composer, this._renderingEngine.camera, this._renderingEngine.scene, {
                            resolutionScale: properties.resolutionScale !== undefined ? properties.resolutionScale : 1,
                            spp: properties.spp !== undefined ? properties.spp : 8,
                            distance: properties.distance !== undefined ? properties.distance * sceneSizeFactor : sceneSizeFactor,
                            distancePower: properties.distanceIntensity !== undefined ? properties.distanceIntensity : 1,
                            power: properties.intensity !== undefined ? properties.intensity : 2.5,
                            bias: properties.bias !== undefined ? properties.bias : 10,
                            thickness: properties.thickness !== undefined ? properties.thickness : 0.5,
                            color: properties.color !== undefined ? new THREE.Color(this._converter.toHexColor(properties.color).substring(0, 7)) : new THREE.Color('black'),
                            iterations: properties.iterations !== undefined ? properties.iterations : 1,
                            radius: properties.radius !== undefined ? properties.radius : 15,
                            rings: properties.rings !== undefined ? properties.rings : 4,
                            lumaPhi: properties.lumaPhi !== undefined ? properties.lumaPhi : 10,
                            depthPhi: properties.depthPhi !== undefined ? properties.depthPhi : 2,
                            normalPhi: properties.normalPhi !== undefined ? properties.normalPhi : 3.25,
                            samples: properties.samples !== undefined ? properties.samples : 16
                        });
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: hbaoEffect
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HUE_SATURATION:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.HueSaturationEffect({
                                blendFunction: properties.blendFunction,
                                hue: properties.hue,
                                saturation: properties.saturation
                            })
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.NOISE:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.NoiseEffect({
                                blendFunction: properties.blendFunction,
                                premultiply: properties.premultiply
                            })
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.OUTLINE:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        const outlineEffect = new postprocessing_1.OutlineEffect(this._renderingEngine.scene, this._renderingEngine.camera, {
                            blendFunction: properties.blendFunction !== undefined ? properties.blendFunction : postprocessing_1.BlendFunction.SCREEN,
                            edgeStrength: properties.edgeStrength,
                            pulseSpeed: properties.pulseSpeed,
                            visibleEdgeColor: new THREE.Color(this._converter.toHexColor(properties.visibleEdgeColor).substring(0, 7)),
                            hiddenEdgeColor: new THREE.Color(this._converter.toHexColor(properties.hiddenEdgeColor).substring(0, 7)),
                            kernelSize: properties.kernelSize,
                            blur: properties.blur,
                            xRay: properties.xRay,
                            multisampling: properties.multisampling
                        });
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: outlineEffect
                        });
                        this._outlineManagers[this._effectDefinitions[i].token].setEffect(outlineEffect);
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.PIXELATION:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.PixelationEffect(properties.granularity)
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SSAO:
                    {
                        // we currently do not support devices with WebGL 1: https://shapediver.atlassian.net/browse/SS-7069
                        if (this._renderingEngine.renderer.capabilities.isWebGL2 === false)
                            break;
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        // we adjust the scene size slightly to make the factor fit our requirements
                        // with this adjusted factor, a distance value of 1 fits well as a default
                        const sceneSizeFactor = this._sceneExtents / 50.0;
                        const ssaoEffect = new SSAOEffect_1.SSAOEffect(this._composer, this._renderingEngine.camera, this._renderingEngine.scene, {
                            resolutionScale: properties.resolutionScale !== undefined ? properties.resolutionScale : 1,
                            spp: properties.spp !== undefined ? properties.spp : 8,
                            distance: properties.distance !== undefined ? properties.distance * sceneSizeFactor : sceneSizeFactor,
                            distancePower: properties.distanceIntensity !== undefined ? properties.distanceIntensity : 1,
                            power: properties.intensity !== undefined ? properties.intensity : 2.5,
                            color: properties.color !== undefined ? new THREE.Color(this._converter.toHexColor(properties.color).substring(0, 7)) : new THREE.Color('black'),
                            iterations: properties.iterations !== undefined ? properties.iterations : 1,
                            radius: properties.radius !== undefined ? properties.radius : 15,
                            rings: properties.rings !== undefined ? properties.rings : 4,
                            lumaPhi: properties.lumaPhi !== undefined ? properties.lumaPhi : 10,
                            depthPhi: properties.depthPhi !== undefined ? properties.depthPhi : 2,
                            normalPhi: properties.normalPhi !== undefined ? properties.normalPhi : 3.25,
                            samples: properties.samples !== undefined ? properties.samples : 16
                        });
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: ssaoEffect
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SCANLINE:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.ScanlineEffect({
                                blendFunction: properties.blendFunction,
                                density: properties.density
                            })
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SELECTIVE_BLOOM:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        const selectiveBloomEffect = new postprocessing_1.SelectiveBloomEffect(this._renderingEngine.scene, this._renderingEngine.camera, {
                            blendFunction: properties.blendFunction,
                            mipmapBlur: properties.mipmapBlur,
                            luminanceThreshold: properties.luminanceThreshold,
                            luminanceSmoothing: properties.luminanceSmoothing,
                            intensity: properties.intensity,
                            kernelSize: properties.kernelSize
                        });
                        selectiveBloomEffect.ignoreBackground = properties.ignoreBackground !== undefined ? properties.ignoreBackground : true;
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: selectiveBloomEffect
                        });
                        this._selectiveBloomManagers[this._effectDefinitions[i].token].setEffect(selectiveBloomEffect);
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SEPIA:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.SepiaEffect({
                                blendFunction: properties.blendFunction
                            })
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.TILT_SHIFT:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.TiltShiftEffect({
                                blendFunction: properties.blendFunction,
                                offset: properties.offset,
                                rotation: properties.rotation,
                                focusArea: properties.focusArea,
                                feather: properties.feather,
                                kernelSize: properties.kernelSize
                            })
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.VIGNETTE:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.VignetteEffect({
                                blendFunction: properties.blendFunction,
                                technique: properties.technique,
                                offset: properties.offset,
                                darkness: properties.darkness,
                            })
                        });
                    }
                    break;
                default:
            }
        }
        // sort effects by order in effectDefinitions
        this._effects.sort((a, b) => this._effectDefinitions.indexOf(this._effectDefinitions.find(e => e.token === a.token)) - this._effectDefinitions.indexOf(this._effectDefinitions.find(e => e.token === b.token)));
        const effectArray = this._effects.map(v => v.effect);
        if (antiAliasingTechnique === IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.FXAA) {
            effectArray.unshift(this._fxaaEffect);
        }
        else if (antiAliasingTechnique === IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SMAA) {
            effectArray.unshift(this._smaaEffect);
        }
        this._effectPass = new postprocessing_1.EffectPass(this._renderingEngine.camera, ...this._effects.map(v => v.effect));
        this.addPassToEffectComposer(this._effectPass);
        // for the AO effects we need to add a separate AA pass at the end that anti-aliases the AO effect
        if (this._effectDefinitions.find(e => e.definition.type === IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HBAO || e.definition.type === IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SSAO)) {
            // respect the AA choice if one of the effects was selected, use SMAA otherwise
            this.addPassToEffectComposer(new postprocessing_1.EffectPass(this._renderingEngine.camera, antiAliasingTechnique === IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.FXAA ? this._fxaaEffect : this._smaaEffect));
        }
    }
    getDefaultEffectProperties(type) {
        switch (type) {
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.BLOOM:
                return {
                    blendFunction: postprocessing_1.BlendFunction.ADD,
                    intensity: 1.0,
                    kernelSize: postprocessing_1.KernelSize.LARGE,
                    luminanceSmoothing: 0.025,
                    luminanceThreshold: 0.9,
                    mipmapBlur: false,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.CHROMATIC_ABERRATION:
                return {
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                    modulationOffset: 0.15,
                    offset: { x: 0.001, y: 0.0005 },
                    radialModulation: false,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DEPTH_OF_FIELD:
                return {
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                    bokehScale: 5.0,
                    focusDistance: 0.0,
                    focusRange: 0.01,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DOT_SCREEN:
                return {
                    angle: 1.57,
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                    scale: 1.0,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GOD_RAYS:
                return {
                    blendFunction: postprocessing_1.BlendFunction.SCREEN,
                    blur: true,
                    clampMax: 1.0,
                    decay: 0.9,
                    density: 0.96,
                    exposure: 0.6,
                    kernelSize: postprocessing_1.KernelSize.SMALL,
                    weight: 0.4,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GRID:
                return {
                    blendFunction: postprocessing_1.BlendFunction.MULTIPLY,
                    scale: 1.0,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HBAO:
                return {
                    resolutionScale: 1,
                    spp: 8,
                    distance: 1,
                    distanceIntensity: 1,
                    intensity: 2.5,
                    color: '#000000',
                    bias: 10,
                    thickness: 0.5,
                    iterations: 1,
                    radius: 15,
                    rings: 4,
                    lumaPhi: 10,
                    depthPhi: 2,
                    normalPhi: 3.25,
                    samples: 16,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HUE_SATURATION:
                return {
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                    hue: 0.0,
                    saturation: 0.0,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.NOISE:
                return {
                    blendFunction: postprocessing_1.BlendFunction.SCREEN,
                    premultiply: false,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.OUTLINE:
                return {
                    blendFunction: postprocessing_1.BlendFunction.SCREEN,
                    blur: false,
                    edgeStrength: 1.0,
                    hiddenEdgeColor: '#22090a',
                    kernelSize: postprocessing_1.KernelSize.VERY_SMALL,
                    multisampling: 0,
                    pulseSpeed: 0.0,
                    resolution: 480,
                    visibleEdgeColor: '#ffffff',
                    xRay: true,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.PIXELATION:
                return {
                    granularity: 30.0,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SSAO:
                return {
                    resolutionScale: 1,
                    spp: 8,
                    distance: 1,
                    distanceIntensity: 1,
                    intensity: 2.5,
                    color: '#000000',
                    iterations: 1,
                    radius: 15,
                    rings: 4,
                    lumaPhi: 10,
                    depthPhi: 2,
                    normalPhi: 3.25,
                    samples: 16,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SCANLINE:
                return {
                    blendFunction: postprocessing_1.BlendFunction.OVERLAY,
                    density: 1.25,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SELECTIVE_BLOOM:
                return {
                    blendFunction: postprocessing_1.BlendFunction.ADD,
                    intensity: 1.0,
                    kernelSize: postprocessing_1.KernelSize.LARGE,
                    luminanceSmoothing: 0.025,
                    luminanceThreshold: 0.9,
                    mipmapBlur: false,
                    ignoreBackground: true,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SEPIA:
                return {
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.TILT_SHIFT:
                return {
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                    feather: 0.3,
                    focusArea: 0.4,
                    kernelSize: postprocessing_1.KernelSize.MEDIUM,
                    offset: 0.0,
                    rotation: 0.0,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.VIGNETTE:
                return {
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                    darkness: 0.5,
                    offset: 0.5,
                    technique: postprocessing_1.VignetteTechnique.DEFAULT,
                };
            default:
                return {};
        }
    }
    getEffect(token) {
        return this._effects.find(e => e.token === token).effect;
    }
    getEffectTokens() {
        return Object.assign({}, ...this._effectDefinitions.map((e) => ({ [e.token]: e.definition.type })));
    }
    getPostProcessingEffectsArray() {
        const effects = [];
        for (let i = 0; i < this._effectDefinitions.length; i++) {
            switch (this._effectDefinitions[i].definition.type) {
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.BLOOM:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.BLOOM,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                luminanceThreshold: properties.luminanceThreshold,
                                luminanceSmoothing: properties.luminanceSmoothing,
                                mipmapBlur: properties.mipmapBlur,
                                intensity: properties.intensity,
                                kernelSize: properties.kernelSize
                            }
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.CHROMATIC_ABERRATION:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.CHROMATIC_ABERRATION,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                offset: properties.offset ? Array.isArray(properties.offset) ? { x: properties.offset[0], y: properties.offset[1] } : properties.offset : undefined,
                                radialModulation: properties.radialModulation,
                                modulationOffset: properties.modulationOffset
                            }
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DEPTH_OF_FIELD:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DEPTH_OF_FIELD,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                focusDistance: properties.focusDistance,
                                focusRange: properties.focusRange,
                                bokehScale: properties.bokehScale
                            }
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DOT_SCREEN:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DOT_SCREEN,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                scale: properties.scale,
                                angle: properties.angle
                            }
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GRID:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GRID,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                scale: properties.scale
                            }
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HBAO:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HBAO,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                resolutionScale: properties.resolutionScale,
                                spp: properties.spp,
                                distance: properties.distance,
                                distanceIntensity: properties.distanceIntensity,
                                intensity: properties.intensity,
                                bias: properties.bias,
                                thickness: properties.thickness,
                                color: properties.color !== undefined ? this._converter.toHexColor(properties.color) : undefined,
                                iterations: properties.iterations,
                                radius: properties.radius,
                                rings: properties.rings,
                                lumaPhi: properties.lumaPhi,
                                depthPhi: properties.depthPhi,
                                normalPhi: properties.normalPhi,
                                samples: properties.samples
                            }
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HUE_SATURATION:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HUE_SATURATION,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                hue: properties.hue,
                                saturation: properties.saturation
                            }
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.NOISE:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.NOISE,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                premultiply: properties.premultiply
                            }
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.PIXELATION:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.PIXELATION,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                granularity: properties.granularity
                            }
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SSAO:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SSAO,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                resolutionScale: properties.resolutionScale,
                                spp: properties.spp,
                                distance: properties.distance,
                                distanceIntensity: properties.distanceIntensity,
                                intensity: properties.intensity,
                                color: properties.color !== undefined ? this._converter.toHexColor(properties.color) : undefined,
                                iterations: properties.iterations,
                                radius: properties.radius,
                                rings: properties.rings,
                                lumaPhi: properties.lumaPhi,
                                depthPhi: properties.depthPhi,
                                normalPhi: properties.normalPhi,
                                samples: properties.samples
                            }
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SCANLINE:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SCANLINE,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                density: properties.density
                            }
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SEPIA:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SEPIA,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction
                            }
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.TILT_SHIFT:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.TILT_SHIFT,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                offset: properties.offset,
                                rotation: properties.rotation,
                                focusArea: properties.focusArea,
                                feather: properties.feather,
                                kernelSize: properties.kernelSize
                            }
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.VIGNETTE:
                    {
                        const definition = this._effectDefinitions[i].definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.VIGNETTE,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                technique: properties.technique,
                                offset: properties.offset,
                                darkness: properties.darkness,
                            }
                        });
                    }
                    break;
                default:
            }
        }
        return effects;
    }
    init() {
        postprocessing_1.OverrideMaterialManager.workaroundEnabled = true;
        const initComposer = () => {
            this._composer = new postprocessing_1.EffectComposer(this._renderingEngine.renderer);
            // EffectComposer disables autoClear, we enable/disable this in the postprocessing render loop
            this._renderingEngine.renderer.autoClear = true;
            // create anti-aliasing effects and passes
            this._fxaaEffect = new postprocessing_1.FXAAEffect();
            this._smaaEffect = new postprocessing_1.SMAAEffect({ preset: postprocessing_1.SMAAPreset.ULTRA });
            this._renderPass = new postprocessing_1.RenderPass(this._renderingEngine.scene, this._renderingEngine.camera);
            this._ssaaRenderPass = new SSAARenderPass_1.SSAARenderPass(this._renderingEngine.scene, this._renderingEngine.camera);
        };
        if (this._sceneExtents === 0) {
            const token = this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => __awaiter(this, void 0, void 0, function* () {
                const viewerEvent = e;
                if (viewerEvent.viewportId === this._renderingEngine.id) {
                    if (gl_matrix_1.vec3.distance(viewerEvent.boundingBox.min, viewerEvent.boundingBox.max) > 0) {
                        initComposer();
                        this.changeEffectPass();
                        this._eventEngine.removeListener(token);
                    }
                }
            }));
        }
        else {
            initComposer();
        }
    }
    removeEffect(token) {
        const effectToRemove = this._effectDefinitions.find(e => e.token === token);
        if (effectToRemove)
            this._effectDefinitions.splice(this._effectDefinitions.indexOf(effectToRemove), 1);
        this.changeEffectPass();
        return true;
    }
    render(deltaTime, camera) {
        if (!this._composer)
            return;
        const cameraId = `${camera.id}_${camera.type}${(camera.type === 'PerspectiveCamera' ? '' : '_' + camera.up.toArray().toString())}`;
        if (cameraId !== this._currentCameraId) {
            this._currentCameraId = cameraId;
            this.changeEffectPass();
        }
        const currentClearColor = this._renderingEngine.renderer.getClearColor(new THREE.Color());
        const convertedClearColor = currentClearColor.clone().convertSRGBToLinear();
        this._renderingEngine.renderer.setClearColor(convertedClearColor);
        this._renderingEngine.renderer.setClearAlpha(this._renderingEngine.clearAlpha);
        this._renderingEngine.renderer.autoClear = false;
        this._composer.setMainCamera(camera);
        this._composer.render();
        this._renderingEngine.renderer.autoClear = true;
        this._renderingEngine.renderer.setClearColor(currentClearColor);
    }
    resize(width, height) {
        var _a;
        if (!this._composer)
            return;
        this.effects.forEach(e => {
            if (e.effect.setSize)
                e.effect.setSize(width, height);
        });
        this._renderPass.setSize(width, height);
        this._ssaaRenderPass.setSize(width, height);
        (_a = this._effectPass) === null || _a === void 0 ? void 0 : _a.setSize(width, height);
        this._composer.setSize(width, height);
    }
    saveSettings(settingsEngine) {
        settingsEngine.settings.postprocessing.antiAliasingTechnique = this.antiAliasingTechnique;
        settingsEngine.settings.postprocessing.antiAliasingTechniqueMobile = this.antiAliasingTechniqueMobile;
        settingsEngine.settings.postprocessing.enablePostProcessingOnMobile = this.enablePostProcessingOnMobile;
        settingsEngine.settings.postprocessing.ssaaSampleLevel = this.ssaaSampleLevel;
        const effects = this.getPostProcessingEffectsArray();
        // delete the tokens as we don't want to save them
        effects.forEach(e => delete e.token);
        settingsEngine.settings.postprocessing.effects = effects;
    }
    updateEffect(token, definition) {
        const effectDefinition = this._effectDefinitions.find(e => e.token === token);
        if (!effectDefinition)
            return;
        this.removeEffect(token);
        this.addEffect(definition, token);
    }
    // #endregion Public Methods (13)
    // #region Private Methods (1)
    addPassToEffectComposer(pass) {
        if (this._composer) {
            try {
                this._composer.addPass(pass);
            }
            catch (e) {
                // in this case a WebGL error is thrown, when the WebGL context is lost
                // as we already throw an error in the rendering engine, we can ignore this error here
                // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getContextAttributes
            }
        }
    }
}
exports.PostProcessingManager = PostProcessingManager;
//# sourceMappingURL=PostProcessingManager.js.map

/***/ }),

/***/ 1042:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenderingManager = void 0;
const Stats = __importStar(__webpack_require__(96571));
const THREE = __importStar(__webpack_require__(39437));
const viewer_rendering_engine_animation_engine_1 = __webpack_require__(46560);
const viewer_rendering_engine_animation_frame_engine_1 = __webpack_require__(98476);
const viewer_rendering_engine_rendering_engine_1 = __webpack_require__(45850);
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const viewer_rendering_engine_camera_engine_1 = __webpack_require__(17989);
const viewer_shared_services_1 = __webpack_require__(8389);
class RenderingManager {
    // #endregion Properties (30)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (30)
        this._animationEngine = viewer_rendering_engine_animation_engine_1.AnimationEngine.instance;
        this._animationFrameEngine = viewer_rendering_engine_animation_frame_engine_1.AnimationFrameEngine.instance;
        this._converter = viewer_shared_services_1.Converter.instance;
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._logger = viewer_shared_services_1.Logger.instance;
        this._systemInfo = viewer_shared_services_1.SystemInfo.instance;
        this._tree = viewer_shared_node_tree_1.Tree.instance;
        this._activeRendering = true;
        this._cameraChanged = false;
        this._continuousRendering = false;
        this._continuousShadowMapUpdate = false;
        this._height = 0;
        this._hidden = true;
        this._hiddenCamera = new THREE.PerspectiveCamera();
        this._hiddenRenderTarget = new THREE.WebGLRenderTarget();
        this._hideLogo = false;
        this._lastSize = {
            adjustedWidth: 0,
            adjustedHeight: 0,
            width: 0,
            height: 0
        };
        this._lightSizeUVEnd = 0.15;
        this._lightSizeUVStart = 0.025;
        this._maxTextureUnits = 0;
        this._minimalRendering = false;
        this._noWebGL = false;
        this._runningAnimation = false;
        this._sizeChanged = false;
        this._softShadowRenderingActive = false;
        this._softShadowRenderingDurationActive = 0;
        this._softShadowRenderingTimeout = null;
        this._usingSwiftShader = false;
        this._width = 0;
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (6)
    get continuousRendering() {
        return this._continuousRendering;
    }
    set continuousRendering(value) {
        this._continuousRendering = value;
    }
    get continuousShadowMapUpdate() {
        return this._continuousShadowMapUpdate;
    }
    set continuousShadowMapUpdate(value) {
        this._continuousShadowMapUpdate = value;
    }
    get minimalRendering() {
        return this._minimalRendering;
    }
    get usingSwiftShader() {
        return this._usingSwiftShader;
    }
    // #endregion Public Getters And Setters (6)
    // #region Public Methods (10)
    addLogo(canvas, branding) {
        var _a, _b;
        const logoDivElement = document.createElement('div');
        logoDivElement.style.backgroundColor = branding.backgroundColor;
        logoDivElement.classList.add('sdv-logo-container');
        (_a = canvas.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(logoDivElement, (_b = canvas.parentElement) === null || _b === void 0 ? void 0 : _b.firstChild);
        if (branding.logo) {
            const img = new Image();
            img.classList.add('sdv-logo');
            img.src = branding.logo;
            logoDivElement.appendChild(img);
        }
        return logoDivElement;
    }
    addSpinner(canvas, branding) {
        var _a, _b;
        const spinnerDivElement = document.createElement('div');
        spinnerDivElement.classList.add('sdv-spinner-container');
        spinnerDivElement.style.visibility = 'hidden';
        (_a = canvas.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(spinnerDivElement, (_b = canvas.parentElement) === null || _b === void 0 ? void 0 : _b.firstChild);
        if (branding.busyModeSpinner) {
            const img = new Image();
            img.src = branding.busyModeSpinner;
            img.classList.add('sdv-spinner');
            img.classList.add('sdv-spinner-' + branding.spinnerPositioning.replace('_', '-').toLowerCase());
            spinnerDivElement.appendChild(img);
        }
        return spinnerDivElement;
    }
    createRenderer(canvas) {
        const renderingProperties = {
            alpha: true,
            depth: true,
            antialias: true,
            preserveDrawingBuffer: true,
            stencil: true,
            premultipliedAlpha: true,
            canvas
        };
        const renderer = new THREE.WebGLRenderer(renderingProperties);
        renderer.setPixelRatio(window.devicePixelRatio);
        const context = renderer.getContext();
        if (renderer.extensions.has('WEBGL_debug_renderer_info')) {
            const debugInfo = renderer.extensions.get('WEBGL_debug_renderer_info');
            // const vendor = context.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
            const rendererInfo = context.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
            if (rendererInfo === 'Google SwiftShader') {
                this._usingSwiftShader = true;
                this._logger.warn('RenderingLogic.createWebGLContext: The current device is using Google SwiftShader, a CPU-based renderer. To achieve better rendering results, please enable GPU-rendering in your settings.');
            }
        }
        if (!renderer.extensions.has('EXT_shader_texture_lod'))
            this._minimalRendering = true;
        renderer.useLegacyLights = true;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.NoToneMapping;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.needsUpdate = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowMap.autoUpdate = false;
        renderer.localClippingEnabled = true;
        renderer.setSize(canvas.width, canvas.height);
        renderer.setClearColor(new THREE.Color('#ffffff'), 1);
        this._maxTextureUnits = renderer.getContext().getParameter(renderer.getContext().MAX_TEXTURE_IMAGE_UNITS);
        return renderer;
    }
    evaluateTextureUnitCount(value) {
        if (value > this._maxTextureUnits) {
            this._logger.warn('RenderingManager.evaluateTextureUnitCount: Maximum number of texture units exceeded. Disabling shadows.');
            this._renderingEngine.lightLoader.forceDisabledShadows = true;
            this._renderingEngine.update('RenderingManager.evaluateTextureUnitCount');
        }
        else {
            this._renderingEngine.lightLoader.forceDisabledShadows = false;
        }
    }
    getScreenshot(type = 'image/png', encoderOptions = 1) {
        return this._renderingEngine.renderer.domElement.toDataURL(type, encoderOptions);
    }
    init() {
        try {
            this._renderingEngine.materialLoader.updateSoftShadow(this._lightSizeUVEnd, 1.0);
            this._renderingEngine.renderer.shadowMap.type = THREE.PCFShadowMap;
            this._renderingEngine.renderer.shadowMap.needsUpdate = true;
            this._renderingEngine.materialLoader.updateMaterials();
            this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_START, (e) => {
                const viewerEvent = e;
                if (viewerEvent.viewportId === this._renderingEngine.id)
                    this.startRendering();
            });
            this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_END, (e) => {
                const viewerEvent = e;
                if (viewerEvent.viewportId === this._renderingEngine.id)
                    this.stopRendering();
            });
            window.onresize = () => { this.render(); };
            this._renderingEngine.canvas.onresize = () => { this.render(); };
            this._renderingEngine.canvas.parentElement.onresize = () => { this.render(); };
            const stats1 = new Stats.default();
            stats1.showPanel(0); // Panel 0 = fps
            stats1.dom.style.cssText = 'position:absolute;top:0px;left:0px;display:none;';
            this._renderingEngine.canvas.parentElement.appendChild(stats1.dom);
            const stats2 = new Stats.default();
            stats2.showPanel(1); // Panel 1 = ms
            stats2.dom.style.cssText = 'position:absolute;top:0px;left:80px;display:none;';
            this._renderingEngine.canvas.parentElement.appendChild(stats2.dom);
            const stats3 = new Stats.default();
            stats3.showPanel(2); // Panel 2 = ms
            stats3.dom.style.cssText = 'position:absolute;top:0px;left:160px;display:none;';
            this._renderingEngine.canvas.parentElement.appendChild(stats3.dom);
            this._stats = {
                stats: [stats1, stats2, stats3],
                begin: () => {
                    stats1.begin();
                    stats2.begin();
                    stats3.begin();
                },
                end: () => {
                    stats1.end();
                    stats2.end();
                    stats3.end();
                }
            };
        }
        catch (e) {
            this._noWebGL = true;
            throw e;
        }
    }
    render() {
        this.startAndStopRendering();
    }
    resize(width, height) {
        this._width = width, this._height = height;
        this._renderingEngine.materialLoader.assignPointSize(this._renderingEngine.pointSize);
    }
    /**
     * Must only be called once by the RenderingEngine!
     */
    start() {
        this._animationFrameEngine.addAnimationFrameCallback(this.animate.bind(this));
        this.startAndStopRendering();
    }
    updateShadowMap() {
        this._renderingEngine.renderer.shadowMap.needsUpdate = true;
    }
    // #endregion Public Methods (10)
    // #region Private Methods (14)
    activateBeautyRenderShaders() {
        this._renderingEngine.renderer.shadowMap.type = THREE.PCFShadowMap;
        this._renderingEngine.renderer.shadowMap.needsUpdate = true;
        this._renderingEngine.materialLoader.updateMaterials();
    }
    animate(time, deltaTime, runningAnimation) {
        // animation loop - part 1: initial discarding
        if (this._renderingEngine.closed || this._noWebGL)
            return;
        this._renderingEngine.evaluateFlagState();
        // update if needed
        if (this._renderingEngine.show === true && this._tree.root.version !== this._renderingEngine.sceneTreeManager.lastRootVersion) {
            this._renderingEngine.sceneTreeManager.updateSceneTree(this._tree.root);
            this.updateShadowMap();
            this._animationEngine.updateAnimationData();
            this.render();
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE_VIEWPORT.VIEWPORT_UPDATED, { viewportId: this._renderingEngine.id });
        }
        if (this._renderingEngine.preRenderingCallback)
            this._renderingEngine.preRenderingCallback(this._renderingEngine.renderer);
        if (runningAnimation !== this._runningAnimation)
            this.render();
        this._runningAnimation = runningAnimation;
        if (this._runningAnimation)
            this._renderingEngine.sceneTreeManager.updateNode(undefined, undefined, { transformationOnly: true });
        if (this._runningAnimation)
            this._renderingEngine.sceneTreeManager.updateMorphWeights();
        // get the current size
        const { width, height, adjustedWidth, adjustedHeight } = this.calculateSize();
        const aspect = width / height;
        this._sizeChanged = this._lastSize.adjustedHeight !== adjustedHeight || this._lastSize.adjustedWidth !== adjustedWidth || this._lastSize.height !== height || this._lastSize.width !== width;
        this._lastSize = { width, height, adjustedWidth, adjustedHeight };
        // animation loop - part 3: update the camera, if there are new movements, they will start / continue the rendering
        this._cameraChanged = this._renderingEngine.cameraEngine.camera ? this._renderingEngine.cameraManager.updateCamera(deltaTime, aspect) : false;
        // animation loop - part 4: evaluating state
        const states = this.evaluateRenderingState();
        // toggle the blurring
        this.toggleBusyMode(states.busyMode);
        // animation loop - part 5: the scene is not even shown
        if (states.showScene === false) {
            // toggle on logo
            this.toggleLogo(true);
            if (this._hidden === false)
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.VIEWPORT.VIEWPORT_HIDDEN, { viewportId: this._renderingEngine.id });
            this._hidden = true;
            return;
        }
        else {
            // we delay for one render call as some of the postprocessing effects have artefacts in the first call
            if (this._hideLogo === true && this._hidden === true) {
                this.toggleLogo(false);
                this._hideLogo = false;
                if (this._hidden === true)
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.VIEWPORT.VIEWPORT_VISIBLE, { viewportId: this._renderingEngine.id });
                this._hidden = false;
            }
            else {
                this._hideLogo = true;
                if (this._hidden === true)
                    this._renderingEngine.postProcessingManager.changeEffectPass();
            }
        }
        // animation loop - part 6: the scene is shown, but there is no active rendering happening
        if (states.rendering === false || this._renderingEngine.pause === true)
            return;
        // animation loop - part 7: there is actual rendering happening
        // do the things that have to be done for standard and beauty rendering in the same way
        this._stats.begin();
        this.showStatistics();
        // animation loop - part 8: calculate the current size
        const currentSize = new THREE.Vector2();
        this._renderingEngine.renderer.getSize(currentSize);
        if (!currentSize.equals(new THREE.Vector2(adjustedWidth, adjustedHeight))) {
            this._renderingEngine.renderer.setSize(adjustedWidth, adjustedHeight);
            this._renderingEngine.postProcessingManager.resize(adjustedWidth, adjustedHeight);
            this._renderingEngine.renderer.domElement.style.width = width + 'px';
            this._renderingEngine.renderer.domElement.style.height = height + 'px';
            this._renderingEngine.materialLoader.assignPointSize(this._renderingEngine.pointSize);
        }
        // animation loop - part 9: adjust the camera (the rendering state would be false if we didn't have a camera)
        const { camera, matrix } = this._renderingEngine.cameraManager.adjustCamera(aspect);
        // if a matrix is provided after a camera adjustment
        // that means that the turntable controls or the object controls are activated
        if (matrix) {
            for (let i = 0; i < this._tree.root.children.length; i++) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (!this._tree.root.children[i].sessionNode || this._tree.root.children[i].excludeViewports.includes(this._renderingEngine.id))
                    continue;
                const transform = this._tree.root.children[i].transformations.find(t => t.id === 'objectRotation');
                if (transform) {
                    transform.matrix = matrix;
                }
                else {
                    this._tree.root.children[i].addTransformation({
                        id: 'objectRotation',
                        matrix
                    });
                }
            }
            states.updateShadowMap = true;
            this._renderingEngine.sceneTreeManager.updateNode(undefined, undefined, { transformationOnly: true });
        }
        // animation loop - part 10: adjust the anchor elements
        this._renderingEngine.htmlElementAnchorLoader.adjustPositions(adjustedWidth / width, adjustedHeight / height);
        // animation loop - part 11: adjust some scene settings
        // enable / disable the shadow map
        const enabled = this._renderingEngine.renderer.shadowMap.enabled;
        this._renderingEngine.renderer.shadowMap.enabled = this._renderingEngine.usingSwiftShader || this._renderingEngine.type === viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.ATTRIBUTES ? false : this._renderingEngine.shadows;
        if (enabled !== this._renderingEngine.renderer.shadowMap.enabled)
            this._renderingEngine.materialLoader.updateMaterials();
        let threeJsLightObject, oldLightVisibility = true;
        // enable / disable lights
        if (this._renderingEngine.lights === false) {
            const ls = this._renderingEngine.lightEngine.lightScene;
            if (ls) {
                threeJsLightObject = ls.node.convertedObject[this._renderingEngine.id];
                if (threeJsLightObject) {
                    oldLightVisibility = threeJsLightObject.visible;
                    threeJsLightObject.visible = false;
                }
            }
        }
        // update shadowMap if need
        if (states.updateShadowMap && this._renderingEngine.renderer.shadowMap.enabled)
            this._renderingEngine.renderer.shadowMap.needsUpdate = true;
        // enable / disable the background
        this._renderingEngine.sceneTreeManager.scene.background = this._renderingEngine.environmentMapAsBackground ? this._renderingEngine.environmentMapLoader.environmentMap : null;
        // set the background color / alpha
        this._renderingEngine.renderer.setClearColor(new THREE.Color(this._converter.toThreeJsColorInput(this._renderingEngine.clearColor)), this._renderingEngine.clearAlpha);
        // check if we should render with post-processing
        const renderPostProcessing = (this._renderingEngine.postProcessingManager.effects.length > 0 || this._renderingEngine.postProcessingManager.manualPostProcessing) &&
            !(this._renderingEngine.postProcessingManager.enablePostProcessingOnMobile === false && this._systemInfo.isMobile === true);
        // animation loop - part 12: actual rendering separation
        if (states.softShadowRendering === true) {
            this.setShaderProperties();
            if (renderPostProcessing) {
                this._renderingEngine.postProcessingManager.render(deltaTime, camera);
            }
            else {
                this._renderingEngine.renderer.render(this._renderingEngine.sceneTreeManager.scene, camera);
            }
            // if the duration was long enough, disable the beauty rendering
            if (this._softShadowRenderingDurationActive >= this._renderingEngine.beautyRenderBlendingDuration) {
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.RENDERING.BEAUTY_RENDERING_FINISHED, { viewportId: this._renderingEngine.id });
                this.deactivateBeautyRenderShaders();
                this._activeRendering = false;
            }
            else {
                this._softShadowRenderingDurationActive += deltaTime;
            }
        }
        else {
            if (renderPostProcessing) {
                this._renderingEngine.postProcessingManager.render(deltaTime, camera);
            }
            else {
                this._renderingEngine.renderer.render(this._renderingEngine.sceneTreeManager.scene, camera);
            }
            // if the beauty rendering was active, disable it
            if (this._softShadowRenderingActive) {
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.RENDERING.BEAUTY_RENDERING_FINISHED, { viewportId: this._renderingEngine.id });
                this.deactivateBeautyRenderShaders();
                this._activeRendering = false;
            }
        }
        // reset the visibility of the threeJs light object
        if (threeJsLightObject)
            threeJsLightObject.visible = oldLightVisibility;
        if (this._renderingEngine.postRenderingCallback)
            this._renderingEngine.postRenderingCallback(this._renderingEngine.renderer, this._renderingEngine.scene, this._renderingEngine.camera);
        this._stats.end();
    }
    calculateSize() {
        let width = this._width, height = this._height;
        if (this._renderingEngine.automaticResizing) {
            width = this._renderingEngine.canvas.parentNode.clientWidth;
            height = this._renderingEngine.canvas.parentNode.clientHeight;
        }
        const aspect = width / height;
        let adjustedWidth = width, adjustedHeight = height;
        if (width > this._renderingEngine.maximumRenderingSize.width || height > this._renderingEngine.maximumRenderingSize.height) {
            if ((width - this._renderingEngine.maximumRenderingSize.width) / aspect > (height - this._renderingEngine.maximumRenderingSize.height)) {
                adjustedWidth = this._renderingEngine.maximumRenderingSize.width;
                adjustedHeight = this._renderingEngine.maximumRenderingSize.width / aspect;
            }
            else {
                adjustedWidth = this._renderingEngine.maximumRenderingSize.height * aspect;
                adjustedHeight = this._renderingEngine.maximumRenderingSize.height;
            }
        }
        return {
            width, adjustedWidth,
            height, adjustedHeight
        };
    }
    deactivateBeautyRenderShaders() {
        this._softShadowRenderingTimeout = null;
        this._softShadowRenderingActive = false;
        this._softShadowRenderingDurationActive = 0;
        this._renderingEngine.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this._renderingEngine.renderer.shadowMap.needsUpdate = true;
        this._renderingEngine.materialLoader.updateSoftShadow(this._lightSizeUVStart, 0.1);
        this._renderingEngine.materialLoader.updateMaterials();
    }
    evaluateRenderingState() {
        // If there is a camera to show the scene and the setting for it is set to true, we show the scene
        let showScene = false;
        if (this._renderingEngine.cameraEngine.camera && this._renderingEngine.show === true)
            showScene = true;
        // If we should render at all
        let rendering = false;
        if (this._activeRendering === true || this._cameraChanged === true || this._sizeChanged === true || this._runningAnimation === true || this._continuousRendering === true)
            rendering = true;
        let updateShadowMap = false;
        if (this._runningAnimation === true || this._continuousShadowMapUpdate === true)
            updateShadowMap = true;
        // special case, autorotation
        if (this._renderingEngine.cameraEngine.camera) {
            const camera = this._renderingEngine.cameraEngine.camera;
            if (camera.type === viewer_rendering_engine_camera_engine_1.CAMERA_TYPE.PERSPECTIVE) {
                const controls = camera.controls;
                if (controls.enableAutoRotation === true && controls.autoRotationSpeed !== 0)
                    return { showScene, rendering: true, updateShadowMap, busyMode: this._renderingEngine.busy, softShadowRendering: false };
            }
        }
        else {
            rendering = false;
        }
        // If the scene should be blurred
        let busyMode = false;
        if (this._renderingEngine.busy)
            busyMode = true;
        // If we should render in beauty mode
        let softShadowRendering = false;
        if (this._softShadowRenderingActive === true && busyMode === false && this._continuousRendering === false &&
            (this._renderingEngine.shadows || !this._systemInfo.isIOS) &&
            this._renderingEngine.usingSwiftShader === false && this._runningAnimation === false && this._renderingEngine.type !== viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.ATTRIBUTES)
            softShadowRendering = true;
        return { showScene, rendering, updateShadowMap, busyMode, softShadowRendering };
    }
    setShaderProperties() {
        if (this._renderingEngine.softShadows === false) {
            this._renderingEngine.materialLoader.updateSoftShadow(this._lightSizeUVStart, 0);
            return 0;
        }
        const deltaTime = Math.min(this._softShadowRenderingDurationActive, this._renderingEngine.beautyRenderBlendingDuration);
        const percentage = deltaTime / this._renderingEngine.beautyRenderBlendingDuration;
        if (percentage < 0.25) {
            const percentageMapped = percentage / 0.25;
            this._renderingEngine.materialLoader.updateSoftShadow(this._lightSizeUVStart, percentageMapped);
        }
        else {
            const percentageMapped = (percentage - 0.25) / (1 - 0.25);
            // this._lightSizeUVStart -> this._lightSizeUVEnd
            this._renderingEngine.materialLoader.updateSoftShadow(this._lightSizeUVStart + (this._lightSizeUVEnd - this._lightSizeUVStart) * percentageMapped, 1.0);
        }
        return percentage;
    }
    showStatistics() {
        if (this._renderingEngine.showStatistics) {
            for (let i = 0; i < this._stats.stats.length; i++)
                this._stats.stats[i].dom.style.display = '';
        }
        else {
            for (let i = 0; i < this._stats.stats.length; i++)
                this._stats.stats[i].dom.style.display = 'none';
        }
    }
    startAndStopRendering() {
        this._activeRendering = true;
        this.stopBeautyRenderCountdown();
        this.startBeautyRenderCountdown();
    }
    startBeautyRenderCountdown() {
        this._softShadowRenderingTimeout = setTimeout(() => {
            this._softShadowRenderingActive = true;
            this._softShadowRenderingDurationActive = 0;
            this.activateBeautyRenderShaders();
        }, this._renderingEngine.beautyRenderDelay);
    }
    startRendering() {
        this._activeRendering = true;
        this.stopBeautyRenderCountdown();
    }
    stopBeautyRenderCountdown() {
        if (this._softShadowRenderingTimeout)
            clearTimeout(this._softShadowRenderingTimeout);
        this.deactivateBeautyRenderShaders();
    }
    stopRendering() {
        this.startBeautyRenderCountdown();
    }
    toggleBusyMode(toggle) {
        if (this._renderingEngine.branding.busyModeDisplay === viewer_rendering_engine_rendering_engine_1.BUSY_MODE_DISPLAY.BLUR) {
            this._renderingEngine.htmlElementAnchorLoader.toggleBusyMode(toggle);
            if (toggle) {
                if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 && navigator.userAgent.toLowerCase().indexOf('android') > -1)
                    return;
                this._renderingEngine.renderer.domElement.style.filter = 'blur(3px)';
            }
            else {
                this._renderingEngine.renderer.domElement.style.filter = '';
            }
        }
        else if (this._renderingEngine.branding.busyModeDisplay === viewer_rendering_engine_rendering_engine_1.BUSY_MODE_DISPLAY.SPINNER) {
            if (toggle) {
                this._renderingEngine.spinnerDivElement.style.visibility = 'visible';
            }
            else {
                this._renderingEngine.spinnerDivElement.style.visibility = 'hidden';
            }
        }
    }
    toggleLogo(toggle) {
        if (this._renderingEngine.logoDivElement)
            this._renderingEngine.logoDivElement.style.display = toggle ? 'inherit' : 'none';
        if (this._renderingEngine.canvas)
            this._renderingEngine.canvas.style.display = !toggle ? 'inherit' : 'none';
    }
}
exports.RenderingManager = RenderingManager;
//# sourceMappingURL=RenderingManager.js.map

/***/ }),

/***/ 27028:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SceneTracingManager = void 0;
const THREE = __importStar(__webpack_require__(39437));
const viewer_rendering_engine_camera_engine_1 = __webpack_require__(17989);
const viewer_shared_services_1 = __webpack_require__(8389);
const gl_matrix_1 = __webpack_require__(61961);
class SceneTracingManager {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (1)
        this._raycaster = new THREE.Raycaster();
    }
    // #endregion Constructors (1)
    // #region Public Methods (3)
    convert3Dto2D(p) {
        const canvasPageCoordinates = this._renderingEngine.canvas.getBoundingClientRect(), width = this._renderingEngine.canvas.width, height = this._renderingEngine.canvas.height;
        const camera = this._renderingEngine.cameraEngine.camera;
        if (!camera)
            throw new viewer_shared_services_1.ShapeDiverViewerViewportError('SceneTracingManager.convert3Dto2D: No camera is defined for this viewer.');
        if (camera instanceof viewer_rendering_engine_camera_engine_1.OrthographicCamera) {
            const direction = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), camera.target, camera.position);
            const length = gl_matrix_1.vec3.length(direction);
            gl_matrix_1.vec3.divide(direction, direction, gl_matrix_1.vec3.fromValues(length, length, length));
            this._raycaster.ray.direction.set(direction[0], direction[1], direction[2]);
            // set the origin of the ray to the opposite direction of the camera with the start at the initial provided point
            this._raycaster.ray.origin.set(p[0] + direction[0] * length, p[1] + direction[1] * length, p[2] + direction[2] * length);
        }
        else {
            this._raycaster.ray.direction.set(p[0], p[1], p[2]);
            this._raycaster.ray.origin.set(0, 0, 0);
            camera.convertedObject[this._renderingEngine.id].localToWorld(this._raycaster.ray.origin);
            this._raycaster.ray.direction.sub(this._raycaster.ray.origin);
            this._raycaster.ray.direction.normalize();
        }
        let closestIntersectionDistance = Number.MAX_VALUE;
        this._renderingEngine.sceneTreeManager.scene.traverseVisible((obj) => {
            if (obj instanceof THREE.Mesh) {
                const curIntersections = this._raycaster.intersectObject(obj);
                if (curIntersections.length)
                    if (curIntersections[0].distance < closestIntersectionDistance)
                        closestIntersectionDistance = curIntersections[0].distance;
            }
        });
        const pos = camera.project(gl_matrix_1.vec3.clone(p));
        pos[0] = (pos[0] * (width / 2)) + (width / 2);
        pos[1] = -(pos[1] * (height / 2)) + (height / 2);
        // take care of correction by device pixel ratio
        pos[0] = pos[0] / devicePixelRatio;
        pos[1] = pos[1] / devicePixelRatio;
        // epsilon is added as a distance spacer as users tend to put the anchors of html elements directly at the vertices
        // with this we prevent flickering
        const eps = 0.0001;
        return {
            hidden: closestIntersectionDistance + eps < gl_matrix_1.vec3.distance(camera.position, p),
            container: gl_matrix_1.vec2.clone(pos),
            client: gl_matrix_1.vec2.fromValues(pos[0] + canvasPageCoordinates.left, pos[1] + canvasPageCoordinates.top),
            page: gl_matrix_1.vec2.fromValues(pos[0] + canvasPageCoordinates.left + window.pageXOffset, pos[1] + canvasPageCoordinates.top + window.pageYOffset)
        };
    }
    init() { }
    /**
     * Calculate the ray that is created by the mouse event and the camera.
     *
     * @param event
     * @returns
     */
    pointerEventToRay(event) {
        const rect = this._renderingEngine.canvas.getBoundingClientRect();
        const camera = this._renderingEngine.cameraEngine.camera;
        if (!camera)
            throw new viewer_shared_services_1.ShapeDiverViewerViewportError('SceneTracingManager.pointerEventToRay: No camera is defined for this viewer.');
        const _mouse_x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const _mouse_y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        let origin = gl_matrix_1.vec3.clone(camera.position);
        if (camera instanceof viewer_rendering_engine_camera_engine_1.OrthographicCamera) {
            if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, _mouse_y * camera.top, 0));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, _mouse_y * camera.top, 0));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.left, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.right, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, 0, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, 0, _mouse_y * camera.top));
            }
            else {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.left, _mouse_y * camera.top));
            }
        }
        const direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), camera.unproject(gl_matrix_1.vec3.fromValues(_mouse_x, _mouse_y, 0.5)), origin));
        return { origin, direction };
    }
}
exports.SceneTracingManager = SceneTracingManager;
//# sourceMappingURL=SceneTracingManager.js.map

/***/ }),

/***/ 68198:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SceneTreeManager = void 0;
const THREE = __importStar(__webpack_require__(39437));
const viewer_rendering_engine_camera_engine_1 = __webpack_require__(17989);
const viewer_rendering_engine_light_engine_1 = __webpack_require__(9454);
const viewer_shared_types_1 = __webpack_require__(64766);
const viewer_shared_math_1 = __webpack_require__(67275);
const viewer_rendering_engine_rendering_engine_1 = __webpack_require__(45850);
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const gl_matrix_1 = __webpack_require__(61961);
const SDData_1 = __webpack_require__(85284);
const SDBone_1 = __webpack_require__(23438);
const SDObject_1 = __webpack_require__(93867);
const ThreejsData_1 = __webpack_require__(54609);
/* eslint-disable @typescript-eslint/no-empty-function */
const viewer_shared_services_1 = __webpack_require__(8389);
// #endregion Type aliases (1)
// #region Classes (1)
class SceneTreeManager {
    // #endregion Properties (12)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (12)
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._inputValidator = viewer_shared_services_1.InputValidator.instance;
        this._scene = new THREE.Scene();
        this._stateEngine = viewer_shared_services_1.StateEngine.instance;
        this._tree = viewer_shared_node_tree_1.Tree.instance;
        this._boundingBox = new viewer_shared_math_1.Box();
        this._boundingBoxSensitiveData = [];
        this._hiddenCamera = new THREE.PerspectiveCamera();
        this._lastRendererType = viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.STANDARD;
        this._lastRootVersion = '';
        this._scene.background = new THREE.Color('#ffffff');
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (4)
    get boundingBox() {
        return this._boundingBox;
    }
    get lastRendererType() {
        return this._lastRendererType;
    }
    get lastRootVersion() {
        return this._lastRootVersion;
    }
    get scene() {
        return this._scene;
    }
    // #endregion Public Getters And Setters (4)
    // #region Public Methods (6)
    init() { }
    isEmpty() {
        return ((this._boundingBox.min[0] === 0 && this._boundingBox.min[1] === 0 && this._boundingBox.min[2] === 0 &&
            this._boundingBox.max[0] === 0 && this._boundingBox.max[1] === 0 && this._boundingBox.max[2] === 0) || this._boundingBox.isEmpty());
    }
    /**
     * Convert the data of the scene graph node into the format of the implementation.
     *
     * @param data the data element
     * @param obj the corresponding type node
     */
    updateData(node, obj, data, filter, isVisibleInHierarchy, skeleton) {
        let dataChild = obj.children.find(oc => oc.SDid === data.id && oc.SDversion === data.version);
        let newChild = false;
        if (!dataChild) {
            newChild = true;
            dataChild = new SDData_1.SDData(data.id, data.version);
            obj.add(dataChild);
        }
        if (this._renderingEngine.type === viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.ATTRIBUTES) {
            this.injectAttributeData(node, data);
        }
        else {
            const sdtfTransform = node.getTransformation('sdtf');
            if (sdtfTransform)
                node.removeTransformation(sdtfTransform);
            if (data instanceof viewer_shared_types_1.GeometryData)
                data.attributeMaterial = null;
        }
        switch (true) {
            case data instanceof viewer_shared_types_1.GeometryData:
                {
                    dataChild.SDtype = SDData_1.SD_DATA_TYPE.GEOMETRY;
                    if (filter.transformationOnly === false)
                        this._renderingEngine.geometryLoader.load(data, dataChild, newChild, skeleton).clone();
                    let bb = new viewer_shared_math_1.Box();
                    if (skeleton) {
                        bb = data.primitive.computeBoundingBox(node.worldMatrix);
                    }
                    else {
                        const clone = dataChild.clone();
                        clone.applyTransformation(node.worldMatrix);
                        const threeBox = new THREE.Box3().setFromObject(clone, true);
                        bb = new viewer_shared_math_1.Box(gl_matrix_1.vec3.fromValues(threeBox.min.x, threeBox.min.y, threeBox.min.z), gl_matrix_1.vec3.fromValues(threeBox.max.x, threeBox.max.y, threeBox.max.z));
                    }
                    // adjust the general BB
                    node.boundingBox.union(bb);
                    // create the specific BB if it doesn't exist yet
                    if (!node.boundingBoxViewport[this._renderingEngine.id])
                        node.boundingBoxViewport[this._renderingEngine.id] = new viewer_shared_math_1.Box();
                    // adjust the specific BB
                    node.boundingBoxViewport[this._renderingEngine.id].union(bb);
                }
                break;
            case data instanceof ThreejsData_1.ThreejsData:
                {
                    dataChild.SDtype = SDData_1.SD_DATA_TYPE.THREEJS;
                    dataChild.add(data.obj);
                    const bbThree = new THREE.Box3().setFromObject(data.obj);
                    // adjust the general BB
                    node.boundingBox.union(new viewer_shared_math_1.Box(gl_matrix_1.vec3.fromValues(...bbThree.min.toArray()), gl_matrix_1.vec3.fromValues(...bbThree.max.toArray())));
                    // create the specific BB if it doesn't exist yet
                    if (!node.boundingBoxViewport[this._renderingEngine.id])
                        node.boundingBoxViewport[this._renderingEngine.id] = new viewer_shared_math_1.Box();
                    // adjust the specific BB
                    node.boundingBoxViewport[this._renderingEngine.id].union(new viewer_shared_math_1.Box(gl_matrix_1.vec3.fromValues(...bbThree.min.toArray()), gl_matrix_1.vec3.fromValues(...bbThree.max.toArray())));
                }
                break;
            case data instanceof viewer_shared_types_1.AbstractMaterialData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.MATERIAL;
                break;
            case data instanceof viewer_rendering_engine_light_engine_1.AbstractLight:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.LIGHT;
                if (filter.transformationOnly === false)
                    this._renderingEngine.lightLoader.load(data, dataChild);
                if (data instanceof viewer_rendering_engine_light_engine_1.DirectionalLight && data.useNodeData === false)
                    this._boundingBoxSensitiveData.push({ data: data, dataChild });
                break;
            case data instanceof viewer_rendering_engine_camera_engine_1.AbstractCamera:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.CAMERA;
                if (filter.transformationOnly === false)
                    this._renderingEngine.cameraManager.load(data, dataChild);
                break;
            case data instanceof viewer_shared_types_1.HTMLElementAnchorData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.HTML_ELEMENT_ANCHOR;
                if (filter.transformationOnly === false)
                    this._renderingEngine.htmlElementAnchorLoader.load(node, data, isVisibleInHierarchy);
                break;
            case data instanceof viewer_shared_types_1.AnimationData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.ANIMATION;
                break;
            default:
                // if there is no valid conversion here, call the convertData of the implementation
                break;
        }
    }
    updateMorphWeights(node = this._tree.root, obj = this._mainNode) {
        if (!node || !obj)
            return;
        for (let i = 0, len = node.data.length; i < len; i++) {
            if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {
                const data = node.data[i];
                const dataChild = obj.children.find(oc => oc.SDid === data.id && oc.SDversion === data.version);
                if (dataChild)
                    dataChild.traverse(o => {
                        if (o instanceof THREE.Points ||
                            o instanceof THREE.LineSegments ||
                            o instanceof THREE.LineLoop ||
                            o instanceof THREE.Line ||
                            o instanceof THREE.Mesh)
                            o.morphTargetInfluences = data.morphWeights;
                    });
            }
        }
        for (let i = 0, len = node.children.length; i < len; i++) {
            const nodeChild = node.children[i];
            if (!nodeChild)
                continue;
            const objChild = obj.children.find(oc => oc.SDid === nodeChild.id);
            if (objChild)
                this.updateMorphWeights(nodeChild, objChild);
        }
    }
    /**
     * Update the current node via the scene graph node.
     * Convert the data if needed.
     *
     * @param node the scene graph node
     * @param obj the current type object
     */
    updateNode(node = this._tree.root, obj, filter = { transformationOnly: false }, visibleInHierarchy = true, skeleton) {
        if (obj === undefined) {
            // check if there is a converted object
            if (node.convertedObject[this._renderingEngine.id]) {
                obj = node.convertedObject[this._renderingEngine.id];
            }
            else {
                // the node has not been converted yet
                // go up the hierarchy until a converted object is found
                let parent = node.parent;
                while (parent) {
                    if (parent.convertedObject[this._renderingEngine.id]) {
                        this.updateNode(parent, parent.convertedObject[this._renderingEngine.id], filter, visibleInHierarchy, skeleton);
                        return;
                    }
                    else {
                        parent = parent.parent;
                    }
                }
                // no converted object found in the hierarchy
                // update the whole scene tree
                this.updateSceneTree(this._tree.root);
                return;
            }
        }
        const convertedObject = obj;
        // reset the general bounding box of the current node
        // it will be recomputed in the following steps
        node.boundingBox.reset();
        // create the specific BB if it doesn't exist yet
        if (!node.boundingBoxViewport[this._renderingEngine.id])
            node.boundingBoxViewport[this._renderingEngine.id] = new viewer_shared_math_1.Box();
        // reset the specific bounding box of the current node
        // it will be recomputed in the following steps
        node.boundingBoxViewport[this._renderingEngine.id].reset();
        if (filter.transformationOnly === false) {
            // remove all data items that do not exist anymore
            const dataIds = node.data.map(d => d.id);
            const dataToRemove = convertedObject.children.filter(oc => {
                if (oc instanceof SDData_1.SDData) {
                    if (dataIds.includes(oc.SDid)) {
                        const data = node.data.find(d => d.id === oc.SDid);
                        if (data && data.version !== oc.SDversion) {
                            // version is different
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        // id not included anymore
                        return true;
                    }
                }
                else {
                    return false;
                }
            });
            dataToRemove.forEach(dTR => {
                this.removeData(dTR);
                convertedObject.remove(dTR);
            });
            // remove all child nodes in the transformed object that do not exist anymore
            // the filter goes also through the data items as they were already added
            const nodeIds = node.children.filter(d => !d.excludeViewports.includes(this._renderingEngine.id)).map(d => d.id);
            const childrenToRemove = convertedObject.children.filter(oc => {
                if (oc instanceof SDObject_1.SDObject && !(oc instanceof SDData_1.SDData)) {
                    if (nodeIds.includes(oc.SDid)) {
                        return false;
                    }
                    else {
                        // id not included anymore
                        return true;
                    }
                }
                else {
                    return false;
                }
            });
            childrenToRemove.forEach(cTR => {
                cTR.traverse(o => {
                    if (o instanceof SDData_1.SDData)
                        this.removeData(o);
                });
                convertedObject.remove(cTR);
            });
        }
        // create the skeleton if the node is marked as the skin node (root node of the skeleton)
        if (node.skinNode === true) {
            const bones = [];
            for (let i = 0; i < node.bones.length; i++)
                bones.push(this.getBone(node.bones[i]));
            const boneInverses = [];
            for (let i = 0; i < node.boneInverses.length; i++)
                boneInverses.push(new THREE.Matrix4().fromArray(node.boneInverses[i]));
            skeleton = new THREE.Skeleton(bones, boneInverses);
        }
        const isVisible = node.visible && !node.excludeViewports.includes(this._renderingEngine.id) && !(node.restrictViewports.length > 0 && !node.restrictViewports.includes(this._renderingEngine.id));
        const isVisibleInHierarchy = visibleInHierarchy && isVisible;
        // convert all data items of the current node
        // old versions will be replaced by new ones
        for (let i = 0, len = node.data.length; i < len; i++)
            this.updateData(node, convertedObject, node.data[i], filter, isVisibleInHierarchy, skeleton);
        // add new children and update the ones that have a different version
        for (let i = 0, len = node.children.length; i < len; i++) {
            const nodeChild = node.children[i];
            const objChild = convertedObject.children.find(oc => oc.SDid === nodeChild.id);
            if (!objChild) {
                const newChild = node.data.find(d => d instanceof viewer_shared_types_1.BoneData) ? new SDBone_1.SDBone(nodeChild.id, nodeChild.version) : new SDObject_1.SDObject(nodeChild.id, nodeChild.version);
                const oldChild = nodeChild.convertedObject[this._renderingEngine.id];
                nodeChild.convertedObject[this._renderingEngine.id] = newChild;
                if (nodeChild.updateCallbackConvertedObject)
                    nodeChild.updateCallbackConvertedObject(newChild, oldChild, this._renderingEngine.id);
                convertedObject.add(newChild);
                this.updateNode(nodeChild, newChild, filter, isVisibleInHierarchy, skeleton);
            }
            else if (objChild.SDversion !== nodeChild.version) {
                // if the version is different, update the child
                this.updateNode(nodeChild, objChild, filter, isVisibleInHierarchy, skeleton);
                objChild.SDversion = nodeChild.version;
            }
            else {
                this.updateNode(nodeChild, objChild, filter, isVisibleInHierarchy, skeleton);
            }
            // adjust the general BB
            if (!nodeChild.boundingBox.isEmpty())
                node.boundingBox.union(nodeChild.boundingBox);
            // adjust the specific BB
            if (nodeChild.boundingBoxViewport[this._renderingEngine.id] && !nodeChild.boundingBoxViewport[this._renderingEngine.id].isEmpty()) {
                // only do this if the node is
                // 1. visible
                // 2. no included in the "excludeViewports"
                // 3. if there are "restrictViewports", it needs to be in them
                if (isVisible)
                    node.boundingBoxViewport[this._renderingEngine.id].union(nodeChild.boundingBoxViewport[this._renderingEngine.id]);
            }
        }
        convertedObject.visible = node.visible && !node.excludeViewports.includes(this._renderingEngine.id) && !(node.restrictViewports.length > 0 && !node.restrictViewports.includes(this._renderingEngine.id));
        convertedObject.applyTransformation(node.nodeMatrix);
    }
    updateSceneTree(root) {
        var _a, _b;
        if (this._tree.root.version === this._lastRootVersion)
            return;
        this._lastRootVersion = this._tree.root.version;
        this._lastRendererType = this._renderingEngine.type;
        if (this._renderingEngine.closed)
            return;
        const oldBB = this._boundingBox.clone();
        this._boundingBox = new viewer_shared_math_1.Box();
        this._renderingEngine.lightLoader.shadowMapCount = 0;
        if (!this._mainNode) {
            this._mainNode = new SDObject_1.SDObject(root.id, root.version);
            const oldObj = root.convertedObject[this._renderingEngine.id];
            root.convertedObject[this._renderingEngine.id] = this._mainNode;
            if (root.updateCallbackConvertedObject)
                root.updateCallbackConvertedObject(this._mainNode, oldObj, this._renderingEngine.id);
            this._scene.add(this._mainNode);
        }
        this._boundingBoxSensitiveData = [];
        this._currentSDTFOverview = this.createSDTFOverview();
        this.updateNode(root, this._mainNode);
        this._boundingBox = root.boundingBoxViewport[this._renderingEngine.id].clone();
        for (let i = 0; i < this._boundingBoxSensitiveData.length; i++)
            this._renderingEngine.lightLoader.adjustToBoundingBox(this._boundingBoxSensitiveData[i].data, this._boundingBoxSensitiveData[i].dataChild, this._boundingBox);
        if (!(this._boundingBox.min[0] === oldBB.min[0] && this._boundingBox.min[1] === oldBB.min[1] && this._boundingBox.min[2] === oldBB.min[2] &&
            this._boundingBox.max[0] === oldBB.max[0] && this._boundingBox.max[1] === oldBB.max[1] && this._boundingBox.max[2] === oldBB.max[2])) {
            if (!((_a = this._stateEngine.viewportEngines[this._renderingEngine.id]) === null || _a === void 0 ? void 0 : _a.boundingBoxCreated.resolved) && !this._boundingBox.isEmpty())
                (_b = this._stateEngine.viewportEngines[this._renderingEngine.id]) === null || _b === void 0 ? void 0 : _b.boundingBoxCreated.resolve(true);
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, {
                viewportId: this._renderingEngine.id, boundingBox: {
                    min: gl_matrix_1.vec3.clone(this._boundingBox.min),
                    max: gl_matrix_1.vec3.clone(this._boundingBox.max),
                }
            });
        }
        if (this._boundingBox.isEmpty()) {
            // check if all outputs that should be loaded at the start of a session are loaded
            // if the bounding box is empty then, emit the event
            if (Object.values(this._stateEngine.sessionEngines).every(s => s && s.initialOutputsLoaded.resolved === true)) {
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_EMPTY, {
                    viewportId: this._renderingEngine.id
                });
            }
        }
        this._renderingEngine.renderingManager.evaluateTextureUnitCount(this._renderingEngine.lightLoader.shadowMapCount + this._renderingEngine.materialLoader.maxMapCount);
        /**
         *
         * Three.js texture upload and compiling
         * This step is needed as three.js would compile the shaders and initialize the texture on the first render call instead.
         *
         */
        // we initialize all texture and then clear the cache
        const threeJsTextureCache = this._renderingEngine.materialLoader.threeJsTextureCache;
        for (const key in threeJsTextureCache) {
            if (threeJsTextureCache[key].usage === 0) {
                threeJsTextureCache[key].texture.dispose();
                delete threeJsTextureCache[key];
            }
            else if (threeJsTextureCache[key].initialized === false) {
                this._renderingEngine.renderer.initTexture(threeJsTextureCache[key].texture);
                threeJsTextureCache[key].initialized = true;
            }
        }
        // we compile the shaders
        this._renderingEngine.renderer.compile(this._renderingEngine.scene, this._hiddenCamera);
    }
    // #endregion Public Methods (6)
    // #region Private Methods (5)
    collectSDTFItemData(node) {
        for (let i = 0, len = node.data.length; i < len; i++)
            if (node.data[i] instanceof viewer_shared_types_1.SDTFItemData)
                return node.data[i];
        if (!node.parent)
            return;
        return this.collectSDTFItemData(node.parent);
    }
    createSDTFOverview(node = this._tree.root) {
        const out = new viewer_shared_types_1.SDTFOverviewData({});
        for (let i = 0, len = node.data.length; i < len; i++)
            if (node.data[i] instanceof viewer_shared_types_1.SDTFOverviewData)
                out.merge(node.data[i]);
        for (let i = 0, len = node.children.length; i < len; i++)
            out.merge(new viewer_shared_types_1.SDTFOverviewData(this.createSDTFOverview(node.children[i])));
        return out.overview;
    }
    getBone(node) {
        let bone;
        this._mainNode.traverse((o) => {
            if (o.SDid === node.id)
                bone = o;
        });
        return bone;
    }
    injectAttributeData(node, data) {
        const itemData = this.collectSDTFItemData(node);
        const visData = {
            material: new viewer_shared_types_1.MaterialStandardData({ color: this._renderingEngine.defaultMaterialColor, opacity: 1 }),
            matrix: gl_matrix_1.mat4.create()
        };
        if (this._renderingEngine.visualizeAttributes) {
            const userVisData = this._renderingEngine.visualizeAttributes(this._currentSDTFOverview, itemData);
            this._inputValidator.validateAndError('Viewer.visualizeAttributes', userVisData, 'object', true);
            this._inputValidator.validateAndError('Viewer.visualizeAttributes', userVisData.matrix, 'mat4', true);
            visData.material = userVisData.material;
            visData.matrix = userVisData.matrix;
        }
        node.addTransformation({
            id: 'sdtf',
            matrix: visData.matrix
        });
        if (data instanceof viewer_shared_types_1.GeometryData)
            data.attributeMaterial = visData.material;
    }
    removeData(dataObject) {
        if (dataObject.userData.removed === true)
            return;
        dataObject.userData.removed = true;
        switch (true) {
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.GEOMETRY:
                dataObject.traverse((o) => {
                    if (dataObject.id !== o.id && o.userData.removed === true)
                        return;
                    o.userData.removed = true;
                    if (o instanceof THREE.Mesh || o instanceof THREE.Line || o instanceof THREE.Points || o instanceof THREE.LineSegments || o instanceof THREE.LineLoop) {
                        this.scene.remove(o);
                        this._renderingEngine.geometryLoader.removeFromGeometryCache(o.geometry.userData.SDid + '_' + o.geometry.userData.SDversion);
                        this._renderingEngine.materialLoader.removeFromMaterialCache(o.material.userData.SDid + '_' + o.material.userData.SDversion);
                        const texturesToRemove = [];
                        for (const t in o.material) {
                            if (o.material[t] instanceof THREE.Texture) {
                                o.material[t].name = t;
                                if (t !== 'envMap') {
                                    if (!texturesToRemove.includes(o.material[t]))
                                        texturesToRemove.push(o.material[t]);
                                }
                            }
                        }
                        for (const texture of texturesToRemove) {
                            if (texture.userData.cacheKey) {
                                this._renderingEngine.materialLoader.threeJsTextureCache[texture.userData.cacheKey].usage--;
                            }
                            else {
                                if (texture.name === 'sphericalNormalMap') {
                                    this._renderingEngine.geometryLoader.removeFromGemSphericalMapsCache(o.geometry.userData.primitiveSDid + '_' + o.geometry.userData.primitiveSDversion);
                                    texture.dispose();
                                }
                                else {
                                    texture.dispose();
                                }
                            }
                        }
                    }
                });
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.THREEJS:
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.MATERIAL:
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.LIGHT:
                dataObject.traverse((o) => {
                    if (o instanceof THREE.Light)
                        o.dispose();
                });
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.HTML_ELEMENT_ANCHOR:
                this._renderingEngine.htmlElementAnchorLoader.removeData(dataObject.SDid, dataObject.SDversion);
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.ANIMATION:
                break;
            default:
                // if there is no valid conversion here, call the convertData of the implementation
                break;
        }
    }
}
exports.SceneTreeManager = SceneTreeManager;
// #endregion Classes (1)
//# sourceMappingURL=SceneTreeManager.js.map

/***/ }),

/***/ 79581:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GodRaysManager = void 0;
const THREE = __importStar(__webpack_require__(39437));
class GodRaysManager {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        this._lightSource = null;
    }
    // #endregion Constructors (1)
    // #region Public Methods (3)
    removeLightSource() {
        this._godRaysEffect.lightSource = new THREE.Mesh();
    }
    setEffect(godRaysEffect) {
        this._godRaysEffect = godRaysEffect;
        this._godRaysEffect.lightSource = this._lightSource;
    }
    setLightSource(node) {
        this._lightSource = null;
        node.convertedObject[this._renderingEngine.id].traverse(o => {
            if (o instanceof THREE.Mesh || o instanceof THREE.Points)
                this._lightSource = o;
        });
        if (this._lightSource) {
            if (Array.isArray(this._lightSource.material)) {
                this._lightSource.material.forEach(m => m.transparent = true);
                this._lightSource.material.forEach(m => m.depthWrite = false);
            }
            else {
                this._lightSource.material.transparent = true;
                this._lightSource.material.depthWrite = false;
            }
        }
        this._godRaysEffect.lightSource = this._lightSource;
    }
}
exports.GodRaysManager = GodRaysManager;
//# sourceMappingURL=GodRaysManager.js.map

/***/ }),

/***/ 93654:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutlineManager = void 0;
const THREE = __importStar(__webpack_require__(39437));
class OutlineManager {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        this._outlineNodes = [];
    }
    // #endregion Constructors (1)
    // #region Public Methods (5)
    addSelection(node) {
        this._outlineNodes.push(node);
        this.updateOutlineEffectObjects();
    }
    clearSelection() {
        this._outlineNodes = [];
        this.updateOutlineEffectObjects();
    }
    removeSelection(node) {
        const index = this._outlineNodes.indexOf(node);
        if (index !== -1)
            this._outlineNodes.splice(index, 1);
        this.updateOutlineEffectObjects();
        return index !== -1;
    }
    setEffect(outlineEffect) {
        this._outlineEffect = outlineEffect;
        this.updateOutlineEffectObjects();
    }
    updateOutlineEffectObjects() {
        this._outlineEffect.selection.clear();
        for (let i = 0; i < this._outlineNodes.length; i++) {
            this._outlineNodes[i].convertedObject[this._renderingEngine.id].traverse(o => {
                if (o instanceof THREE.Mesh)
                    this._outlineEffect.selection.add(o);
            });
        }
    }
}
exports.OutlineManager = OutlineManager;
//# sourceMappingURL=OutlineManager.js.map

/***/ }),

/***/ 83982:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSAARenderPass = void 0;
const postprocessing_1 = __webpack_require__(66739);
const three_1 = __webpack_require__(39437);
const CopyShader_1 = __webpack_require__(74841);
const FullScreenQuad_1 = __webpack_require__(73987);
const CopyMaterial_1 = __webpack_require__(397);
let geometry = null;
/**
 * Returns a shared fullscreen triangle.
 *
 * The screen size is 2x2 units (NDC). A triangle needs to be 4x4 units to fill the screen.
 *
 * @private
 * @return {BufferGeometry} The fullscreen geometry.
 */
const getFullscreenTriangle = () => {
    if (geometry === null) {
        const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
        const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
        geometry = new three_1.BufferGeometry();
        geometry.setAttribute("position", new three_1.BufferAttribute(vertices, 3));
        geometry.setAttribute("uv", new three_1.BufferAttribute(uvs, 2));
    }
    return geometry;
};
/**
*
* Supersample Anti-Aliasing Render Pass
*
* This manual approach to SSAA re-renders the scene once for each sample with camera jitter and accumulates the results.
*
* References: https://en.wikipedia.org/wiki/Supersampling
*
* original implementation from three.js@0.152.2 was modified to work with the postprocessing library
*
*/
class SSAARenderPass extends postprocessing_1.Pass {
    // #endregion Properties (9)
    // #region Constructors (1)
    constructor(scene, camera) {
        super("SSAARenderPass", scene, camera);
        this._clearColor = new three_1.Color();
        this._oldClearColor = new three_1.Color();
        this._sampleLevel = 2;
        this._unbiased = true;
        this.needsSwap = false;
        this._sampleRenderTarget = new three_1.WebGLRenderTarget(1, 1, {
            type: three_1.HalfFloatType,
        });
        this._sampleRenderTarget.texture.name = "SSAARender.Target";
        this._sampleRenderTarget.texture.colorSpace = three_1.SRGBColorSpace;
        const copyShader = CopyShader_1.CopyShader;
        this._copyUniforms = three_1.UniformsUtils.clone(copyShader.uniforms);
        // Create a copy material to render the ssaa sample render target to.
        this._ssaaCopyMaterial = new three_1.ShaderMaterial({
            uniforms: this._copyUniforms,
            vertexShader: copyShader.vertexShader,
            fragmentShader: copyShader.fragmentShader,
            transparent: true,
            depthTest: false,
            depthWrite: false,
            // do not use AdditiveBlending because it mixes the alpha channel instead of adding
            blending: three_1.CustomBlending,
            blendEquation: three_1.AddEquation,
            blendDst: three_1.OneFactor,
            blendDstAlpha: three_1.OneFactor,
            blendSrc: three_1.SrcAlphaFactor,
            blendSrcAlpha: three_1.OneFactor,
        });
        this._fsQuad = new FullScreenQuad_1.FullScreenQuad(this._ssaaCopyMaterial);
        // create a second copy material to render the final results to
        this._copyMaterial = new CopyMaterial_1.CopyMaterial();
        this._fullScreen = new three_1.Mesh(getFullscreenTriangle(), this._copyMaterial);
        this._fullScreen.frustumCulled = false;
        // clear pass for color and depth
        this._clearPass = new postprocessing_1.ClearPass(true, true, false);
    }
    // #endregion Constructors (1)
    // #region Public Accessors (6)
    set mainCamera(value) {
        this.camera = value;
    }
    set mainScene(value) {
        this.scene = value;
    }
    get renderToScreen() {
        return super.renderToScreen;
    }
    set renderToScreen(value) {
        super.renderToScreen = value;
    }
    get sampleLevel() {
        return this._sampleLevel;
    }
    /**
     * specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.
     */
    set sampleLevel(value) {
        this._sampleLevel = value;
    }
    /**
     * to cancel out rounding errors
     */
    set unbiased(value) {
        this._unbiased = value;
    }
    // #endregion Public Accessors (6)
    // #region Public Methods (3)
    dispose() {
        this._sampleRenderTarget.dispose();
        this._ssaaCopyMaterial.dispose();
        this._fsQuad.dispose();
    }
    /**
     * Renders the scene.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */
    render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
        // set clear color / clear alpha / color space from the current renderer
        this._clearColor = renderer.getClearColor(new three_1.Color());
        this._clearAlpha = renderer.getClearAlpha();
        this._sampleRenderTarget.texture.colorSpace = renderer.outputColorSpace;
        const jitterOffsets = _JitterVectors[Math.max(0, Math.min(this._sampleLevel, 5))];
        // save the original auto clear and set to false
        const autoClear = renderer.autoClear;
        renderer.autoClear = false;
        // save the original clear color and alpha
        renderer.getClearColor(this._oldClearColor);
        const oldClearAlpha = renderer.getClearAlpha();
        const baseSampleWeight = 1.0 / jitterOffsets.length;
        const roundingRange = 1 / 32;
        this._copyUniforms["tDiffuse"].value = this._sampleRenderTarget.texture;
        const viewOffset = {
            fullWidth: inputBuffer.width,
            fullHeight: inputBuffer.height,
            offsetX: 0,
            offsetY: 0,
            width: inputBuffer.width,
            height: inputBuffer.height,
        };
        const originalViewOffset = Object.assign({}, this.camera.view);
        if (originalViewOffset.enabled)
            Object.assign(viewOffset, originalViewOffset);
        // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.
        for (let i = 0; i < jitterOffsets.length; i++) {
            const jitterOffset = jitterOffsets[i];
            if (this.camera.setViewOffset) {
                this.camera.setViewOffset(viewOffset.fullWidth, viewOffset.fullHeight, viewOffset.offsetX + jitterOffset[0] * 0.0625, viewOffset.offsetY + jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16
                viewOffset.width, viewOffset.height);
            }
            let sampleWeight = baseSampleWeight;
            if (this._unbiased) {
                // the theory is that equal weights for each sample lead to an accumulation of rounding errors.
                // The following equation varies the sampleWeight per sample so that it is uniformly distributed
                // across a range of values whose rounding errors cancel each other out.
                const uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;
                sampleWeight += roundingRange * uniformCenteredDistribution;
            }
            renderer.setClearColor(this._clearColor, this._clearAlpha);
            renderer.setRenderTarget(this._sampleRenderTarget);
            renderer.clear();
            renderer.render(this.scene, this.camera);
            renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
            if (i === 0) {
                renderer.setClearColor(0x000000, 0.0);
                renderer.clear();
            }
            // set the weight of the current samples in the ssaaCopyMaterial
            this._copyUniforms["opacity"].value = sampleWeight;
            // render the sampleRenderTarget to fullscreen
            this._fsQuad.render(renderer);
        }
        // clear color and depth
        this._clearPass.render(renderer, inputBuffer, inputBuffer);
        // render to the final result to fullscreen
        this._copyMaterial.uniforms.inputBuffer.value = outputBuffer.texture;
        this._copyMaterial.uniforms.opacity.value = 1;
        renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);
        this.scene.add(this._fullScreen);
        renderer.render(this.scene, this.camera);
        this.scene.remove(this._fullScreen);
        if (this.camera.setViewOffset && originalViewOffset.enabled) {
            this.camera.setViewOffset(originalViewOffset.fullWidth, originalViewOffset.fullHeight, originalViewOffset.offsetX, originalViewOffset.offsetY, originalViewOffset.width, originalViewOffset.height);
        }
        else if (this.camera.clearViewOffset) {
            this.camera.clearViewOffset();
        }
        renderer.autoClear = autoClear;
        renderer.setClearColor(this._oldClearColor, oldClearAlpha);
    }
    setSize(width, height) {
        this._sampleRenderTarget.setSize(width, height);
    }
}
exports.SSAARenderPass = SSAARenderPass;
const _JitterVectors = [
    [
        [0, 0]
    ],
    [
        [4, 4], [-4, -4]
    ],
    [
        [-2, -6], [6, -2], [-6, 2], [2, 6]
    ],
    [
        [1, -3], [-1, 3], [5, 1], [-3, -5],
        [-5, 5], [-7, -1], [3, 7], [7, -7]
    ],
    [
        [1, 1], [-1, -3], [-3, 2], [4, -1],
        [-5, -2], [2, 5], [5, 3], [3, -5],
        [-2, 6], [0, -7], [-4, -6], [-6, 4],
        [-8, 0], [7, -4], [6, 7], [-7, -8]
    ],
    [
        [-4, -7], [-7, -5], [-3, -5], [-5, -4],
        [-1, -4], [-2, -2], [-6, -1], [-4, 0],
        [-7, 1], [-1, 2], [-6, 3], [-3, 3],
        [-7, 6], [-3, 6], [-5, 7], [-1, 7],
        [5, -7], [1, -6], [6, -5], [4, -4],
        [2, -3], [7, -2], [1, -1], [4, -1],
        [2, 1], [6, 2], [0, 4], [4, 4],
        [2, 5], [7, 5], [5, 6], [3, 7]
    ]
];
//# sourceMappingURL=SSAARenderPass.js.map

/***/ }),

/***/ 26207:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectiveBloomManager = void 0;
const THREE = __importStar(__webpack_require__(39437));
class SelectiveBloomManager {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        this._selectiveBloomNodes = [];
    }
    // #endregion Constructors (1)
    // #region Public Methods (5)
    addSelection(node) {
        this._selectiveBloomNodes.push(node);
        this.updateSelectiveBloomEffectObjects();
    }
    clearSelection() {
        this._selectiveBloomNodes = [];
        this.updateSelectiveBloomEffectObjects();
    }
    removeSelection(node) {
        const index = this._selectiveBloomNodes.indexOf(node);
        if (index !== -1)
            this._selectiveBloomNodes.splice(index, 1);
        this.updateSelectiveBloomEffectObjects();
        return index !== -1;
    }
    setEffect(selectiveBloomEffect) {
        this._selectiveBloomEffect = selectiveBloomEffect;
        this.updateSelectiveBloomEffectObjects();
    }
    updateSelectiveBloomEffectObjects() {
        this._selectiveBloomEffect.selection.clear();
        for (let i = 0; i < this._selectiveBloomNodes.length; i++) {
            this._selectiveBloomNodes[i].convertedObject[this._renderingEngine.id].traverse(o => {
                if (o instanceof THREE.Mesh)
                    this._selectiveBloomEffect.selection.add(o);
            });
        }
    }
}
exports.SelectiveBloomManager = SelectiveBloomManager;
//# sourceMappingURL=SelectiveBloomManager.js.map

/***/ }),

/***/ 94296:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AOEffect = void 0;
const postprocessing_1 = __webpack_require__(66739);
const three_1 = __webpack_require__(39437);
const PoissionDenoisePass_1 = __webpack_require__(50438);
const ao_compose_1 = __webpack_require__(66180);
const NormalPass_1 = __webpack_require__(79191);
const defaultAOOptions = Object.assign({ resolutionScale: 1, spp: 8, distancePower: 1, power: 2, bias: 40, thickness: 0.075, color: new three_1.Color('black'), useNormalPass: false, velocityDepthNormalPass: null }, PoissionDenoisePass_1.PoissionDenoisePass.DefaultOptions);
class AOEffect extends postprocessing_1.Effect {
    // #endregion Properties (7)
    // #region Constructors (1)
    constructor(composer, camera, scene, aoPass, options = defaultAOOptions) {
        var _a, _b;
        super('AOEffect', ao_compose_1.ao_compose, {
            uniforms: new Map([
                ['inputTexture', new three_1.Uniform(null)],
                ['depthTexture', new three_1.Uniform(null)],
                ['power', new three_1.Uniform(0)],
                ['color', new three_1.Uniform(new three_1.Color('black'))]
            ])
        });
        this.lastSize = { width: 0, height: 0, resolutionScale: 0 };
        this.resolutionScale = 1;
        this.composer = composer;
        this.aoPass = aoPass;
        options = Object.assign(Object.assign({}, defaultAOOptions), options);
        this.normalPass = new NormalPass_1.NormalPass(scene, camera);
        const normalTexture = (_a = options.normalTexture) !== null && _a !== void 0 ? _a : (_b = this.normalPass) === null || _b === void 0 ? void 0 : _b.texture;
        this.aoPass.fullscreenMaterial.uniforms.normalTexture.value = normalTexture;
        this.aoPass.fullscreenMaterial.defines.useNormalTexture = '';
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.aoPass.fullscreenMaterial.uniforms.depthTexture.value = this.normalPass.depthTexture;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.uniforms.get('depthTexture').value = this.normalPass.depthTexture;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.poissionDenoisePass = new PoissionDenoisePass_1.PoissionDenoisePass(camera, this.aoPass.texture, this.normalPass.depthTexture);
        this.makeOptionsReactive(options);
    }
    // #endregion Constructors (1)
    // #region Public Methods (3)
    makeOptionsReactive(options) {
        for (const key of Object.keys(options)) {
            Object.defineProperty(this, key, {
                get() {
                    return options[key];
                },
                set(value) {
                    if (value === null || value === undefined)
                        return;
                    options[key] = value;
                    switch (key) {
                        case 'spp':
                            this.aoPass.fullscreenMaterial.defines.spp = value.toFixed(0);
                            this.aoPass.fullscreenMaterial.needsUpdate = true;
                            break;
                        case 'distance':
                            this.aoPass.fullscreenMaterial.uniforms.aoDistance.value = value;
                            this.poissionDenoisePass.fullscreenMaterial.uniforms['distance'].value = Math.max(value, 0.0001);
                            break;
                        case 'resolutionScale':
                            this.setSize(this.lastSize.width, this.lastSize.height);
                            break;
                        case 'power':
                            this.uniforms.get('power').value = value;
                            break;
                        case 'color':
                            this.uniforms.get('color').value.copy(new three_1.Color(value));
                            break;
                        // denoiser
                        case 'iterations':
                        case 'radius':
                        case 'rings':
                        case 'samples':
                            this.poissionDenoisePass[key] = value;
                            break;
                        case 'lumaPhi':
                        case 'depthPhi':
                        case 'normalPhi':
                            this.poissionDenoisePass.fullscreenMaterial.uniforms[key].value = Math.max(value, 0.0001);
                            break;
                        default:
                            if (key in this.aoPass.fullscreenMaterial.uniforms) {
                                this.aoPass.fullscreenMaterial.uniforms[key].value = value;
                            }
                    }
                },
                configurable: true
            });
            // apply all uniforms and defines
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this[key] = options[key];
        }
    }
    setSize(width, height) {
        var _a;
        if (width === undefined || height === undefined)
            return;
        if (width === this.lastSize.width &&
            height === this.lastSize.height &&
            this.resolutionScale === this.lastSize.resolutionScale) {
            return;
        }
        (_a = this.normalPass) === null || _a === void 0 ? void 0 : _a.setSize(width, height);
        this.aoPass.setSize(width * this.resolutionScale, height * this.resolutionScale);
        this.poissionDenoisePass.setSize(width, height);
        this.lastSize = {
            width,
            height,
            resolutionScale: this.resolutionScale
        };
    }
    update(renderer) {
        var _a;
        if ('animatedNoise' in this.aoPass.fullscreenMaterial.defines) {
            delete this.aoPass.fullscreenMaterial.defines.animatedNoise;
            this.aoPass.fullscreenMaterial.needsUpdate = true;
        }
        // set input texture
        if (this.poissionDenoisePass.iterations > 0) {
            this.uniforms.get('inputTexture').value = this.poissionDenoisePass.texture;
        }
        else {
            this.uniforms.get('inputTexture').value = this.aoPass.texture;
        }
        (_a = this.normalPass) === null || _a === void 0 ? void 0 : _a.render(renderer);
        this.aoPass.render(renderer);
        this.poissionDenoisePass.render(renderer);
    }
}
exports.AOEffect = AOEffect;
// #region Properties (7)
AOEffect.DefaultOptions = defaultAOOptions;
//# sourceMappingURL=AOEffect.js.map

/***/ }),

/***/ 18484:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AOPass = void 0;
const postprocessing_1 = __webpack_require__(66739);
const three_1 = __webpack_require__(39437);
const basic_1 = __webpack_require__(58676);
const sampleBlueNoise_1 = __webpack_require__(18130);
const PoissionDenoisePass_1 = __webpack_require__(50438);
// a general AO pass that can be used for any AO algorithm
class AOPass extends postprocessing_1.Pass {
    // #endregion Properties (3)
    // #region Constructors (1)
    constructor(camera, scene, fragmentShader) {
        super();
        this._camera = camera;
        this._scene = scene;
        this.renderTarget = new three_1.WebGLRenderTarget(1, 1, {
            type: three_1.HalfFloatType,
            depthBuffer: false
        });
        const finalFragmentShader = fragmentShader.replace('#include <sampleBlueNoise>', sampleBlueNoise_1.sampleBlueNoise);
        this.fullscreenMaterial = new three_1.ShaderMaterial({
            fragmentShader: finalFragmentShader,
            vertexShader: basic_1.basic,
            uniforms: {
                depthTexture: { value: null },
                normalTexture: { value: null },
                cameraNear: { value: 0 },
                cameraFar: { value: 0 },
                viewMatrix: { value: this._camera.matrixWorldInverse },
                projectionViewMatrix: { value: new three_1.Matrix4() },
                projectionMatrixInverse: { value: this._camera.projectionMatrixInverse },
                cameraMatrixWorld: { value: this._camera.matrixWorld },
                texSize: { value: new three_1.Vector2() },
                blueNoiseTexture: { value: null },
                blueNoiseRepeat: { value: new three_1.Vector2() },
                aoDistance: { value: 0 },
                distancePower: { value: 0 },
                bias: { value: 0 },
                thickness: { value: 0 },
                power: { value: 0 },
                frame: { value: 0 }
            },
            blending: three_1.NoBlending,
            depthWrite: false,
            depthTest: false,
            toneMapped: false
        });
        this.fullscreenMaterial.uniforms.blueNoiseTexture.value = PoissionDenoisePass_1.PoissionDenoisePass.blueNoiseTexture;
    }
    // #endregion Constructors (1)
    // #region Public Accessors (1)
    get texture() {
        return this.renderTarget.texture;
    }
    // #endregion Public Accessors (1)
    // #region Public Methods (2)
    render(renderer) {
        const spp = +this.fullscreenMaterial.defines.spp;
        this.fullscreenMaterial.uniforms.frame.value = (this.fullscreenMaterial.uniforms.frame.value + spp) % 65536;
        this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near;
        this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far;
        this.fullscreenMaterial.uniforms.projectionViewMatrix.value.multiplyMatrices(this._camera.projectionMatrix, this._camera.matrixWorldInverse);
        const noiseTexture = this.fullscreenMaterial.uniforms.blueNoiseTexture.value;
        if (noiseTexture) {
            const { width, height } = noiseTexture.source.data;
            this.fullscreenMaterial.uniforms.blueNoiseRepeat.value.set(this.renderTarget.width / width, this.renderTarget.height / height);
        }
        renderer.setRenderTarget(this.renderTarget);
        renderer.render(this.scene, this.camera);
    }
    setSize(width, height) {
        this.renderTarget.setSize(width, height);
        this.fullscreenMaterial.uniforms.texSize.value.set(this.renderTarget.width, this.renderTarget.height);
    }
}
exports.AOPass = AOPass;
//# sourceMappingURL=AOPass.js.map

/***/ }),

/***/ 66180:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ao_compose = void 0;
exports.ao_compose = `
uniform sampler2D inputTexture;
uniform highp sampler2D depthTexture;
uniform float power;
uniform vec3 color;

void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
    float unpackedDepth = textureLod(depthTexture, uv, 0.).r;

    float ao = unpackedDepth > 0.9999 ? 1.0 : textureLod(inputTexture, uv, 0.0).a;
    ao = pow(ao, power);

    vec3 aoColor = mix(color, vec3(1.), ao);

    aoColor *= inputColor.rgb;

    outputColor = vec4(aoColor, inputColor.a);
}
`;
//# sourceMappingURL=ao_compose.js.map

/***/ }),

/***/ 58140:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HBAOEffect = void 0;
const AOEffect_1 = __webpack_require__(94296);
const AOPass_1 = __webpack_require__(18484);
const hbao_1 = __webpack_require__(90323);
const hbao_utils_1 = __webpack_require__(65541);
const finalFragmentShader = hbao_1.hbao.replace('#include <hbao_utils>', hbao_utils_1.hbao_utils);
class HBAOPass extends AOPass_1.AOPass {
    // #region Constructors (1)
    constructor(camera, scene) {
        super(camera, scene, finalFragmentShader);
    }
}
class HBAOEffect extends AOEffect_1.AOEffect {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(composer, camera, scene, options = AOEffect_1.AOEffect.DefaultOptions) {
        super(composer, camera, scene, new HBAOPass(camera, scene), Object.assign(Object.assign(Object.assign({}, AOEffect_1.AOEffect.DefaultOptions), HBAOEffect.DefaultOptions), options));
        // #region Properties (1)
        this.lastSize = { width: 0, height: 0, resolutionScale: 0 };
    }
}
exports.HBAOEffect = HBAOEffect;
//# sourceMappingURL=HBAOEffect.js.map

/***/ }),

/***/ 90323:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hbao = void 0;
exports.hbao = `
varying vec2 vUv;

uniform highp sampler2D depthTexture;

uniform mat4 projectionViewMatrix;
uniform int frame;

uniform sampler2D blueNoiseTexture;
uniform vec2 blueNoiseRepeat;
uniform vec2 texSize;

uniform float aoDistance;
uniform float distancePower;
uniform float bias;
uniform float thickness;

#include <packing>
// HBAO Utils
#include <hbao_utils>

float getOcclusion(const vec3 cameraPosition, const vec3 worldPos, const vec3 worldNormal, const float depth, const int seed, inout float totalWeight) {
    vec4 blueNoise = sampleBlueNoise(blueNoiseTexture, seed, blueNoiseRepeat, texSize);

    vec3 sampleWorldDir = cosineSampleHemisphere(worldNormal, blueNoise.rg);

    vec3 sampleWorldPos = worldPos + aoDistance * pow(blueNoise.b, distancePower + 1.0) * sampleWorldDir;

    // Project the sample position to screen space
    vec4 sampleUv = projectionViewMatrix * vec4(sampleWorldPos, 1.);
    sampleUv.xy /= sampleUv.w;
    sampleUv.xy = sampleUv.xy * 0.5 + 0.5;

    // Get the depth of the sample position
    float sampleDepth = textureLod(depthTexture, sampleUv.xy, 0.0).r;

    // Compute the horizon line
    float deltaDepth = depth - sampleDepth;

    // distance based bias
    float d = distance(sampleWorldPos, cameraPosition) / aoDistance;
    deltaDepth *= 0.001 * d * d;

    float th = thickness * 0.01;

    float theta = dot(worldNormal, sampleWorldDir);
    totalWeight += theta;

    if (deltaDepth < th) {
        float horizon = sampleDepth + deltaDepth * bias * 1000.;

        float occlusion = max(0.0, horizon - depth) * theta;

        float m = max(0., 1. - deltaDepth / th);
        occlusion = 10. * occlusion * m / d;

        occlusion = max(0.0, occlusion);
        occlusion = sqrt(occlusion);
        return occlusion;
    }

    return 0.;
}

void main() {
    float depth = textureLod(depthTexture, vUv, 0.0).r;

    // filter out background
    if (depth == 1.0) {
        discard;
        return;
    }

    vec4 cameraPosition = cameraMatrixWorld * vec4(0.0, 0.0, 0.0, 1.0);

    vec3 worldPos = getWorldPos(depth, vUv);
    vec3 worldNormal = getWorldNormal(vUv);

    float ao = 0.0, totalWeight = 0.0;

    for (int i = 0; i < spp; i++) {
        int seed = i;
#ifdef animatedNoise
        seed += frame;
#endif

        float occlusion = getOcclusion(cameraPosition.xyz, worldPos, worldNormal, depth, seed, totalWeight);
        ao += occlusion;
    }

    if (totalWeight > 0.) ao /= totalWeight;

    // clamp ao to [0, 1]
    ao = clamp(1. - ao, 0., 1.);

    gl_FragColor = vec4(worldNormal, ao);
}
`;
//# sourceMappingURL=hbao.js.map

/***/ }),

/***/ 65541:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hbao_utils = void 0;
exports.hbao_utils = `
#include <sampleBlueNoise>

uniform sampler2D normalTexture;
uniform float cameraNear;
uniform float cameraFar;
uniform mat4 projectionMatrixInverse;
uniform mat4 cameraMatrixWorld;

// source: https://github.com/mrdoob/three.js/blob/342946c8392639028da439b6dc0597e58209c696/examples/js/shaders/SAOShader.js#L123
float getViewZ(const float depth) {
#ifdef PERSPECTIVE_CAMERA
    return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
#else
    return orthographicDepthToViewZ(depth, cameraNear, cameraFar);
#endif
}

// source: https://github.com/N8python/ssao/blob/master/EffectShader.js#L52
vec3 getWorldPos(const float depth, const vec2 coord) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
    vec4 viewSpacePosition = projectionMatrixInverse * clipSpacePosition;

    // Perspective division
    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;
    worldSpacePosition.xyz /= worldSpacePosition.w;

    return worldSpacePosition.xyz;
}

vec3 slerp(const vec3 a, const vec3 b, const float t) {
    float cosAngle = dot(a, b);
    float angle = acos(cosAngle);

    if (abs(angle) < 0.001) {
        return mix(a, b, t);
    }

    float sinAngle = sin(angle);
    float t1 = sin((1.0 - t) * angle) / sinAngle;
    float t2 = sin(t * angle) / sinAngle;

    return (a * t1) + (b * t2);
}

vec3 computeWorldNormal() {
    vec2 size = vec2(textureSize(depthTexture, 0));
    ivec2 p = ivec2(vUv * size);
    float c0 = texelFetch(depthTexture, p, 0).x;
    float l2 = texelFetch(depthTexture, p - ivec2(2, 0), 0).x;
    float l1 = texelFetch(depthTexture, p - ivec2(1, 0), 0).x;
    float r1 = texelFetch(depthTexture, p + ivec2(1, 0), 0).x;
    float r2 = texelFetch(depthTexture, p + ivec2(2, 0), 0).x;
    float b2 = texelFetch(depthTexture, p - ivec2(0, 2), 0).x;
    float b1 = texelFetch(depthTexture, p - ivec2(0, 1), 0).x;
    float t1 = texelFetch(depthTexture, p + ivec2(0, 1), 0).x;
    float t2 = texelFetch(depthTexture, p + ivec2(0, 2), 0).x;
    float dl = abs((2.0 * l1 - l2) - c0);
    float dr = abs((2.0 * r1 - r2) - c0);
    float db = abs((2.0 * b1 - b2) - c0);
    float dt = abs((2.0 * t1 - t2) - c0);
    vec3 ce = getWorldPos(c0, vUv).xyz;
    vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / size.x, 0.0))).xyz
                          : -ce + getWorldPos(r1, (vUv + vec2(1.0 / size.x, 0.0))).xyz;
    vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / size.y))).xyz
                          : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / size.y))).xyz;
    return normalize(cross(dpdx, dpdy));
}

vec3 getWorldNormal(const vec2 uv) {
#ifdef useNormalTexture
    vec3 worldNormal = unpackRGBToNormal(textureLod(normalTexture, uv, 0.).rgb);

    worldNormal = (vec4(worldNormal, 1.) * viewMatrix).xyz;  // view-space to world-space
    return normalize(worldNormal);
#else
    return computeWorldNormal();  // compute world normal from depth
#endif
}

#define PI 3.14159265358979323846264338327950288

// source: https://www.shadertoy.com/view/cll3R4
vec3 cosineSampleHemisphere(const vec3 n, const vec2 u) {
    float r = sqrt(u.x);
    float theta = 2.0 * PI * u.y;

    vec3 b = normalize(cross(n, vec3(0.0, 1.0, 1.0)));
    vec3 t = cross(b, n);

    return normalize(r * sin(theta) * b + sqrt(1.0 - u.x) * n + r * cos(theta) * t);
}

`;
//# sourceMappingURL=hbao_utils.js.map

/***/ }),

/***/ 50438:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PoissionDenoisePass = void 0;
const basic_1 = __webpack_require__(58676);
const three_1 = __webpack_require__(39437);
const viewer_shared_services_1 = __webpack_require__(8389);
const postprocessing_1 = __webpack_require__(66739);
const poissionDenoise_1 = __webpack_require__(47779);
const sampleBlueNoise_1 = __webpack_require__(18130);
const finalFragmentShader = poissionDenoise_1.poissionDenoise.replace('#include <sampleBlueNoise>', sampleBlueNoise_1.sampleBlueNoise);
const defaultPoissonBlurOptions = {
    iterations: 1,
    radius: 8,
    rings: 5.625,
    lumaPhi: 10,
    depthPhi: 2,
    normalPhi: 3.25,
    samples: 16,
    distance: 1,
    normalTexture: null
};
class PoissionDenoisePass extends postprocessing_1.Pass {
    // #endregion Properties (11)
    // #region Constructors (1)
    constructor(camera, inputTexture, depthTexture, options = defaultPoissonBlurOptions) {
        super('PoissionBlurPass');
        this.index = 0;
        this.iterations = defaultPoissonBlurOptions.iterations;
        this.radius = 8;
        this.rings = 5.625;
        this.samples = 16;
        if (PoissionDenoisePass.blueNoiseTexture === undefined)
            this.loadBlueNoiseTexture();
        options = Object.assign(Object.assign({}, defaultPoissonBlurOptions), options);
        this.inputTexture = inputTexture;
        this.fullscreenMaterial = new three_1.ShaderMaterial({
            fragmentShader: finalFragmentShader,
            vertexShader: basic_1.basic,
            uniforms: {
                depthTexture: { value: null },
                inputTexture: { value: null },
                projectionMatrixInverse: { value: new three_1.Matrix4() },
                cameraMatrixWorld: { value: new three_1.Matrix4() },
                lumaPhi: { value: 5.0 },
                depthPhi: { value: 5.0 },
                normalPhi: { value: 5.0 },
                distance: { value: 1.0 },
                resolution: { value: new three_1.Vector2() },
                blueNoiseTexture: { value: null },
                index: { value: 0 },
                blueNoiseRepeat: { value: new three_1.Vector2() }
            }
        });
        const renderTargetOptions = {
            type: three_1.HalfFloatType,
            depthBuffer: false
        };
        this.renderTargetA = new three_1.WebGLRenderTarget(1, 1, renderTargetOptions);
        this.renderTargetB = new three_1.WebGLRenderTarget(1, 1, renderTargetOptions);
        const { uniforms } = this.fullscreenMaterial;
        uniforms['inputTexture'].value = this.inputTexture;
        uniforms['depthTexture'].value = depthTexture;
        uniforms['projectionMatrixInverse'].value = camera.projectionMatrixInverse;
        uniforms['cameraMatrixWorld'].value = camera.matrixWorld;
        uniforms['depthPhi'].value = options.depthPhi;
        uniforms['normalPhi'].value = options.normalPhi;
        uniforms['distance'].value = options.distance;
        if (options.normalTexture) {
            uniforms['normalTexture'] = { value: options.normalTexture };
        }
        else {
            this.fullscreenMaterial.defines.NORMAL_IN_RGB = '';
        }
        // these properties need the shader to be recompiled
        for (const prop of ['radius', 'rings', 'samples']) {
            Object.defineProperty(this, prop, {
                get: () => options[prop],
                set: value => {
                    options[prop] = value;
                    this.setSize(this.renderTargetA.width, this.renderTargetA.height);
                }
            });
        }
    }
    loadBlueNoiseTexture() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield viewer_shared_services_1.HttpClient.instance.loadTexture('https://viewer.shapediver.com/v3/graphics/LDR_RGBA_0.png');
            if (result) {
                const url = URL.createObjectURL(result.data.blob);
                new three_1.TextureLoader().load(url, texture => {
                    URL.revokeObjectURL(url);
                    PoissionDenoisePass.blueNoiseTexture = texture;
                    PoissionDenoisePass.blueNoiseTexture.minFilter = three_1.NearestFilter;
                    PoissionDenoisePass.blueNoiseTexture.magFilter = three_1.NearestFilter;
                    PoissionDenoisePass.blueNoiseTexture.wrapS = three_1.RepeatWrapping;
                    PoissionDenoisePass.blueNoiseTexture.wrapT = three_1.RepeatWrapping;
                    PoissionDenoisePass.blueNoiseTexture.colorSpace = three_1.NoColorSpace;
                    PoissionDenoisePass.blueNoiseTexture.needsUpdate = true;
                    this.fullscreenMaterial.uniforms.blueNoiseTexture.value = PoissionDenoisePass.blueNoiseTexture;
                });
            }
            else {
                viewer_shared_services_1.Logger.instance.warn('The blue noise texture could not be loaded. This may result in a suboptimal denoising quality. Retrying in 1 second...');
                // if there was an issue loading the texture
                // set a timeout with 1 second to try again
                setTimeout(() => {
                    this.loadBlueNoiseTexture();
                }, 1000);
            }
        });
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (1)
    get texture() {
        return this.renderTargetB.texture;
    }
    // #endregion Public Getters And Setters (1)
    // #region Public Methods (4)
    generateDenoiseSamples(numSamples, numRings, r, texelSize) {
        const angleStep = (2 * Math.PI * numRings) / numSamples;
        const invNumSamples = 1.0 / numSamples;
        const radiusStep = invNumSamples;
        const samples = [];
        let radius = invNumSamples;
        let angle = 0;
        for (let i = 0; i < numSamples; i++) {
            const v = new three_1.Vector2(Math.cos(angle), Math.sin(angle))
                .multiplyScalar(Math.pow(radius, 0.75))
                .multiply(texelSize)
                .multiplyScalar(r);
            if (isNaN(v.x) || v.x === Infinity || v.x === -Infinity)
                v.x = 0;
            if (isNaN(v.y) || v.y === Infinity || v.y === -Infinity)
                v.y = 0;
            samples.push(v);
            radius += radiusStep;
            angle += angleStep;
        }
        return samples;
    }
    generatePoissonDiskConstant(poissonDisk) {
        const samples = poissonDisk.length;
        let glslCode = 'const vec2 poissonDisk[samples] = vec2[samples](\n';
        for (let i = 0; i < samples; i++) {
            const sample = poissonDisk[i];
            glslCode += `    vec2(${sample.x}, ${sample.y})`;
            if (i < samples - 1) {
                glslCode += ',';
            }
            glslCode += '\n';
        }
        glslCode += ');';
        return glslCode;
    }
    render(renderer) {
        this.fullscreenMaterial.uniforms.index.value = 0;
        const noiseTexture = this.fullscreenMaterial.uniforms.blueNoiseTexture.value;
        if (noiseTexture !== undefined && noiseTexture !== null && noiseTexture instanceof three_1.Texture) {
            const { width, height } = noiseTexture.source.data;
            this.fullscreenMaterial.uniforms.blueNoiseRepeat.value.set(this.renderTargetA.width / width, this.renderTargetA.height / height);
        }
        for (let i = 0; i < 2 * this.iterations; i++) {
            const horizontal = i % 2 === 0;
            const inputRenderTarget = horizontal ? this.renderTargetB : this.renderTargetA;
            this.fullscreenMaterial.uniforms['inputTexture'].value = i === 0 ? this.inputTexture : inputRenderTarget.texture;
            const renderTarget = horizontal ? this.renderTargetA : this.renderTargetB;
            renderer.setRenderTarget(renderTarget);
            renderer.render(this.scene, this.camera);
            this.fullscreenMaterial.uniforms.index.value = (this.fullscreenMaterial.uniforms.index.value + 1) % 4;
        }
    }
    setSize(width, height) {
        this.renderTargetA.setSize(width, height);
        this.renderTargetB.setSize(width, height);
        this.fullscreenMaterial.uniforms.resolution.value.set(width, height);
        const poissonDisk = this.generateDenoiseSamples(this.samples, this.rings, this.radius, new three_1.Vector2(1 / width, 1 / height));
        const sampleDefine = `const int samples = ${this.samples};\n`;
        const poissonDiskConstant = this.generatePoissonDiskConstant(poissonDisk);
        this.fullscreenMaterial.fragmentShader = sampleDefine + poissonDiskConstant + '\n' + finalFragmentShader;
        this.fullscreenMaterial.needsUpdate = true;
    }
}
exports.PoissionDenoisePass = PoissionDenoisePass;
// #region Properties (11)
PoissionDenoisePass.DefaultOptions = defaultPoissonBlurOptions;
//# sourceMappingURL=PoissionDenoisePass.js.map

/***/ }),

/***/ 47779:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.poissionDenoise = void 0;
exports.poissionDenoise = `
varying vec2 vUv;

uniform sampler2D inputTexture;
uniform highp sampler2D depthTexture;
uniform sampler2D normalTexture;
uniform mat4 projectionMatrixInverse;
uniform mat4 cameraMatrixWorld;
uniform float lumaPhi;
uniform float depthPhi;
uniform float normalPhi;
uniform float distance;
uniform sampler2D blueNoiseTexture;
uniform vec2 blueNoiseRepeat;
uniform int index;
uniform vec2 resolution;

#include <common>
#include <sampleBlueNoise>

vec3 getWorldPos(float depth, vec2 coord) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
    vec4 viewSpacePosition = projectionMatrixInverse * clipSpacePosition;

    // Perspective division
    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;
    worldSpacePosition.xyz /= worldSpacePosition.w;
    return worldSpacePosition.xyz;
}

#define luminance(a) dot(vec3(0.2125, 0.7154, 0.0721), a)

vec3 getNormal(vec2 uv, vec4 texel) {
#ifdef NORMAL_IN_RGB
    // in case the normal is stored in the RGB channels of the texture
    return texel.rgb;
#else
    return normalize(textureLod(normalTexture, uv, 0.).xyz * 2.0 - 1.0);
#endif
}

float distToPlane(const vec3 worldPos, const vec3 neighborWorldPos, const vec3 worldNormal) {
    vec3 toCurrent = worldPos - neighborWorldPos;
    float distToPlane = abs(dot(toCurrent, worldNormal));

    return distToPlane;
}

void main() {
    vec4 depthTexel = textureLod(depthTexture, vUv, 0.);

    if (depthTexel.r == 1.0 || dot(depthTexel.rgb, depthTexel.rgb) == 0.) {
        discard;
        return;
    }

    vec4 texel = textureLod(inputTexture, vUv, 0.0);

    vec3 normal = getNormal(vUv, texel);

#ifdef NORMAL_IN_RGB
    float denoised = texel.a;
    float center = texel.a;
#else
    vec3 denoised = texel.rgb;
    vec3 center = texel.rgb;
#endif

    float depth = depthTexel.x;
    vec3 worldPos = getWorldPos(depth, vUv);

    float totalWeight = 1.0;

    vec4 blueNoise = sampleBlueNoise(blueNoiseTexture, 0, blueNoiseRepeat, resolution);
    float angle = blueNoise[index];

    float s = sin(angle), c = cos(angle);

    mat2 rotationMatrix = mat2(c, -s, s, c);

    for (int i = 0; i < samples; i++) {
        vec2 offset = rotationMatrix * poissonDisk[i];
        vec2 neighborUv = vUv + offset;

        vec4 neighborTexel = textureLod(inputTexture, neighborUv, 0.0);

        vec3 neighborNormal = getNormal(neighborUv, neighborTexel);
#ifdef NORMAL_IN_RGB
        float neighborColor = neighborTexel.a;
#else
        vec3 neighborColor = neighborTexel.rgb;
#endif

        float sampleDepth = textureLod(depthTexture, neighborUv, 0.0).x;

        vec3 worldPosSample = getWorldPos(sampleDepth, neighborUv);
        float tangentPlaneDist = abs(dot(worldPos - worldPosSample, normal));

        float normalDiff = dot(normal, neighborNormal);
        float normalSimilarity = pow(max(normalDiff, 0.), normalPhi);

#ifdef NORMAL_IN_RGB
        float lumaDiff = abs(neighborColor - center);
#else
        float lumaDiff = abs(luminance(neighborColor) - luminance(center));
#endif
        float lumaSimilarity = max(1.0 - lumaDiff / lumaPhi, 0.0);

        float depthDiff = 1. - (distToPlane(worldPos, worldPosSample, normal) / distance);
        float depthSimilarity = max(depthDiff / depthPhi, 0.);

        float w = lumaSimilarity * depthSimilarity * normalSimilarity;

        denoised += w * neighborColor;
        totalWeight += w;
    }

    if (totalWeight > 0.) denoised /= totalWeight;

#ifdef NORMAL_IN_RGB
    gl_FragColor = vec4(normal, denoised);
#else
    gl_FragColor = vec4(denoised, 1.);
#endif
}
`;
//# sourceMappingURL=poissionDenoise.js.map

/***/ }),

/***/ 85120:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSAOEffect = void 0;
const three_1 = __webpack_require__(39437);
const AOEffect_1 = __webpack_require__(94296);
const AOPass_1 = __webpack_require__(18484);
const ssao_1 = __webpack_require__(81275);
class SSAOPass extends AOPass_1.AOPass {
    // #region Constructors (1)
    constructor(camera, scene) {
        super(camera, scene, ssao_1.ssao);
    }
}
class SSAOEffect extends AOEffect_1.AOEffect {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(composer, camera, scene, options) {
        super(composer, camera, scene, new SSAOPass(camera, scene), options);
        // #region Properties (1)
        this.spp = 16;
        SSAOEffect.DefaultOptions = Object.assign(Object.assign({}, AOEffect_1.AOEffect.DefaultOptions), {
            spp: 16,
            distance: 1,
            distancePower: 0.25,
            power: 2
        });
        options = Object.assign(Object.assign({}, SSAOEffect.DefaultOptions), options);
    }
    // #endregion Constructors (1)
    // #region Public Methods (2)
    getPointsOnSphere(n) {
        const points = [];
        const inc = Math.PI * (3 - Math.sqrt(5));
        const off = 2 / n;
        for (let k = 0; k < n; k++) {
            const y = k * off - 1 + off / 2;
            const r = Math.sqrt(1 - y * y);
            const phi = k * inc;
            points.push(new three_1.Vector3(Math.cos(phi) * r, y, Math.sin(phi) * r));
        }
        return points;
    }
    makeOptionsReactive(options) {
        super.makeOptionsReactive(options);
        for (const key of ['spp']) {
            Object.defineProperty(this, key, {
                get() {
                    return options[key];
                },
                set(value) {
                    if (value === null || value === undefined)
                        return;
                    options[key] = value;
                    switch (key) {
                        case 'spp': {
                            this.aoPass.fullscreenMaterial.defines.spp = value.toFixed(0);
                            const samples = this.getPointsOnSphere(value);
                            const samplesR = [];
                            for (let i = 0; i < value; i++) {
                                samplesR.push((i + 1) / value);
                            }
                            this.aoPass.fullscreenMaterial.uniforms.samples = { value: samples };
                            this.aoPass.fullscreenMaterial.uniforms.samplesR = { value: samplesR };
                            this.aoPass.fullscreenMaterial.needsUpdate = true;
                            break;
                        }
                    }
                },
                configurable: true
            });
        }
        this.spp = options['spp'];
    }
}
exports.SSAOEffect = SSAOEffect;
//# sourceMappingURL=SSAOEffect.js.map

/***/ }),

/***/ 81275:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ssao = void 0;
exports.ssao = `
varying vec2 vUv;

uniform highp sampler2D depthTexture;
uniform sampler2D normalTexture;
uniform mat4 projectionViewMatrix;
uniform mat4 cameraMatrixWorld;

uniform sampler2D blueNoiseTexture;
uniform vec2 blueNoiseRepeat;
uniform vec2 texSize;
uniform mat4 projectionMatrixInverse;

uniform float aoDistance;
uniform float distancePower;
uniform float cameraNear;
uniform float cameraFar;
uniform int frame;

uniform vec3[spp] samples;
uniform float[spp] samplesR;

#include <common>
#include <packing>
#include <sampleBlueNoise>

// source: https://github.com/N8python/ssao/blob/master/EffectShader.js#L52
vec3 getWorldPos(const float depth, const vec2 coord) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
    vec4 viewSpacePosition = projectionMatrixInverse * clipSpacePosition;

    // Perspective division
    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;
    worldSpacePosition.xyz /= worldSpacePosition.w;

    return worldSpacePosition.xyz;
}

vec3 computeNormal(vec3 worldPos, vec2 vUv) {
    vec2 size = vec2(textureSize(depthTexture, 0));
    ivec2 p = ivec2(vUv * size);
    float c0 = texelFetch(depthTexture, p, 0).x;
    float l2 = texelFetch(depthTexture, p - ivec2(2, 0), 0).x;
    float l1 = texelFetch(depthTexture, p - ivec2(1, 0), 0).x;
    float r1 = texelFetch(depthTexture, p + ivec2(1, 0), 0).x;
    float r2 = texelFetch(depthTexture, p + ivec2(2, 0), 0).x;
    float b2 = texelFetch(depthTexture, p - ivec2(0, 2), 0).x;
    float b1 = texelFetch(depthTexture, p - ivec2(0, 1), 0).x;
    float t1 = texelFetch(depthTexture, p + ivec2(0, 1), 0).x;
    float t2 = texelFetch(depthTexture, p + ivec2(0, 2), 0).x;
    float dl = abs((2.0 * l1 - l2) - c0);
    float dr = abs((2.0 * r1 - r2) - c0);
    float db = abs((2.0 * b1 - b2) - c0);
    float dt = abs((2.0 * t1 - t2) - c0);
    vec3 ce = getWorldPos(c0, vUv).xyz;
    vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / size.x, 0.0))).xyz
                          : -ce + getWorldPos(r1, (vUv + vec2(1.0 / size.x, 0.0))).xyz;
    vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / size.y))).xyz
                          : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / size.y))).xyz;
    return normalize(cross(dpdx, dpdy));
}

highp float linearize_depth(highp float d, highp float zNear, highp float zFar) {
    highp float z_n = 2.0 * d - 1.0;
    return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));
}

void main() {
    float depth = textureLod(depthTexture, vUv, 0.).x;

    // filter out background
    if (depth == 1.0) {
        discard;
        return;
    }

    vec3 worldPos = getWorldPos(depth, vUv);
    vec3 normal = computeNormal(worldPos, vUv);

#ifdef animatedNoise
    int seed = frame;
#else
    int seed = 0;
#endif

    vec4 noise = sampleBlueNoise(blueNoiseTexture, seed, blueNoiseRepeat, texSize);

    vec3 randomVec = normalize(noise.rgb * 2.0 - 1.0);
    vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));
    vec3 bitangent = cross(normal, tangent);
    mat3 tbn = mat3(tangent, bitangent, normal);

    float occluded = 0.0;
    float totalWeight = 0.0;

    vec3 samplePos;

    float sppF = float(spp);

    for (float i = 0.0; i < sppF; i++) {
        vec3 sampleDirection = tbn * samples[int(i)];

        // make sure sample direction is in the same hemisphere as the normal
        if (dot(sampleDirection, normal) < 0.0) sampleDirection *= -1.0;

        float moveAmt = samplesR[int(mod(i + noise.a * sppF, sppF))];
        samplePos = worldPos + aoDistance * moveAmt * sampleDirection;

        vec4 offset = projectionViewMatrix * vec4(samplePos, 1.0);
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5 + 0.5;

        float sampleDepth = textureLod(depthTexture, offset.xy, 0.0).x;

        float distSample = linearize_depth(sampleDepth, cameraNear, cameraFar);
        float distWorld = linearize_depth(offset.z, cameraNear, cameraFar);

        float rangeCheck = smoothstep(0.0, 1.0, aoDistance / abs(distSample - distWorld));
        rangeCheck = pow(rangeCheck, distancePower);
        float weight = dot(sampleDirection, normal);

        occluded += rangeCheck * weight * (distSample < distWorld ? 1.0 : 0.0);
        totalWeight += weight;
    }

    float occ = clamp(1.0 - occluded / totalWeight, 0.0, 1.0);
    gl_FragColor = vec4(normal, occ);
}
`;
//# sourceMappingURL=ssao.js.map

/***/ }),

/***/ 58676:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.basic = void 0;
exports.basic = `
varying vec2 vUv;

void main() {
    vUv = position.xy * 0.5 + 0.5;
    gl_Position = vec4(position.xy, 1.0, 1.0);
}
`;
//# sourceMappingURL=basic.js.map

/***/ }),

/***/ 18130:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sampleBlueNoise = void 0;
exports.sampleBlueNoise = `
const float g = 1.6180339887498948482;
const float a1 = 1.0 / g;

// reference: https://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/
float r1(float n) {
    // 7th harmonious number
    return fract(1.1127756842787055 + a1 * n);
}

const vec4 hn = vec4(0.618033988749895, 0.3247179572447458, 0.2207440846057596, 0.1673039782614187);

vec4 sampleBlueNoise(sampler2D texture, int seed, vec2 repeat, vec2 texSize) {
    vec2 size = vUv * texSize;
    vec2 blueNoiseSize = texSize / repeat;
    float blueNoiseIndex = floor(floor(size.y / blueNoiseSize.y) * repeat.x) + floor(size.x / blueNoiseSize.x);

    // get the offset of this pixel's blue noise tile
    // int blueNoiseTileOffset = int(r1(blueNoiseIndex + 1.0) * 65536.);

    vec2 blueNoiseUv = vUv * repeat;

    // fetch blue noise for this pixel
    vec4 blueNoise = textureLod(texture, blueNoiseUv, 0.);

    // animate blue noise
    if (seed != 0) {
        blueNoise = fract(blueNoise + hn * float(seed));

        blueNoise.r = (blueNoise.r > 0.5 ? 1.0 - blueNoise.r : blueNoise.r) * 2.0;
        blueNoise.g = (blueNoise.g > 0.5 ? 1.0 - blueNoise.g : blueNoise.g) * 2.0;
        blueNoise.b = (blueNoise.b > 0.5 ? 1.0 - blueNoise.b : blueNoise.b) * 2.0;
        blueNoise.a = (blueNoise.a > 0.5 ? 1.0 - blueNoise.a : blueNoise.a) * 2.0;
    }

    return blueNoise;
}
`;
//# sourceMappingURL=sampleBlueNoise.js.map

/***/ }),

/***/ 397:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CopyMaterial = void 0;
const three_1 = __webpack_require__(39437);
const vertexShader = `
varying vec2 vUv;

void main() {

	vUv = position.xy * 0.5 + 0.5;
	gl_Position = vec4(position.xy, 1.0, 1.0);

}
`;
const fragmentShader = `
#include <common>
#include <dithering_pars_fragment>

#ifdef FRAMEBUFFER_PRECISION_HIGH

	uniform mediump sampler2D inputBuffer;

#else

	uniform lowp sampler2D inputBuffer;

#endif

uniform float opacity;

varying vec2 vUv;

void main() {

	vec4 texel = texture2D(inputBuffer, vUv);
	gl_FragColor = opacity * texel;

	#include <colorspace_fragment>
	#include <dithering_fragment>

}
`;
/**
 * A simple copy shader material.
 */
class CopyMaterial extends three_1.ShaderMaterial {
    /**
     * Constructs a new copy material.
     */
    constructor() {
        super({
            name: "CopyMaterial",
            uniforms: {
                inputBuffer: new three_1.Uniform(null),
                opacity: new three_1.Uniform(1.0)
            },
            blending: three_1.CustomBlending,
            blendEquation: three_1.AddEquation,
            blendDst: three_1.ZeroFactor,
            blendSrc: three_1.OneFactor,
            toneMapped: false,
            depthWrite: false,
            depthTest: false,
            transparent: true,
            fragmentShader,
            vertexShader
        });
    }
    /**
     * The input buffer.
     *
     * @type {Texture}
     */
    set inputBuffer(value) {
        this.uniforms.inputBuffer.value = value;
    }
    /**
     * Sets the input buffer.
     *
     * @deprecated Use inputBuffer instead.
     * @param {Number} value - The buffer.
     */
    setInputBuffer(value) {
        this.uniforms.inputBuffer.value = value;
    }
    /**
     * Returns the opacity.
     *
     * @deprecated Use opacity instead.
     * @return {Number} The opacity.
     */
    getOpacity(value) {
        return this.uniforms.opacity.value;
    }
    /**
     * Sets the opacity.
     *
     * @deprecated Use opacity instead.
     * @param {Number} value - The opacity.
     */
    setOpacity(value) {
        this.uniforms.opacity.value = value;
    }
}
exports.CopyMaterial = CopyMaterial;
//# sourceMappingURL=CopyMaterial.js.map

/***/ }),

/***/ 74841:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CopyShader = void 0;
exports.CopyShader = {
    name: 'CopyShader',
    uniforms: {
        'tDiffuse': { value: null },
        'opacity': { value: 1.0 }
    },
    vertexShader: /* glsl */ `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: /* glsl */ `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`
};
//# sourceMappingURL=CopyShader.js.map

/***/ }),

/***/ 73987:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// Helper for passes that need to fill the viewport with a single quad.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullScreenQuad = void 0;
const three_1 = __webpack_require__(39437);
const _camera = new three_1.OrthographicCamera(-1, 1, 1, -1, 0, 1);
// https://github.com/mrdoob/three.js/pull/21358
const _geometry = new three_1.BufferGeometry();
_geometry.setAttribute('position', new three_1.Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
_geometry.setAttribute('uv', new three_1.Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
class FullScreenQuad {
    constructor(material) {
        this._mesh = new three_1.Mesh(_geometry, material);
    }
    dispose() {
        this._mesh.geometry.dispose();
    }
    render(renderer) {
        renderer.render(this._mesh, _camera);
    }
    get material() {
        return this._mesh.material;
    }
    set material(value) {
        this._mesh.material = value;
    }
}
exports.FullScreenQuad = FullScreenQuad;
//# sourceMappingURL=FullScreenQuad.js.map

/***/ }),

/***/ 79191:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NormalPass = void 0;
const postprocessing_1 = __webpack_require__(66739);
const three_1 = __webpack_require__(39437);
const RenderPass_1 = __webpack_require__(25472);
/**
 * A pass that renders the normals of a given scene.
 */
class NormalPass extends postprocessing_1.Pass {
    /**
     * Constructs a new normal pass.
     *
     * @param {Scene} scene - The scene to render.
     * @param {Camera} camera - The camera to use to render the scene.
     * @param {Object} [options] - The options.
     * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
     * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
     * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
     * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
     * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
     * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
     */
    constructor(scene, camera, { renderTarget, resolutionScale = 1.0, width = postprocessing_1.Resolution.AUTO_SIZE, height = postprocessing_1.Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}) {
        super("NormalPass");
        this.needsSwap = false;
        /**
         * A render pass.
         *
         * @type {RenderPass}
         * @private
         */
        this.renderPass = new RenderPass_1.RenderPass(scene, camera, new three_1.MeshNormalMaterial());
        const renderPass = this.renderPass;
        renderPass.ignoreBackground = true;
        renderPass.skipShadowMapUpdate = true;
        const clearPass = renderPass.getClearPass();
        clearPass.overrideClearColor = new three_1.Color(0x7777ff);
        clearPass.overrideClearAlpha = 1.0;
        /**
         * A render target for the scene normals.
         *
         * @type {WebGLRenderTarget}
         * @readonly
         */
        this.renderTarget = renderTarget;
        if (this.renderTarget === undefined) {
            this.renderTarget = new three_1.WebGLRenderTarget(1, 1, {
                minFilter: three_1.NearestFilter,
                magFilter: three_1.NearestFilter
            });
            this.renderTarget.texture.name = "NormalPass.Target";
        }
        this.dTexture = new three_1.DepthTexture(1, 1);
        // Hack: Make sure the input buffer uses the depth texture.
        this.renderTarget.depthTexture = this.dTexture;
        this.renderTarget.dispose();
        if (this.renderTarget.stencilBuffer) {
            this.dTexture.format = three_1.DepthStencilFormat;
            this.dTexture.type = three_1.UnsignedInt248Type;
        }
        else {
            this.dTexture.type = three_1.UnsignedIntType;
        }
        /**
         * The resolution.
         *
         * @type {Resolution}
         * @readonly
         */
        const resolution = this.resolution = new postprocessing_1.Resolution(this, resolutionX, resolutionY, resolutionScale);
        resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    }
    set mainScene(value) {
        this.renderPass.mainScene = value;
    }
    set mainCamera(value) {
        this.renderPass.mainCamera = value;
    }
    /**
     * The normal texture.
     *
     * @type {Texture}
     */
    get texture() {
        var _a;
        return (_a = this.renderTarget) === null || _a === void 0 ? void 0 : _a.texture;
    }
    get depthTexture() {
        var _a;
        return (_a = this.renderTarget) === null || _a === void 0 ? void 0 : _a.depthTexture;
    }
    /**
     * The normal texture.
     *
     * @deprecated Use texture instead.
     * @return {Texture} The texture.
     */
    getTexture() {
        var _a;
        return (_a = this.renderTarget) === null || _a === void 0 ? void 0 : _a.texture;
    }
    /**
     * Returns the resolution settings.
     *
     * @deprecated Use resolution instead.
     * @return {Resolution} The resolution.
     */
    getResolution() {
        return this.resolution;
    }
    /**
     * Returns the current resolution scale.
     *
     * @return {Number} The resolution scale.
     * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.
     */
    getResolutionScale() {
        return this.resolution.scale;
    }
    /**
     * Sets the resolution scale.
     *
     * @param {Number} scale - The new resolution scale.
     * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.
     */
    setResolutionScale(scale) {
        this.resolution.scale = scale;
    }
    /**
     * Renders the scene normals.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */
    render(renderer) {
        const renderTarget = this.renderToScreen ? null : this.renderTarget;
        this.renderPass.render(renderer, renderTarget, renderTarget, 0, true);
    }
    /**
     * Updates the size of this pass.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */
    setSize(width, height) {
        var _a;
        const resolution = this.resolution;
        resolution.setBaseSize(width, height);
        (_a = this.renderTarget) === null || _a === void 0 ? void 0 : _a.setSize(resolution.width, resolution.height);
    }
}
exports.NormalPass = NormalPass;
//# sourceMappingURL=NormalPass.js.map

/***/ }),

/***/ 25472:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * A pass that renders a given scene into the input buffer or to screen.
 *
 * This pass uses a {@link ClearPass} to clear the target buffer.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenderPass = void 0;
const postprocessing_1 = __webpack_require__(66739);
const three_1 = __webpack_require__(39437);
const GemMaterial_1 = __webpack_require__(75655);
class RenderPass extends postprocessing_1.Pass {
    /**
     * Constructs a new render pass.
     *
     * @param {Scene} scene - The scene to render.
     * @param {Camera} camera - The camera to use to render the scene.
     * @param {Material} [overrideMaterial=null] - An override material.
     */
    constructor(scene, camera, overrideMaterial = null) {
        super("RenderPass", scene, camera);
        this.needsSwap = false;
        /**
         * A clear pass.
         *
         * @type {ClearPass}
         * @readonly
         */
        this.clearPass = new postprocessing_1.ClearPass();
        /**
         * An override material manager.
         *
         * @type {OverrideMaterialManager}
         * @private
         */
        this.overrideMaterialManager = (overrideMaterial === null) ? null : new postprocessing_1.OverrideMaterialManager(overrideMaterial);
        /**
         * Indicates whether the scene background should be ignored.
         *
         * @type {Boolean}
         */
        this.ignoreBackground = false;
        /**
         * Indicates whether the shadow map auto update should be skipped.
         *
         * @type {Boolean}
         */
        this.skipShadowMapUpdate = false;
        /**
         * A selection of objects to render.
         *
         * @type {Selection}
         * @readonly
         */
        this.selection = null;
    }
    set mainScene(value) {
        this.scene = value;
    }
    set mainCamera(value) {
        this.camera = value;
    }
    get renderToScreen() {
        return super.renderToScreen;
    }
    set renderToScreen(value) {
        super.renderToScreen = value;
        this.clearPass.renderToScreen = value;
    }
    /**
     * The current override material.
     *
     * @type {Material}
     */
    get overrideMaterial() {
        const manager = this.overrideMaterialManager;
        return (manager !== null) ? manager.material : null;
    }
    set overrideMaterial(value) {
        const manager = this.overrideMaterialManager;
        if (value !== null) {
            if (manager !== null) {
                manager.setMaterial(value);
            }
            else {
                this.overrideMaterialManager = new postprocessing_1.OverrideMaterialManager(value);
            }
        }
        else if (manager !== null) {
            manager.dispose();
            this.overrideMaterialManager = null;
        }
    }
    /**
     * Returns the current override material.
     *
     * @deprecated Use overrideMaterial instead.
     * @return {Material} The material.
     */
    getOverrideMaterial() {
        return this.overrideMaterial;
    }
    /**
     * Sets the override material.
     *
     * @deprecated Use overrideMaterial instead.
     * @return {Material} value - The material.
     */
    setOverrideMaterial(value) {
        this.overrideMaterial = value;
    }
    /**
     * Indicates whether the target buffer should be cleared before rendering.
     *
     * @type {Boolean}
     * @deprecated Use clearPass.enabled instead.
     */
    get clear() {
        return this.clearPass.enabled;
    }
    set clear(value) {
        this.clearPass.enabled = value;
    }
    /**
     * Returns the selection. Default is `null` (no restriction).
     *
     * @deprecated Use selection instead.
     * @return {Selection} The selection.
     */
    getSelection() {
        return this.selection;
    }
    /**
     * Sets the selection. Set to `null` to disable.
     *
     * @deprecated Use selection instead.
     * @param {Selection} value - The selection.
     */
    setSelection(value) {
        this.selection = value;
    }
    /**
     * Indicates whether the scene background is disabled.
     *
     * @deprecated Use ignoreBackground instead.
     * @return {Boolean} Whether the scene background is disabled.
     */
    isBackgroundDisabled() {
        return this.ignoreBackground;
    }
    /**
     * Enables or disables the scene background.
     *
     * @deprecated Use ignoreBackground instead.
     * @param {Boolean} value - Whether the scene background should be disabled.
     */
    setBackgroundDisabled(value) {
        this.ignoreBackground = value;
    }
    /**
     * Indicates whether the shadow map auto update is disabled.
     *
     * @deprecated Use skipShadowMapUpdate instead.
     * @return {Boolean} Whether the shadow map update is disabled.
     */
    isShadowMapDisabled() {
        return this.skipShadowMapUpdate;
    }
    /**
     * Enables or disables the shadow map auto update.
     *
     * @deprecated Use skipShadowMapUpdate instead.
     * @param {Boolean} value - Whether the shadow map auto update should be disabled.
     */
    setShadowMapDisabled(value) {
        this.skipShadowMapUpdate = value;
    }
    /**
     * Returns the clear pass.
     *
     * @deprecated Use clearPass.enabled instead.
     * @return {ClearPass} The clear pass.
     */
    getClearPass() {
        return this.clearPass;
    }
    /**
     * Renders the scene.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */
    render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
        const materialsNotRenderer = [];
        this.scene.traverse(function (object) {
            if (object.visible === true) {
                if (object instanceof three_1.Mesh && object.material) {
                    if (object.material instanceof three_1.MeshPhysicalMaterial && !(object.material instanceof GemMaterial_1.GemMaterial) && object.material.transparent) {
                        materialsNotRenderer.push(object);
                        object.visible = false;
                    }
                }
                if (object instanceof three_1.Line || object instanceof three_1.LineLoop || object instanceof three_1.LineSegments || object instanceof three_1.Points) {
                    materialsNotRenderer.push(object);
                    object.visible = false;
                }
                if (object.userData.ambientOcclusion === false) {
                    materialsNotRenderer.push(object);
                    object.visible = false;
                }
            }
        });
        const scene = this.scene;
        const camera = this.camera;
        const selection = this.selection;
        const mask = camera.layers.mask;
        const background = scene.background;
        const shadowMapAutoUpdate = renderer.shadowMap.autoUpdate;
        const renderTarget = this.renderToScreen ? null : inputBuffer;
        if (selection !== null) {
            camera.layers.set(selection.getLayer());
        }
        if (this.skipShadowMapUpdate) {
            renderer.shadowMap.autoUpdate = false;
        }
        if (this.ignoreBackground || this.clearPass.overrideClearColor !== null) {
            scene.background = null;
        }
        if (this.clearPass.enabled) {
            this.clearPass.render(renderer, inputBuffer, inputBuffer);
        }
        renderer.setRenderTarget(renderTarget);
        if (this.overrideMaterialManager !== null) {
            this.overrideMaterialManager.render(renderer, scene, camera);
        }
        else {
            renderer.render(scene, camera);
        }
        // Restore original values.
        camera.layers.mask = mask;
        scene.background = background;
        renderer.shadowMap.autoUpdate = shadowMapAutoUpdate;
        for (let i = 0; i < materialsNotRenderer.length; i++)
            materialsNotRenderer[i].visible = true;
    }
}
exports.RenderPass = RenderPass;
//# sourceMappingURL=RenderPass.js.map

/***/ }),

/***/ 75655:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GemMaterial = void 0;
const THREE = __importStar(__webpack_require__(39437));
const three_1 = __webpack_require__(39437);
const gem_1 = __webpack_require__(75414);
class GemMaterial extends three_1.MeshPhysicalMaterial {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(params) {
        super();
        this.refractionIndex = 2.4;
        this.impurityMap = null;
        this.impurityScale = 1.0;
        this.colorTransferBegin = new THREE.Color(0xffffff);
        this.colorTransferEnd = new THREE.Color(0xffffff);
        this.center = new THREE.Vector3(0, 0, 0);
        this.tracingDepth = 5;
        this.radius = 1.0;
        this.sphericalNormalMap = null;
        this.gamma = 1.0;
        this.contrast = 1.0;
        this.brightness = 0.0;
        this.dispersion = 0.0;
        this.tracingOpacity = 0.0;
        this.isGemMaterial = true;
        const uniforms = {
            refractionIndex: { value: 2.4 },
            impurityMap: { value: null },
            impurityScale: { value: 1.0 },
            colorTransferBegin: { value: new THREE.Color(0xffffff) },
            colorTransferEnd: { value: new THREE.Color(0xffffff) },
            center: { value: new THREE.Vector3(0, 0, 0) },
            tracingDepth: { value: 5 },
            radius: { value: 1.0 },
            sphericalNormalMap: { value: null },
            gamma: { value: 1.0 },
            contrast: { value: 1.0 },
            brightness: { value: 0.0 },
            dispersion: { value: 0.0 },
            tracingOpacity: { value: 0.0 }
        };
        this._extraUniforms = uniforms;
        this.onBeforeCompile = function (shader) {
            for (const uniformName in uniforms) {
                shader.uniforms[uniformName] = uniforms[uniformName];
            }
            shader.vertexShader = gem_1.vert;
            shader.fragmentShader = gem_1.frag;
        };
        Object.defineProperties(this, {
            tracingDepth: {
                get: function () {
                    return uniforms.tracingDepth.value;
                },
                set: function (v) {
                    uniforms.tracingDepth.value = v;
                    if (v) {
                        this.defines.TRACING_DEPTH = Math.floor(v);
                    }
                    else {
                        delete this.defines.TRACING_DEPTH;
                    }
                }
            },
            refractionIndex: {
                get: function () {
                    return uniforms.refractionIndex.value;
                },
                set: function (v) {
                    uniforms.refractionIndex.value = v;
                }
            },
            impurityMap: {
                get: function () {
                    return uniforms.impurityMap.value;
                },
                set: function (v) {
                    uniforms.impurityMap.value = v;
                    if (v) {
                        this.defines.USE_IMPURITYMAP = '';
                        this.defines.USE_UV = '';
                    }
                    else {
                        delete this.defines.USE_IMPURITYMAP;
                        delete this.defines.USE_UV;
                    }
                }
            },
            impurityScale: {
                get: function () {
                    return uniforms.impurityScale.value;
                },
                set: function (v) {
                    uniforms.impurityScale.value = v;
                }
            },
            colorTransferBegin: {
                get: function () {
                    return uniforms.colorTransferBegin.value;
                },
                set: function (v) {
                    uniforms.colorTransferBegin.value = v;
                }
            },
            colorTransferEnd: {
                get: function () {
                    return uniforms.colorTransferEnd.value;
                },
                set: function (v) {
                    uniforms.colorTransferEnd.value = v;
                }
            },
            center: {
                get: function () {
                    return uniforms.center.value;
                },
                set: function (v) {
                    uniforms.center.value = v;
                }
            },
            radius: {
                get: function () {
                    return uniforms.radius.value;
                },
                set: function (v) {
                    uniforms.radius.value = v;
                }
            },
            sphericalNormalMap: {
                get: function () {
                    return uniforms.sphericalNormalMap.value;
                },
                set: function (v) {
                    uniforms.sphericalNormalMap.value = v;
                    if (v) {
                        this.defines.USE_UV = '';
                    }
                    else {
                        delete this.defines.USE_UV;
                    }
                }
            },
            gamma: {
                get: function () {
                    return uniforms.gamma.value;
                },
                set: function (v) {
                    uniforms.gamma.value = v;
                }
            },
            contrast: {
                get: function () {
                    return uniforms.contrast.value;
                },
                set: function (v) {
                    uniforms.contrast.value = v;
                }
            },
            brightness: {
                get: function () {
                    return uniforms.brightness.value;
                },
                set: function (v) {
                    uniforms.brightness.value = v;
                }
            },
            dispersion: {
                get: function () {
                    return uniforms.dispersion.value;
                },
                set: function (v) {
                    uniforms.dispersion.value = v;
                    if (v !== 0) {
                        this.defines.DISPERSION = '';
                    }
                    else {
                        delete this.defines.DISPERSION;
                    }
                }
            },
            tracingOpacity: {
                get: function () {
                    return uniforms.tracingOpacity.value;
                },
                set: function (v) {
                    uniforms.tracingOpacity.value = v;
                }
            }
        });
        this.refractionIndex = params.refractionIndex || 2.4;
        this.impurityMap = params.impurityMap || null;
        this.impurityScale = params.impurityScale || 1;
        this.colorTransferBegin.copy(params.colorTransferBegin || new THREE.Color(0xffffff));
        this.colorTransferEnd.copy(params.colorTransferEnd || new THREE.Color(0xffffff));
        this.center.copy(params.center || new THREE.Vector3(0, 0, 0));
        this.tracingDepth = params.tracingDepth || 5;
        this.radius = params.radius || 1;
        this.sphericalNormalMap = params.sphericalNormalMap || null;
        this.gamma = params.gamma || 1;
        this.contrast = params.contrast || 1;
        this.brightness = params.brightness || 0;
        this.dispersion = params.dispersion || 0;
        this.tracingOpacity = params.tracingOpacity || 0;
        this.setValues(params);
    }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    copy(s) {
        super.copy(s);
        const source = s;
        this.refractionIndex = source.refractionIndex;
        this.impurityMap = source.impurityMap;
        this.impurityScale = source.impurityScale;
        this.colorTransferBegin.copy(source.colorTransferBegin);
        this.colorTransferEnd.copy(source.colorTransferEnd);
        this.center.copy(source.center);
        this.tracingDepth = source.tracingDepth;
        this.radius = source.radius;
        this.sphericalNormalMap = source.sphericalNormalMap;
        this.gamma = source.gamma;
        this.contrast = source.contrast;
        this.brightness = source.brightness;
        this.dispersion = source.dispersion;
        this.tracingOpacity = source.tracingOpacity;
        return this;
    }
}
exports.GemMaterial = GemMaterial;
//# sourceMappingURL=GemMaterial.js.map

/***/ }),

/***/ 3382:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultiPointsMaterial = void 0;
const THREE = __importStar(__webpack_require__(39437));
const multi_points_1 = __webpack_require__(35940);
// #endregion Interfaces (1)
// #region Classes (1)
class MultiPointsMaterial extends THREE.PointsMaterial {
    // #endregion Properties (22)
    // #region Constructors (1)
    constructor(params) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17;
        super();
        // #region Properties (22)
        this.alphaMap_0 = null;
        this.alphaMap_1 = null;
        this.alphaMap_2 = null;
        this.alphaMap_3 = null;
        this.alphaMap_4 = null;
        this.alphaMap_5 = null;
        this.alphaMap_6 = null;
        this.alphaMap_7 = null;
        this.color_0 = new THREE.Color(0xffffff);
        this.color_1 = new THREE.Color(0xffffff);
        this.color_2 = new THREE.Color(0xffffff);
        this.color_3 = new THREE.Color(0xffffff);
        this.color_4 = new THREE.Color(0xffffff);
        this.color_5 = new THREE.Color(0xffffff);
        this.color_6 = new THREE.Color(0xffffff);
        this.color_7 = new THREE.Color(0xffffff);
        this.map_0 = null;
        this.map_1 = null;
        this.map_2 = null;
        this.map_3 = null;
        this.map_4 = null;
        this.map_5 = null;
        this.map_6 = null;
        this.map_7 = null;
        this.materialIndexDataTexture = null;
        this.materialIndexDataTextureSize = 1024;
        this.sizeAttenuation_0 = false;
        this.sizeAttenuation_1 = false;
        this.sizeAttenuation_2 = false;
        this.sizeAttenuation_3 = false;
        this.sizeAttenuation_4 = false;
        this.sizeAttenuation_5 = false;
        this.sizeAttenuation_6 = false;
        this.sizeAttenuation_7 = false;
        this.size_0 = 1.0;
        this.size_1 = 1.0;
        this.size_2 = 1.0;
        this.size_3 = 1.0;
        this.size_4 = 1.0;
        this.size_5 = 1.0;
        this.size_6 = 1.0;
        this.size_7 = 1.0;
        this.isMultiPointsMaterial = true;
        const uniforms = {
            materialIndexDataTexture: { value: null },
            materialIndexDataTextureSize: { value: 1024 },
            map_0: { value: null },
            color_0: { value: new THREE.Color(0xff0000) },
            alphaMap_0: { value: null },
            size_0: { value: 1.0 },
            sizeAttenuation_0: { value: false },
            map_1: { value: null },
            color_1: { value: new THREE.Color(0x00ff00) },
            alphaMap_1: { value: null },
            size_1: { value: 1.0 },
            sizeAttenuation_1: { value: false },
            map_2: { value: null },
            color_2: { value: new THREE.Color(0x0000ff) },
            alphaMap_2: { value: null },
            size_2: { value: 1.0 },
            sizeAttenuation_2: { value: false },
            map_3: { value: null },
            color_3: { value: new THREE.Color(0x0000ff) },
            alphaMap_3: { value: null },
            size_3: { value: 1.0 },
            sizeAttenuation_3: { value: false },
            map_4: { value: null },
            color_4: { value: new THREE.Color(0x0000ff) },
            alphaMap_4: { value: null },
            size_4: { value: 1.0 },
            sizeAttenuation_4: { value: false },
            map_5: { value: null },
            color_5: { value: new THREE.Color(0x0000ff) },
            alphaMap_5: { value: null },
            size_5: { value: 1.0 },
            sizeAttenuation_5: { value: false },
            map_6: { value: null },
            color_6: { value: new THREE.Color(0x0000ff) },
            alphaMap_6: { value: null },
            size_6: { value: 1.0 },
            sizeAttenuation_6: { value: false },
            map_7: { value: null },
            color_7: { value: new THREE.Color(0x0000ff) },
            alphaMap_7: { value: null },
            size_7: { value: 1.0 },
            sizeAttenuation_7: { value: false }
        };
        this._extraUniforms = uniforms;
        this.onBeforeCompile = function (shader) {
            for (const uniformName in uniforms) {
                shader.uniforms[uniformName] = uniforms[uniformName];
            }
            shader.vertexShader = multi_points_1.vert;
            shader.fragmentShader = multi_points_1.frag;
        };
        Object.defineProperties(this, {
            materialIndexDataTexture: {
                get: function () {
                    return uniforms.materialIndexDataTexture.value;
                },
                set: function (v) {
                    uniforms.materialIndexDataTexture.value = v;
                }
            },
            materialIndexDataTextureSize: {
                get: function () {
                    return uniforms.materialIndexDataTextureSize.value;
                },
                set: function (v) {
                    uniforms.materialIndexDataTextureSize.value = v;
                }
            },
            map_0: {
                get: function () {
                    return uniforms.map_0.value;
                },
                set: function (v) {
                    uniforms.map_0.value = v;
                }
            },
            color_0: {
                get: function () {
                    return uniforms.color_0.value;
                },
                set: function (v) {
                    uniforms.color_0.value = v;
                }
            },
            alphaMap_0: {
                get: function () {
                    return uniforms.alphaMap_0.value;
                },
                set: function (v) {
                    uniforms.alphaMap_0.value = v;
                }
            },
            size_0: {
                get: function () {
                    return uniforms.size_0.value;
                },
                set: function (v) {
                    uniforms.size_0.value = v;
                }
            },
            sizeAttenuation_0: {
                get: function () {
                    return uniforms.sizeAttenuation_0.value;
                },
                set: function (v) {
                    uniforms.sizeAttenuation_0.value = v;
                }
            },
            map_1: {
                get: function () {
                    return uniforms.map_1.value;
                },
                set: function (v) {
                    uniforms.map_1.value = v;
                }
            },
            color_1: {
                get: function () {
                    return uniforms.color_1.value;
                },
                set: function (v) {
                    uniforms.color_1.value = v;
                }
            },
            alphaMap_1: {
                get: function () {
                    return uniforms.alphaMap_1.value;
                },
                set: function (v) {
                    uniforms.alphaMap_1.value = v;
                }
            },
            size_1: {
                get: function () {
                    return uniforms.size_1.value;
                },
                set: function (v) {
                    uniforms.size_1.value = v;
                }
            },
            sizeAttenuation_1: {
                get: function () {
                    return uniforms.sizeAttenuation_1.value;
                },
                set: function (v) {
                    uniforms.sizeAttenuation_1.value = v;
                }
            },
            map_2: {
                get: function () {
                    return uniforms.map_2.value;
                },
                set: function (v) {
                    uniforms.map_2.value = v;
                }
            },
            color_2: {
                get: function () {
                    return uniforms.color_2.value;
                },
                set: function (v) {
                    uniforms.color_2.value = v;
                }
            },
            alphaMap_2: {
                get: function () {
                    return uniforms.alphaMap_2.value;
                },
                set: function (v) {
                    uniforms.alphaMap_2.value = v;
                }
            },
            size_2: {
                get: function () {
                    return uniforms.size_2.value;
                },
                set: function (v) {
                    uniforms.size_2.value = v;
                }
            },
            sizeAttenuation_2: {
                get: function () {
                    return uniforms.sizeAttenuation_2.value;
                },
                set: function (v) {
                    uniforms.sizeAttenuation_2.value = v;
                }
            },
            map_3: {
                get: function () {
                    return uniforms.map_3.value;
                },
                set: function (v) {
                    uniforms.map_3.value = v;
                }
            },
            color_3: {
                get: function () {
                    return uniforms.color_3.value;
                },
                set: function (v) {
                    uniforms.color_3.value = v;
                }
            },
            alphaMap_3: {
                get: function () {
                    return uniforms.alphaMap_3.value;
                },
                set: function (v) {
                    uniforms.alphaMap_3.value = v;
                }
            },
            size_3: {
                get: function () {
                    return uniforms.size_3.value;
                },
                set: function (v) {
                    uniforms.size_3.value = v;
                }
            },
            sizeAttenuation_3: {
                get: function () {
                    return uniforms.sizeAttenuation_3.value;
                },
                set: function (v) {
                    uniforms.sizeAttenuation_3.value = v;
                }
            },
            map_4: {
                get: function () {
                    return uniforms.map_4.value;
                },
                set: function (v) {
                    uniforms.map_4.value = v;
                }
            },
            color_4: {
                get: function () {
                    return uniforms.color_4.value;
                },
                set: function (v) {
                    uniforms.color_4.value = v;
                }
            },
            alphaMap_4: {
                get: function () {
                    return uniforms.alphaMap_4.value;
                },
                set: function (v) {
                    uniforms.alphaMap_4.value = v;
                }
            },
            size_4: {
                get: function () {
                    return uniforms.size_4.value;
                },
                set: function (v) {
                    uniforms.size_4.value = v;
                }
            },
            sizeAttenuation_4: {
                get: function () {
                    return uniforms.sizeAttenuation_4.value;
                },
                set: function (v) {
                    uniforms.sizeAttenuation_4.value = v;
                }
            },
            map_5: {
                get: function () {
                    return uniforms.map_5.value;
                },
                set: function (v) {
                    uniforms.map_5.value = v;
                }
            },
            color_5: {
                get: function () {
                    return uniforms.color_5.value;
                },
                set: function (v) {
                    uniforms.color_5.value = v;
                }
            },
            alphaMap_5: {
                get: function () {
                    return uniforms.alphaMap_5.value;
                },
                set: function (v) {
                    uniforms.alphaMap_5.value = v;
                }
            },
            size_5: {
                get: function () {
                    return uniforms.size_5.value;
                },
                set: function (v) {
                    uniforms.size_5.value = v;
                }
            },
            sizeAttenuation_5: {
                get: function () {
                    return uniforms.sizeAttenuation_5.value;
                },
                set: function (v) {
                    uniforms.sizeAttenuation_5.value = v;
                }
            },
            map_6: {
                get: function () {
                    return uniforms.map_6.value;
                },
                set: function (v) {
                    uniforms.map_6.value = v;
                }
            },
            color_6: {
                get: function () {
                    return uniforms.color_6.value;
                },
                set: function (v) {
                    uniforms.color_6.value = v;
                }
            },
            alphaMap_6: {
                get: function () {
                    return uniforms.alphaMap_6.value;
                },
                set: function (v) {
                    uniforms.alphaMap_6.value = v;
                }
            },
            size_6: {
                get: function () {
                    return uniforms.size_6.value;
                },
                set: function (v) {
                    uniforms.size_6.value = v;
                }
            },
            sizeAttenuation_6: {
                get: function () {
                    return uniforms.sizeAttenuation_6.value;
                },
                set: function (v) {
                    uniforms.sizeAttenuation_6.value = v;
                }
            },
            map_7: {
                get: function () {
                    return uniforms.map_7.value;
                },
                set: function (v) {
                    uniforms.map_7.value = v;
                }
            },
            color_7: {
                get: function () {
                    return uniforms.color_7.value;
                },
                set: function (v) {
                    uniforms.color_7.value = v;
                }
            },
            alphaMap_7: {
                get: function () {
                    return uniforms.alphaMap_7.value;
                },
                set: function (v) {
                    uniforms.alphaMap_7.value = v;
                }
            },
            size_7: {
                get: function () {
                    return uniforms.size_7.value;
                },
                set: function (v) {
                    uniforms.size_7.value = v;
                }
            },
            sizeAttenuation_7: {
                get: function () {
                    return uniforms.sizeAttenuation_7.value;
                },
                set: function (v) {
                    uniforms.sizeAttenuation_7.value = v;
                }
            }
        });
        this.materialIndexDataTexture = (_a = params.materialIndexDataTexture) !== null && _a !== void 0 ? _a : null;
        this.materialIndexDataTextureSize = (_b = params.materialIndexDataTextureSize) !== null && _b !== void 0 ? _b : 1024;
        this.map_0 = (_c = params.map_0) !== null && _c !== void 0 ? _c : null;
        this.color_0 = new THREE.Color((_d = params.color_0) !== null && _d !== void 0 ? _d : 0xffffff);
        this.alphaMap_0 = (_e = params.alphaMap_0) !== null && _e !== void 0 ? _e : null;
        this.size_0 = (_f = params.size_0) !== null && _f !== void 0 ? _f : 1.0;
        this.sizeAttenuation_0 = (_g = params.sizeAttenuation_0) !== null && _g !== void 0 ? _g : false;
        this.map_1 = (_h = params.map_1) !== null && _h !== void 0 ? _h : null;
        this.color_1 = new THREE.Color((_j = params.color_1) !== null && _j !== void 0 ? _j : 0xffffff);
        this.alphaMap_1 = (_k = params.alphaMap_1) !== null && _k !== void 0 ? _k : null;
        this.size_1 = (_l = params.size_1) !== null && _l !== void 0 ? _l : 1.0;
        this.sizeAttenuation_1 = (_m = params.sizeAttenuation_1) !== null && _m !== void 0 ? _m : false;
        this.map_2 = (_o = params.map_2) !== null && _o !== void 0 ? _o : null;
        this.color_2 = new THREE.Color((_p = params.color_2) !== null && _p !== void 0 ? _p : 0xffffff);
        this.alphaMap_2 = (_q = params.alphaMap_2) !== null && _q !== void 0 ? _q : null;
        this.size_2 = (_r = params.size_2) !== null && _r !== void 0 ? _r : 1.0;
        this.sizeAttenuation_2 = (_s = params.sizeAttenuation_2) !== null && _s !== void 0 ? _s : false;
        this.map_3 = (_t = params.map_3) !== null && _t !== void 0 ? _t : null;
        this.color_3 = new THREE.Color((_u = params.color_3) !== null && _u !== void 0 ? _u : 0xffffff);
        this.alphaMap_3 = (_v = params.alphaMap_3) !== null && _v !== void 0 ? _v : null;
        this.size_3 = (_w = params.size_3) !== null && _w !== void 0 ? _w : 1.0;
        this.sizeAttenuation_3 = (_x = params.sizeAttenuation_3) !== null && _x !== void 0 ? _x : false;
        this.map_4 = (_y = params.map_4) !== null && _y !== void 0 ? _y : null;
        this.color_4 = new THREE.Color((_z = params.color_4) !== null && _z !== void 0 ? _z : 0xffffff);
        this.alphaMap_4 = (_0 = params.alphaMap_4) !== null && _0 !== void 0 ? _0 : null;
        this.size_4 = (_1 = params.size_4) !== null && _1 !== void 0 ? _1 : 1.0;
        this.sizeAttenuation_4 = (_2 = params.sizeAttenuation_4) !== null && _2 !== void 0 ? _2 : false;
        this.map_5 = (_3 = params.map_5) !== null && _3 !== void 0 ? _3 : null;
        this.color_5 = new THREE.Color((_4 = params.color_5) !== null && _4 !== void 0 ? _4 : 0xffffff);
        this.alphaMap_5 = (_5 = params.alphaMap_5) !== null && _5 !== void 0 ? _5 : null;
        this.size_5 = (_6 = params.size_5) !== null && _6 !== void 0 ? _6 : 1.0;
        this.sizeAttenuation_5 = (_7 = params.sizeAttenuation_5) !== null && _7 !== void 0 ? _7 : false;
        this.map_6 = (_8 = params.map_6) !== null && _8 !== void 0 ? _8 : null;
        this.color_6 = new THREE.Color((_9 = params.color_6) !== null && _9 !== void 0 ? _9 : 0xffffff);
        this.alphaMap_6 = (_10 = params.alphaMap_6) !== null && _10 !== void 0 ? _10 : null;
        this.size_6 = (_11 = params.size_6) !== null && _11 !== void 0 ? _11 : 1.0;
        this.sizeAttenuation_6 = (_12 = params.sizeAttenuation_6) !== null && _12 !== void 0 ? _12 : false;
        this.map_7 = (_13 = params.map_7) !== null && _13 !== void 0 ? _13 : null;
        this.color_7 = new THREE.Color((_14 = params.color_7) !== null && _14 !== void 0 ? _14 : 0xffffff);
        this.alphaMap_7 = (_15 = params.alphaMap_7) !== null && _15 !== void 0 ? _15 : null;
        this.size_7 = (_16 = params.size_7) !== null && _16 !== void 0 ? _16 : 1.0;
        this.sizeAttenuation_7 = (_17 = params.sizeAttenuation_7) !== null && _17 !== void 0 ? _17 : false;
        this.setValues(params);
    }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    copy(s) {
        super.copy(s);
        const source = s;
        this.materialIndexDataTexture = source.materialIndexDataTexture;
        this.materialIndexDataTextureSize = source.materialIndexDataTextureSize;
        this.map_0 = source.map_0;
        this.color_0.copy(source.color_0);
        this.alphaMap_0 = source.alphaMap_0;
        this.size_0 = source.size_0;
        this.sizeAttenuation_0 = source.sizeAttenuation_0;
        this.map_1 = source.map_1;
        this.color_1.copy(source.color_1);
        this.alphaMap_1 = source.alphaMap_1;
        this.size_1 = source.size_1;
        this.sizeAttenuation_1 = source.sizeAttenuation_1;
        this.map_2 = source.map_2;
        this.color_2.copy(source.color_2);
        this.alphaMap_2 = source.alphaMap_2;
        this.size_2 = source.size_2;
        this.sizeAttenuation_2 = source.sizeAttenuation_2;
        this.map_3 = source.map_3;
        this.color_3.copy(source.color_3);
        this.alphaMap_3 = source.alphaMap_3;
        this.size_3 = source.size_3;
        this.sizeAttenuation_3 = source.sizeAttenuation_3;
        this.map_4 = source.map_4;
        this.color_4.copy(source.color_4);
        this.alphaMap_4 = source.alphaMap_4;
        this.size_4 = source.size_4;
        this.sizeAttenuation_4 = source.sizeAttenuation_4;
        this.map_5 = source.map_5;
        this.color_5.copy(source.color_5);
        this.alphaMap_5 = source.alphaMap_5;
        this.size_5 = source.size_5;
        this.sizeAttenuation_5 = source.sizeAttenuation_5;
        this.map_6 = source.map_6;
        this.color_6.copy(source.color_6);
        this.alphaMap_6 = source.alphaMap_6;
        this.size_6 = source.size_6;
        this.sizeAttenuation_6 = source.sizeAttenuation_6;
        this.map_7 = source.map_7;
        this.color_7.copy(source.color_7);
        this.alphaMap_7 = source.alphaMap_7;
        this.size_7 = source.size_7;
        this.sizeAttenuation_7 = source.sizeAttenuation_7;
        return this;
    }
}
exports.MultiPointsMaterial = MultiPointsMaterial;
// #endregion Classes (1)
//# sourceMappingURL=MultiPointsMaterial.js.map

/***/ }),

/***/ 16871:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpecularGlossinessMaterial = void 0;
const THREE = __importStar(__webpack_require__(39437));
const three_1 = __webpack_require__(39437);
class SpecularGlossinessMaterial extends three_1.MeshStandardMaterial {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(params) {
        super();
        this.isGLTFSpecularGlossinessMaterial = true;
        //various chunks that need replacing
        const specularMap2ParsFragmentChunk = [
            '#ifdef USE_SPECULARMAP2',
            '	uniform sampler2D specularMap2;',
            '#endif'
        ].join('\n');
        const glossinessMapParsFragmentChunk = [
            '#ifdef USE_GLOSSINESSMAP',
            '	uniform sampler2D glossinessMap;',
            '#endif'
        ].join('\n');
        const specularMap2FragmentChunk = [
            'vec3 specularFactor = specular;',
            '#ifdef USE_SPECULARMAP2',
            '	vec4 texelSpecular = texture2D( specularMap2, vUv );',
            '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
            '	specularFactor *= texelSpecular.rgb;',
            '#endif'
        ].join('\n');
        const glossinessMapFragmentChunk = [
            'float glossinessFactor = glossiness;',
            '#ifdef USE_GLOSSINESSMAP',
            '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
            '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
            '	glossinessFactor *= texelGlossiness.a;',
            '#endif'
        ].join('\n');
        const lightPhysicalFragmentChunk = [
            'PhysicalMaterial material;',
            'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
            'vec3 dxy = max( abs( dFdx( nonPerturbedNormal  ) ), abs( dFdy( nonPerturbedNormal ) ) );',
            'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
            'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
            'material.roughness += geometryRoughness;',
            'material.roughness = min( material.roughness, 1.0 );',
            'material.specularColor = specularFactor;',
        ].join('\n');
        const uniforms = {
            specular: { value: new THREE.Color().setHex(0xffffff) },
            glossiness: { value: 1 },
            specularMap2: { value: null },
            glossinessMap: { value: null }
        };
        this._extraUniforms = uniforms;
        this.onBeforeCompile = function (shader) {
            for (const uniformName in uniforms) {
                shader.uniforms[uniformName] = uniforms[uniformName];
            }
            shader.fragmentShader = shader.fragmentShader
                .replace('uniform float roughness;', 'uniform vec3 specular;')
                .replace('uniform float metalness;', 'uniform float glossiness;')
                .replace('#include <roughnessmap_pars_fragment>', specularMap2ParsFragmentChunk)
                .replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk)
                .replace('#include <roughnessmap_fragment>', specularMap2FragmentChunk)
                .replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk)
                .replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);
        };
        Object.defineProperties(this, {
            specular: {
                get: function () {
                    return uniforms.specular.value;
                },
                set: function (v) {
                    uniforms.specular.value = v;
                }
            },
            specularMap2: {
                get: function () {
                    return uniforms.specularMap2.value;
                },
                set: function (v) {
                    uniforms.specularMap2.value = v;
                    if (v) {
                        this.defines.USE_SPECULARMAP2 = ''; // USE_UV is set by the renderer for specular maps
                    }
                    else {
                        delete this.defines.USE_SPECULARMAP2;
                    }
                }
            },
            glossiness: {
                get: function () {
                    return uniforms.glossiness.value;
                },
                set: function (v) {
                    uniforms.glossiness.value = v;
                }
            },
            glossinessMap: {
                get: function () {
                    return uniforms.glossinessMap.value;
                },
                set: function (v) {
                    uniforms.glossinessMap.value = v;
                    if (v) {
                        this.defines.USE_GLOSSINESSMAP = '';
                        this.defines.USE_UV = '';
                    }
                    else {
                        delete this.defines.USE_GLOSSINESSMAP;
                        delete this.defines.USE_UV;
                    }
                }
            }
        });
        delete this.metalness;
        delete this.roughness;
        delete this.metalnessMap;
        delete this.roughnessMap;
        this.setValues(params);
    }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    copy(source) {
        super.copy(source);
        this.specularMap2 = source.specularMap2;
        this.specular.copy(source.specular);
        this.glossinessMap = source.glossinessMap;
        this.glossiness = source.glossiness;
        delete this.metalness;
        delete this.roughness;
        delete this.metalnessMap;
        delete this.roughnessMap;
        return this;
    }
}
exports.SpecularGlossinessMaterial = SpecularGlossinessMaterial;
//# sourceMappingURL=SpecularGlossinessMaterial.js.map

/***/ }),

/***/ 23438:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SDBone_SDid, _SDBone_SDversion;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SDBone = void 0;
const THREE = __importStar(__webpack_require__(39437));
const three_1 = __webpack_require__(39437);
class SDBone extends three_1.Bone {
    constructor(SDid, SDversion) {
        super();
        // #region Constructors (1)
        _SDBone_SDid.set(this, void 0);
        _SDBone_SDversion.set(this, void 0);
        __classPrivateFieldSet(this, _SDBone_SDid, SDid, "f");
        __classPrivateFieldSet(this, _SDBone_SDversion, SDversion, "f");
    }
    applyTransformation(transformation) {
        this.matrix.identity();
        this.matrixWorld.identity();
        this.position.set(0, 0, 0);
        this.scale.set(1, 1, 1);
        this.quaternion.set(0, 0, 0, 1);
        this.applyMatrix4(new THREE.Matrix4().fromArray(transformation));
    }
    // #endregion Constructors (1)
    // #region Public Accessors (4)
    get SDid() {
        return __classPrivateFieldGet(this, _SDBone_SDid, "f");
    }
    set SDid(value) {
        __classPrivateFieldSet(this, _SDBone_SDid, value, "f");
    }
    get SDversion() {
        return __classPrivateFieldGet(this, _SDBone_SDversion, "f");
    }
    set SDversion(value) {
        __classPrivateFieldSet(this, _SDBone_SDversion, value, "f");
    }
}
exports.SDBone = SDBone;
_SDBone_SDid = new WeakMap(), _SDBone_SDversion = new WeakMap();
//# sourceMappingURL=SDBone.js.map

/***/ }),

/***/ 1161:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SDColor = void 0;
const three_1 = __webpack_require__(39437);
class SDColor extends three_1.Color {
    // #endregion Properties (3)
    // #region Constructors (1)
    constructor(hexColor, originalColor) {
        super(hexColor);
        // #region Properties (3)
        this._colorSpace = 'srgb-linear';
        this._originalColorSpace = 'srgb-linear';
        if (typeof originalColor === 'number' || Array.isArray(originalColor) && (originalColor.length == 3 || originalColor.length == 4)) {
            this._colorSpace = 'srgb-linear';
            this._originalColorSpace = 'srgb-linear';
        }
        else {
            this._colorSpace = 'srgb';
            this._originalColorSpace = 'srgb';
        }
    }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    /**
     * Depending on the current state and provided value, this function converts the color to a different color space.
     *
     * If the color is in 'srgb' space and active is set to true, it will be converted to 'srgb-linear' space.
     * If the color is in 'srgb-linear' space, the color is not originally in 'srgb-linear' and active is set to false, it will be converted to 'srgb' space.
     *
     * @param active
     */
    colorCorrection(active) {
        if (this._colorSpace === 'srgb' && active === true) {
            // we assume all colors provided are in 'srgb' color space
            // therefore we need to correct those colors to 'srgb-linear' if the color conversion is active
            this.convertSRGBToLinear();
            this._colorSpace = 'srgb-linear';
        }
        else if (this._colorSpace === 'srgb-linear' && active === false && this._originalColorSpace !== 'srgb-linear') {
            // if the color space is already 'srgb-linear', the color was already converted
            // therefore we need to convert it back if the color conversion was deactivted
            // if it was not originally in 'srgb-linear'
            this.convertLinearToSRGB();
            this._colorSpace = 'srgb';
        }
    }
}
exports.SDColor = SDColor;
//# sourceMappingURL=SDColor.js.map

/***/ }),

/***/ 85284:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _SDData_SDtype;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SDData = exports.SD_DATA_TYPE = void 0;
const SDObject_1 = __webpack_require__(93867);
var SD_DATA_TYPE;
(function (SD_DATA_TYPE) {
    SD_DATA_TYPE["GEOMETRY"] = "geometry";
    SD_DATA_TYPE["MATERIAL"] = "material";
    SD_DATA_TYPE["THREEJS"] = "threejs";
    SD_DATA_TYPE["LIGHT"] = "light";
    SD_DATA_TYPE["CAMERA"] = "camera";
    SD_DATA_TYPE["ANIMATION"] = "animation";
    SD_DATA_TYPE["INTERACTION"] = "interaction";
    SD_DATA_TYPE["HTML_ELEMENT_ANCHOR"] = "html_element_anchor";
    SD_DATA_TYPE["CUSTOM"] = "custom";
})(SD_DATA_TYPE = exports.SD_DATA_TYPE || (exports.SD_DATA_TYPE = {}));
class SDData extends SDObject_1.SDObject {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(SDid, SDversion) {
        super(SDid, SDversion);
        // #region Properties (1)
        _SDData_SDtype.set(this, SD_DATA_TYPE.CUSTOM);
    }
    // #endregion Constructors (1)
    // #region Public Accessors (2)
    get SDtype() {
        return __classPrivateFieldGet(this, _SDData_SDtype, "f");
    }
    set SDtype(value) {
        __classPrivateFieldSet(this, _SDData_SDtype, value, "f");
    }
}
exports.SDData = SDData;
_SDData_SDtype = new WeakMap();
//# sourceMappingURL=SDData.js.map

/***/ }),

/***/ 93867:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SDObject_SDid, _SDObject_SDversion;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SDObject = void 0;
const THREE = __importStar(__webpack_require__(39437));
const three_1 = __webpack_require__(39437);
class SDObject extends three_1.Object3D {
    constructor(SDid, SDversion) {
        super();
        // #region Constructors (1)
        _SDObject_SDid.set(this, void 0);
        _SDObject_SDversion.set(this, void 0);
        __classPrivateFieldSet(this, _SDObject_SDid, SDid, "f");
        __classPrivateFieldSet(this, _SDObject_SDversion, SDversion, "f");
    }
    applyTransformation(transformation) {
        this.matrix.identity();
        this.matrixWorld.identity();
        this.position.set(0, 0, 0);
        this.scale.set(1, 1, 1);
        this.quaternion.set(0, 0, 0, 1);
        this.applyMatrix4(new THREE.Matrix4().fromArray(transformation));
    }
    // #endregion Constructors (1)
    // #region Public Accessors (4)
    get SDid() {
        return __classPrivateFieldGet(this, _SDObject_SDid, "f");
    }
    set SDid(value) {
        __classPrivateFieldSet(this, _SDObject_SDid, value, "f");
    }
    get SDversion() {
        return __classPrivateFieldGet(this, _SDObject_SDversion, "f");
    }
    set SDversion(value) {
        __classPrivateFieldSet(this, _SDObject_SDversion, value, "f");
    }
    cloneObject() {
        const clone = this.clone();
        clone.SDid = this.SDid;
        clone.SDversion = this.SDversion;
        return clone;
    }
}
exports.SDObject = SDObject;
_SDObject_SDid = new WeakMap(), _SDObject_SDversion = new WeakMap();
//# sourceMappingURL=SDObject.js.map

/***/ }),

/***/ 65642:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.entry = exports.main = void 0;
exports.main = `

uniform float lightSizeUV;
uniform float blending;

#ifdef SHADOWMAP_TYPE_PCF

#define NEAR_PLANE 0.1
#define NUM_SAMPLES 20
#define NUM_RINGS 11

vec2 poissonDisk[NUM_SAMPLES];

void initPoissonSamples( const in vec2 randomSeed ) {
    float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);
    float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);

    // jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
    float angle = rand(randomSeed) * PI2;
    float radius = INV_NUM_SAMPLES;
    float radiusStep = radius;

    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {
        poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);
        radius += radiusStep;
        angle += ANGLE_STEP;
    }
}

float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
    return (zReceiver - zBlocker) / zBlocker;
}

float findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {
    // This uses similar triangles to compute what
    // area of the shadow map we should search
    float searchRadius = lightSizeUV * (zReceiver - NEAR_PLANE) / zReceiver;
    float blockerDepthSum = 0.0;
    int numBlockers = 0;

    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {
        float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));
        if (shadowMapDepth < zReceiver) {
            blockerDepthSum += shadowMapDepth;
            numBlockers++;
        }
    }

    if (numBlockers == 0) return -1.0;

    return blockerDepthSum / float(numBlockers);
}

float PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {
    float sum = 0.0;
    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {
        float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * filterRadius));
        if (zReceiver <= depth) sum += 1.0;
    }
    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {
        float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[i].yx * filterRadius));
        if (zReceiver <= depth) sum += 1.0;
    }
    return sum / (2.0 * float(NUM_SAMPLES));
}

float PCSS(sampler2D shadowMap, vec4 coords) {
    vec2 uv = coords.xy;
    float zReceiver = coords.z; // Assumed to be eye-space z in this code

    initPoissonSamples(uv);
    // STEP 1: blocker search
    float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);

    //There are no occluders so early out (this saves filtering)
    if (avgBlockerDepth == -1.0) return 1.0;

    // STEP 2: penumbra size
    float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
    float filterRadius = penumbraRatio * lightSizeUV * NEAR_PLANE / zReceiver;

    // STEP 3: filtering
    //return avgBlockerDepth;
    return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);
}
#endif
`;
exports.entry = `
// PCSS implementation
vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
float dx = texelSize.x;
float dy = texelSize.y;
vec2 uv = shadowCoord.xy;
vec2 f = fract( uv * shadowMapSize + 0.5 );
uv -= f * texelSize;
float shadow1 = (
    texture2DCompare( shadowMap, uv, shadowCoord.z ) +
    texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
    texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
    texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
    mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
         texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
         f.x ) +
    mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
         texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
         f.x ) +
    mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
         texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
         f.y ) +
    mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
         texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
         f.y ) +
    mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
              texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
              f.x ),
         mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
              texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
              f.x ),
         f.y )
) * ( 1.0 / 9.0 );
float shadow2 = PCSS( shadowMap, shadowCoord );
shadow = shadow1 * (1.0 - blending) + blending * shadow2;
            `;
//# sourceMappingURL=PCSS.js.map

/***/ }),

/***/ 75414:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.frag = exports.vert = void 0;
exports.vert = `
#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// CUSTOM START
varying vec3 frag_position;
varying vec3 frag_normal;
// CUSTOM END

void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
    #ifdef USE_TRANSMISSION
        vWorldPosition = worldPosition.xyz;
    #endif

    // CUSTOM START
    frag_position = position;
    frag_normal = objectNormal;
    // CUSTOM END
}
`;
exports.frag = `
#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif

// CUSTOM START
#ifdef USE_IMPURITYMAP
	uniform sampler2D impurityMap;
#endif
// CUSTOM END

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>



// CUSTOM START

varying vec4 initialPosition;
varying vec3 initialNormal;

varying vec3 frag_position;
varying vec3 frag_normal;

uniform vec3 center;
uniform float radius;
uniform samplerCube sphericalNormalMap;
uniform mat3 normalMatrix;
uniform mat4 modelMatrix;

uniform float impurityScale;
uniform vec3 colorTransferBegin;
uniform vec3 colorTransferEnd;
uniform float refractionIndex;
uniform float gamma;
uniform float contrast;
uniform float brightness;
uniform float dispersion;
uniform float tracingOpacity;


vec3 getIBLRadianceVariation( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
	#if defined( ENVMAP_TYPE_CUBE_UV )
		vec3 reflectVec = reflect( - viewDir, normal );
		// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
		reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		return min(envMapColor.rgb * envMapIntensity, vec3(1.0));
	#else
		return vec3( 0.0 );
	#endif
}

vec3 calculateReflectedLight(vec3 position, vec3 normal, vec3 viewDir, PhysicalMaterial material, int depth) {
	
	vec3 currentGeometryPosition = (modelMatrix * vec4(position, 1.0)).xyz;

	mat3 normalMatrix;
	normalMatrix[0] = normalize(modelMatrix[0].xyz);
	normalMatrix[1] = normalize(modelMatrix[1].xyz);
	normalMatrix[2] = normalize(modelMatrix[2].xyz);
	
	// Calculate the normal vector in world space
	vec3 currentGeometryNormal = normalize(normalMatrix * normal);
	
	// Calculate the view direction vector in world space
	vec3 currentGeometryViewDir = normalize(normalMatrix * -viewDir);

    vec3 currentGeometryClearcoatNormal;
	
	#ifdef USE_CLEARCOAT
        currentGeometryClearcoatNormal = clearcoatNormal;
    #endif

	ReflectedLight rLight;
	IncidentLight dLight;

	float temp = material.roughness;
	material.roughness = 0.5;

	#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

		PointLight pointLight;
        #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
            PointLightShadow pointLightShadow;
        #endif

	    #pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
			pointLight = pointLights[ i ];
            getPointLightInfo( pointLight, currentGeometryPosition, dLight );
            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
                pointLightShadow = pointLightShadows[ i ];
                dLight.color *= all( bvec2( dLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
            #endif
		    RE_Direct( dLight, currentGeometryPosition, currentGeometryNormal, currentGeometryViewDir, currentGeometryClearcoatNormal, material, rLight );
		}
        #pragma unroll_loop_end
	#endif
	#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
        SpotLight spotLight;
        #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
            SpotLightShadow spotLightShadow;
        #endif
        #pragma unroll_loop_start
        for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
            spotLight = spotLights[ i ];
            getSpotLightInfo( spotLight, currentGeometryPosition, dLight );
            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
                spotLightShadow = spotLightShadows[ i ];
                dLight.color *= all( bvec2( dLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
            #endif
            RE_Direct( dLight, currentGeometryPosition, currentGeometryNormal, currentGeometryViewDir, currentGeometryClearcoatNormal, material, rLight );
        }
        #pragma unroll_loop_end
	#endif

    #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
        DirectionalLight directionalLight;
        #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
            DirectionalLightShadow directionalLightShadow;
        #endif
        #pragma unroll_loop_start
        for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
            directionalLight = directionalLights[ i ];
            getDirectionalLightInfo( directionalLight, dLight );
            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
                directionalLightShadow = directionalLightShadows[ i ];
                dLight.color *= all( bvec2( dLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
            #endif
            RE_Direct( dLight, currentGeometryPosition, currentGeometryNormal, currentGeometryViewDir, currentGeometryClearcoatNormal, material, rLight );
        }
        #pragma unroll_loop_end
    #endif
	material.roughness = temp;
	
    #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
        RectAreaLight rectAreaLight;
        #pragma unroll_loop_start
        for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
            rectAreaLight = rectAreaLights[ i ];
            RE_Direct_RectArea( rectAreaLight, currentGeometryPosition, currentGeometryNormal, currentGeometryViewDir, currentGeometryClearcoatNormal, material, rLight );
        }
        #pragma unroll_loop_end
    #endif
    #if defined( RE_IndirectDiffuse )
        vec3 iblIrradiance = vec3( 0.0 );
        vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
		
		#if defined( USE_LIGHT_PROBES )
        	irradiance += getLightProbeIrradiance( lightProbe, currentGeometryNormal );
		#endif
        #if ( NUM_HEMI_LIGHTS > 0 )
            #pragma unroll_loop_start
            for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
                irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], currentGeometryNormal );
            }
            #pragma unroll_loop_end
        #endif
    #endif
    #if defined( RE_IndirectSpecular )
        vec3 radiance = vec3( 0.0 );
        vec3 clearcoatRadiance = vec3( 0.0 );
    #endif


    #if defined( RE_IndirectDiffuse )
        #ifdef USE_LIGHTMAP
            vec4 lightMapTexel = texture2D( lightMap, vUv2 );
            vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
            irradiance += lightMapIrradiance;
        #endif
        #if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
            iblIrradiance += getIBLIrradiance( currentGeometryNormal );
        #endif
    #endif
    #if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
        radiance += getIBLRadianceVariation( currentGeometryViewDir, currentGeometryNormal, material.roughness );
        #ifdef USE_CLEARCOAT
            clearcoatRadiance += getIBLRadianceVariation( currentGeometryViewDir, currentGeometryClearcoatNormal, material.clearcoatRoughness );
        #endif
    #endif

    #if defined( RE_IndirectDiffuse )
        RE_IndirectDiffuse( irradiance, currentGeometryPosition, currentGeometryNormal, currentGeometryViewDir, currentGeometryClearcoatNormal, material, rLight );
    #endif
    #if defined( RE_IndirectSpecular )
        RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, currentGeometryPosition, currentGeometryNormal, currentGeometryViewDir, currentGeometryClearcoatNormal, material, rLight );
    #endif

	if(depth >= 0) {
		float frac = float(depth) / float(TRACING_DEPTH);
		vec3 colorTransfer = (1.0-frac) * colorTransferBegin + frac * colorTransferEnd;
		rLight.indirectSpecular *= colorTransfer;
		rLight.directSpecular *= colorTransfer;
	}

	vec3 color = rLight.indirectSpecular + rLight.directSpecular + rLight.indirectDiffuse + rLight.directDiffuse;

	// gamma
	color = pow(color, vec3(1.0/gamma)); 

	// contrast
	color.rgb = ((color.rgb - 0.5) * max(contrast, 0.0)) + 0.5; 

	// brightness
	color.r = min(max(color.r + brightness, 0.0), 1.0);
	color.g = min(max(color.g + brightness, 0.0), 1.0);
	color.b = min(max(color.b + brightness, 0.0), 1.0);

	return color;
}

vec3 normalLookUp(vec3 dir) {
	vec4 s = textureCube(sphericalNormalMap, dir);
	if(s.a < 1.0/256.0) {
		return normalize(vec3(-s.x, -s.y, -s.z));
	} else if(s.a < 3.0/256.0) {
		return normalize(vec3(-s.x, -s.y, s.z));
	} else if(s.a < 5.0/256.0) {
		return normalize(vec3(-s.x, s.y, -s.z));
	} else if(s.a < 7.0/256.0) {
		return normalize(vec3(s.x, -s.y, -s.z));
	} else if(s.a < 9.0/256.0) {
		return normalize(vec3(-s.x, s.y, s.z));
	} else if(s.a < 11.0/256.0) {
		return normalize(vec3(s.x, -s.y, s.z));
	} else if(s.a < 13.0/256.0) {
		return normalize(vec3(s.x, s.y, -s.z));
	} else {
		return normalize(s.xyz);
	}
}

#ifdef USE_IMPURITYMAP
	float impurityLookUp(vec3 dir) {
		vec3 c = textureCube(impurityMap, dir.xy).rgb;
		return (c.x + c.y + c.z) / 3.0;
	}
#endif

vec3 raySphereIntersection(vec3 o, vec3 d) {

	vec3 oc = o - center;
    float a = dot(d, d);
    float b = 2.0 * dot(oc, d);
    float c = dot(oc,oc) - radius*radius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant < 0.0){
        return vec3(0.0);
    }
    else{
        return o +( (-b + sqrt(discriminant)) / (2.0*a)) * d;
    }
}

vec3 hueToSaturatedColor(float hue) {
    float r,g,b;
    if (hue < 0.25){
		float t = 1.0 - (hue / 0.25);
        r = 1.0;
        g = 1.0;
        b = t;    
	} else if (hue < 0.5){
    	float t = 1.0 - (hue - 0.25 / 0.25);
		r = 1.0;
        g = t;
        b = 0.0;
	} else if (hue < 0.75){
    	float t = 1.0 - (hue - 0.5 / 0.25);
		r = t;
        g = 0.0;
        b = 1.0 - t;
    } else {
    	float t = hue - 0.75 / 0.25;
        r = t;
        g = t;
        b = 1.0;
    }
    return vec3(r, g, b) / 0.5 + 0.5;
}
// CUSTOM END

void main() {    
    // CUSTOM START
    vec3 frag_normal_normalized = frag_normal;
    // CUSTOM END
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>

    // CUSTOM START
	
    // Extract the translation part of the model matrix
	vec3 translation = modelMatrix[3].xyz;

	// Extract the rotation part of the model matrix (3x3 upper-left submatrix)
	mat3 rotationMatrix = mat3(modelMatrix);

	// Calculate the inverse of the rotation matrix (transpose since it's orthogonal)
	mat3 inverseRotationMatrix;
	inverseRotationMatrix[0] = vec3(rotationMatrix[0].x, rotationMatrix[1].x, rotationMatrix[2].x);
	inverseRotationMatrix[1] = vec3(rotationMatrix[0].y, rotationMatrix[1].y, rotationMatrix[2].y);
	inverseRotationMatrix[2] = vec3(rotationMatrix[0].z, rotationMatrix[1].z, rotationMatrix[2].z);

	// Calculate the camera position in model space
	vec3 cameraPositionInModelSpace = inverseRotationMatrix * (cameraPosition - translation);

	// Calculate the initial direction
	vec3 initialDirection = normalize(frag_position.xyz - cameraPositionInModelSpace);

	vec4 outgoingLight2;
	float r_0 = (1.0-refractionIndex)/(1.0+refractionIndex);
	r_0 = r_0*r_0;

	float cos_theta_0 = -dot(initialDirection, frag_normal_normalized);
	float r_0_outside = (refractionIndex-1.0)/(refractionIndex+1.0);
	r_0_outside = r_0_outside*r_0_outside;
	float initialProbability = r_0_outside + (1.0 - r_0_outside)*pow(1.0 - cos_theta_0, 5.0);

	outgoingLight2 = vec4(calculateReflectedLight(frag_position, frag_normal_normalized, initialDirection, material, -1), 1.0);
	// gl_FragColor = outgoingLight2;
	// return;
	if(TRACING_DEPTH > 0) 
		outgoingLight2 *= initialProbability;
		
	vec3 tempColor;

	#ifdef DISPERSION
		const int loop = 3;
		vec3 dispersionColor;
	#else
		const int loop = 1;
	#endif
		#pragma unroll_loop_start
		for(int j = 0; j < loop; j++){
			vec3 refractedDirection = refract(initialDirection, frag_normal_normalized, 1.0/refractionIndex + float(j)*dispersion * 0.025);
			vec3 newPosition = raySphereIntersection(frag_position, refractedDirection);
			vec3 lookUpVector = normalize(newPosition - center);
			vec3 newNormal = normalLookUp(lookUpVector);
			vec3 newDirection = reflect(refractedDirection, newNormal);

			float currentProbability = 1.0;

			#ifdef USE_IMPURITYMAP
				float impurityProbability = impurityLookUp(lookUpVector);
				currentProbability -= impurityProbability * impurityScale;
				// gl_FragColor = vec4(vec3(impurityProbability), 1.0);
				// return;
			#endif
			
			// if(0 == TRACING_DEPTH) {
			// 	gl_FragColor = vec4(0.5 * newNormal + 0.5, 1.0);
			// 	return;
			// }

			tempColor = vec3(0.0);
			#pragma unroll_loop_start
			for(int i = 0; i < TRACING_DEPTH; i++) {
				// small position correction to avoid artefacts
				newPosition = newPosition - lookUpVector * 1e-6;
				newPosition = raySphereIntersection(newPosition, newDirection);
				lookUpVector = normalize(newPosition - center);
				newNormal = normalLookUp(lookUpVector);
			
				float cos_theta = dot(newDirection, newNormal);
				float ratio;
				if(cos_theta > 0.0) {
					ratio = refractionIndex;
				} else {
					cos_theta = -cos_theta;
					ratio = 1.0 / refractionIndex;
				}
				float cos_theta_2 = 1.0 - ratio*ratio * (1.0 - cos_theta*cos_theta);
				float probability = r_0 + (1.0 - r_0)*pow(1.0 - cos_theta, 5.0);
				if(cos_theta_2 < 0.0) probability = 0.0;

				vec3 refracted = refract(newDirection, newNormal*-1.0, 1.0/refractionIndex);
				tempColor += probability * currentProbability * calculateReflectedLight(newPosition, newNormal*-1.0, reflect(refracted, newNormal), material, i);
				if(i+1 == TRACING_DEPTH)
					tempColor += (1.0 - probability) * currentProbability * calculateReflectedLight(newPosition, newNormal, newDirection, material, i);

				newDirection = reflect(newDirection, newNormal);

				// if(i+1 == TRACING_DEPTH) {
				// 	gl_FragColor = vec4(0.5 * newNormal + 0.5, 1.0);
				// 	return;
				// }

				currentProbability *= (1.0 - probability);
			}
			#pragma unroll_loop_end

			#ifdef DISPERSION
				if(j == 0) {
					dispersionColor.r = tempColor.r;	
				} else if(j == 1) {
					dispersionColor.g = tempColor.g;	
				} else if(j == 2) {
					dispersionColor.b = tempColor.b;	
				}
				tempColor = dispersionColor;
			#endif
		}	
		#pragma unroll_loop_end

	if(TRACING_DEPTH > 0)
		outgoingLight2.rgb += (1.0 - initialProbability) * tempColor;

	float alpha = (1.0 - initialProbability) + initialProbability*tracingOpacity;
	gl_FragColor = vec4(outgoingLight2.rgb, alpha*diffuseColor.a);

    // CUSTOM END

	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}

`;
//# sourceMappingURL=gem.js.map

/***/ }),

/***/ 35940:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.frag = exports.vert = void 0;
exports.vert = `
attribute float positionIndex;
flat varying int vMaterialIndex;
flat varying int vPositionIndex;

uniform float size_0;
uniform float size_1;
uniform float size_2;
uniform float size_3;
uniform float size_4;
uniform float size_5;
uniform float size_6;
uniform float size_7;

uniform bool sizeAttenuation_0;
uniform bool sizeAttenuation_1;
uniform bool sizeAttenuation_2;
uniform bool sizeAttenuation_3;
uniform bool sizeAttenuation_4;
uniform bool sizeAttenuation_5;
uniform bool sizeAttenuation_6;
uniform bool sizeAttenuation_7;

uniform highp usampler2D materialIndexDataTexture;

uniform float scale;

float getSize(int materialIndex) {
    if ( materialIndex == 1 ) {
        return size_1;
    } else if ( materialIndex == 2 ) {
        return size_2;
    } else if ( materialIndex == 3 ) {
        return size_3;
    } else if ( materialIndex == 4 ) {
        return size_4;
    } else if ( materialIndex == 5 ) {
        return size_5;
    } else if ( materialIndex == 6 ) {
        return size_6;
    } else if ( materialIndex == 7 ) {
        return size_7;
    } else {
        return size_0;
    }
}

bool getSizeAttenuation(int materialIndex) {
    if ( materialIndex == 1 ) {
        return sizeAttenuation_1;
    } else if ( materialIndex == 2 ) {
        return sizeAttenuation_2;
    } else if ( materialIndex == 3 ) {
        return sizeAttenuation_3;
    } else if ( materialIndex == 4 ) {
        return sizeAttenuation_4;
    } else if ( materialIndex == 5 ) {
        return sizeAttenuation_5;
    } else if ( materialIndex == 6 ) {
        return sizeAttenuation_6;
    } else if ( materialIndex == 7 ) {
        return sizeAttenuation_7;
    } else {
        return sizeAttenuation_0;
    }
}

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_POINTS_UV

	varying vec2 vUv;
	uniform mat3 uvTransform;

#endif

int retrieveMaterialIndex() {
    vec2 uv = vec2(positionIndex/1024.0, 0.5);

    // get the value of a texture at a specific index
    return int(texture2D(materialIndexDataTexture, uv).r);
}

void main() {
    int materialIndex = retrieveMaterialIndex();
    vMaterialIndex = materialIndex;

    float size = getSize(materialIndex);
    bool sizeAttenuation = getSizeAttenuation(materialIndex);

	#ifdef USE_POINTS_UV

		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	#endif

	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

    gl_PointSize = size;

	if(sizeAttenuation) {
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
    }


	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`;
exports.frag = `
uniform vec3 diffuse;
uniform vec3 color_0;
uniform vec3 color_1;
uniform vec3 color_2;
uniform vec3 color_3;
uniform vec3 color_4;
uniform vec3 color_5;
uniform vec3 color_6;
uniform vec3 color_7;


uniform float opacity;
flat varying int vMaterialIndex;
flat varying int vPositionIndex;

#include <common>
#include <color_pars_fragment>

#if defined( USE_POINTS_UV )

	varying vec2 vUv;

#else

	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

		uniform mat3 uvTransform;

	#endif

#endif

#ifdef USE_MAP

	uniform sampler2D map_0;
	uniform sampler2D map_1;
	uniform sampler2D map_2;
	uniform sampler2D map_3;
    uniform sampler2D map_4;
    uniform sampler2D map_5;
    uniform sampler2D map_6;
    uniform sampler2D map_7;

#endif

#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap_0;
    uniform sampler2D alphaMap_1;
    uniform sampler2D alphaMap_2;
    uniform sampler2D alphaMap_3;
    uniform sampler2D alphaMap_4;
    uniform sampler2D alphaMap_5;
    uniform sampler2D alphaMap_6;
    uniform sampler2D alphaMap_7;

#endif


#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );

    vec3 c = vec3(1.0, 0.0, 0.0);
    if ( vMaterialIndex == 1 ) {
        c = color_1;
    } else if ( vMaterialIndex == 2 ) {
        c = color_2;
    } else if ( vMaterialIndex == 3 ) {
        c = color_3;
    } else if ( vMaterialIndex == 4 ) {
        c = color_4;
    } else if ( vMaterialIndex == 5 ) {
        c = color_5;
    } else if ( vMaterialIndex == 6 ) {
        c = color_6;
    } else if ( vMaterialIndex == 7 ) {
        c = color_7;
    } else {
        c = color_0;
    }

	vec4 diffuseColor = vec4( c, opacity );

    


	#include <logdepthbuf_fragment>

    #if defined( USE_MAP ) || defined( USE_ALPHAMAP )

        #if defined( USE_POINTS_UV )

            vec2 uv = vUv;

        #else

            vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

        #endif

    #endif

    #ifdef USE_MAP

        if ( vMaterialIndex == 1 ) {
            diffuseColor *= texture2D( map_1, uv );
        } else if ( vMaterialIndex == 2 ) {
            diffuseColor *= texture2D( map_2, uv );
        } else if ( vMaterialIndex == 3 ) {
            diffuseColor *= texture2D( map_3, uv );
        } else if ( vMaterialIndex == 4 ) {
            diffuseColor *= texture2D( map_4, uv );
        } else if ( vMaterialIndex == 5 ) {
            diffuseColor *= texture2D( map_5, uv );
        } else if ( vMaterialIndex == 6 ) {
            diffuseColor *= texture2D( map_6, uv );
        } else if ( vMaterialIndex == 7 ) {
            diffuseColor *= texture2D( map_7, uv );
        } else {
            diffuseColor *= texture2D( map_0, uv );
        }

    #endif

    #ifdef USE_ALPHAMAP

        if ( vMaterialIndex == 1 ) {
            diffuseColor *= texture2D( alphaMap_1, uv );
        } else if ( vMaterialIndex == 2 ) {
            diffuseColor *= texture2D( alphaMap_2, uv );
        } else if ( vMaterialIndex == 3 ) {
            diffuseColor *= texture2D( alphaMap_3, uv );
        } else if ( vMaterialIndex == 4 ) {
            diffuseColor *= texture2D( alphaMap_4, uv );
        } else if ( vMaterialIndex == 5 ) {
            diffuseColor *= texture2D( alphaMap_5, uv );
        } else if ( vMaterialIndex == 6 ) {
            diffuseColor *= texture2D( alphaMap_6, uv );
        } else if ( vMaterialIndex == 7 ) {
            diffuseColor *= texture2D( alphaMap_7, uv );
        } else {
            diffuseColor *= texture2D( alphaMap_0, uv );
        }

    #endif

	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`;
//# sourceMappingURL=multi_points.js.map

/***/ }),

/***/ 31349:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.css = void 0;
exports.css = `
.sdv-error-message-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
}

.sdv-error-message {
    font-family: "CircularXXWeb-Book", sans-serif;
    font-size: x-large;
    filter: invert(100);
}

.sdv-anchor-container {
    user-select: none;
    cursor: default;
    pointer-events: none;
    overflow: hidden;
    position: absolute;
    width: 100%;
    height: 100%;
    left: 0%;
    top: 0%;
}

.sdv-anchor-inner-container {
    position: absolute;
    white-space: nowrap;
    text-overflow: clip;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}

.sdv-anchor-text {
    user-select: none;
    cursor: default;
    pointer-events: none;
    display: block;
    text-overflow: clip;
    overflow: hidden;
}

.sdv-anchor-image {
    user-select: none;
    cursor: default;
    pointer-events: none;
}

.sdv-logo-container {
    position: relative;
    height: 100%;
    width: 100%;
}

.sdv-logo {
    position: absolute;
    top: 50%;
    left: 50%;
    max-width: calc(100% - 0.5);
    max-height: calc(100% - 0.5);
    transform: translate(-50%, -50%);
}

.sdv-spinner-container {
    position: absolute;
    height: 100%;
    width: 100%;
    top: 0;
    left: 0;
    user-select: none;
    cursor: default;
    pointer-events: none;
}

.sdv-spinner {
    position: absolute;
    max-width: calc(100% * 0.15);
    max-height: calc(100% * 0.15);
    mix-blend-mode: difference;
    filter: invert(1) grayscale(100%);
}

.sdv-spinner-top-left {
    left: calc(100% * 0.01);
    top: calc(100% * 0.01);
    float: left;
}

.sdv-spinner-top-right {
    right: calc(100% * 0.01);
    top: calc(100% * 0.01);
    float: right;
}

.sdv-spinner-bottom-left {
    left: calc(100% * 0.01);
    bottom: calc(100% * 0.01);
    float: left;
}

.sdv-spinner-bottom-right {
    right: calc(100% * 0.01);
    bottom: calc(100% * 0.01);
    float: right;
}

.sdv-spinner-center {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
    `;
//# sourceMappingURL=viewport-css.js.map

/***/ }),

/***/ 10566:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.font = void 0;
// @ts-ignore
exports.font = { "glyphs": { "0": { "ha": 946, "x_min": 0, "x_max": 0, "o": "m 478 88 b 740 472 651 88 740 221 l 740 528 b 475 908 740 758 643 908 b 207 525 307 908 207 769 l 207 469 b 478 88 207 218 313 88 m 478 -12 b 83 468 240 -12 83 179 l 83 524 b 475 1006 83 817 232 1006 b 863 526 719 1006 863 810 l 863 471 b 478 -12 863 182 722 -12 " }, "1": { "ha": 554, "x_min": 0, "x_max": 0, "o": "m 268 874 l 46 714 l 46 826 l 276 993 l 389 993 l 389 0 l 268 0 " }, "2": { "ha": 769, "x_min": 0, "x_max": 0, "o": "m 26 28 l 421 443 b 564 731 511 539 564 629 b 386 908 564 842 499 908 b 176 688 271 908 196 843 l 64 688 b 386 1006 79 882 197 1006 b 686 726 569 1006 686 897 b 486 365 686 604 608 485 l 213 99 l 692 99 l 692 0 l 26 0 " }, "3": { "ha": 839, "x_min": 0, "x_max": 0, "o": "m 403 -12 b 56 293 192 -12 63 119 l 167 293 b 406 85 178 175 249 85 b 632 276 561 85 632 160 b 422 469 632 404 563 469 l 347 469 l 347 571 l 417 571 b 603 740 546 571 603 632 b 422 907 603 835 543 907 b 203 719 299 907 215 832 l 97 719 b 422 1006 104 876 233 1006 b 721 743 611 1006 721 881 b 564 526 721 631 654 564 b 756 276 681 496 756 414 b 403 -12 756 96 608 -12 " }, "4": { "ha": 857, "x_min": 0, "x_max": 0, "o": "m 551 208 l 54 208 l 54 247 l 508 993 l 669 993 l 669 307 l 807 307 l 807 208 l 669 208 l 669 0 l 551 0 m 551 307 l 551 901 l 207 307 " }, "5": { "ha": 815, "x_min": 0, "x_max": 0, "o": "m 390 -12 b 60 268 176 -12 74 106 l 175 268 b 389 85 194 160 238 85 b 607 325 524 85 607 175 b 399 557 607 465 525 557 b 164 461 283 557 217 521 l 119 461 l 119 993 l 678 993 l 678 889 l 219 889 l 219 586 b 422 654 260 624 328 654 b 731 325 600 654 731 528 b 390 -12 731 115 579 -12 " }, "6": { "ha": 860, "x_min": 0, "x_max": 0, "o": "m 440 -12 b 83 439 169 -12 83 190 l 83 463 b 472 1006 83 819 244 1006 b 763 765 626 1006 736 925 l 647 765 b 464 907 625 857 575 907 b 203 510 314 907 208 772 b 458 644 250 590 343 644 b 783 319 656 644 783 501 b 440 -12 783 121 650 -12 m 440 82 b 660 314 571 82 660 174 b 439 550 660 457 574 550 b 211 331 306 550 211 460 b 440 82 211 168 307 82 " }, "7": { "ha": 729, "x_min": 0, "x_max": 0, "o": "m 549 896 l 44 896 l 44 993 l 699 993 l 699 976 l 326 0 l 203 0 " }, "8": { "ha": 843, "x_min": 0, "x_max": 0, "o": "m 422 -12 b 79 282 260 -12 79 85 b 267 539 79 415 161 501 b 117 747 172 575 117 650 b 422 1006 117 908 269 1006 b 726 750 576 1006 726 906 b 574 540 726 650 665 581 b 764 285 689 499 764 413 b 422 -12 764 86 590 -12 m 422 86 b 640 289 544 86 640 157 b 425 486 640 419 543 486 b 203 286 307 486 203 418 b 422 86 203 156 307 86 m 426 582 b 604 749 532 582 604 643 b 422 911 604 844 525 911 b 239 746 319 911 239 849 b 426 582 239 642 325 582 " }, "9": { "ha": 861, "x_min": 0, "x_max": 0, "o": "m 403 -11 b 83 244 219 -11 110 85 l 200 244 b 406 88 222 147 278 88 b 660 482 564 88 657 218 b 403 350 613 401 517 350 b 76 675 210 350 76 488 b 419 1007 76 874 210 1007 b 776 563 654 1007 776 849 l 776 500 b 403 -11 776 171 640 -11 m 421 444 b 649 660 554 444 649 531 b 419 913 649 822 553 913 b 200 681 289 913 200 821 b 421 444 200 538 286 444 " }, " ": { "ha": 368, "x_min": 0, "x_max": 0, "o": "" }, "!": { "ha": 397, "x_min": 0, "x_max": 0, "o": "m 199 -7 b 110 82 150 -7 110 32 b 199 171 110 132 150 171 b 288 82 247 171 288 132 b 199 -7 288 32 247 -7 m 136 993 l 264 993 l 244 281 l 156 281 " }, "\"": { "ha": 521, "x_min": 0, "x_max": 0, "o": "m 85 993 l 210 993 l 189 653 l 106 653 m 311 993 l 436 993 l 415 653 l 332 653 " }, "#": { "ha": 699, "x_min": 0, "x_max": 0, "o": "m 386 392 l 251 392 l 215 138 l 121 138 l 157 392 l 42 392 l 42 489 l 172 489 l 199 672 l 81 672 l 81 769 l 213 769 l 246 993 l 340 993 l 307 769 l 442 769 l 475 993 l 569 993 l 536 769 l 657 769 l 657 672 l 522 672 l 496 489 l 618 489 l 618 392 l 481 392 l 444 138 l 350 138 m 267 489 l 401 489 l 428 672 l 293 672 " }, "$": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 396 -11 b 63 303 158 6 79 143 l 179 303 b 396 83 193 194 226 99 l 396 469 b 103 736 213 504 103 569 b 396 1004 103 881 222 993 l 396 1129 l 478 1129 l 478 1003 b 767 732 644 988 749 893 l 658 732 b 478 908 638 839 581 894 l 478 561 b 788 281 682 525 788 460 b 478 -11 788 122 658 0 l 478 -187 l 396 -187 m 672 272 b 478 456 672 375 629 424 l 478 83 b 672 272 589 94 672 169 m 213 747 b 396 575 213 660 242 607 l 396 910 b 213 747 279 900 213 833 " }, "%": { "ha": 1089, "x_min": 0, "x_max": 0, "o": "m 275 622 b 397 767 350 622 397 674 b 275 911 397 856 350 911 b 153 765 201 911 153 860 b 275 622 153 671 201 622 m 275 532 b 47 764 157 532 47 629 b 275 1001 47 901 154 1001 b 503 767 399 1001 503 901 b 275 532 503 629 394 532 m 794 993 l 900 993 l 293 0 l 188 0 m 814 79 b 936 224 889 79 936 131 b 814 368 936 313 889 368 b 692 222 740 368 692 317 b 814 79 692 128 740 79 m 814 -11 b 586 221 696 -11 586 86 b 814 458 586 358 693 458 b 1042 224 938 458 1042 358 b 814 -11 1042 86 933 -11 " }, "&": { "ha": 953, "x_min": 0, "x_max": 0, "o": "m 732 203 l 899 0 l 758 0 l 660 119 b 385 -10 597 47 510 -10 b 71 263 203 -10 71 99 b 299 561 71 419 171 499 b 211 771 240 636 211 704 b 454 999 211 921 329 999 b 671 794 576 999 671 914 b 458 538 671 674 585 592 l 667 283 l 788 513 l 894 513 m 389 85 b 600 193 468 85 540 121 l 353 494 b 188 274 256 447 188 390 b 389 85 188 154 264 85 m 322 769 b 408 601 322 719 354 669 b 563 797 519 651 563 701 b 450 908 563 861 517 908 b 322 769 381 908 322 867 " }, "'": { "ha": 294, "x_min": 0, "x_max": 0, "o": "m 85 993 l 210 993 l 189 653 l 106 653 " }, "(": { "ha": 447, "x_min": 0, "x_max": 0, "o": "m 304 -206 b 74 433 176 -56 74 157 b 304 1074 74 710 176 924 l 419 1074 b 194 433 294 918 194 719 b 419 -206 194 147 294 -50 l 304 -206 " }, ")": { "ha": 447, "x_min": 0, "x_max": 0, "o": "m 28 -201 b 253 439 153 -46 253 153 b 28 1078 253 725 153 922 l 143 1078 b 374 439 271 928 374 715 b 143 -201 374 163 271 -51 l 28 -201 " }, "*": { "ha": 586, "x_min": 0, "x_max": 0, "o": "m 114 625 l 229 779 l 58 819 l 89 913 l 253 846 l 243 1032 l 344 1032 l 335 846 l 497 913 l 528 819 l 356 779 l 471 625 l 393 568 l 290 735 l 193 568 " }, "+": { "ha": 721, "x_min": 0, "x_max": 0, "o": "m 310 426 l 50 426 l 50 524 l 310 524 l 310 804 l 411 804 l 411 524 l 671 524 l 671 426 l 411 426 l 411 146 l 310 146 " }, ",": { "ha": 392, "x_min": 0, "x_max": 0, "o": "m 50 -132 l 183 172 l 296 119 l 125 -171 " }, "-": { "ha": 464, "x_min": 0, "x_max": 0, "o": "m 83 436 l 381 436 l 381 328 l 83 328 " }, ".": { "ha": 392, "x_min": 0, "x_max": 0, "o": "m 196 -7 b 107 82 147 -7 107 32 b 196 171 107 132 147 171 b 285 82 244 171 285 132 b 196 -7 285 32 244 -7 " }, "/": { "ha": 560, "x_min": 0, "x_max": 0, "o": "m 413 1078 l 518 1078 l 114 -206 l 8 -206 " }, ":": { "ha": 406, "x_min": 0, "x_max": 0, "o": "m 203 -7 b 114 82 154 -7 114 32 b 203 171 114 132 154 171 b 292 82 251 171 292 132 b 203 -7 292 32 251 -7 m 203 406 b 114 494 154 406 114 444 b 203 583 114 544 154 583 b 292 494 251 583 292 544 b 203 406 292 444 251 406 " }, ";": { "ha": 406, "x_min": 0, "x_max": 0, "o": "m 29 -132 l 163 172 l 275 119 l 104 -171 m 215 406 b 126 494 167 406 126 444 b 215 583 126 544 167 583 b 304 494 264 583 304 544 b 215 406 304 444 264 406 " }, "<": { "ha": 700, "x_min": 0, "x_max": 0, "o": "m 74 433 l 74 461 l 607 763 l 607 651 l 242 447 l 607 243 l 607 132 " }, "=": { "ha": 672, "x_min": 0, "x_max": 0, "o": "m 56 372 l 617 372 l 617 272 l 56 272 m 56 622 l 617 622 l 617 522 l 56 522 " }, ">": { "ha": 700, "x_min": 0, "x_max": 0, "o": "m 93 243 l 458 447 l 93 651 l 93 763 l 626 461 l 626 433 l 93 132 " }, "?": { "ha": 679, "x_min": 0, "x_max": 0, "o": "m 249 350 b 392 600 249 463 322 532 b 493 771 446 654 493 704 b 344 910 493 853 447 910 b 160 729 240 910 169 839 l 51 729 b 346 1006 61 892 176 1006 b 610 775 535 1006 610 892 b 474 543 610 672 540 607 b 351 340 411 483 351 425 l 351 281 l 249 281 m 297 -7 b 208 82 249 -7 208 32 b 297 171 208 132 249 171 b 386 82 346 171 386 132 b 297 -7 386 32 346 -7 " }, "@": { "ha": 1271, "x_min": 0, "x_max": 0, "o": "m 638 -204 b 63 361 267 -204 63 65 b 656 956 63 701 335 956 b 1208 447 988 956 1208 733 b 947 93 1208 186 1058 93 b 788 213 835 93 799 140 b 581 83 747 140 667 83 b 357 325 446 83 357 175 b 631 647 357 511 479 647 b 799 553 729 647 779 600 l 808 636 l 924 636 l 882 286 b 949 176 872 213 896 176 b 1108 444 1028 176 1108 256 b 656 864 1108 693 942 864 b 169 364 375 864 169 658 b 638 -112 169 111 328 -112 b 965 0 789 -112 879 -74 l 1072 0 b 638 -204 1001 -121 838 -204 m 606 172 b 783 399 692 172 783 251 b 639 556 783 504 729 556 b 475 326 551 556 475 472 b 606 172 475 229 531 172 " }, "A": { "ha": 936, "x_min": 0, "x_max": 0, "o": "m 392 993 l 550 993 l 886 0 l 767 0 l 669 286 l 260 286 l 164 0 l 50 0 m 293 382 l 638 382 l 465 893 " }, "B": { "ha": 864, "x_min": 0, "x_max": 0, "o": "m 125 993 l 424 993 b 743 736 608 993 743 932 l 743 731 b 593 521 743 640 707 560 b 792 283 738 486 792 413 l 792 278 b 465 0 792 90 664 0 l 125 0 m 463 94 b 674 279 607 94 674 158 l 674 285 b 446 465 674 407 606 465 l 243 465 l 243 94 m 424 560 b 625 735 569 560 625 613 l 625 740 b 421 899 625 853 560 899 l 243 899 l 243 560 " }, "C": { "ha": 1014, "x_min": 0, "x_max": 0, "o": "m 540 -12 b 76 490 253 -12 76 185 l 76 501 b 543 1008 76 796 274 1008 b 946 683 750 1008 925 899 l 826 683 b 544 913 801 835 714 913 b 201 503 339 913 201 753 l 201 492 b 543 86 201 239 329 86 b 843 329 706 86 818 168 l 956 329 b 540 -12 921 100 763 -12 " }, "D": { "ha": 967, "x_min": 0, "x_max": 0, "o": "m 382 99 b 765 494 638 99 765 251 l 765 506 b 381 896 765 735 654 896 l 246 896 l 246 99 m 125 993 l 388 993 b 890 506 729 993 890 782 l 890 493 b 385 0 890 218 732 0 l 125 0 " }, "E": { "ha": 786, "x_min": 0, "x_max": 0, "o": "m 125 993 l 704 993 l 704 894 l 246 894 l 246 557 l 615 557 l 615 458 l 246 458 l 246 99 l 729 99 l 729 0 l 125 0 " }, "F": { "ha": 758, "x_min": 0, "x_max": 0, "o": "m 125 993 l 706 993 l 706 894 l 246 894 l 246 543 l 604 543 l 604 444 l 246 444 l 246 0 l 125 0 " }, "G": { "ha": 1065, "x_min": 0, "x_max": 0, "o": "m 557 -12 b 76 490 251 -12 76 200 l 76 501 b 557 1008 76 792 272 1008 b 961 693 754 1008 931 917 l 840 693 b 560 913 813 851 704 913 b 201 503 332 913 201 746 l 201 492 b 557 85 201 246 324 85 b 869 401 772 85 865 225 l 579 401 l 579 501 l 988 501 l 988 428 b 557 -12 988 140 811 -12 " }, "H": { "ha": 1014, "x_min": 0, "x_max": 0, "o": "m 125 993 l 246 993 l 246 543 l 768 543 l 768 993 l 889 993 l 889 0 l 768 0 l 768 442 l 246 442 l 246 0 l 125 0 " }, "I": { "ha": 385, "x_min": 0, "x_max": 0, "o": "m 132 993 l 253 993 l 253 0 l 132 0 " }, "J": { "ha": 583, "x_min": 0, "x_max": 0, "o": "m 192 -12 b 53 14 117 -12 79 0 l 53 114 b 185 86 89 99 125 86 b 346 275 283 86 346 142 l 346 993 l 467 993 l 467 269 b 192 -12 467 71 343 -12 " }, "K": { "ha": 856, "x_min": 0, "x_max": 0, "o": "m 125 993 l 246 993 l 246 515 l 678 994 l 813 994 l 371 511 l 835 0 l 689 0 l 246 485 l 246 0 l 125 0 " }, "L": { "ha": 743, "x_min": 0, "x_max": 0, "o": "m 125 993 l 246 993 l 246 99 l 700 99 l 700 0 l 125 0 " }, "M": { "ha": 1189, "x_min": 0, "x_max": 0, "o": "m 125 993 l 293 993 l 600 219 l 897 993 l 1064 993 l 1064 0 l 943 0 l 943 836 l 614 0 l 576 0 l 236 836 l 236 0 l 125 0 " }, "N": { "ha": 1006, "x_min": 0, "x_max": 0, "o": "m 125 993 l 282 993 l 765 172 l 765 993 l 881 993 l 881 0 l 742 0 l 240 851 l 240 0 l 125 0 " }, "O": { "ha": 1126, "x_min": 0, "x_max": 0, "o": "m 568 88 b 925 494 789 88 925 254 l 925 506 b 565 908 925 728 794 908 b 201 503 335 908 201 739 l 201 492 b 568 88 201 251 361 88 m 568 -12 b 76 490 275 -12 76 213 l 76 501 b 565 1006 76 783 274 1006 b 1050 504 857 1006 1050 783 l 1050 493 b 568 -12 1050 213 857 -12 " }, "P": { "ha": 807, "x_min": 0, "x_max": 0, "o": "m 125 993 l 407 993 b 754 703 597 993 754 910 l 754 697 b 407 404 754 486 596 404 l 246 404 l 246 0 l 125 0 m 415 500 b 633 697 557 500 633 569 l 633 703 b 415 896 633 843 550 896 l 246 896 l 246 500 " }, "Q": { "ha": 1126, "x_min": 0, "x_max": 0, "o": "m 776 32 b 568 -12 715 3 644 -12 b 76 490 275 -12 76 213 l 76 501 b 565 1006 76 783 274 1006 b 1050 504 857 1006 1050 783 l 1050 493 b 864 86 1050 325 981 178 l 989 -53 l 915 -124 m 568 88 b 704 113 618 88 664 96 l 593 238 l 667 308 l 793 165 b 925 494 878 238 925 353 l 925 506 b 565 908 925 728 794 908 b 201 503 335 908 201 739 l 201 492 b 568 88 201 251 361 88 " }, "R": { "ha": 872, "x_min": 0, "x_max": 0, "o": "m 125 993 l 424 993 b 771 717 614 993 771 915 l 771 711 b 525 440 771 547 661 467 l 829 0 l 694 0 l 399 432 l 246 432 l 246 0 l 125 0 m 432 528 b 650 711 574 528 650 589 l 650 717 b 432 896 650 851 567 896 l 246 896 l 246 528 " }, "S": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 446 -12 b 67 303 181 -12 85 133 l 183 303 b 446 85 199 185 246 85 b 672 272 574 85 672 160 b 432 463 672 385 621 432 b 100 736 224 494 100 560 b 419 1006 100 889 232 1006 b 761 732 618 1006 742 908 l 653 732 b 419 908 629 857 557 908 b 213 747 283 908 213 840 b 451 569 213 650 249 600 b 789 281 672 535 789 468 b 446 -12 789 114 643 -12 " }, "T": { "ha": 779, "x_min": 0, "x_max": 0, "o": "m 329 894 l 40 894 l 40 993 l 739 993 l 739 894 l 450 894 l 450 0 l 329 0 " }, "U": { "ha": 967, "x_min": 0, "x_max": 0, "o": "m 474 -12 b 117 363 246 -12 117 121 l 117 993 l 238 993 l 238 376 b 476 88 238 168 311 88 b 729 394 635 88 729 151 l 729 993 l 850 993 l 850 378 b 474 -12 850 136 729 -12 " }, "V": { "ha": 908, "x_min": 0, "x_max": 0, "o": "m 42 993 l 161 993 l 457 117 l 753 993 l 867 993 l 524 0 l 379 0 " }, "W": { "ha": 1289, "x_min": 0, "x_max": 0, "o": "m 47 993 l 171 993 l 372 192 l 606 993 l 692 993 l 925 189 l 1129 993 l 1242 993 l 983 0 l 872 0 l 647 785 l 415 0 l 306 0 " }, "X": { "ha": 913, "x_min": 0, "x_max": 0, "o": "m 390 510 l 85 993 l 218 993 l 465 603 l 711 993 l 835 993 l 526 510 l 850 0 l 714 0 l 449 418 l 183 0 l 63 0 " }, "Y": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 364 433 l 32 993 l 168 993 l 428 532 l 678 993 l 799 993 l 485 432 l 485 0 l 364 0 " }, "Z": { "ha": 826, "x_min": 0, "x_max": 0, "o": "m 39 19 l 601 894 l 89 894 l 89 993 l 768 993 l 768 975 l 221 103 l 760 103 l 760 0 l 39 0 " }, "[": { "ha": 494, "x_min": 0, "x_max": 0, "o": "m 122 1078 l 433 1078 l 433 986 l 238 986 l 238 -114 l 433 -114 l 433 -206 l 122 -206 " }, "\\": { "ha": 560, "x_min": 0, "x_max": 0, "o": "m 42 1078 l 147 1078 l 551 -206 l 446 -206 " }, "]": { "ha": 494, "x_min": 0, "x_max": 0, "o": "m 61 -114 l 257 -114 l 257 986 l 61 986 l 61 1078 l 372 1078 l 372 -206 l 61 -206 " }, "^": { "ha": 704, "x_min": 0, "x_max": 0, "o": "m 293 993 l 411 993 l 643 567 l 526 567 l 350 894 l 175 567 l 61 567 " }, "_": { "ha": 547, "x_min": 0, "x_max": 0, "o": "m -1 -128 l 549 -128 l 549 -219 l -1 -219 " }, "`": { "ha": 556, "x_min": 0, "x_max": 0, "o": "m 101 1056 l 246 1056 l 332 851 l 246 851 " }, "a": { "ha": 750, "x_min": 0, "x_max": 0, "o": "m 299 -12 b 57 201 164 -12 57 53 b 421 426 57 369 235 426 l 525 426 l 525 479 b 369 643 525 594 481 643 b 203 513 269 643 214 601 l 88 513 b 375 739 103 678 235 739 b 640 479 514 739 640 682 l 640 0 l 525 0 l 525 92 b 299 -12 471 24 406 -12 m 310 79 b 525 254 432 79 525 142 l 525 344 l 425 344 b 172 201 279 344 172 308 b 310 79 172 126 208 79 " }, "b": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 478 -12 b 232 119 360 -12 274 47 l 232 0 l 117 0 l 117 1074 l 232 1074 l 232 604 b 478 739 274 675 372 739 b 808 374 668 739 808 600 l 808 363 b 478 -12 808 140 678 -12 m 467 83 b 689 357 611 83 689 181 l 689 368 b 465 643 689 551 588 643 b 228 368 331 643 228 554 l 228 357 b 467 83 228 171 325 83 " }, "c": { "ha": 792, "x_min": 0, "x_max": 0, "o": "m 418 -12 b 63 356 215 -12 63 131 l 63 367 b 415 739 63 589 221 739 b 731 485 567 739 708 669 l 617 485 b 415 643 599 600 515 643 b 182 367 283 643 182 538 l 182 356 b 419 83 182 178 279 83 b 628 261 522 83 615 143 l 735 261 b 418 -12 719 104 593 -12 " }, "d": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 390 -12 b 63 349 200 -12 63 122 l 63 360 b 401 739 63 582 201 739 b 639 610 522 739 597 681 l 639 1074 l 754 1074 l 754 0 l 639 0 l 639 125 b 390 -12 597 54 496 -12 m 403 83 b 643 358 538 83 643 172 l 643 369 b 413 643 643 556 554 643 b 182 365 268 643 182 542 l 182 354 b 403 83 182 171 281 83 " }, "e": { "ha": 789, "x_min": 0, "x_max": 0, "o": "m 414 -12 b 63 356 208 -12 63 132 l 63 367 b 403 739 63 586 203 739 b 729 378 571 739 729 638 l 729 340 l 182 340 b 415 83 188 175 267 83 b 608 210 528 83 593 125 l 724 210 b 414 -12 699 64 578 -12 m 611 433 b 403 643 600 583 522 643 b 186 433 285 643 206 563 " }, "f": { "ha": 481, "x_min": 0, "x_max": 0, "o": "m 142 629 l 38 629 l 38 726 l 142 726 l 142 844 b 358 1078 142 992 214 1078 b 444 1064 396 1078 415 1074 l 444 967 b 363 982 424 975 394 982 b 257 857 288 982 257 931 l 257 726 l 435 726 l 435 629 l 257 629 l 257 0 l 142 0 " }, "g": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 407 -265 b 78 -42 192 -265 97 -164 l 196 -42 b 406 -168 213 -125 282 -168 b 639 56 549 -168 639 -100 l 639 161 b 393 24 597 90 499 24 b 63 368 203 24 63 168 l 63 378 b 401 739 63 575 201 739 b 639 610 522 739 597 681 l 639 726 l 754 726 l 754 49 b 407 -265 753 -162 610 -265 m 406 119 b 643 376 540 119 643 214 l 643 386 b 413 643 643 549 554 643 b 182 383 268 643 182 536 l 182 372 b 406 119 182 214 283 119 " }, "h": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 117 1074 l 232 1074 l 232 611 b 465 739 265 679 346 739 b 721 446 615 739 721 657 l 721 0 l 606 0 l 606 454 b 435 639 606 582 551 639 b 232 440 328 639 232 571 l 232 0 l 117 0 " }, "i": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 119 726 l 235 726 l 235 0 l 119 0 m 175 878 b 99 954 133 878 99 913 b 175 1031 99 996 133 1031 b 251 954 217 1031 251 996 b 175 878 251 913 217 878 " }, "j": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 13 -168 b 119 -56 94 -161 119 -119 l 119 726 l 235 726 l 235 -46 b 13 -265 235 -185 174 -260 m 175 878 b 99 954 133 878 99 913 b 175 1031 99 996 133 1031 b 251 954 217 1031 251 996 b 175 878 251 913 217 878 " }, "k": { "ha": 717, "x_min": 0, "x_max": 0, "o": "m 117 1074 l 232 1074 l 232 392 l 533 726 l 668 726 l 357 389 l 694 0 l 554 0 l 232 376 l 232 0 l 117 0 " }, "l": { "ha": 356, "x_min": 0, "x_max": 0, "o": "m 119 1074 l 236 1074 l 236 0 l 119 0 " }, "m": { "ha": 1264, "x_min": 0, "x_max": 0, "o": "m 117 726 l 232 726 l 232 615 b 449 739 265 683 344 739 b 661 603 542 739 624 700 b 910 739 711 697 819 739 b 1154 450 1040 739 1154 661 l 1154 0 l 1039 0 l 1039 458 b 885 639 1039 586 985 639 b 693 444 790 639 693 575 l 693 0 l 578 0 l 578 458 b 424 639 578 586 524 639 b 232 444 329 639 232 575 l 232 0 l 117 0 " }, "n": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 117 726 l 232 726 l 232 611 b 465 739 265 679 346 739 b 721 446 615 739 721 657 l 721 0 l 606 0 l 606 454 b 435 639 606 582 551 639 b 232 440 328 639 232 571 l 232 0 l 117 0 " }, "o": { "ha": 839, "x_min": 0, "x_max": 0, "o": "m 419 83 b 657 357 565 83 657 193 l 657 367 b 419 643 657 535 564 643 b 182 368 274 643 182 535 l 182 357 b 419 83 182 192 272 83 m 418 -12 b 63 357 211 -12 63 144 l 63 368 b 419 739 63 586 214 739 b 776 369 625 739 776 588 l 776 358 b 418 -12 776 139 625 -12 " }, "p": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 117 726 l 232 726 l 232 604 b 478 739 274 675 372 739 b 808 374 668 739 808 600 l 808 363 b 478 -12 808 140 678 -12 b 232 119 358 -12 274 47 l 232 -253 l 117 -253 m 467 83 b 689 357 611 83 689 181 l 689 368 b 465 643 689 551 588 643 b 228 368 331 643 228 554 l 228 357 b 467 83 228 171 325 83 " }, "q": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 639 125 b 390 -12 597 54 496 -12 b 63 349 200 -12 63 122 l 63 360 b 401 739 63 582 201 739 b 639 610 522 739 597 681 l 639 726 l 754 726 l 754 -253 l 639 -253 m 403 83 b 643 358 538 83 643 172 l 643 369 b 413 643 643 556 554 643 b 182 365 268 643 182 542 l 182 354 b 403 83 182 171 281 83 " }, "r": { "ha": 522, "x_min": 0, "x_max": 0, "o": "m 117 726 l 232 726 l 232 596 b 471 739 278 678 340 735 l 471 631 b 232 399 325 624 232 578 l 232 0 l 117 0 " }, "s": { "ha": 667, "x_min": 0, "x_max": 0, "o": "m 342 -12 b 57 224 168 -12 64 75 l 169 224 b 340 83 178 138 224 83 b 499 199 450 83 499 121 b 329 321 499 275 442 300 b 76 535 140 356 76 408 b 322 739 76 669 208 739 b 585 529 453 739 565 686 l 474 529 b 321 643 457 608 413 643 b 183 539 238 643 183 601 b 353 424 183 474 219 447 b 608 208 503 396 608 363 b 342 -12 608 76 518 -12 " }, "t": { "ha": 493, "x_min": 0, "x_max": 0, "o": "m 338 -10 b 142 182 206 -10 142 68 l 142 629 l 38 629 l 38 726 l 142 726 l 142 892 l 257 892 l 257 726 l 426 726 l 426 629 l 257 629 l 257 193 b 347 88 257 122 289 88 b 436 103 383 88 411 93 l 436 6 b 338 -10 413 -3 385 -10 " }, "u": { "ha": 825, "x_min": 0, "x_max": 0, "o": "m 363 -12 b 110 267 218 -12 110 67 l 110 726 l 225 726 l 225 272 b 393 88 225 144 279 88 b 593 286 496 88 593 156 l 593 726 l 708 726 l 708 0 l 593 0 l 593 115 b 363 -12 560 47 479 -12 " }, "v": { "ha": 742, "x_min": 0, "x_max": 0, "o": "m 35 726 l 160 726 l 375 117 l 588 726 l 707 726 l 446 0 l 299 0 " }, "w": { "ha": 1103, "x_min": 0, "x_max": 0, "o": "m 39 726 l 164 726 l 333 142 l 510 726 l 610 726 l 775 142 l 946 726 l 1064 726 l 838 0 l 710 0 l 558 544 l 389 0 l 263 0 " }, "x": { "ha": 733, "x_min": 0, "x_max": 0, "o": "m 299 374 l 56 726 l 190 726 l 368 463 l 544 726 l 669 726 l 429 382 l 694 0 l 558 0 l 363 293 l 163 0 l 39 0 " }, "y": { "ha": 735, "x_min": 0, "x_max": 0, "o": "m 319 75 l 35 726 l 158 726 l 381 206 l 582 726 l 700 726 l 299 -253 l 182 -253 " }, "z": { "ha": 671, "x_min": 0, "x_max": 0, "o": "m 29 17 l 458 629 l 71 629 l 71 726 l 636 726 l 636 706 l 217 101 l 631 101 l 631 0 l 29 0 " }, "{": { "ha": 529, "x_min": 0, "x_max": 0, "o": "m 468 -204 b 193 85 263 -204 156 -125 l 219 229 b 56 396 235 311 197 396 l 56 482 b 219 649 197 482 235 567 l 193 793 b 468 1082 156 1003 263 1082 l 468 994 b 303 790 332 993 278 949 l 329 631 b 193 439 346 526 286 463 b 329 247 286 415 346 351 l 303 88 b 468 -117 278 -71 332 -115 l 468 -204 " }, "|": { "ha": 351, "x_min": 0, "x_max": 0, "o": "m 129 1078 l 222 1078 l 222 -206 l 129 -206 " }, "}": { "ha": 529, "x_min": 0, "x_max": 0, "o": "m 61 -117 b 226 88 197 -115 251 -71 l 200 247 b 336 439 183 351 243 415 b 200 631 243 463 183 526 l 226 790 b 61 994 251 949 197 993 l 61 1082 b 336 793 267 1082 374 1003 l 310 649 b 474 482 294 567 332 482 l 474 396 b 310 229 332 396 294 311 l 336 85 b 61 -204 374 -125 267 -204 " }, "~": { "ha": 618, "x_min": 0, "x_max": 0, "o": "m 61 310 b 208 488 71 431 139 488 b 403 417 300 488 357 417 b 465 490 432 417 461 440 l 557 490 b 414 313 549 367 479 313 b 217 383 318 313 261 383 b 153 310 186 383 160 358 l 61 310 " }, " ": { "ha": 368, "x_min": 0, "x_max": 0, "o": "" }, "¡": { "ha": 400, "x_min": 0, "x_max": 0, "o": "m 154 550 l 243 550 l 263 -162 l 135 -162 m 200 660 b 111 749 151 660 111 699 b 200 838 111 799 151 838 b 289 749 249 838 289 799 b 200 660 289 699 249 660 " }, "¢": { "ha": 785, "x_min": 0, "x_max": 0, "o": "m 371 -10 b 63 356 190 8 63 147 l 63 367 b 371 736 63 572 196 715 l 371 874 l 453 874 l 453 736 b 731 485 589 725 710 653 l 617 485 b 453 640 601 583 535 629 l 453 86 b 628 261 540 99 617 157 l 735 261 b 453 -10 721 115 608 4 l 453 -187 l 371 -187 m 182 356 b 371 86 182 197 256 106 l 371 639 b 182 367 260 618 182 518 l 182 356 " }, "£": { "ha": 828, "x_min": 0, "x_max": 0, "o": "m 67 524 l 157 524 b 132 719 143 582 132 646 b 438 1006 132 889 265 1006 b 735 743 615 1006 722 901 l 618 743 b 438 907 599 849 553 907 b 254 718 331 907 254 832 b 278 524 254 643 265 582 l 574 524 l 574 438 l 297 438 b 318 254 308 382 318 324 b 300 164 318 221 311 190 b 539 89 392 142 479 89 b 665 208 613 89 660 118 l 767 208 b 553 -12 758 81 683 -12 b 244 75 431 -12 324 75 b 154 0 183 75 158 36 l 53 0 b 196 169 58 63 100 151 b 213 256 206 193 213 221 b 181 438 213 317 197 375 l 67 438 " }, "¥": { "ha": 800, "x_min": 0, "x_max": 0, "o": "m 117 471 l 333 471 l 39 993 l 169 993 l 413 543 l 644 993 l 761 993 l 483 471 l 701 471 l 701 390 l 468 390 l 468 282 l 701 282 l 701 201 l 468 201 l 468 0 l 350 0 l 350 201 l 117 201 l 117 282 l 350 282 l 350 390 l 117 390 " }, "¦": { "ha": 361, "x_min": 0, "x_max": 0, "o": "m 129 413 l 222 413 l 222 -206 l 129 -206 m 129 1078 l 222 1078 l 222 510 l 129 510 " }, "§": { "ha": 749, "x_min": 0, "x_max": 0, "o": "m 369 -190 b 108 36 215 -190 111 -108 l 226 36 b 367 -93 233 -43 269 -93 b 508 32 464 -93 508 -37 b 313 181 508 104 474 140 b 58 415 160 219 58 278 b 215 603 58 507 118 575 b 131 779 160 642 131 693 b 378 1006 131 911 250 1006 b 632 788 529 1006 628 928 l 515 788 b 381 908 510 861 478 908 b 242 782 283 908 242 851 b 428 636 242 710 274 675 b 690 397 581 597 690 549 b 538 211 690 318 635 242 b 619 35 590 172 619 118 b 369 -190 619 -90 508 -190 m 453 257 b 576 388 538 278 576 324 b 403 528 576 468 514 499 l 293 557 b 172 425 221 542 172 493 b 349 286 172 351 232 318 l 453 257 " }, "¨": { "ha": 556, "x_min": 0, "x_max": 0, "o": "m 147 881 b 74 954 107 881 74 914 b 147 1028 74 994 107 1028 b 221 954 188 1028 221 994 b 147 881 221 914 188 881 m 408 881 b 335 954 368 881 335 914 b 408 1028 335 994 368 1028 b 482 954 449 1028 482 994 b 408 881 482 914 449 881 " }, "©": { "ha": 1172, "x_min": 0, "x_max": 0, "o": "m 588 215 b 321 490 419 215 321 322 l 321 501 b 588 778 321 667 433 778 b 822 586 713 778 811 715 l 717 586 b 588 694 706 657 664 694 b 431 501 492 694 431 624 l 431 492 b 588 300 431 369 488 300 b 728 415 663 300 717 338 l 828 415 b 588 215 814 282 718 215 m 585 46 b 1029 499 821 46 1029 231 b 588 947 1029 763 828 947 b 143 496 344 947 143 761 b 585 46 143 228 353 46 m 585 -12 b 76 496 303 -12 76 208 b 588 1006 76 779 301 1006 b 1096 499 876 1006 1096 781 b 585 -12 1096 210 871 -12 " }, "ª": { "ha": 582, "x_min": 0, "x_max": 0, "o": "m 236 403 b 42 575 129 403 42 456 b 336 757 42 710 179 757 l 417 757 l 417 793 b 299 918 417 879 383 918 b 174 824 222 918 183 885 l 67 824 b 304 1006 78 953 183 1006 b 525 794 425 1006 525 957 l 525 414 l 417 414 l 417 486 b 236 403 376 433 324 403 m 256 488 b 417 618 347 488 417 533 l 417 682 l 339 682 b 151 578 229 682 151 656 b 256 488 151 521 179 488 " }, "«": { "ha": 694, "x_min": 0, "x_max": 0, "o": "m 82 363 l 263 610 l 376 610 l 203 363 l 376 115 l 263 115 m 329 363 l 510 610 l 624 610 l 450 363 l 624 115 l 510 115 " }, "®": { "ha": 714, "x_min": 0, "x_max": 0, "o": "m 251 854 l 358 854 b 475 763 429 854 475 825 l 475 761 b 413 679 475 715 449 690 l 493 550 l 424 550 l 350 668 l 318 668 l 318 550 l 251 550 m 357 714 b 410 758 392 714 410 729 l 410 760 b 357 803 410 792 390 803 l 318 803 l 318 714 m 357 442 b 610 699 500 442 610 547 b 357 956 610 850 504 956 b 104 697 210 956 104 849 b 357 442 104 544 215 442 m 357 392 b 49 697 186 392 49 524 b 357 1006 49 868 185 1006 b 665 699 532 1006 665 869 b 357 392 665 525 529 392 " }, "¯": { "ha": 556, "x_min": 0, "x_max": 0, "o": "m 96 989 l 460 989 l 460 900 l 96 900 " }, "°": { "ha": 593, "x_min": 0, "x_max": 0, "o": "m 297 644 b 421 783 371 644 421 706 b 297 925 421 864 371 925 b 168 783 222 925 168 864 b 297 644 168 706 222 644 m 297 564 b 69 783 171 564 69 664 b 297 1006 69 906 171 1006 b 524 783 422 1006 524 906 b 297 564 524 664 422 564 " }, "±": { "ha": 721, "x_min": 0, "x_max": 0, "o": "m 310 454 l 50 454 l 50 551 l 310 551 l 310 804 l 411 804 l 411 551 l 671 551 l 671 454 l 411 454 l 411 201 l 310 201 m 50 97 l 671 97 l 671 0 l 50 0 " }, "²": { "ha": 397, "x_min": 0, "x_max": 0, "o": "m 11 533 l 189 722 b 264 857 235 769 264 813 b 194 926 264 900 239 926 b 111 835 149 926 119 900 l 26 835 b 197 999 32 939 96 999 b 356 858 297 999 356 943 b 264 689 356 796 319 743 l 163 589 l 360 589 l 360 518 l 11 518 " }, "³": { "ha": 432, "x_min": 0, "x_max": 0, "o": "m 211 511 b 29 665 96 511 32 572 l 114 665 b 208 581 119 617 146 581 b 296 656 268 581 296 610 b 213 731 296 706 268 731 l 176 731 l 176 796 l 211 796 b 289 864 264 796 289 821 b 217 929 289 901 265 929 b 131 853 168 929 136 900 l 46 853 b 218 999 51 938 115 999 b 378 871 319 999 378 943 b 299 768 378 818 346 785 b 392 654 354 756 392 717 b 211 511 392 565 322 511 " }, "´": { "ha": 556, "x_min": 0, "x_max": 0, "o": "m 310 1056 l 454 1056 l 310 851 l 224 851 " }, "¶": { "ha": 817, "x_min": 0, "x_max": 0, "o": "m 383 481 l 364 481 b 63 732 188 481 63 564 b 364 993 63 908 193 993 l 686 993 l 686 -139 l 590 -139 l 590 914 l 478 914 l 478 -139 l 383 -139 " }, "·": { "ha": 392, "x_min": 0, "x_max": 0, "o": "m 196 365 b 107 454 147 365 107 404 b 196 543 107 504 147 543 b 285 454 244 543 285 504 b 196 365 285 404 244 365 " }, "¸": { "ha": 556, "x_min": 0, "x_max": 0, "o": "m 289 -297 b 150 -181 208 -297 156 -250 l 225 -181 b 285 -231 231 -207 250 -231 b 340 -181 319 -231 340 -210 b 290 -133 340 -151 319 -133 b 251 -144 272 -133 258 -140 l 207 -106 l 265 0 l 339 0 l 299 -74 b 429 -186 363 -65 429 -101 b 289 -297 429 -261 364 -297 " }, "¹": { "ha": 321, "x_min": 0, "x_max": 0, "o": "m 146 901 l 33 826 l 33 908 l 157 993 l 240 993 l 240 518 l 146 518 " }, "º": { "ha": 685, "x_min": 0, "x_max": 0, "o": "m 343 492 b 519 700 453 492 519 575 l 519 708 b 343 917 519 835 451 917 b 165 708 233 917 165 835 l 165 700 b 343 492 165 574 232 492 m 342 403 b 51 699 174 403 51 526 l 51 707 b 343 1006 51 885 175 1006 b 633 710 510 1006 633 886 l 633 701 b 342 403 633 522 510 403 " }, "»": { "ha": 694, "x_min": 0, "x_max": 0, "o": "m 244 363 l 71 610 l 185 610 l 365 363 l 185 115 l 71 115 m 492 363 l 318 610 l 432 610 l 613 363 l 432 115 l 318 115 " }, "¼": { "ha": 942, "x_min": 0, "x_max": 0, "o": "m 150 901 l 38 826 l 38 908 l 161 993 l 244 993 l 244 518 l 150 518 m 772 993 l 864 993 l 160 0 l 68 0 m 758 96 l 519 96 l 519 129 l 732 475 l 847 475 l 847 164 l 910 164 l 910 96 l 847 96 l 847 0 l 758 0 m 760 164 l 760 404 l 619 164 " }, "½": { "ha": 940, "x_min": 0, "x_max": 0, "o": "m 150 901 l 38 826 l 38 908 l 161 993 l 244 993 l 244 518 l 150 518 m 754 993 l 846 993 l 142 0 l 50 0 m 549 15 l 726 204 b 801 339 772 251 801 294 b 732 408 801 382 776 408 b 649 317 686 408 657 382 l 564 317 b 735 481 569 421 633 481 b 893 340 835 481 893 425 b 801 171 893 278 857 225 l 700 71 l 897 71 l 897 0 l 549 0 " }, "¾": { "ha": 946, "x_min": 0, "x_max": 0, "o": "m 215 511 b 33 665 100 511 36 572 l 118 665 b 213 581 124 617 150 581 b 300 656 272 581 300 610 b 217 731 300 706 272 731 l 181 731 l 181 796 l 215 796 b 293 864 268 796 293 821 b 221 929 293 901 269 929 b 135 853 172 929 140 900 l 50 853 b 222 999 56 938 119 999 b 382 871 324 999 382 943 b 303 768 382 818 350 785 b 396 654 358 756 396 717 b 215 511 396 565 326 511 m 822 993 l 914 993 l 210 0 l 118 0 m 758 96 l 519 96 l 519 129 l 732 475 l 847 475 l 847 164 l 910 164 l 910 96 l 847 96 l 847 0 l 758 0 m 760 164 l 760 404 l 619 164 " }, "¿": { "ha": 679, "x_min": 0, "x_max": 0, "o": "m 431 481 b 288 231 431 368 357 299 b 186 60 233 176 186 126 b 335 -79 186 -22 232 -79 b 519 101 439 -79 510 -8 l 628 101 b 333 -175 618 -61 503 -175 b 69 56 144 -175 69 -61 b 206 288 69 158 139 224 b 328 490 268 347 328 406 l 328 550 l 431 550 m 382 838 b 471 749 431 838 471 799 b 382 660 471 699 431 660 b 293 749 333 660 293 699 b 382 838 293 799 333 838 " }, "À": { "ha": 936, "x_min": 0, "x_max": 0, "o": "m 392 993 l 550 993 l 886 0 l 767 0 l 669 286 l 260 286 l 164 0 l 50 0 m 293 382 l 638 382 l 465 893 m 297 1247 l 442 1247 l 519 1071 l 433 1071 " }, "Á": { "ha": 936, "x_min": 0, "x_max": 0, "o": "m 392 993 l 550 993 l 886 0 l 767 0 l 669 286 l 260 286 l 164 0 l 50 0 m 293 382 l 638 382 l 465 893 m 494 1247 l 639 1247 l 503 1071 l 417 1071 " }, "Â": { "ha": 936, "x_min": 0, "x_max": 0, "o": "m 392 993 l 550 993 l 886 0 l 767 0 l 669 286 l 260 286 l 164 0 l 50 0 m 293 382 l 638 382 l 465 893 m 417 1247 l 521 1247 l 669 1071 l 585 1071 l 467 1151 l 349 1071 l 267 1071 " }, "Ã": { "ha": 936, "x_min": 0, "x_max": 0, "o": "m 392 993 l 550 993 l 886 0 l 767 0 l 669 286 l 260 286 l 164 0 l 50 0 m 293 382 l 638 382 l 465 893 m 543 1075 b 393 1135 483 1075 433 1135 b 338 1072 367 1135 344 1108 l 254 1072 b 394 1233 265 1171 322 1233 b 543 1174 453 1233 503 1174 b 599 1236 569 1174 592 1200 l 682 1236 b 543 1075 671 1138 614 1075 " }, "Ä": { "ha": 936, "x_min": 0, "x_max": 0, "o": "m 392 993 l 550 993 l 886 0 l 767 0 l 669 286 l 260 286 l 164 0 l 50 0 m 293 382 l 638 382 l 465 893 m 326 1096 b 253 1169 286 1096 253 1129 b 326 1243 253 1210 286 1243 b 400 1169 367 1243 400 1210 b 326 1096 400 1129 367 1096 m 608 1096 b 535 1169 568 1096 535 1129 b 608 1243 535 1210 568 1243 b 682 1169 649 1243 682 1210 b 608 1096 682 1129 649 1096 " }, "Å": { "ha": 936, "x_min": 0, "x_max": 0, "o": "m 392 993 l 550 993 l 886 0 l 767 0 l 669 286 l 260 286 l 164 0 l 50 0 m 293 382 l 638 382 l 465 893 m 468 1054 b 319 1199 386 1054 319 1119 b 468 1343 319 1278 386 1343 b 617 1199 550 1343 617 1278 b 468 1054 617 1119 550 1054 m 468 1118 b 542 1199 511 1118 542 1153 b 468 1279 542 1244 511 1279 b 394 1199 425 1279 394 1244 b 468 1118 394 1153 425 1118 " }, "Æ": { "ha": 1319, "x_min": 0, "x_max": 0, "o": "m 554 993 l 1238 993 l 1238 894 l 779 894 l 779 557 l 1149 557 l 1149 458 l 779 458 l 779 99 l 1263 99 l 1263 0 l 658 0 l 658 288 l 308 288 l 163 0 l 40 0 m 356 382 l 658 382 l 658 894 l 615 894 " }, "Ç": { "ha": 1014, "x_min": 0, "x_max": 0, "o": "m 529 -297 b 390 -181 449 -297 396 -250 l 465 -181 b 525 -231 471 -207 490 -231 b 581 -181 560 -231 581 -210 b 531 -133 581 -151 560 -133 b 492 -144 513 -133 499 -140 l 447 -106 l 499 -11 b 76 490 236 7 76 199 l 76 501 b 543 1008 76 796 274 1008 b 946 683 750 1008 925 899 l 826 683 b 544 913 801 835 714 913 b 201 503 339 913 201 753 l 201 492 b 543 86 201 239 329 86 b 843 329 706 86 818 168 l 956 329 b 572 -11 922 111 778 -1 l 539 -74 b 669 -186 603 -65 669 -101 b 529 -297 669 -261 604 -297 " }, "È": { "ha": 786, "x_min": 0, "x_max": 0, "o": "m 125 993 l 704 993 l 704 894 l 246 894 l 246 557 l 615 557 l 615 458 l 246 458 l 246 99 l 729 99 l 729 0 l 125 0 m 254 1247 l 399 1247 l 476 1071 l 390 1071 " }, "É": { "ha": 786, "x_min": 0, "x_max": 0, "o": "m 125 993 l 704 993 l 704 894 l 246 894 l 246 557 l 615 557 l 615 458 l 246 458 l 246 99 l 729 99 l 729 0 l 125 0 m 451 1247 l 596 1247 l 460 1071 l 374 1071 " }, "Ê": { "ha": 786, "x_min": 0, "x_max": 0, "o": "m 125 993 l 704 993 l 704 894 l 246 894 l 246 557 l 615 557 l 615 458 l 246 458 l 246 99 l 729 99 l 729 0 l 125 0 m 374 1247 l 478 1247 l 626 1071 l 542 1071 l 424 1151 l 306 1071 l 224 1071 " }, "Ë": { "ha": 786, "x_min": 0, "x_max": 0, "o": "m 125 993 l 704 993 l 704 894 l 246 894 l 246 557 l 615 557 l 615 458 l 246 458 l 246 99 l 729 99 l 729 0 l 125 0 m 283 1096 b 210 1169 243 1096 210 1129 b 283 1243 210 1210 243 1243 b 357 1169 324 1243 357 1210 b 283 1096 357 1129 324 1096 m 565 1096 b 492 1169 525 1096 492 1129 b 565 1243 492 1210 525 1243 b 639 1169 606 1243 639 1210 b 565 1096 639 1129 606 1096 " }, "Ì": { "ha": 385, "x_min": 0, "x_max": 0, "o": "m 132 993 l 253 993 l 253 0 l 132 0 m 21 1247 l 165 1247 l 243 1071 l 157 1071 " }, "Í": { "ha": 385, "x_min": 0, "x_max": 0, "o": "m 132 993 l 253 993 l 253 0 l 132 0 m 218 1247 l 363 1247 l 226 1071 l 140 1071 " }, "Î": { "ha": 385, "x_min": 0, "x_max": 0, "o": "m 132 993 l 253 993 l 253 0 l 132 0 m 140 1247 l 244 1247 l 393 1071 l 308 1071 l 190 1151 l 72 1071 l -10 1071 " }, "Ï": { "ha": 385, "x_min": 0, "x_max": 0, "o": "m 132 993 l 253 993 l 253 0 l 132 0 m 50 1096 b -24 1169 10 1096 -24 1129 b 50 1243 -24 1210 10 1243 b 124 1169 90 1243 124 1210 b 50 1096 124 1129 90 1096 m 332 1096 b 258 1169 292 1096 258 1129 b 332 1243 258 1210 292 1243 b 406 1169 372 1243 406 1210 b 332 1096 406 1129 372 1096 " }, "Ð": { "ha": 994, "x_min": 0, "x_max": 0, "o": "m 47 544 l 153 544 l 153 993 l 415 993 b 918 506 757 993 918 782 l 918 493 b 413 0 918 218 760 0 l 153 0 l 153 451 l 47 451 m 410 99 b 793 494 665 99 793 251 l 793 506 b 408 896 793 735 682 896 l 274 896 l 274 544 l 561 544 l 561 451 l 274 451 l 274 99 " }, "Ñ": { "ha": 1006, "x_min": 0, "x_max": 0, "o": "m 125 993 l 282 993 l 765 172 l 765 993 l 881 993 l 881 0 l 742 0 l 240 851 l 240 0 l 125 0 m 592 1075 b 442 1135 532 1075 482 1135 b 386 1072 415 1135 393 1108 l 303 1072 b 443 1233 314 1171 371 1233 b 592 1174 501 1233 551 1174 b 647 1236 618 1174 640 1200 l 731 1236 b 592 1075 719 1138 663 1075 " }, "Ò": { "ha": 1126, "x_min": 0, "x_max": 0, "o": "m 568 88 b 925 494 789 88 925 254 l 925 506 b 565 908 925 728 794 908 b 201 503 335 908 201 739 l 201 492 b 568 88 201 251 361 88 m 568 -12 b 76 490 275 -12 76 213 l 76 501 b 565 1006 76 783 274 1006 b 1050 504 857 1006 1050 783 l 1050 493 b 568 -12 1050 213 857 -12 m 392 1247 l 536 1247 l 614 1071 l 528 1071 " }, "Ó": { "ha": 1126, "x_min": 0, "x_max": 0, "o": "m 568 88 b 925 494 789 88 925 254 l 925 506 b 565 908 925 728 794 908 b 201 503 335 908 201 739 l 201 492 b 568 88 201 251 361 88 m 568 -12 b 76 490 275 -12 76 213 l 76 501 b 565 1006 76 783 274 1006 b 1050 504 857 1006 1050 783 l 1050 493 b 568 -12 1050 213 857 -12 m 589 1247 l 733 1247 l 597 1071 l 511 1071 " }, "Ô": { "ha": 1126, "x_min": 0, "x_max": 0, "o": "m 568 88 b 925 494 789 88 925 254 l 925 506 b 565 908 925 728 794 908 b 201 503 335 908 201 739 l 201 492 b 568 88 201 251 361 88 m 568 -12 b 76 490 275 -12 76 213 l 76 501 b 565 1006 76 783 274 1006 b 1050 504 857 1006 1050 783 l 1050 493 b 568 -12 1050 213 857 -12 m 511 1247 l 615 1247 l 764 1071 l 679 1071 l 561 1151 l 443 1071 l 361 1071 " }, "Õ": { "ha": 1126, "x_min": 0, "x_max": 0, "o": "m 568 88 b 925 494 789 88 925 254 l 925 506 b 565 908 925 728 794 908 b 201 503 335 908 201 739 l 201 492 b 568 88 201 251 361 88 m 568 -12 b 76 490 275 -12 76 213 l 76 501 b 565 1006 76 783 274 1006 b 1050 504 857 1006 1050 783 l 1050 493 b 568 -12 1050 213 857 -12 m 638 1075 b 488 1135 578 1075 528 1135 b 432 1072 461 1135 439 1108 l 349 1072 b 489 1233 360 1171 417 1233 b 638 1174 547 1233 597 1174 b 693 1236 664 1174 686 1200 l 776 1236 b 638 1075 765 1138 708 1075 " }, "Ö": { "ha": 1126, "x_min": 0, "x_max": 0, "o": "m 568 88 b 925 494 789 88 925 254 l 925 506 b 565 908 925 728 794 908 b 201 503 335 908 201 739 l 201 492 b 568 88 201 251 361 88 m 568 -12 b 76 490 275 -12 76 213 l 76 501 b 565 1006 76 783 274 1006 b 1050 504 857 1006 1050 783 l 1050 493 b 568 -12 1050 213 857 -12 m 421 1096 b 347 1169 381 1096 347 1129 b 421 1243 347 1210 381 1243 b 494 1169 461 1243 494 1210 b 421 1096 494 1129 461 1096 m 703 1096 b 629 1169 663 1096 629 1129 b 703 1243 629 1210 663 1243 b 776 1169 743 1243 776 1210 b 703 1096 776 1129 743 1096 " }, "×": { "ha": 651, "x_min": 0, "x_max": 0, "o": "m 46 249 l 260 463 l 46 676 l 111 743 l 325 528 l 539 743 l 606 676 l 392 463 l 606 249 l 539 182 l 325 397 l 111 182 " }, "Ø": { "ha": 1126, "x_min": 0, "x_max": 0, "o": "m 49 17 l 185 165 b 76 490 115 253 76 367 l 76 501 b 565 1006 76 783 274 1006 b 863 908 682 1006 783 969 l 975 1031 l 1038 968 l 928 847 b 1050 504 1006 758 1050 638 l 1050 493 b 568 -12 1050 213 857 -12 b 246 101 440 -12 329 31 l 111 -46 m 568 88 b 925 494 789 88 925 254 l 925 506 b 853 767 925 608 900 697 l 319 182 b 568 88 383 119 471 88 m 201 492 b 263 251 201 396 224 315 l 793 832 b 565 908 735 881 658 908 b 201 503 335 908 201 739 l 201 492 " }, "Ù": { "ha": 967, "x_min": 0, "x_max": 0, "o": "m 474 -12 b 117 363 246 -12 117 121 l 117 993 l 238 993 l 238 376 b 476 88 238 168 311 88 b 729 394 635 88 729 151 l 729 993 l 850 993 l 850 378 b 474 -12 850 136 729 -12 m 313 1247 l 457 1247 l 535 1071 l 449 1071 " }, "Ú": { "ha": 967, "x_min": 0, "x_max": 0, "o": "m 474 -12 b 117 363 246 -12 117 121 l 117 993 l 238 993 l 238 376 b 476 88 238 168 311 88 b 729 394 635 88 729 151 l 729 993 l 850 993 l 850 378 b 474 -12 850 136 729 -12 m 510 1247 l 654 1247 l 518 1071 l 432 1071 " }, "Û": { "ha": 967, "x_min": 0, "x_max": 0, "o": "m 474 -12 b 117 363 246 -12 117 121 l 117 993 l 238 993 l 238 376 b 476 88 238 168 311 88 b 729 394 635 88 729 151 l 729 993 l 850 993 l 850 378 b 474 -12 850 136 729 -12 m 432 1247 l 536 1247 l 685 1071 l 600 1071 l 482 1151 l 364 1071 l 282 1071 " }, "Ü": { "ha": 967, "x_min": 0, "x_max": 0, "o": "m 474 -12 b 117 363 246 -12 117 121 l 117 993 l 238 993 l 238 376 b 476 88 238 168 311 88 b 729 394 635 88 729 151 l 729 993 l 850 993 l 850 378 b 474 -12 850 136 729 -12 m 342 1096 b 268 1169 301 1096 268 1129 b 342 1243 268 1210 301 1243 b 415 1169 382 1243 415 1210 b 342 1096 415 1129 382 1096 m 624 1096 b 550 1169 583 1096 550 1129 b 624 1243 550 1210 583 1243 b 697 1169 664 1243 697 1210 b 624 1096 697 1129 664 1096 " }, "Ý": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 364 433 l 32 993 l 168 993 l 428 532 l 678 993 l 799 993 l 485 432 l 485 0 l 364 0 m 442 1247 l 586 1247 l 450 1071 l 364 1071 " }, "Þ": { "ha": 807, "x_min": 0, "x_max": 0, "o": "m 125 993 l 246 993 l 246 807 l 407 807 b 754 522 597 807 754 729 l 754 517 b 407 229 754 306 596 229 l 246 229 l 246 0 l 125 0 m 415 325 b 633 517 557 325 633 389 l 633 522 b 415 710 633 663 550 710 l 246 710 l 246 325 " }, "ß": { "ha": 819, "x_min": 0, "x_max": 0, "o": "m 465 -12 b 338 10 407 -12 358 1 l 338 108 b 460 83 364 96 407 83 b 640 292 544 83 640 118 l 640 301 b 368 543 640 451 535 549 l 368 642 b 575 824 525 638 575 739 l 575 829 b 406 983 575 928 515 983 b 232 792 300 983 232 908 l 232 0 l 117 0 l 117 786 b 407 1078 117 964 251 1078 b 685 829 572 1078 685 978 l 685 824 b 519 600 685 736 628 636 b 760 303 663 564 760 447 l 760 294 b 465 -12 760 60 615 -12 " }, "à": { "ha": 750, "x_min": 0, "x_max": 0, "o": "m 299 -12 b 57 201 164 -12 57 53 b 421 426 57 369 235 426 l 525 426 l 525 479 b 369 643 525 594 481 643 b 203 513 269 643 214 601 l 88 513 b 375 739 103 678 235 739 b 640 479 514 739 640 682 l 640 0 l 525 0 l 525 92 b 299 -12 471 24 406 -12 m 310 79 b 525 254 432 79 525 142 l 525 344 l 425 344 b 172 201 279 344 172 308 b 310 79 172 126 208 79 m 197 1056 l 342 1056 l 428 851 l 342 851 " }, "á": { "ha": 750, "x_min": 0, "x_max": 0, "o": "m 299 -12 b 57 201 164 -12 57 53 b 421 426 57 369 235 426 l 525 426 l 525 479 b 369 643 525 594 481 643 b 203 513 269 643 214 601 l 88 513 b 375 739 103 678 235 739 b 640 479 514 739 640 682 l 640 0 l 525 0 l 525 92 b 299 -12 471 24 406 -12 m 310 79 b 525 254 432 79 525 142 l 525 344 l 425 344 b 172 201 279 344 172 308 b 310 79 172 126 208 79 m 411 1056 l 556 1056 l 411 851 l 325 851 " }, "â": { "ha": 750, "x_min": 0, "x_max": 0, "o": "m 299 -12 b 57 201 164 -12 57 53 b 421 426 57 369 235 426 l 525 426 l 525 479 b 369 643 525 594 481 643 b 203 513 269 643 214 601 l 88 513 b 375 739 103 678 235 739 b 640 479 514 739 640 682 l 640 0 l 525 0 l 525 92 b 299 -12 471 24 406 -12 m 310 79 b 525 254 432 79 525 142 l 525 344 l 425 344 b 172 201 279 344 172 308 b 310 79 172 126 208 79 m 310 1051 l 414 1051 l 563 851 l 478 851 l 360 956 l 242 851 l 160 851 " }, "ã": { "ha": 750, "x_min": 0, "x_max": 0, "o": "m 299 -12 b 57 201 164 -12 57 53 b 421 426 57 369 235 426 l 525 426 l 525 479 b 369 643 525 594 481 643 b 203 513 269 643 214 601 l 88 513 b 375 739 103 678 235 739 b 640 479 514 739 640 682 l 640 0 l 525 0 l 525 92 b 299 -12 471 24 406 -12 m 310 79 b 525 254 432 79 525 142 l 525 344 l 425 344 b 172 201 279 344 172 308 b 310 79 172 126 208 79 m 451 860 b 301 919 392 860 342 919 b 246 857 275 919 253 893 l 163 857 b 303 1018 174 956 231 1018 b 451 958 361 1018 411 958 b 507 1021 478 958 500 985 l 590 1021 b 451 860 579 922 522 860 " }, "ä": { "ha": 750, "x_min": 0, "x_max": 0, "o": "m 299 -12 b 57 201 164 -12 57 53 b 421 426 57 369 235 426 l 525 426 l 525 479 b 369 643 525 594 481 643 b 203 513 269 643 214 601 l 88 513 b 375 739 103 678 235 739 b 640 479 514 739 640 682 l 640 0 l 525 0 l 525 92 b 299 -12 471 24 406 -12 m 310 79 b 525 254 432 79 525 142 l 525 344 l 425 344 b 172 201 279 344 172 308 b 310 79 172 126 208 79 m 246 881 b 172 954 206 881 172 914 b 246 1028 172 994 206 1028 b 319 954 286 1028 319 994 b 246 881 319 914 286 881 m 507 881 b 433 954 467 881 433 914 b 507 1028 433 994 467 1028 b 581 954 547 1028 581 994 b 507 881 581 914 547 881 " }, "å": { "ha": 750, "x_min": 0, "x_max": 0, "o": "m 299 -12 b 57 201 164 -12 57 53 b 421 426 57 369 235 426 l 525 426 l 525 479 b 369 643 525 594 481 643 b 203 513 269 643 214 601 l 88 513 b 375 739 103 678 235 739 b 640 479 514 739 640 682 l 640 0 l 525 0 l 525 92 b 299 -12 471 24 406 -12 m 310 79 b 525 254 432 79 525 142 l 525 344 l 425 344 b 172 201 279 344 172 308 b 310 79 172 126 208 79 m 376 894 b 450 975 419 894 450 929 b 376 1056 450 1021 419 1056 b 303 975 333 1056 303 1021 b 376 894 303 929 333 894 m 376 831 b 228 975 294 831 228 896 b 376 1119 228 1054 294 1119 b 525 975 458 1119 525 1054 b 376 831 525 896 458 831 " }, "æ": { "ha": 1222, "x_min": 0, "x_max": 0, "o": "m 856 -12 b 582 138 733 -12 638 43 b 299 -12 515 33 432 -12 b 57 201 164 -12 57 53 b 417 431 57 371 231 431 l 525 431 l 525 478 b 369 643 525 593 476 643 b 203 513 269 643 214 601 l 88 513 b 375 739 103 678 235 739 b 603 615 471 739 561 708 b 847 739 658 693 742 739 b 1163 378 1008 739 1163 640 l 1163 343 l 636 343 b 857 83 642 178 714 83 b 1042 210 965 83 1026 125 l 1157 210 b 856 -12 1132 64 1013 -12 m 310 79 b 525 254 432 79 525 142 l 525 343 l 421 343 b 172 201 275 343 172 308 b 310 79 172 126 208 79 m 1044 431 b 847 643 1033 583 963 643 b 640 431 735 643 658 561 " }, "ç": { "ha": 792, "x_min": 0, "x_max": 0, "o": "m 397 -297 b 258 -181 317 -297 264 -250 l 333 -181 b 393 -231 339 -207 358 -231 b 449 -181 428 -231 449 -210 b 399 -133 449 -151 428 -133 b 360 -144 381 -133 367 -140 l 315 -106 l 368 -10 b 63 356 190 11 63 149 l 63 367 b 415 739 63 589 221 739 b 731 485 567 739 708 669 l 617 485 b 415 643 599 600 515 643 b 182 367 283 643 182 538 l 182 356 b 419 83 182 178 279 83 b 628 261 522 83 615 143 l 735 261 b 440 -11 719 111 604 -1 l 407 -74 b 538 -186 471 -65 538 -101 b 397 -297 538 -261 472 -297 " }, "è": { "ha": 789, "x_min": 0, "x_max": 0, "o": "m 414 -12 b 63 356 208 -12 63 132 l 63 367 b 403 739 63 586 203 739 b 729 378 571 739 729 638 l 729 340 l 182 340 b 415 83 188 175 267 83 b 608 210 528 83 593 125 l 724 210 b 414 -12 699 64 578 -12 m 611 433 b 403 643 600 583 522 643 b 186 433 285 643 206 563 m 224 1056 l 368 1056 l 454 851 l 368 851 " }, "é": { "ha": 789, "x_min": 0, "x_max": 0, "o": "m 414 -12 b 63 356 208 -12 63 132 l 63 367 b 403 739 63 586 203 739 b 729 378 571 739 729 638 l 729 340 l 182 340 b 415 83 188 175 267 83 b 608 210 528 83 593 125 l 724 210 b 414 -12 699 64 578 -12 m 611 433 b 403 643 600 583 522 643 b 186 433 285 643 206 563 m 438 1056 l 582 1056 l 438 851 l 351 851 " }, "ê": { "ha": 789, "x_min": 0, "x_max": 0, "o": "m 414 -12 b 63 356 208 -12 63 132 l 63 367 b 403 739 63 586 203 739 b 729 378 571 739 729 638 l 729 340 l 182 340 b 415 83 188 175 267 83 b 608 210 528 83 593 125 l 724 210 b 414 -12 699 64 578 -12 m 611 433 b 403 643 600 583 522 643 b 186 433 285 643 206 563 m 351 1051 l 456 1051 l 604 851 l 519 851 l 401 956 l 283 851 l 201 851 " }, "ë": { "ha": 789, "x_min": 0, "x_max": 0, "o": "m 414 -12 b 63 356 208 -12 63 132 l 63 367 b 403 739 63 586 203 739 b 729 378 571 739 729 638 l 729 340 l 182 340 b 415 83 188 175 267 83 b 608 210 528 83 593 125 l 724 210 b 414 -12 699 64 578 -12 m 611 433 b 403 643 600 583 522 643 b 186 433 285 643 206 563 m 272 881 b 199 954 232 881 199 914 b 272 1028 199 994 232 1028 b 346 954 313 1028 346 994 b 272 881 346 914 313 881 m 533 881 b 460 954 493 881 460 914 b 533 1028 460 994 493 1028 b 607 954 574 1028 607 994 b 533 881 607 914 574 881 " }, "ì": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 119 726 l 235 726 l 235 0 l 119 0 m -3 1056 l 142 1056 l 228 851 l 142 851 " }, "í": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 119 726 l 235 726 l 235 0 l 119 0 m 211 1056 l 356 1056 l 211 851 l 125 851 " }, "î": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 119 726 l 235 726 l 235 0 l 119 0 m 125 1051 l 229 1051 l 378 851 l 293 851 l 175 956 l 57 851 l -25 851 " }, "ï": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 51 881 b -22 954 11 881 -22 914 b 51 1028 -22 994 11 1028 b 125 954 92 1028 125 994 b 51 881 125 914 92 881 m 301 881 b 228 954 261 881 228 914 b 301 1028 228 994 261 1028 b 375 954 342 1028 375 994 b 301 881 375 914 342 881 m 119 726 l 235 726 l 235 0 l 119 0 " }, "ð": { "ha": 839, "x_min": 0, "x_max": 0, "o": "m 217 863 l 351 942 b 179 1074 296 990 236 1035 l 328 1074 b 444 997 363 1054 403 1029 l 560 1065 l 600 997 l 507 943 b 776 394 644 815 776 622 l 776 364 b 418 -12 776 144 625 -12 b 63 357 211 -12 63 144 l 63 368 b 393 739 63 586 215 739 b 603 639 489 739 557 696 b 413 888 558 728 490 813 l 257 796 m 419 83 b 657 357 565 83 657 193 l 657 367 b 421 643 657 535 565 643 b 182 368 275 643 182 535 l 182 357 b 419 83 182 192 272 83 " }, "ñ": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 117 726 l 232 726 l 232 611 b 465 739 265 679 346 739 b 721 446 615 739 721 657 l 721 0 l 606 0 l 606 454 b 435 639 606 582 551 639 b 232 440 328 639 232 571 l 232 0 l 117 0 m 489 860 b 339 919 429 860 379 919 b 283 857 313 919 290 893 l 200 857 b 340 1018 211 956 268 1018 b 489 958 399 1018 449 958 b 544 1021 515 958 538 985 l 628 1021 b 489 860 617 922 560 860 " }, "ò": { "ha": 839, "x_min": 0, "x_max": 0, "o": "m 419 83 b 657 357 565 83 657 193 l 657 367 b 419 643 657 535 564 643 b 182 368 274 643 182 535 l 182 357 b 419 83 182 192 272 83 m 418 -12 b 63 357 211 -12 63 144 l 63 368 b 419 739 63 586 214 739 b 776 369 625 739 776 588 l 776 358 b 418 -12 776 139 625 -12 m 240 1056 l 385 1056 l 471 851 l 385 851 " }, "ó": { "ha": 839, "x_min": 0, "x_max": 0, "o": "m 419 83 b 657 357 565 83 657 193 l 657 367 b 419 643 657 535 564 643 b 182 368 274 643 182 535 l 182 357 b 419 83 182 192 272 83 m 418 -12 b 63 357 211 -12 63 144 l 63 368 b 419 739 63 586 214 739 b 776 369 625 739 776 588 l 776 358 b 418 -12 776 139 625 -12 m 454 1056 l 599 1056 l 454 851 l 368 851 " }, "ô": { "ha": 839, "x_min": 0, "x_max": 0, "o": "m 419 83 b 657 357 565 83 657 193 l 657 367 b 419 643 657 535 564 643 b 182 368 274 643 182 535 l 182 357 b 419 83 182 192 272 83 m 418 -12 b 63 357 211 -12 63 144 l 63 368 b 419 739 63 586 214 739 b 776 369 625 739 776 588 l 776 358 b 418 -12 776 139 625 -12 m 368 1051 l 472 1051 l 621 851 l 536 851 l 418 956 l 300 851 l 218 851 " }, "õ": { "ha": 839, "x_min": 0, "x_max": 0, "o": "m 419 83 b 657 357 565 83 657 193 l 657 367 b 419 643 657 535 564 643 b 182 368 274 643 182 535 l 182 357 b 419 83 182 192 272 83 m 418 -12 b 63 357 211 -12 63 144 l 63 368 b 419 739 63 586 214 739 b 776 369 625 739 776 588 l 776 358 b 418 -12 776 139 625 -12 m 494 860 b 344 919 435 860 385 919 b 289 857 318 919 296 893 l 206 857 b 346 1018 217 956 274 1018 b 494 958 404 1018 454 958 b 550 1021 521 958 543 985 l 633 1021 b 494 860 622 922 565 860 " }, "ö": { "ha": 839, "x_min": 0, "x_max": 0, "o": "m 419 83 b 657 357 565 83 657 193 l 657 367 b 419 643 657 535 564 643 b 182 368 274 643 182 535 l 182 357 b 419 83 182 192 272 83 m 418 -12 b 63 357 211 -12 63 144 l 63 368 b 419 739 63 586 214 739 b 776 369 625 739 776 588 l 776 358 b 418 -12 776 139 625 -12 m 289 881 b 215 954 249 881 215 914 b 289 1028 215 994 249 1028 b 363 954 329 1028 363 994 b 289 881 363 914 329 881 m 550 881 b 476 954 510 881 476 914 b 550 1028 476 994 510 1028 b 624 954 590 1028 624 994 b 550 881 624 914 590 881 " }, "÷": { "ha": 721, "x_min": 0, "x_max": 0, "o": "m 360 124 b 271 213 311 124 271 163 b 360 301 271 263 311 301 b 449 213 408 301 449 263 b 360 124 449 163 408 124 m 50 524 l 671 524 l 671 426 l 50 426 m 360 649 b 271 738 311 649 271 688 b 360 826 271 788 311 826 b 449 738 408 826 449 788 b 360 649 449 688 408 649 " }, "ø": { "ha": 839, "x_min": 0, "x_max": 0, "o": "m 32 1 l 139 119 b 63 357 90 182 63 264 l 63 368 b 419 739 63 586 214 739 b 636 669 503 739 578 714 l 731 772 l 792 719 l 694 613 b 776 369 746 549 776 465 l 776 358 b 418 -12 776 139 625 -12 b 196 63 331 -12 256 15 l 93 -51 m 419 83 b 657 357 565 83 657 193 l 657 367 b 619 529 657 431 643 485 l 264 139 b 419 83 304 103 356 83 m 182 357 b 215 203 182 297 193 246 l 567 592 b 419 643 528 625 478 643 b 182 368 274 643 182 535 l 182 357 " }, "ù": { "ha": 825, "x_min": 0, "x_max": 0, "o": "m 363 -12 b 110 267 218 -12 110 67 l 110 726 l 225 726 l 225 272 b 393 88 225 144 279 88 b 593 286 496 88 593 156 l 593 726 l 708 726 l 708 0 l 593 0 l 593 115 b 363 -12 560 47 479 -12 m 233 1056 l 378 1056 l 464 851 l 378 851 " }, "ú": { "ha": 825, "x_min": 0, "x_max": 0, "o": "m 363 -12 b 110 267 218 -12 110 67 l 110 726 l 225 726 l 225 272 b 393 88 225 144 279 88 b 593 286 496 88 593 156 l 593 726 l 708 726 l 708 0 l 593 0 l 593 115 b 363 -12 560 47 479 -12 m 447 1056 l 592 1056 l 447 851 l 361 851 " }, "û": { "ha": 825, "x_min": 0, "x_max": 0, "o": "m 363 -12 b 110 267 218 -12 110 67 l 110 726 l 225 726 l 225 272 b 393 88 225 144 279 88 b 593 286 496 88 593 156 l 593 726 l 708 726 l 708 0 l 593 0 l 593 115 b 363 -12 560 47 479 -12 m 361 1051 l 465 1051 l 614 851 l 529 851 l 411 956 l 293 851 l 211 851 " }, "ü": { "ha": 825, "x_min": 0, "x_max": 0, "o": "m 363 -12 b 110 267 218 -12 110 67 l 110 726 l 225 726 l 225 272 b 393 88 225 144 279 88 b 593 286 496 88 593 156 l 593 726 l 708 726 l 708 0 l 593 0 l 593 115 b 363 -12 560 47 479 -12 m 282 881 b 208 954 242 881 208 914 b 282 1028 208 994 242 1028 b 356 954 322 1028 356 994 b 282 881 356 914 322 881 m 543 881 b 469 954 503 881 469 914 b 543 1028 469 994 503 1028 b 617 954 583 1028 617 994 b 543 881 617 914 583 881 " }, "ý": { "ha": 735, "x_min": 0, "x_max": 0, "o": "m 319 75 l 35 726 l 158 726 l 381 206 l 582 726 l 700 726 l 299 -253 l 182 -253 m 413 1056 l 557 1056 l 413 851 l 326 851 " }, "þ": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 117 1074 l 232 1074 l 232 604 b 478 739 274 675 372 739 b 808 374 668 739 808 600 l 808 363 b 478 -12 808 140 678 -12 b 232 119 358 -12 274 47 l 232 -253 l 117 -253 m 467 83 b 689 357 611 83 689 181 l 689 368 b 465 643 689 551 588 643 b 228 368 331 643 228 554 l 228 357 b 467 83 228 171 325 83 " }, "ÿ": { "ha": 735, "x_min": 0, "x_max": 0, "o": "m 319 75 l 35 726 l 158 726 l 381 206 l 582 726 l 700 726 l 299 -253 l 182 -253 m 247 881 b 174 954 207 881 174 914 b 247 1028 174 994 207 1028 b 321 954 288 1028 321 994 b 247 881 321 914 288 881 m 508 881 b 435 954 468 881 435 914 b 508 1028 435 994 468 1028 b 582 954 549 1028 582 994 b 508 881 582 914 549 881 " }, "ı": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 119 726 l 235 726 l 235 0 l 119 0 " }, "Ł": { "ha": 771, "x_min": 0, "x_max": 0, "o": "m 58 443 l 153 478 l 153 993 l 274 993 l 274 522 l 550 624 l 550 529 l 274 428 l 274 99 l 728 99 l 728 0 l 153 0 l 153 383 l 58 349 " }, "ł": { "ha": 383, "x_min": 0, "x_max": 0, "o": "m 28 529 l 133 589 l 133 1074 l 250 1074 l 250 656 l 361 719 l 361 622 l 250 558 l 250 0 l 133 0 l 133 492 l 28 432 " }, "Œ": { "ha": 1326, "x_min": 0, "x_max": 0, "o": "m 76 500 b 582 993 76 775 235 993 l 1244 993 l 1244 894 l 808 894 l 808 557 l 1156 557 l 1156 458 l 808 458 l 808 99 l 1269 99 l 1269 0 l 579 0 b 76 488 238 0 76 211 l 76 500 m 585 894 b 201 499 329 894 201 742 l 201 488 b 586 97 201 258 313 97 l 688 97 l 688 894 " }, "œ": { "ha": 1382, "x_min": 0, "x_max": 0, "o": "m 418 -12 b 63 357 211 -12 63 144 l 63 368 b 419 739 63 586 214 739 b 714 564 556 739 660 672 b 996 739 765 672 864 739 b 1322 378 1164 739 1322 638 l 1322 340 l 775 340 b 1008 83 781 175 860 83 b 1201 210 1121 83 1186 125 l 1317 210 b 1007 -12 1292 64 1171 -12 b 714 161 869 -12 767 51 b 418 -12 658 53 554 -12 m 419 83 b 657 357 565 83 657 193 l 657 367 b 419 643 657 535 564 643 b 182 368 274 643 182 535 l 182 357 b 419 83 182 192 272 83 m 1204 433 b 996 643 1193 583 1115 643 b 779 433 878 643 799 563 " }, "Š": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 446 -12 b 67 303 181 -12 85 133 l 183 303 b 446 85 199 185 246 85 b 672 272 574 85 672 160 b 432 463 672 385 621 432 b 100 736 224 494 100 560 b 419 1006 100 889 232 1006 b 761 732 618 1006 742 908 l 653 732 b 419 908 629 857 557 908 b 213 747 283 908 213 840 b 451 569 213 650 249 600 b 789 281 672 535 789 468 b 446 -12 789 114 643 -12 m 218 1247 l 303 1247 l 421 1167 l 539 1247 l 621 1247 l 471 1071 l 367 1071 " }, "š": { "ha": 667, "x_min": 0, "x_max": 0, "o": "m 342 -12 b 57 224 168 -12 64 75 l 169 224 b 340 83 178 138 224 83 b 499 199 450 83 499 121 b 329 321 499 275 442 300 b 76 535 140 356 76 408 b 322 739 76 669 208 739 b 585 529 453 739 565 686 l 474 529 b 321 643 457 608 413 643 b 183 539 238 643 183 601 b 353 424 183 474 219 447 b 608 208 503 396 608 363 b 342 -12 608 76 518 -12 m 129 1051 l 214 1051 l 332 947 l 450 1051 l 532 1051 l 382 851 l 278 851 " }, "Ÿ": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 364 433 l 32 993 l 168 993 l 428 532 l 678 993 l 799 993 l 485 432 l 485 0 l 364 0 m 274 1096 b 200 1169 233 1096 200 1129 b 274 1243 200 1210 233 1243 b 347 1169 314 1243 347 1210 b 274 1096 347 1129 314 1096 m 556 1096 b 482 1169 515 1096 482 1129 b 556 1243 482 1210 515 1243 b 629 1169 596 1243 629 1210 b 556 1096 629 1129 596 1096 " }, "Ž": { "ha": 826, "x_min": 0, "x_max": 0, "o": "m 39 19 l 601 894 l 89 894 l 89 993 l 768 993 l 768 975 l 221 103 l 760 103 l 760 0 l 39 0 m 208 1247 l 293 1247 l 411 1167 l 529 1247 l 611 1247 l 461 1071 l 357 1071 " }, "ž": { "ha": 671, "x_min": 0, "x_max": 0, "o": "m 29 17 l 458 629 l 71 629 l 71 726 l 636 726 l 636 706 l 217 101 l 631 101 l 631 0 l 29 0 m 143 1051 l 228 1051 l 346 947 l 464 1051 l 546 1051 l 396 851 l 292 851 " }, "ƒ": { "ha": 551, "x_min": 0, "x_max": 0, "o": "m 40 574 l 175 574 l 207 785 b 442 1006 229 928 307 1006 b 536 990 482 1006 510 1000 l 536 893 b 444 910 515 901 485 910 b 321 779 367 910 332 854 l 289 574 l 472 574 l 472 479 l 275 479 l 164 -253 l 49 -253 l 160 479 l 40 479 " }, "ˆ": { "ha": 556, "x_min": 0, "x_max": 0, "o": "m 226 1051 l 331 1051 l 479 851 l 394 851 l 276 956 l 158 851 l 76 851 " }, "ˇ": { "ha": 556, "x_min": 0, "x_max": 0, "o": "m 76 1051 l 161 1051 l 279 947 l 397 1051 l 479 1051 l 329 851 l 225 851 " }, "˘": { "ha": 556, "x_min": 0, "x_max": 0, "o": "m 275 860 b 92 1043 175 860 97 938 l 183 1043 b 275 954 193 989 219 954 b 375 1043 333 954 364 988 l 464 1043 b 275 860 458 938 375 860 " }, "˙": { "ha": 556, "x_min": 0, "x_max": 0, "o": "m 278 878 b 201 954 236 878 201 913 b 278 1031 201 996 236 1031 b 354 954 319 1031 354 996 b 278 878 354 913 319 878 " }, "˚": { "ha": 556, "x_min": 0, "x_max": 0, "o": "m 278 894 b 351 975 321 894 351 929 b 278 1056 351 1021 321 1056 b 204 975 235 1056 204 1021 b 278 894 204 929 235 894 m 278 831 b 129 975 196 831 129 896 b 278 1119 129 1054 196 1119 b 426 975 360 1119 426 1054 b 278 831 426 896 360 831 " }, "˛": { "ha": 556, "x_min": 0, "x_max": 0, "o": "m 310 -253 b 165 -142 224 -253 165 -211 b 274 0 165 -82 214 -29 l 369 0 b 275 -119 307 -42 275 -76 b 328 -169 275 -153 294 -169 b 400 -154 351 -169 379 -165 l 400 -236 b 310 -253 376 -246 349 -253 " }, "˜": { "ha": 556, "x_min": 0, "x_max": 0, "o": "m 353 860 b 203 919 293 860 243 919 b 147 857 176 919 154 893 l 64 857 b 204 1018 75 956 132 1018 b 353 958 263 1018 313 958 b 408 1021 379 958 401 985 l 492 1021 b 353 860 481 922 424 860 " }, "˝": { "ha": 556, "x_min": 0, "x_max": 0, "o": "m 189 1056 l 321 1056 l 217 851 l 133 851 m 403 1056 l 535 1056 l 431 851 l 347 851 " }, "–": { "ha": 731, "x_min": 0, "x_max": 0, "o": "m 63 432 l 668 432 l 668 335 l 63 335 " }, "—": { "ha": 1229, "x_min": 0, "x_max": 0, "o": "m 63 432 l 1167 432 l 1167 335 l 63 335 " }, "‘": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 56 728 l 218 1008 l 289 972 l 165 678 " }, "’": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 65 714 l 189 1008 l 299 958 l 136 678 " }, "‚": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 65 -122 l 189 172 l 299 122 l 136 -158 " }, "“": { "ha": 600, "x_min": 0, "x_max": 0, "o": "m 56 728 l 218 1008 l 289 972 l 165 678 m 301 728 l 464 1008 l 535 972 l 411 678 " }, "”": { "ha": 600, "x_min": 0, "x_max": 0, "o": "m 65 714 l 189 1008 l 299 958 l 136 678 m 311 714 l 435 1008 l 544 958 l 382 678 " }, "„": { "ha": 600, "x_min": 0, "x_max": 0, "o": "m 65 -122 l 189 172 l 299 122 l 136 -158 m 311 -122 l 435 172 l 544 122 l 382 -158 " }, "†": { "ha": 519, "x_min": 0, "x_max": 0, "o": "m 208 721 l 47 721 l 47 814 l 208 814 l 208 993 l 313 993 l 313 814 l 472 814 l 472 721 l 313 721 l 313 296 l 208 296 " }, "‡": { "ha": 519, "x_min": 0, "x_max": 0, "o": "m 208 721 l 47 721 l 47 814 l 208 814 l 208 993 l 313 993 l 313 814 l 472 814 l 472 721 l 313 721 l 313 568 l 472 568 l 472 475 l 313 475 l 313 296 l 208 296 l 208 475 l 47 475 l 47 568 l 208 568 " }, "•": { "ha": 461, "x_min": 0, "x_max": 0, "o": "m 231 264 b 69 425 139 264 69 336 b 231 586 69 514 139 586 b 392 425 324 586 392 514 b 231 264 392 336 324 264 " }, "…": { "ha": 1119, "x_min": 0, "x_max": 0, "o": "m 196 -7 b 107 82 147 -7 107 32 b 196 171 107 132 147 171 b 285 82 244 171 285 132 b 196 -7 285 32 244 -7 m 560 -7 b 471 82 511 -7 471 32 b 560 171 471 132 511 171 b 649 82 608 171 649 132 b 560 -7 649 32 608 -7 m 924 -7 b 835 82 875 -7 835 32 b 924 171 835 132 875 171 b 1013 82 972 171 1013 132 b 924 -7 1013 32 972 -7 " }, "‰": { "ha": 1564, "x_min": 0, "x_max": 0, "o": "m 268 638 b 385 775 339 638 385 689 b 268 913 385 858 339 913 b 151 774 199 913 151 863 b 268 638 151 686 199 638 m 268 549 b 47 772 154 549 47 643 b 268 1001 47 906 151 1001 b 489 775 388 1001 489 906 b 268 549 489 643 383 549 m 782 993 l 888 993 l 281 0 l 175 0 m 785 78 b 901 215 856 78 901 129 b 785 353 901 299 856 353 b 668 214 715 353 668 303 b 785 78 668 126 715 78 m 785 -11 b 564 213 671 -11 564 83 b 785 442 564 346 668 442 b 1006 215 904 442 1006 346 b 785 -11 1006 83 900 -11 m 1296 78 b 1413 215 1367 78 1413 129 b 1296 353 1413 299 1367 353 b 1179 214 1226 353 1179 303 b 1296 78 1179 126 1226 78 m 1296 -11 b 1075 213 1182 -11 1075 83 b 1296 442 1075 346 1179 442 b 1517 215 1415 442 1517 346 b 1296 -11 1517 83 1411 -11 " }, "‹": { "ha": 447, "x_min": 0, "x_max": 0, "o": "m 82 363 l 263 610 l 376 610 l 203 363 l 376 115 l 263 115 " }, "›": { "ha": 447, "x_min": 0, "x_max": 0, "o": "m 244 363 l 71 610 l 185 610 l 365 363 l 185 115 l 71 115 " }, "⁄": { "ha": 157, "x_min": 0, "x_max": 0, "o": "m 385 993 l 476 993 l -228 0 l -319 0 " }, "™": { "ha": 994, "x_min": 0, "x_max": 0, "o": "m 475 993 l 582 993 l 707 679 l 829 993 l 938 993 l 938 546 l 860 546 l 860 894 l 717 546 l 690 546 l 546 894 l 546 546 l 475 546 m 183 932 l 47 932 l 47 993 l 396 993 l 396 932 l 261 932 l 261 546 l 183 546 " }, "−": { "ha": 721, "x_min": 0, "x_max": 0, "o": "m 50 524 l 671 524 l 671 426 l 50 426 " }, "≈": { "ha": 692, "x_min": 0, "x_max": 0, "o": "m 61 231 b 214 396 71 342 138 396 b 481 335 319 396 407 335 b 543 399 510 335 539 354 l 631 399 b 482 233 622 285 554 233 b 213 294 372 233 285 294 b 149 231 182 294 156 274 l 61 231 m 61 476 b 214 642 71 588 138 642 b 481 581 319 642 407 581 b 543 644 510 581 539 600 l 631 644 b 482 479 622 531 554 479 b 213 540 372 479 285 540 b 149 476 182 540 156 519 l 61 476 " }, "≠": { "ha": 672, "x_min": 0, "x_max": 0, "o": "m 56 622 l 354 622 l 410 765 l 515 765 l 460 622 l 617 622 l 617 522 l 421 522 l 364 372 l 617 372 l 617 272 l 325 272 l 269 129 l 164 129 l 219 272 l 56 272 l 56 372 l 258 372 l 315 522 l 56 522 " }, "≤": { "ha": 700, "x_min": 0, "x_max": 0, "o": "m 74 450 l 74 478 l 607 763 l 607 651 l 246 464 l 607 276 l 607 165 m 74 97 l 607 97 l 607 0 l 74 0 " }, "≥": { "ha": 700, "x_min": 0, "x_max": 0, "o": "m 93 276 l 454 464 l 93 651 l 93 763 l 626 478 l 626 450 l 93 165 m 93 97 l 626 97 l 626 0 l 93 0 " }, "Đ": { "ha": 994, "x_min": 0, "x_max": 0, "o": "m 47 544 l 153 544 l 153 993 l 415 993 b 918 506 757 993 918 782 l 918 493 b 413 0 918 218 760 0 l 153 0 l 153 451 l 47 451 m 410 99 b 793 494 665 99 793 251 l 793 506 b 408 896 793 735 682 896 l 274 896 l 274 544 l 561 544 l 561 451 l 274 451 l 274 99 " }, "Ŋ": { "ha": 1006, "x_min": 0, "x_max": 0, "o": "m 606 -268 b 467 -242 531 -268 493 -256 l 467 -142 b 599 -169 503 -157 539 -169 b 763 -1 696 -169 760 -115 l 240 851 l 240 0 l 125 0 l 125 993 l 282 993 l 765 204 l 765 993 l 881 993 l 881 14 b 606 -268 881 -185 757 -268 " }, "Ĳ": { "ha": 913, "x_min": 0, "x_max": 0, "o": "m 132 993 l 253 993 l 253 0 l 132 0 m 521 -12 b 382 14 446 -12 408 0 l 382 114 b 514 86 418 99 454 86 b 675 275 613 86 675 142 l 675 993 l 796 993 l 796 269 b 521 -12 796 71 672 -12 " }, "đ": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 392 939 l 639 939 l 639 1074 l 754 1074 l 754 939 l 858 939 l 858 854 l 754 854 l 754 0 l 639 0 l 639 125 b 390 -12 597 54 496 -12 b 63 349 200 -12 63 122 l 63 360 b 401 739 63 582 201 739 b 639 610 522 739 597 681 l 639 854 l 392 854 m 403 83 b 643 358 538 83 643 172 l 643 369 b 413 643 643 556 554 643 b 182 365 268 643 182 542 l 182 354 b 403 83 182 171 281 83 " }, "ŋ": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 499 -168 b 606 -56 581 -161 606 -119 l 606 454 b 435 639 606 582 551 639 b 232 440 328 639 232 571 l 232 0 l 117 0 l 117 726 l 232 726 l 232 611 b 465 739 265 679 346 739 b 721 446 615 739 721 657 l 721 -46 b 499 -265 721 -185 660 -260 " }, "ĳ": { "ha": 708, "x_min": 0, "x_max": 0, "o": "m 119 726 l 235 726 l 235 0 l 119 0 m 175 878 b 99 954 133 878 99 913 b 175 1031 99 996 133 1031 b 251 954 217 1031 251 996 b 175 878 251 913 217 878 m 367 -168 b 474 -56 449 -161 474 -119 l 474 726 l 589 726 l 589 -46 b 367 -265 589 -185 528 -260 m 529 878 b 453 954 488 878 453 913 b 529 1031 453 996 488 1031 b 606 954 571 1031 606 996 b 529 878 606 913 571 878 " }, "Ă": { "ha": 936, "x_min": 0, "x_max": 0, "o": "m 392 993 l 550 993 l 886 0 l 767 0 l 669 286 l 260 286 l 164 0 l 50 0 m 293 382 l 638 382 l 465 893 m 465 1065 b 282 1249 365 1065 288 1143 l 374 1249 b 465 1160 383 1194 410 1160 b 565 1249 524 1160 554 1193 l 654 1249 b 465 1065 649 1143 565 1065 " }, "Ā": { "ha": 936, "x_min": 0, "x_max": 0, "o": "m 392 993 l 550 993 l 886 0 l 767 0 l 669 286 l 260 286 l 164 0 l 50 0 m 293 382 l 638 382 l 465 893 m 283 1181 l 653 1181 l 653 1092 l 283 1092 " }, "Ą": { "ha": 936, "x_min": 0, "x_max": 0, "o": "m 813 -253 b 668 -142 726 -253 668 -211 b 768 -4 668 -85 713 -33 l 669 286 l 260 286 l 164 0 l 50 0 l 392 993 l 550 993 l 885 4 b 778 -119 808 -40 778 -76 b 831 -169 778 -153 797 -169 b 903 -154 854 -169 882 -165 l 903 -236 b 813 -253 879 -246 851 -253 m 293 382 l 638 382 l 465 893 " }, "Ǻ": { "ha": 936, "x_min": 0, "x_max": 0, "o": "m 392 993 l 550 993 l 886 0 l 767 0 l 669 286 l 260 286 l 164 0 l 50 0 m 293 382 l 638 382 l 465 893 m 478 1040 b 329 1185 396 1040 329 1106 b 478 1329 329 1264 396 1329 b 626 1185 560 1329 626 1264 b 478 1040 626 1106 560 1040 m 510 1546 l 654 1546 l 518 1369 l 432 1369 m 478 1104 b 551 1185 521 1104 551 1139 b 478 1265 551 1231 521 1265 b 404 1185 435 1265 404 1231 b 478 1104 404 1139 435 1104 " }, "Ǽ": { "ha": 1319, "x_min": 0, "x_max": 0, "o": "m 554 993 l 1238 993 l 1238 894 l 779 894 l 779 557 l 1149 557 l 1149 458 l 779 458 l 779 99 l 1263 99 l 1263 0 l 658 0 l 658 288 l 308 288 l 163 0 l 40 0 m 356 382 l 658 382 l 658 894 l 615 894 m 874 1247 l 1018 1247 l 882 1071 l 796 1071 " }, "Ć": { "ha": 1014, "x_min": 0, "x_max": 0, "o": "m 540 -12 b 76 490 253 -12 76 185 l 76 501 b 543 1008 76 796 274 1008 b 946 683 750 1008 925 899 l 826 683 b 544 913 801 835 714 913 b 201 503 339 913 201 753 l 201 492 b 543 86 201 239 329 86 b 843 329 706 86 818 168 l 956 329 b 540 -12 921 100 763 -12 m 572 1247 l 717 1247 l 581 1071 l 494 1071 " }, "Č": { "ha": 1014, "x_min": 0, "x_max": 0, "o": "m 540 -12 b 76 490 253 -12 76 185 l 76 501 b 543 1008 76 796 274 1008 b 946 683 750 1008 925 899 l 826 683 b 544 913 801 835 714 913 b 201 503 339 913 201 753 l 201 492 b 543 86 201 239 329 86 b 843 329 706 86 818 168 l 956 329 b 540 -12 921 100 763 -12 m 344 1247 l 429 1247 l 547 1167 l 665 1247 l 747 1247 l 597 1071 l 493 1071 " }, "Ĉ": { "ha": 1014, "x_min": 0, "x_max": 0, "o": "m 540 -12 b 76 490 253 -12 76 185 l 76 501 b 543 1008 76 796 274 1008 b 946 683 750 1008 925 899 l 826 683 b 544 913 801 835 714 913 b 201 503 339 913 201 753 l 201 492 b 543 86 201 239 329 86 b 843 329 706 86 818 168 l 956 329 b 540 -12 921 100 763 -12 m 494 1247 l 599 1247 l 747 1071 l 663 1071 l 544 1151 l 426 1071 l 344 1071 " }, "Ċ": { "ha": 1014, "x_min": 0, "x_max": 0, "o": "m 540 -12 b 76 490 253 -12 76 185 l 76 501 b 543 1008 76 796 274 1008 b 946 683 750 1008 925 899 l 826 683 b 544 913 801 835 714 913 b 201 503 339 913 201 753 l 201 492 b 543 86 201 239 329 86 b 843 329 706 86 818 168 l 956 329 b 540 -12 921 100 763 -12 m 540 1093 b 464 1169 499 1093 464 1128 b 540 1246 464 1211 499 1246 b 617 1169 582 1246 617 1211 b 540 1093 617 1128 582 1093 " }, "Ď": { "ha": 967, "x_min": 0, "x_max": 0, "o": "m 382 99 b 765 494 638 99 765 251 l 765 506 b 381 896 765 735 654 896 l 246 896 l 246 99 m 125 993 l 388 993 b 890 506 729 993 890 782 l 890 493 b 385 0 890 218 732 0 l 125 0 m 238 1247 l 322 1247 l 440 1167 l 558 1247 l 640 1247 l 490 1071 l 386 1071 " }, "Ĕ": { "ha": 786, "x_min": 0, "x_max": 0, "o": "m 125 993 l 704 993 l 704 894 l 246 894 l 246 557 l 615 557 l 615 458 l 246 458 l 246 99 l 729 99 l 729 0 l 125 0 m 432 1065 b 249 1249 332 1065 254 1143 l 340 1249 b 432 1160 350 1194 376 1160 b 532 1249 490 1160 521 1193 l 621 1249 b 432 1065 615 1143 532 1065 " }, "Ě": { "ha": 786, "x_min": 0, "x_max": 0, "o": "m 125 993 l 704 993 l 704 894 l 246 894 l 246 557 l 615 557 l 615 458 l 246 458 l 246 99 l 729 99 l 729 0 l 125 0 m 229 1247 l 314 1247 l 432 1167 l 550 1247 l 632 1247 l 482 1071 l 378 1071 " }, "Ė": { "ha": 786, "x_min": 0, "x_max": 0, "o": "m 125 993 l 704 993 l 704 894 l 246 894 l 246 557 l 615 557 l 615 458 l 246 458 l 246 99 l 729 99 l 729 0 l 125 0 m 425 1093 b 349 1169 383 1093 349 1128 b 425 1246 349 1211 383 1246 b 501 1169 467 1246 501 1211 b 425 1093 501 1128 467 1093 " }, "Ē": { "ha": 786, "x_min": 0, "x_max": 0, "o": "m 125 993 l 704 993 l 704 894 l 246 894 l 246 557 l 615 557 l 615 458 l 246 458 l 246 99 l 729 99 l 729 0 l 125 0 m 240 1181 l 610 1181 l 610 1092 l 240 1092 " }, "Ę": { "ha": 786, "x_min": 0, "x_max": 0, "o": "m 631 -253 b 486 -142 544 -253 486 -211 b 594 0 486 -82 535 -29 l 125 0 l 125 993 l 704 993 l 704 894 l 246 894 l 246 557 l 615 557 l 615 458 l 246 458 l 246 99 l 729 99 l 729 0 l 690 0 b 596 -119 628 -42 596 -76 b 649 -169 596 -153 615 -169 b 721 -154 672 -169 700 -165 l 721 -236 b 631 -253 697 -246 669 -253 " }, "Ğ": { "ha": 1065, "x_min": 0, "x_max": 0, "o": "m 557 -12 b 76 490 251 -12 76 200 l 76 501 b 557 1008 76 792 272 1008 b 961 693 754 1008 931 917 l 840 693 b 560 913 813 851 704 913 b 201 503 332 913 201 746 l 201 492 b 557 85 201 246 324 85 b 869 401 772 85 865 225 l 579 401 l 579 501 l 988 501 l 988 428 b 557 -12 988 140 811 -12 m 546 1065 b 363 1249 446 1065 368 1143 l 454 1249 b 546 1160 464 1194 490 1160 b 646 1249 604 1160 635 1193 l 735 1249 b 546 1065 729 1143 646 1065 " }, "Ĝ": { "ha": 1065, "x_min": 0, "x_max": 0, "o": "m 557 -12 b 76 490 251 -12 76 200 l 76 501 b 557 1008 76 792 272 1008 b 961 693 754 1008 931 917 l 840 693 b 560 913 813 851 704 913 b 201 503 332 913 201 746 l 201 492 b 557 85 201 246 324 85 b 869 401 772 85 865 225 l 579 401 l 579 501 l 988 501 l 988 428 b 557 -12 988 140 811 -12 m 497 1247 l 601 1247 l 750 1071 l 665 1071 l 547 1151 l 429 1071 l 347 1071 " }, "Ģ": { "ha": 1065, "x_min": 0, "x_max": 0, "o": "m 557 -12 b 76 490 251 -12 76 200 l 76 501 b 557 1008 76 792 272 1008 b 961 693 754 1008 931 917 l 840 693 b 560 913 813 851 704 913 b 201 503 332 913 201 746 l 201 492 b 557 85 201 246 324 85 b 869 401 772 85 865 225 l 579 401 l 579 501 l 988 501 l 988 428 b 557 -12 988 140 811 -12 m 432 -269 l 513 -51 l 624 -85 l 503 -306 " }, "Ġ": { "ha": 1065, "x_min": 0, "x_max": 0, "o": "m 557 -12 b 76 490 251 -12 76 200 l 76 501 b 557 1008 76 792 272 1008 b 961 693 754 1008 931 917 l 840 693 b 560 913 813 851 704 913 b 201 503 332 913 201 746 l 201 492 b 557 85 201 246 324 85 b 869 401 772 85 865 225 l 579 401 l 579 501 l 988 501 l 988 428 b 557 -12 988 140 811 -12 m 549 1093 b 472 1169 507 1093 472 1128 b 549 1246 472 1211 507 1246 b 625 1169 590 1246 625 1211 b 549 1093 625 1128 590 1093 " }, "Ħ": { "ha": 1014, "x_min": 0, "x_max": 0, "o": "m 28 778 l 125 778 l 125 993 l 246 993 l 246 778 l 768 778 l 768 993 l 889 993 l 889 778 l 986 778 l 986 685 l 889 685 l 889 0 l 768 0 l 768 442 l 246 442 l 246 0 l 125 0 l 125 685 l 28 685 m 768 543 l 768 685 l 246 685 l 246 543 " }, "Ĥ": { "ha": 1014, "x_min": 0, "x_max": 0, "o": "m 125 993 l 246 993 l 246 543 l 768 543 l 768 993 l 889 993 l 889 0 l 768 0 l 768 442 l 246 442 l 246 0 l 125 0 m 456 1247 l 560 1247 l 708 1071 l 624 1071 l 506 1151 l 388 1071 l 306 1071 " }, "Ĭ": { "ha": 385, "x_min": 0, "x_max": 0, "o": "m 132 993 l 253 993 l 253 0 l 132 0 m 192 1065 b 8 1249 92 1065 14 1143 l 100 1249 b 192 1160 110 1194 136 1160 b 292 1249 250 1160 281 1193 l 381 1249 b 192 1065 375 1143 292 1065 " }, "İ": { "ha": 385, "x_min": 0, "x_max": 0, "o": "m 132 993 l 253 993 l 253 0 l 132 0 m 192 1093 b 115 1169 150 1093 115 1128 b 192 1246 115 1211 150 1246 b 268 1169 233 1246 268 1211 b 192 1093 268 1128 233 1093 " }, "Ī": { "ha": 385, "x_min": 0, "x_max": 0, "o": "m 132 993 l 253 993 l 253 0 l 132 0 m 7 1181 l 376 1181 l 376 1092 l 7 1092 " }, "Į": { "ha": 385, "x_min": 0, "x_max": 0, "o": "m 181 -253 b 36 -142 94 -253 36 -211 b 132 -6 36 -86 78 -36 l 132 993 l 253 993 l 253 6 b 146 -119 178 -37 146 -76 b 199 -169 146 -153 165 -169 b 271 -154 222 -169 250 -165 l 271 -236 b 181 -253 247 -246 219 -253 " }, "Ĩ": { "ha": 385, "x_min": 0, "x_max": 0, "o": "m 132 993 l 253 993 l 253 0 l 132 0 m 269 1075 b 119 1135 210 1075 160 1135 b 64 1072 93 1135 71 1108 l -19 1072 b 121 1233 -8 1171 49 1233 b 269 1174 179 1233 229 1174 b 325 1236 296 1174 318 1200 l 408 1236 b 269 1075 397 1138 340 1075 " }, "Ĵ": { "ha": 583, "x_min": 0, "x_max": 0, "o": "m 192 -12 b 53 14 117 -12 79 0 l 53 114 b 185 86 89 99 125 86 b 346 275 283 86 346 142 l 346 993 l 467 993 l 467 269 b 192 -12 467 71 343 -12 m 351 1247 l 456 1247 l 604 1071 l 519 1071 l 401 1151 l 283 1071 l 201 1071 " }, "Ķ": { "ha": 856, "x_min": 0, "x_max": 0, "o": "m 125 993 l 246 993 l 246 515 l 678 994 l 813 994 l 371 511 l 835 0 l 689 0 l 246 485 l 246 0 l 125 0 m 331 -269 l 411 -51 l 522 -85 l 401 -306 " }, "Ĺ": { "ha": 743, "x_min": 0, "x_max": 0, "o": "m 125 993 l 246 993 l 246 99 l 700 99 l 700 0 l 125 0 m 214 1247 l 358 1247 l 222 1071 l 136 1071 " }, "Ľ": { "ha": 743, "x_min": 0, "x_max": 0, "o": "m 438 993 l 568 993 l 488 775 l 407 775 m 125 993 l 246 993 l 246 99 l 700 99 l 700 0 l 125 0 " }, "Ļ": { "ha": 743, "x_min": 0, "x_max": 0, "o": "m 125 993 l 246 993 l 246 99 l 700 99 l 700 0 l 125 0 m 297 -269 l 378 -51 l 489 -85 l 368 -306 " }, "Ŀ": { "ha": 743, "x_min": 0, "x_max": 0, "o": "m 125 993 l 246 993 l 246 99 l 700 99 l 700 0 l 125 0 m 556 444 b 467 533 507 444 467 483 b 556 622 467 583 507 622 b 644 533 604 622 644 583 b 556 444 644 483 604 444 " }, "Ń": { "ha": 1006, "x_min": 0, "x_max": 0, "o": "m 125 993 l 282 993 l 765 172 l 765 993 l 881 993 l 881 0 l 742 0 l 240 851 l 240 0 l 125 0 m 543 1247 l 688 1247 l 551 1071 l 465 1071 " }, "Ň": { "ha": 1006, "x_min": 0, "x_max": 0, "o": "m 125 993 l 282 993 l 765 172 l 765 993 l 881 993 l 881 0 l 742 0 l 240 851 l 240 0 l 125 0 m 315 1247 l 400 1247 l 518 1167 l 636 1247 l 718 1247 l 568 1071 l 464 1071 " }, "Ņ": { "ha": 1006, "x_min": 0, "x_max": 0, "o": "m 125 993 l 282 993 l 765 172 l 765 993 l 881 993 l 881 0 l 742 0 l 240 851 l 240 0 l 125 0 m 369 -269 l 450 -51 l 561 -85 l 440 -306 " }, "Ŏ": { "ha": 1126, "x_min": 0, "x_max": 0, "o": "m 568 88 b 925 494 789 88 925 254 l 925 506 b 565 908 925 728 794 908 b 201 503 335 908 201 739 l 201 492 b 568 88 201 251 361 88 m 568 -12 b 76 490 275 -12 76 213 l 76 501 b 565 1006 76 783 274 1006 b 1050 504 857 1006 1050 783 l 1050 493 b 568 -12 1050 213 857 -12 m 560 1065 b 376 1249 460 1065 382 1143 l 468 1249 b 560 1160 478 1194 504 1160 b 660 1249 618 1160 649 1193 l 749 1249 b 560 1065 743 1143 660 1065 " }, "Ő": { "ha": 1126, "x_min": 0, "x_max": 0, "o": "m 568 88 b 925 494 789 88 925 254 l 925 506 b 565 908 925 728 794 908 b 201 503 335 908 201 739 l 201 492 b 568 88 201 251 361 88 m 568 -12 b 76 490 275 -12 76 213 l 76 501 b 565 1006 76 783 274 1006 b 1050 504 857 1006 1050 783 l 1050 493 b 568 -12 1050 213 857 -12 m 458 1247 l 590 1247 l 490 1071 l 407 1071 m 672 1247 l 804 1247 l 704 1071 l 621 1071 " }, "Ō": { "ha": 1126, "x_min": 0, "x_max": 0, "o": "m 568 88 b 925 494 789 88 925 254 l 925 506 b 565 908 925 728 794 908 b 201 503 335 908 201 739 l 201 492 b 568 88 201 251 361 88 m 568 -12 b 76 490 275 -12 76 213 l 76 501 b 565 1006 76 783 274 1006 b 1050 504 857 1006 1050 783 l 1050 493 b 568 -12 1050 213 857 -12 m 378 1181 l 747 1181 l 747 1092 l 378 1092 " }, "Ǿ": { "ha": 1126, "x_min": 0, "x_max": 0, "o": "m 49 17 l 185 165 b 76 490 115 253 76 367 l 76 501 b 565 1006 76 783 274 1006 b 863 908 682 1006 783 969 l 975 1031 l 1038 968 l 928 847 b 1050 504 1006 758 1050 638 l 1050 493 b 568 -12 1050 213 857 -12 b 246 101 440 -12 329 31 l 111 -46 m 568 88 b 925 494 789 88 925 254 l 925 506 b 853 767 925 608 900 697 l 319 182 b 568 88 383 119 471 88 m 201 492 b 263 251 201 396 224 315 l 793 832 b 565 908 735 881 658 908 b 201 503 335 908 201 739 l 201 492 m 590 1247 l 735 1247 l 599 1071 l 513 1071 " }, "Ŕ": { "ha": 872, "x_min": 0, "x_max": 0, "o": "m 125 993 l 424 993 b 771 717 614 993 771 915 l 771 711 b 525 440 771 547 661 467 l 829 0 l 694 0 l 399 432 l 246 432 l 246 0 l 125 0 m 432 528 b 650 711 574 528 650 589 l 650 717 b 432 896 650 851 567 896 l 246 896 l 246 528 m 457 1247 l 601 1247 l 465 1071 l 379 1071 " }, "Ř": { "ha": 872, "x_min": 0, "x_max": 0, "o": "m 125 993 l 424 993 b 771 717 614 993 771 915 l 771 711 b 525 440 771 547 661 467 l 829 0 l 694 0 l 399 432 l 246 432 l 246 0 l 125 0 m 432 528 b 650 711 574 528 650 589 l 650 717 b 432 896 650 851 567 896 l 246 896 l 246 528 m 229 1247 l 314 1247 l 432 1167 l 550 1247 l 632 1247 l 482 1071 l 378 1071 " }, "Ŗ": { "ha": 872, "x_min": 0, "x_max": 0, "o": "m 125 993 l 424 993 b 771 717 614 993 771 915 l 771 711 b 525 440 771 547 661 467 l 829 0 l 694 0 l 399 432 l 246 432 l 246 0 l 125 0 m 432 528 b 650 711 574 528 650 589 l 650 717 b 432 896 650 851 567 896 l 246 896 l 246 528 m 314 -269 l 394 -51 l 506 -85 l 385 -306 " }, "Ś": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 446 -12 b 67 303 181 -12 85 133 l 183 303 b 446 85 199 185 246 85 b 672 272 574 85 672 160 b 432 463 672 385 621 432 b 100 736 224 494 100 560 b 419 1006 100 889 232 1006 b 761 732 618 1006 742 908 l 653 732 b 419 908 629 857 557 908 b 213 747 283 908 213 840 b 451 569 213 650 249 600 b 789 281 672 535 789 468 b 446 -12 789 114 643 -12 m 446 1247 l 590 1247 l 454 1071 l 368 1071 " }, "Ş": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 403 -297 b 264 -181 322 -297 269 -250 l 339 -181 b 399 -231 344 -207 364 -231 b 454 -181 433 -231 454 -210 b 404 -133 454 -151 433 -133 b 365 -144 386 -133 372 -140 l 321 -106 l 374 -8 b 67 303 163 15 83 149 l 183 303 b 446 85 199 185 246 85 b 672 272 574 85 672 160 b 432 463 672 385 621 432 b 100 736 224 494 100 560 b 419 1006 100 889 232 1006 b 761 732 618 1006 742 908 l 653 732 b 419 908 629 857 557 908 b 213 747 283 908 213 840 b 451 569 213 650 249 600 b 789 281 672 535 789 468 b 446 -12 789 114 643 -12 l 413 -74 b 543 -186 476 -65 543 -101 b 403 -297 543 -261 478 -297 " }, "Ŝ": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 446 -12 b 67 303 181 -12 85 133 l 183 303 b 446 85 199 185 246 85 b 672 272 574 85 672 160 b 432 463 672 385 621 432 b 100 736 224 494 100 560 b 419 1006 100 889 232 1006 b 761 732 618 1006 742 908 l 653 732 b 419 908 629 857 557 908 b 213 747 283 908 213 840 b 451 569 213 650 249 600 b 789 281 672 535 789 468 b 446 -12 789 114 643 -12 m 368 1247 l 472 1247 l 621 1071 l 536 1071 l 418 1151 l 300 1071 l 218 1071 " }, "Ș": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 446 -12 b 67 303 181 -12 85 133 l 183 303 b 446 85 199 185 246 85 b 672 272 574 85 672 160 b 432 463 672 385 621 432 b 100 736 224 494 100 560 b 419 1006 100 889 232 1006 b 761 732 618 1006 742 908 l 653 732 b 419 908 629 857 557 908 b 213 747 283 908 213 840 b 451 569 213 650 249 600 b 789 281 672 535 789 468 b 446 -12 789 114 643 -12 m 303 -269 l 383 -51 l 494 -85 l 374 -306 " }, "Ť": { "ha": 779, "x_min": 0, "x_max": 0, "o": "m 329 894 l 40 894 l 40 993 l 739 993 l 739 894 l 450 894 l 450 0 l 329 0 m 188 1247 l 272 1247 l 390 1167 l 508 1247 l 590 1247 l 440 1071 l 336 1071 " }, "Ţ": { "ha": 779, "x_min": 0, "x_max": 0, "o": "m 329 894 l 40 894 l 40 993 l 739 993 l 739 894 l 450 894 l 450 0 l 329 0 m 272 -269 l 353 -51 l 464 -85 l 343 -306 " }, "Ŧ": { "ha": 779, "x_min": 0, "x_max": 0, "o": "m 128 561 l 329 561 l 329 894 l 40 894 l 40 993 l 739 993 l 739 894 l 450 894 l 450 561 l 651 561 l 651 469 l 450 469 l 450 0 l 329 0 l 329 469 l 128 469 " }, "Ŭ": { "ha": 967, "x_min": 0, "x_max": 0, "o": "m 474 -12 b 117 363 246 -12 117 121 l 117 993 l 238 993 l 238 376 b 476 88 238 168 311 88 b 729 394 635 88 729 151 l 729 993 l 850 993 l 850 378 b 474 -12 850 136 729 -12 m 481 1065 b 297 1249 381 1065 303 1143 l 389 1249 b 481 1160 399 1194 425 1160 b 581 1249 539 1160 569 1193 l 669 1249 b 481 1065 664 1143 581 1065 " }, "Ű": { "ha": 967, "x_min": 0, "x_max": 0, "o": "m 474 -12 b 117 363 246 -12 117 121 l 117 993 l 238 993 l 238 376 b 476 88 238 168 311 88 b 729 394 635 88 729 151 l 729 993 l 850 993 l 850 378 b 474 -12 850 136 729 -12 m 379 1247 l 511 1247 l 411 1071 l 328 1071 m 593 1247 l 725 1247 l 625 1071 l 542 1071 " }, "Ū": { "ha": 967, "x_min": 0, "x_max": 0, "o": "m 474 -12 b 117 363 246 -12 117 121 l 117 993 l 238 993 l 238 376 b 476 88 238 168 311 88 b 729 394 635 88 729 151 l 729 993 l 850 993 l 850 378 b 474 -12 850 136 729 -12 m 299 1181 l 668 1181 l 668 1092 l 299 1092 " }, "Ų": { "ha": 967, "x_min": 0, "x_max": 0, "o": "m 533 -253 b 389 -142 447 -253 389 -211 b 475 -12 389 -89 426 -43 l 474 -12 b 117 363 246 -12 117 121 l 117 993 l 238 993 l 238 376 b 476 88 238 168 311 88 b 729 394 635 88 729 151 l 729 993 l 850 993 l 850 378 b 665 25 850 201 785 81 b 499 -119 571 -19 499 -51 b 551 -169 499 -153 518 -169 b 624 -154 575 -169 603 -165 l 624 -236 b 533 -253 600 -246 572 -253 " }, "Ů": { "ha": 967, "x_min": 0, "x_max": 0, "o": "m 474 -12 b 117 363 246 -12 117 121 l 117 993 l 238 993 l 238 376 b 476 88 238 168 311 88 b 729 394 635 88 729 151 l 729 993 l 850 993 l 850 378 b 474 -12 850 136 729 -12 m 483 1090 b 557 1171 526 1090 557 1125 b 483 1251 557 1217 526 1251 b 410 1171 440 1251 410 1217 b 483 1090 410 1125 440 1090 m 483 1026 b 335 1171 401 1026 335 1092 b 483 1315 335 1250 401 1315 b 632 1171 565 1315 632 1250 b 483 1026 632 1092 565 1026 " }, "Ũ": { "ha": 967, "x_min": 0, "x_max": 0, "o": "m 474 -12 b 117 363 246 -12 117 121 l 117 993 l 238 993 l 238 376 b 476 88 238 168 311 88 b 729 394 635 88 729 151 l 729 993 l 850 993 l 850 378 b 474 -12 850 136 729 -12 m 558 1075 b 408 1135 499 1075 449 1135 b 353 1072 382 1135 360 1108 l 269 1072 b 410 1233 281 1171 338 1233 b 558 1174 468 1233 518 1174 b 614 1236 585 1174 607 1200 l 697 1236 b 558 1075 686 1138 629 1075 " }, "Ẃ": { "ha": 1289, "x_min": 0, "x_max": 0, "o": "m 47 993 l 171 993 l 372 192 l 606 993 l 692 993 l 925 189 l 1129 993 l 1242 993 l 983 0 l 872 0 l 647 785 l 415 0 l 306 0 m 689 1247 l 833 1247 l 697 1071 l 611 1071 " }, "Ŵ": { "ha": 1289, "x_min": 0, "x_max": 0, "o": "m 47 993 l 171 993 l 372 192 l 606 993 l 692 993 l 925 189 l 1129 993 l 1242 993 l 983 0 l 872 0 l 647 785 l 415 0 l 306 0 m 593 1247 l 697 1247 l 846 1071 l 761 1071 l 643 1151 l 525 1071 l 443 1071 " }, "Ẅ": { "ha": 1289, "x_min": 0, "x_max": 0, "o": "m 47 993 l 171 993 l 372 192 l 606 993 l 692 993 l 925 189 l 1129 993 l 1242 993 l 983 0 l 872 0 l 647 785 l 415 0 l 306 0 m 507 1096 b 433 1169 467 1096 433 1129 b 507 1243 433 1210 467 1243 b 581 1169 547 1243 581 1210 b 507 1096 581 1129 547 1096 m 789 1096 b 715 1169 749 1096 715 1129 b 789 1243 715 1210 749 1243 b 863 1169 829 1243 863 1210 b 789 1096 863 1129 829 1096 " }, "Ẁ": { "ha": 1289, "x_min": 0, "x_max": 0, "o": "m 47 993 l 171 993 l 372 192 l 606 993 l 692 993 l 925 189 l 1129 993 l 1242 993 l 983 0 l 872 0 l 647 785 l 415 0 l 306 0 m 478 1247 l 622 1247 l 700 1071 l 614 1071 " }, "Ŷ": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 364 433 l 32 993 l 168 993 l 428 532 l 678 993 l 799 993 l 485 432 l 485 0 l 364 0 m 364 1247 l 468 1247 l 617 1071 l 532 1071 l 414 1151 l 296 1071 l 214 1071 " }, "Ỳ": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 364 433 l 32 993 l 168 993 l 428 532 l 678 993 l 799 993 l 485 432 l 485 0 l 364 0 m 258 1247 l 403 1247 l 481 1071 l 394 1071 " }, "Ź": { "ha": 826, "x_min": 0, "x_max": 0, "o": "m 39 19 l 601 894 l 89 894 l 89 993 l 768 993 l 768 975 l 221 103 l 760 103 l 760 0 l 39 0 m 436 1247 l 581 1247 l 444 1071 l 358 1071 " }, "Ż": { "ha": 826, "x_min": 0, "x_max": 0, "o": "m 39 19 l 601 894 l 89 894 l 89 993 l 768 993 l 768 975 l 221 103 l 760 103 l 760 0 l 39 0 m 410 1093 b 333 1169 368 1093 333 1128 b 410 1246 333 1211 368 1246 b 486 1169 451 1246 486 1211 b 410 1093 486 1128 451 1093 " }, "ă": { "ha": 750, "x_min": 0, "x_max": 0, "o": "m 299 -12 b 57 201 164 -12 57 53 b 421 426 57 369 235 426 l 525 426 l 525 479 b 369 643 525 594 481 643 b 203 513 269 643 214 601 l 88 513 b 375 739 103 678 235 739 b 640 479 514 739 640 682 l 640 0 l 525 0 l 525 92 b 299 -12 471 24 406 -12 m 310 79 b 525 254 432 79 525 142 l 525 344 l 425 344 b 172 201 279 344 172 308 b 310 79 172 126 208 79 m 374 860 b 190 1043 274 860 196 938 l 282 1043 b 374 954 292 989 318 954 b 474 1043 432 954 463 988 l 563 1043 b 374 860 557 938 474 860 " }, "ā": { "ha": 750, "x_min": 0, "x_max": 0, "o": "m 299 -12 b 57 201 164 -12 57 53 b 421 426 57 369 235 426 l 525 426 l 525 479 b 369 643 525 594 481 643 b 203 513 269 643 214 601 l 88 513 b 375 739 103 678 235 739 b 640 479 514 739 640 682 l 640 0 l 525 0 l 525 92 b 299 -12 471 24 406 -12 m 310 79 b 525 254 432 79 525 142 l 525 344 l 425 344 b 172 201 279 344 172 308 b 310 79 172 126 208 79 m 194 989 l 558 989 l 558 900 l 194 900 " }, "ą": { "ha": 750, "x_min": 0, "x_max": 0, "o": "m 565 -253 b 421 -142 479 -253 421 -211 b 525 -1 421 -83 467 -32 l 525 92 b 299 -12 471 24 406 -12 b 57 201 164 -12 57 53 b 421 426 57 369 235 426 l 525 426 l 525 479 b 369 643 525 594 481 643 b 203 513 269 643 214 601 l 88 513 b 375 739 103 678 235 739 b 640 479 514 739 640 682 l 640 6 b 531 -119 565 -37 531 -76 b 583 -169 531 -153 550 -169 b 656 -154 607 -169 635 -165 l 656 -236 b 565 -253 632 -246 604 -253 m 310 79 b 525 254 432 79 525 142 l 525 344 l 425 344 b 172 201 279 344 172 308 b 310 79 172 126 208 79 " }, "ǻ": { "ha": 750, "x_min": 0, "x_max": 0, "o": "m 299 -12 b 57 201 164 -12 57 53 b 421 426 57 369 235 426 l 525 426 l 525 479 b 369 643 525 594 481 643 b 203 513 269 643 214 601 l 88 513 b 375 739 103 678 235 739 b 640 479 514 739 640 682 l 640 0 l 525 0 l 525 92 b 299 -12 471 24 406 -12 m 310 79 b 525 254 432 79 525 142 l 525 344 l 425 344 b 172 201 279 344 172 308 b 310 79 172 126 208 79 m 379 867 b 453 947 422 867 453 901 b 379 1028 453 993 422 1028 b 306 947 336 1028 306 993 b 379 867 306 901 336 867 m 379 803 b 231 947 297 803 231 868 b 379 1092 231 1026 297 1092 b 528 947 461 1092 528 1026 b 379 803 528 868 461 803 m 421 1328 l 565 1328 l 429 1151 l 343 1151 " }, "ǽ": { "ha": 1222, "x_min": 0, "x_max": 0, "o": "m 856 -12 b 582 138 733 -12 638 43 b 299 -12 515 33 432 -12 b 57 201 164 -12 57 53 b 417 431 57 371 231 431 l 525 431 l 525 478 b 369 643 525 593 476 643 b 203 513 269 643 214 601 l 88 513 b 375 739 103 678 235 739 b 603 615 471 739 561 708 b 847 739 658 693 742 739 b 1163 378 1008 739 1163 640 l 1163 343 l 636 343 b 857 83 642 178 714 83 b 1042 210 965 83 1026 125 l 1157 210 b 856 -12 1132 64 1013 -12 m 310 79 b 525 254 432 79 525 142 l 525 343 l 421 343 b 172 201 275 343 172 308 b 310 79 172 126 208 79 m 1044 431 b 847 643 1033 583 963 643 b 640 431 735 643 658 561 m 651 1056 l 796 1056 l 651 851 l 565 851 " }, "ć": { "ha": 792, "x_min": 0, "x_max": 0, "o": "m 418 -12 b 63 356 215 -12 63 131 l 63 367 b 415 739 63 589 221 739 b 731 485 567 739 708 669 l 617 485 b 415 643 599 600 515 643 b 182 367 283 643 182 538 l 182 356 b 419 83 182 178 279 83 b 628 261 522 83 615 143 l 735 261 b 418 -12 719 104 593 -12 m 449 1056 l 593 1056 l 449 851 l 363 851 " }, "č": { "ha": 792, "x_min": 0, "x_max": 0, "o": "m 418 -12 b 63 356 215 -12 63 131 l 63 367 b 415 739 63 589 221 739 b 731 485 567 739 708 669 l 617 485 b 415 643 599 600 515 643 b 182 367 283 643 182 538 l 182 356 b 419 83 182 178 279 83 b 628 261 522 83 615 143 l 735 261 b 418 -12 719 104 593 -12 m 213 1051 l 297 1051 l 415 947 l 533 1051 l 615 1051 l 465 851 l 361 851 " }, "ĉ": { "ha": 792, "x_min": 0, "x_max": 0, "o": "m 418 -12 b 63 356 215 -12 63 131 l 63 367 b 415 739 63 589 221 739 b 731 485 567 739 708 669 l 617 485 b 415 643 599 600 515 643 b 182 367 283 643 182 538 l 182 356 b 419 83 182 178 279 83 b 628 261 522 83 615 143 l 735 261 b 418 -12 719 104 593 -12 m 363 1051 l 467 1051 l 615 851 l 531 851 l 413 956 l 294 851 l 213 851 " }, "ċ": { "ha": 792, "x_min": 0, "x_max": 0, "o": "m 418 -12 b 63 356 215 -12 63 131 l 63 367 b 415 739 63 589 221 739 b 731 485 567 739 708 669 l 617 485 b 415 643 599 600 515 643 b 182 367 283 643 182 538 l 182 356 b 419 83 182 178 279 83 b 628 261 522 83 615 143 l 735 261 b 418 -12 719 104 593 -12 m 414 878 b 338 954 372 878 338 913 b 414 1031 338 996 372 1031 b 490 954 456 1031 490 996 b 414 878 490 913 456 878 " }, "ď": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 390 -12 b 63 349 200 -12 63 122 l 63 360 b 401 739 63 582 201 739 b 639 610 522 739 597 681 l 639 1074 l 754 1074 l 754 0 l 639 0 l 639 125 b 390 -12 597 54 496 -12 m 403 83 b 643 358 538 83 643 172 l 643 369 b 413 643 643 556 554 643 b 182 365 268 643 182 542 l 182 354 b 403 83 182 171 281 83 m 838 1074 l 968 1074 l 901 831 l 821 831 " }, "ĕ": { "ha": 789, "x_min": 0, "x_max": 0, "o": "m 414 -12 b 63 356 208 -12 63 132 l 63 367 b 403 739 63 586 203 739 b 729 378 571 739 729 638 l 729 340 l 182 340 b 415 83 188 175 267 83 b 608 210 528 83 593 125 l 724 210 b 414 -12 699 64 578 -12 m 611 433 b 403 643 600 583 522 643 b 186 433 285 643 206 563 m 389 860 b 206 1043 289 860 211 938 l 297 1043 b 389 954 307 989 333 954 b 489 1043 447 954 478 988 l 578 1043 b 389 860 572 938 489 860 " }, "ě": { "ha": 789, "x_min": 0, "x_max": 0, "o": "m 414 -12 b 63 356 208 -12 63 132 l 63 367 b 403 739 63 586 203 739 b 729 378 571 739 729 638 l 729 340 l 182 340 b 415 83 188 175 267 83 b 608 210 528 83 593 125 l 724 210 b 414 -12 699 64 578 -12 m 611 433 b 403 643 600 583 522 643 b 186 433 285 643 206 563 m 201 1051 l 286 1051 l 404 947 l 522 1051 l 604 1051 l 454 851 l 350 851 " }, "ė": { "ha": 789, "x_min": 0, "x_max": 0, "o": "m 414 -12 b 63 356 208 -12 63 132 l 63 367 b 403 739 63 586 203 739 b 729 378 571 739 729 638 l 729 340 l 182 340 b 415 83 188 175 267 83 b 608 210 528 83 593 125 l 724 210 b 414 -12 699 64 578 -12 m 611 433 b 403 643 600 583 522 643 b 186 433 285 643 206 563 m 403 878 b 326 954 361 878 326 913 b 403 1031 326 996 361 1031 b 479 954 444 1031 479 996 b 403 878 479 913 444 878 " }, "ē": { "ha": 789, "x_min": 0, "x_max": 0, "o": "m 414 -12 b 63 356 208 -12 63 132 l 63 367 b 403 739 63 586 203 739 b 729 378 571 739 729 638 l 729 340 l 182 340 b 415 83 188 175 267 83 b 608 210 528 83 593 125 l 724 210 b 414 -12 699 64 578 -12 m 611 433 b 403 643 600 583 522 643 b 186 433 285 643 206 563 m 221 989 l 585 989 l 585 900 l 221 900 " }, "ę": { "ha": 789, "x_min": 0, "x_max": 0, "o": "m 539 -253 b 394 -142 453 -253 394 -211 b 490 -7 394 -86 436 -36 b 414 -12 465 -11 440 -12 b 63 356 208 -12 63 132 l 63 367 b 403 739 63 586 203 739 b 729 378 571 739 729 638 l 729 340 l 182 340 b 415 83 188 175 267 83 b 608 210 528 83 593 125 l 724 210 b 597 15 704 97 633 46 b 504 -119 543 -31 504 -76 b 557 -169 504 -153 524 -169 b 629 -154 581 -169 608 -165 l 629 -236 b 539 -253 606 -246 578 -253 m 611 433 b 403 643 600 583 522 643 b 186 433 285 643 206 563 " }, "ğ": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 407 -265 b 78 -42 192 -265 97 -164 l 196 -42 b 406 -168 213 -125 282 -168 b 639 56 549 -168 639 -100 l 639 161 b 393 24 597 90 499 24 b 63 368 203 24 63 168 l 63 378 b 401 739 63 575 201 739 b 639 610 522 739 597 681 l 639 726 l 754 726 l 754 49 b 407 -265 753 -162 610 -265 m 406 119 b 643 376 540 119 643 214 l 643 386 b 413 643 643 549 554 643 b 182 383 268 643 182 536 l 182 372 b 406 119 182 214 283 119 m 406 860 b 222 1043 306 860 228 938 l 314 1043 b 406 954 324 989 350 954 b 506 1043 464 954 494 988 l 594 1043 b 406 860 589 938 506 860 " }, "ĝ": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 407 -265 b 78 -42 192 -265 97 -164 l 196 -42 b 406 -168 213 -125 282 -168 b 639 56 549 -168 639 -100 l 639 161 b 393 24 597 90 499 24 b 63 368 203 24 63 168 l 63 378 b 401 739 63 575 201 739 b 639 610 522 739 597 681 l 639 726 l 754 726 l 754 49 b 407 -265 753 -162 610 -265 m 406 119 b 643 376 540 119 643 214 l 643 386 b 413 643 643 549 554 643 b 182 383 268 643 182 536 l 182 372 b 406 119 182 214 283 119 m 357 1051 l 461 1051 l 610 851 l 525 851 l 407 956 l 289 851 l 207 851 " }, "ģ": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 407 -265 b 78 -42 192 -265 97 -164 l 196 -42 b 406 -168 213 -125 282 -168 b 639 56 549 -168 639 -100 l 639 161 b 393 24 597 90 499 24 b 63 368 203 24 63 168 l 63 378 b 401 739 63 575 201 739 b 639 610 522 739 597 681 l 639 726 l 754 726 l 754 49 b 407 -265 753 -162 610 -265 m 406 119 b 643 376 540 119 643 214 l 643 386 b 413 643 643 549 554 643 b 182 383 268 643 182 536 l 182 372 b 406 119 182 214 283 119 m 353 869 l 474 1090 l 544 1054 l 464 836 " }, "ġ": { "ha": 871, "x_min": 0, "x_max": 0, "o": "m 407 -265 b 78 -42 192 -265 97 -164 l 196 -42 b 406 -168 213 -125 282 -168 b 639 56 549 -168 639 -100 l 639 161 b 393 24 597 90 499 24 b 63 368 203 24 63 168 l 63 378 b 401 739 63 575 201 739 b 639 610 522 739 597 681 l 639 726 l 754 726 l 754 49 b 407 -265 753 -162 610 -265 m 406 119 b 643 376 540 119 643 214 l 643 386 b 413 643 643 549 554 643 b 182 383 268 643 182 536 l 182 372 b 406 119 182 214 283 119 m 408 878 b 332 954 367 878 332 913 b 408 1031 332 996 367 1031 b 485 954 450 1031 485 996 b 408 878 485 913 450 878 " }, "ħ": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 13 939 l 117 939 l 117 1074 l 232 1074 l 232 939 l 479 939 l 479 854 l 232 854 l 232 611 b 465 739 265 679 346 739 b 721 446 615 739 721 657 l 721 0 l 606 0 l 606 454 b 435 639 606 582 551 639 b 232 440 328 639 232 571 l 232 0 l 117 0 l 117 854 l 13 854 " }, "ĥ": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 117 1074 l 232 1074 l 232 611 b 465 739 265 679 346 739 b 721 446 615 739 721 657 l 721 0 l 606 0 l 606 454 b 435 639 606 582 551 639 b 232 440 328 639 232 571 l 232 0 l 117 0 m 383 1317 l 488 1317 l 636 1140 l 551 1140 l 433 1221 l 315 1140 l 233 1140 " }, "ĭ": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 119 726 l 235 726 l 235 0 l 119 0 m 175 860 b -8 1043 75 860 -3 938 l 83 1043 b 175 954 93 989 119 954 b 275 1043 233 954 264 988 l 364 1043 b 175 860 358 938 275 860 " }, "ī": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 42 989 l 311 989 l 311 900 l 42 900 m 119 726 l 235 726 l 235 0 l 119 0 " }, "į": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 167 -253 b 22 -142 81 -253 22 -211 b 119 -6 22 -85 64 -35 l 119 726 l 235 726 l 235 4 b 132 -119 164 -39 132 -76 b 185 -169 132 -153 151 -169 b 257 -154 208 -169 236 -165 l 257 -236 b 167 -253 233 -246 206 -253 m 175 878 b 99 954 133 878 99 913 b 175 1031 99 996 133 1031 b 251 954 217 1031 251 996 b 175 878 251 913 217 878 " }, "ĩ": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 119 726 l 235 726 l 235 0 l 119 0 m 253 860 b 103 919 193 860 143 919 b 47 857 76 919 54 893 l -36 857 b 104 1018 -25 956 32 1018 b 253 958 163 1018 213 958 b 308 1021 279 958 301 985 l 392 1021 b 253 860 381 922 324 860 " }, "ĵ": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 13 -168 b 119 -56 94 -161 119 -119 l 119 726 l 235 726 l 235 -46 b 13 -265 235 -185 174 -260 m 124 1051 l 228 1051 l 376 851 l 292 851 l 174 956 l 56 851 l -26 851 " }, "ķ": { "ha": 717, "x_min": 0, "x_max": 0, "o": "m 117 1074 l 232 1074 l 232 392 l 533 726 l 668 726 l 357 389 l 694 0 l 554 0 l 232 376 l 232 0 l 117 0 m 258 -269 l 339 -51 l 450 -85 l 329 -306 " }, "ĺ": { "ha": 356, "x_min": 0, "x_max": 0, "o": "m 119 1074 l 236 1074 l 236 0 l 119 0 m 206 1317 l 350 1317 l 214 1140 l 128 1140 " }, "ľ": { "ha": 356, "x_min": 0, "x_max": 0, "o": "m 119 1074 l 236 1074 l 236 0 l 119 0 m 319 1074 l 450 1074 l 383 831 l 303 831 " }, "ļ": { "ha": 356, "x_min": 0, "x_max": 0, "o": "m 119 1074 l 236 1074 l 236 0 l 119 0 m 61 -269 l 142 -51 l 253 -85 l 132 -306 " }, "ŀ": { "ha": 456, "x_min": 0, "x_max": 0, "o": "m 119 1074 l 236 1074 l 236 0 l 119 0 m 403 421 b 314 510 354 421 314 460 b 403 599 314 560 354 599 b 492 510 451 599 492 560 b 403 421 492 460 451 421 " }, "ń": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 117 726 l 232 726 l 232 611 b 465 739 265 679 346 739 b 721 446 615 739 721 657 l 721 0 l 606 0 l 606 454 b 435 639 606 582 551 639 b 232 440 328 639 232 571 l 232 0 l 117 0 m 449 1056 l 593 1056 l 449 851 l 363 851 " }, "ŉ": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 117 726 l 232 726 l 232 611 b 465 739 265 679 346 739 b 721 446 615 739 721 657 l 721 0 l 606 0 l 606 454 b 435 639 606 582 551 639 b 232 440 328 639 232 571 l 232 0 l 117 0 m -61 714 l 63 1008 l 172 958 l 10 678 " }, "ň": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 117 726 l 232 726 l 232 611 b 465 739 265 679 346 739 b 721 446 615 739 721 657 l 721 0 l 606 0 l 606 454 b 435 639 606 582 551 639 b 232 440 328 639 232 571 l 232 0 l 117 0 m 213 1051 l 297 1051 l 415 947 l 533 1051 l 615 1051 l 465 851 l 361 851 " }, "ņ": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 117 726 l 232 726 l 232 611 b 465 739 265 679 346 739 b 721 446 615 739 721 657 l 721 0 l 606 0 l 606 454 b 435 639 606 582 551 639 b 232 440 328 639 232 571 l 232 0 l 117 0 m 297 -269 l 378 -51 l 489 -85 l 368 -306 " }, "ŏ": { "ha": 839, "x_min": 0, "x_max": 0, "o": "m 419 83 b 657 357 565 83 657 193 l 657 367 b 419 643 657 535 564 643 b 182 368 274 643 182 535 l 182 357 b 419 83 182 192 272 83 m 418 -12 b 63 357 211 -12 63 144 l 63 368 b 419 739 63 586 214 739 b 776 369 625 739 776 588 l 776 358 b 418 -12 776 139 625 -12 m 417 860 b 233 1043 317 860 239 938 l 325 1043 b 417 954 335 989 361 954 b 517 1043 475 954 506 988 l 606 1043 b 417 860 600 938 517 860 " }, "ő": { "ha": 839, "x_min": 0, "x_max": 0, "o": "m 419 83 b 657 357 565 83 657 193 l 657 367 b 419 643 657 535 564 643 b 182 368 274 643 182 535 l 182 357 b 419 83 182 192 272 83 m 418 -12 b 63 357 211 -12 63 144 l 63 368 b 419 739 63 586 214 739 b 776 369 625 739 776 588 l 776 358 b 418 -12 776 139 625 -12 m 319 1056 l 451 1056 l 347 851 l 264 851 m 533 1056 l 665 1056 l 561 851 l 478 851 " }, "ō": { "ha": 839, "x_min": 0, "x_max": 0, "o": "m 419 83 b 657 357 565 83 657 193 l 657 367 b 419 643 657 535 564 643 b 182 368 274 643 182 535 l 182 357 b 419 83 182 192 272 83 m 418 -12 b 63 357 211 -12 63 144 l 63 368 b 419 739 63 586 214 739 b 776 369 625 739 776 588 l 776 358 b 418 -12 776 139 625 -12 m 238 989 l 601 989 l 601 900 l 238 900 " }, "ǿ": { "ha": 839, "x_min": 0, "x_max": 0, "o": "m 32 1 l 139 119 b 63 357 90 182 63 264 l 63 368 b 419 739 63 586 214 739 b 636 669 503 739 578 714 l 731 772 l 792 719 l 694 613 b 776 369 746 549 776 465 l 776 358 b 418 -12 776 139 625 -12 b 196 63 331 -12 256 15 l 93 -51 m 419 83 b 657 357 565 83 657 193 l 657 367 b 619 529 657 431 643 485 l 264 139 b 419 83 304 103 356 83 m 182 357 b 215 203 182 297 193 246 l 567 592 b 419 643 528 625 478 643 b 182 368 274 643 182 535 l 182 357 m 453 1056 l 597 1056 l 453 851 l 367 851 " }, "ŕ": { "ha": 522, "x_min": 0, "x_max": 0, "o": "m 117 726 l 232 726 l 232 596 b 471 739 278 678 340 735 l 471 631 b 232 399 325 624 232 578 l 232 0 l 117 0 m 319 1056 l 464 1056 l 319 851 l 233 851 " }, "ř": { "ha": 522, "x_min": 0, "x_max": 0, "o": "m 117 726 l 232 726 l 232 596 b 471 739 278 678 340 735 l 471 631 b 232 399 325 624 232 578 l 232 0 l 117 0 m 83 1051 l 168 1051 l 286 947 l 404 1051 l 486 1051 l 336 851 l 232 851 " }, "ŗ": { "ha": 522, "x_min": 0, "x_max": 0, "o": "m 117 726 l 232 726 l 232 596 b 471 739 278 678 340 735 l 471 631 b 232 399 325 624 232 578 l 232 0 l 117 0 m 54 -269 l 135 -51 l 246 -85 l 125 -306 " }, "ś": { "ha": 667, "x_min": 0, "x_max": 0, "o": "m 342 -12 b 57 224 168 -12 64 75 l 169 224 b 340 83 178 138 224 83 b 499 199 450 83 499 121 b 329 321 499 275 442 300 b 76 535 140 356 76 408 b 322 739 76 669 208 739 b 585 529 453 739 565 686 l 474 529 b 321 643 457 608 413 643 b 183 539 238 643 183 601 b 353 424 183 474 219 447 b 608 208 503 396 608 363 b 342 -12 608 76 518 -12 m 365 1056 l 510 1056 l 365 851 l 279 851 " }, "ş": { "ha": 667, "x_min": 0, "x_max": 0, "o": "m 315 -297 b 176 -181 235 -297 182 -250 l 251 -181 b 311 -231 257 -207 276 -231 b 367 -181 346 -231 367 -210 b 317 -133 367 -151 346 -133 b 278 -144 299 -133 285 -140 l 233 -106 l 286 -8 b 57 224 146 7 63 92 l 169 224 b 340 83 178 138 224 83 b 499 199 450 83 499 121 b 329 321 499 275 442 300 b 76 535 140 356 76 408 b 322 739 76 669 208 739 b 585 529 453 739 565 686 l 474 529 b 321 643 457 608 413 643 b 183 539 238 643 183 601 b 353 424 183 474 219 447 b 608 208 503 396 608 363 b 358 -12 608 81 524 -7 l 325 -74 b 456 -186 389 -65 456 -101 b 315 -297 456 -261 390 -297 " }, "ŝ": { "ha": 667, "x_min": 0, "x_max": 0, "o": "m 342 -12 b 57 224 168 -12 64 75 l 169 224 b 340 83 178 138 224 83 b 499 199 450 83 499 121 b 329 321 499 275 442 300 b 76 535 140 356 76 408 b 322 739 76 669 208 739 b 585 529 453 739 565 686 l 474 529 b 321 643 457 608 413 643 b 183 539 238 643 183 601 b 353 424 183 474 219 447 b 608 208 503 396 608 363 b 342 -12 608 76 518 -12 m 279 1051 l 383 1051 l 532 851 l 447 851 l 329 956 l 211 851 l 129 851 " }, "ș": { "ha": 667, "x_min": 0, "x_max": 0, "o": "m 342 -12 b 57 224 168 -12 64 75 l 169 224 b 340 83 178 138 224 83 b 499 199 450 83 499 121 b 329 321 499 275 442 300 b 76 535 140 356 76 408 b 322 739 76 669 208 739 b 585 529 453 739 565 686 l 474 529 b 321 643 457 608 413 643 b 183 539 238 643 183 601 b 353 424 183 474 219 447 b 608 208 503 396 608 363 b 342 -12 608 76 518 -12 m 214 -269 l 294 -51 l 406 -85 l 285 -306 " }, "ŧ": { "ha": 493, "x_min": 0, "x_max": 0, "o": "m 38 471 l 142 471 l 142 629 l 38 629 l 38 726 l 142 726 l 142 892 l 257 892 l 257 726 l 426 726 l 426 629 l 257 629 l 257 471 l 426 471 l 426 389 l 257 389 l 257 193 b 347 88 257 122 289 88 b 436 103 383 88 411 93 l 436 6 b 338 -10 413 -3 385 -10 b 142 182 206 -10 142 68 l 142 389 l 38 389 " }, "ť": { "ha": 493, "x_min": 0, "x_max": 0, "o": "m 338 -10 b 142 182 206 -10 142 68 l 142 629 l 38 629 l 38 726 l 142 726 l 142 892 l 257 892 l 257 726 l 426 726 l 426 629 l 257 629 l 257 193 b 347 88 257 122 289 88 b 436 103 383 88 411 93 l 436 6 b 338 -10 413 -3 385 -10 m 374 1074 l 504 1074 l 438 831 l 357 831 " }, "ţ": { "ha": 493, "x_min": 0, "x_max": 0, "o": "m 338 -10 b 142 182 206 -10 142 68 l 142 629 l 38 629 l 38 726 l 142 726 l 142 892 l 257 892 l 257 726 l 426 726 l 426 629 l 257 629 l 257 193 b 347 88 257 122 289 88 b 436 103 383 88 411 93 l 436 6 b 338 -10 413 -3 385 -10 m 149 -269 l 229 -51 l 340 -85 l 219 -306 " }, "ŭ": { "ha": 825, "x_min": 0, "x_max": 0, "o": "m 363 -12 b 110 267 218 -12 110 67 l 110 726 l 225 726 l 225 272 b 393 88 225 144 279 88 b 593 286 496 88 593 156 l 593 726 l 708 726 l 708 0 l 593 0 l 593 115 b 363 -12 560 47 479 -12 m 410 860 b 226 1043 310 860 232 938 l 318 1043 b 410 954 328 989 354 954 b 510 1043 468 954 499 988 l 599 1043 b 410 860 593 938 510 860 " }, "ű": { "ha": 825, "x_min": 0, "x_max": 0, "o": "m 363 -12 b 110 267 218 -12 110 67 l 110 726 l 225 726 l 225 272 b 393 88 225 144 279 88 b 593 286 496 88 593 156 l 593 726 l 708 726 l 708 0 l 593 0 l 593 115 b 363 -12 560 47 479 -12 m 313 1056 l 444 1056 l 340 851 l 257 851 m 526 1056 l 658 1056 l 554 851 l 471 851 " }, "ū": { "ha": 825, "x_min": 0, "x_max": 0, "o": "m 363 -12 b 110 267 218 -12 110 67 l 110 726 l 225 726 l 225 272 b 393 88 225 144 279 88 b 593 286 496 88 593 156 l 593 726 l 708 726 l 708 0 l 593 0 l 593 115 b 363 -12 560 47 479 -12 m 231 989 l 594 989 l 594 900 l 231 900 " }, "ų": { "ha": 825, "x_min": 0, "x_max": 0, "o": "m 638 -253 b 493 -142 551 -253 493 -211 b 593 -4 493 -85 538 -33 l 593 115 b 363 -12 560 47 479 -12 b 110 267 218 -12 110 67 l 110 726 l 225 726 l 225 272 b 393 88 225 144 279 88 b 593 286 496 88 593 156 l 593 726 l 708 726 l 708 7 b 603 -119 633 -40 603 -76 b 656 -169 603 -153 622 -169 b 728 -154 679 -169 707 -165 l 728 -236 b 638 -253 704 -246 676 -253 " }, "ů": { "ha": 825, "x_min": 0, "x_max": 0, "o": "m 363 -12 b 110 267 218 -12 110 67 l 110 726 l 225 726 l 225 272 b 393 88 225 144 279 88 b 593 286 496 88 593 156 l 593 726 l 708 726 l 708 0 l 593 0 l 593 115 b 363 -12 560 47 479 -12 m 408 853 b 482 933 451 853 482 888 b 408 1014 482 979 451 1014 b 335 933 365 1014 335 979 b 408 853 335 888 365 853 m 408 789 b 260 933 326 789 260 854 b 408 1078 260 1013 326 1078 b 557 933 490 1078 557 1013 b 408 789 557 854 490 789 " }, "ũ": { "ha": 825, "x_min": 0, "x_max": 0, "o": "m 363 -12 b 110 267 218 -12 110 67 l 110 726 l 225 726 l 225 272 b 393 88 225 144 279 88 b 593 286 496 88 593 156 l 593 726 l 708 726 l 708 0 l 593 0 l 593 115 b 363 -12 560 47 479 -12 m 488 860 b 338 919 428 860 378 919 b 282 857 311 919 289 893 l 199 857 b 339 1018 210 956 267 1018 b 488 958 397 1018 447 958 b 543 1021 514 958 536 985 l 626 1021 b 488 860 615 922 558 860 " }, "ẃ": { "ha": 1103, "x_min": 0, "x_max": 0, "o": "m 39 726 l 164 726 l 333 142 l 510 726 l 610 726 l 775 142 l 946 726 l 1064 726 l 838 0 l 710 0 l 558 544 l 389 0 l 263 0 m 600 1056 l 744 1056 l 600 851 l 514 851 " }, "ŵ": { "ha": 1103, "x_min": 0, "x_max": 0, "o": "m 39 726 l 164 726 l 333 142 l 510 726 l 610 726 l 775 142 l 946 726 l 1064 726 l 838 0 l 710 0 l 558 544 l 389 0 l 263 0 m 500 1051 l 604 1051 l 753 851 l 668 851 l 550 956 l 432 851 l 350 851 " }, "ẅ": { "ha": 1103, "x_min": 0, "x_max": 0, "o": "m 39 726 l 164 726 l 333 142 l 510 726 l 610 726 l 775 142 l 946 726 l 1064 726 l 838 0 l 710 0 l 558 544 l 389 0 l 263 0 m 428 881 b 354 954 388 881 354 914 b 428 1028 354 994 388 1028 b 501 954 468 1028 501 994 b 428 881 501 914 468 881 m 689 881 b 615 954 649 881 615 914 b 689 1028 615 994 649 1028 b 763 954 729 1028 763 994 b 689 881 763 914 729 881 " }, "ẁ": { "ha": 1103, "x_min": 0, "x_max": 0, "o": "m 39 726 l 164 726 l 333 142 l 510 726 l 610 726 l 775 142 l 946 726 l 1064 726 l 838 0 l 710 0 l 558 544 l 389 0 l 263 0 m 385 1056 l 529 1056 l 615 851 l 529 851 " }, "ŷ": { "ha": 735, "x_min": 0, "x_max": 0, "o": "m 319 75 l 35 726 l 158 726 l 381 206 l 582 726 l 700 726 l 299 -253 l 182 -253 m 315 1051 l 419 1051 l 568 851 l 483 851 l 365 956 l 247 851 l 165 851 " }, "ỳ": { "ha": 735, "x_min": 0, "x_max": 0, "o": "m 319 75 l 35 726 l 158 726 l 381 206 l 582 726 l 700 726 l 299 -253 l 182 -253 m 193 1056 l 338 1056 l 424 851 l 338 851 " }, "ź": { "ha": 671, "x_min": 0, "x_max": 0, "o": "m 29 17 l 458 629 l 71 629 l 71 726 l 636 726 l 636 706 l 217 101 l 631 101 l 631 0 l 29 0 m 379 1056 l 524 1056 l 379 851 l 293 851 " }, "ż": { "ha": 671, "x_min": 0, "x_max": 0, "o": "m 29 17 l 458 629 l 71 629 l 71 726 l 636 726 l 636 706 l 217 101 l 631 101 l 631 0 l 29 0 m 344 878 b 268 954 303 878 268 913 b 344 1031 268 996 303 1031 b 421 954 386 1031 421 996 b 344 878 421 913 386 878 " }, "ﬀ": { "ha": 881, "x_min": 0, "x_max": 0, "o": "m 142 629 l 38 629 l 38 726 l 142 726 l 142 835 b 358 1068 142 982 214 1068 b 444 1054 396 1068 415 1064 l 444 957 b 363 972 424 965 394 972 b 257 847 288 972 257 921 l 257 726 l 542 726 l 542 844 b 758 1078 542 992 614 1078 b 844 1064 796 1078 815 1074 l 844 967 b 763 982 824 975 794 982 b 657 857 688 982 657 931 l 657 726 l 835 726 l 835 629 l 657 629 l 657 0 l 542 0 l 542 629 l 257 629 l 257 0 l 142 0 " }, "ﬁ": { "ha": 829, "x_min": 0, "x_max": 0, "o": "m 142 629 l 38 629 l 38 726 l 142 726 l 142 844 b 356 1078 142 992 213 1078 b 435 1067 393 1078 413 1075 l 435 969 b 360 982 414 978 392 982 b 257 857 286 982 257 931 l 257 726 l 435 726 l 435 629 l 257 629 l 257 0 l 142 0 m 594 726 l 710 726 l 710 0 l 594 0 m 650 878 b 574 954 608 878 574 913 b 650 1031 574 996 608 1031 b 726 954 692 1031 726 996 b 650 878 726 913 692 878 " }, "ﬂ": { "ha": 831, "x_min": 0, "x_max": 0, "o": "m 142 629 l 38 629 l 38 726 l 142 726 l 142 844 b 356 1078 142 992 213 1078 b 435 1067 393 1078 413 1075 l 435 969 b 360 982 414 978 392 982 b 257 857 286 982 257 931 l 257 726 l 435 726 l 435 629 l 257 629 l 257 0 l 142 0 m 594 1074 l 711 1074 l 711 0 l 594 0 " }, "⅛": { "ha": 992, "x_min": 0, "x_max": 0, "o": "m 150 901 l 38 826 l 38 908 l 161 993 l 244 993 l 244 518 l 150 518 m 767 993 l 858 993 l 154 0 l 63 0 m 768 -7 b 589 133 672 -7 589 40 b 676 254 589 194 624 236 b 607 353 633 272 607 306 b 769 481 607 433 685 481 b 931 354 856 481 931 433 b 860 256 931 306 903 274 b 949 136 915 235 949 194 b 768 -7 949 43 868 -7 m 769 63 b 856 143 818 63 856 90 b 769 222 856 193 818 222 b 683 142 722 222 683 193 b 769 63 683 90 722 63 m 769 282 b 842 349 813 282 842 307 b 769 414 842 389 810 414 b 696 347 728 414 696 389 b 769 282 696 306 731 282 " }, "⅓": { "ha": 1004, "x_min": 0, "x_max": 0, "o": "m 150 901 l 38 826 l 38 908 l 161 993 l 244 993 l 244 518 l 150 518 m 767 993 l 858 993 l 154 0 l 63 0 m 778 -7 b 596 147 663 -7 599 54 l 681 147 b 775 63 686 99 713 63 b 863 138 835 63 863 92 b 779 213 863 188 835 213 l 743 213 l 743 278 l 778 278 b 856 346 831 278 856 303 b 783 411 856 383 832 411 b 697 335 735 411 703 382 l 613 335 b 785 481 618 419 682 481 b 944 353 886 481 944 425 b 865 250 944 300 913 267 b 958 136 921 238 958 199 b 778 -7 958 47 889 -7 " }, "⅜": { "ha": 1033, "x_min": 0, "x_max": 0, "o": "m 215 511 b 33 665 100 511 36 572 l 118 665 b 213 581 124 617 150 581 b 300 656 272 581 300 610 b 217 731 300 706 272 731 l 181 731 l 181 796 l 215 796 b 293 864 268 796 293 821 b 221 929 293 901 269 929 b 135 853 172 929 140 900 l 50 853 b 222 999 56 938 119 999 b 382 871 324 999 382 943 b 303 768 382 818 350 785 b 396 654 358 756 396 717 b 215 511 396 565 326 511 m 825 993 l 917 993 l 213 0 l 121 0 m 810 -7 b 631 133 714 -7 631 40 b 718 254 631 194 665 236 b 649 353 675 272 649 306 b 811 481 649 433 726 481 b 972 354 897 481 972 433 b 901 256 972 306 944 274 b 990 136 957 235 990 194 b 810 -7 990 43 910 -7 m 811 63 b 897 143 860 63 897 90 b 811 222 897 193 860 222 b 725 142 764 222 725 193 b 811 63 725 90 764 63 m 811 282 b 883 349 854 282 883 307 b 811 414 883 389 851 414 b 738 347 769 414 738 389 b 811 282 738 306 772 282 " }, "⅝": { "ha": 1025, "x_min": 0, "x_max": 0, "o": "m 206 511 b 33 656 93 511 39 572 l 121 656 b 206 583 128 613 144 583 b 286 676 257 583 286 619 b 204 767 286 732 256 767 b 107 726 157 767 128 751 l 57 726 l 63 993 l 354 993 l 354 921 l 133 921 l 132 793 b 236 835 151 815 185 835 b 382 675 322 835 382 775 b 206 511 382 574 310 511 m 815 993 l 907 993 l 203 0 l 111 0 m 801 -7 b 622 133 706 -7 622 40 b 710 254 622 194 657 236 b 640 353 667 272 640 306 b 803 481 640 433 718 481 b 964 354 889 481 964 433 b 893 256 964 306 936 274 b 982 136 949 235 982 194 b 801 -7 982 43 901 -7 m 803 63 b 889 143 851 63 889 90 b 803 222 889 193 851 222 b 717 142 756 222 717 193 b 803 63 717 90 756 63 m 803 282 b 875 349 846 282 875 307 b 803 414 875 389 843 414 b 729 347 761 414 729 389 b 803 282 729 306 764 282 " }, "⅔": { "ha": 1056, "x_min": 0, "x_max": 0, "o": "m 15 533 l 193 722 b 268 857 239 769 268 813 b 199 926 268 900 243 926 b 115 835 153 926 124 900 l 31 835 b 201 999 36 939 100 999 b 360 858 301 999 360 943 b 268 689 360 796 324 743 l 167 589 l 364 589 l 364 518 l 15 518 m 838 993 l 929 993 l 225 0 l 133 0 m 829 -7 b 647 147 714 -7 650 54 l 732 147 b 826 63 738 99 764 63 b 914 138 886 63 914 92 b 831 213 914 188 886 213 l 794 213 l 794 278 l 829 278 b 907 346 882 278 907 303 b 835 411 907 383 883 411 b 749 335 786 411 754 382 l 664 335 b 836 481 669 419 733 481 b 996 353 938 481 996 425 b 917 250 996 300 964 267 b 1010 136 972 238 1010 199 b 829 -7 1010 47 940 -7 " }, "⅞": { "ha": 986, "x_min": 0, "x_max": 0, "o": "m 246 917 l 28 917 l 28 993 l 363 993 l 363 982 l 190 518 l 96 518 m 750 993 l 842 993 l 138 0 l 46 0 m 763 -7 b 583 133 667 -7 583 40 b 671 254 583 194 618 236 b 601 353 628 272 601 306 b 764 481 601 433 679 481 b 925 354 850 481 925 433 b 854 256 925 306 897 274 b 943 136 910 235 943 194 b 763 -7 943 43 863 -7 m 764 63 b 850 143 813 63 850 90 b 764 222 850 193 813 222 b 678 142 717 222 678 193 b 764 63 678 90 717 63 m 764 282 b 836 349 807 282 836 307 b 764 414 836 389 804 414 b 690 347 722 414 690 389 b 764 282 690 306 725 282 " }, "": { "ha": 833, "x_min": 0, "x_max": 0, "o": "m 378 -11 b 44 303 142 4 61 143 l 161 303 b 378 82 175 193 210 96 l 378 469 b 85 738 196 504 85 571 b 378 1004 85 881 206 992 l 378 1129 l 460 1129 l 460 1003 b 749 732 629 988 731 889 l 640 732 b 460 908 619 838 564 894 l 460 561 b 769 279 664 526 769 458 b 460 -11 769 122 644 3 l 460 -187 l 378 -187 m 654 272 b 460 456 654 375 611 425 l 460 82 b 654 272 576 96 654 169 m 194 747 b 378 575 194 660 225 607 l 378 910 b 194 747 258 900 194 832 " }, "": { "ha": 833, "x_min": 0, "x_max": 0, "o": "m 396 -10 b 88 356 215 8 88 147 l 88 367 b 396 736 88 572 221 715 l 396 874 l 478 874 l 478 736 b 756 485 614 725 735 653 l 642 485 b 478 640 626 583 560 631 l 478 86 b 653 261 565 99 642 157 l 760 261 b 478 -10 746 115 633 4 l 478 -187 l 396 -187 m 207 356 b 396 86 207 197 281 106 l 396 639 b 207 367 285 618 207 518 l 207 356 " }, "": { "ha": 833, "x_min": 0, "x_max": 0, "o": "m 21 628 l 106 628 b 449 1006 119 860 242 1006 b 750 706 619 1006 728 897 l 636 706 b 449 911 617 839 558 911 b 226 628 307 911 236 813 l 532 628 l 517 547 l 225 547 l 225 439 l 496 439 l 481 358 l 226 358 b 451 86 236 175 307 86 b 654 308 568 86 632 158 l 767 308 b 451 -12 744 103 625 -12 b 107 358 251 -12 121 119 l 21 358 l 21 439 l 106 439 l 106 547 l 21 547 " }, "": { "ha": 833, "x_min": 0, "x_max": 0, "o": "m 422 88 b 640 410 578 88 640 178 l 640 590 b 419 908 640 803 568 908 b 194 581 269 908 194 806 l 194 407 b 422 88 194 175 276 88 m 422 -12 b 71 406 214 -12 71 128 l 71 579 b 419 1006 71 861 207 1006 b 763 589 635 1006 763 861 l 763 408 b 422 -12 763 131 636 -12 " }, "": { "ha": 833, "x_min": 0, "x_max": 0, "o": "m 436 871 l 151 643 l 151 756 l 431 993 l 557 993 l 557 0 l 436 0 " }, "": { "ha": 833, "x_min": 0, "x_max": 0, "o": "m 58 28 l 453 443 b 596 731 543 539 596 629 b 418 908 596 842 531 908 b 208 688 303 908 228 843 l 96 688 b 418 1006 111 882 229 1006 b 718 726 601 1006 718 897 b 518 365 718 604 640 485 l 244 99 l 724 99 l 724 0 l 58 0 " }, "": { "ha": 833, "x_min": 0, "x_max": 0, "o": "m 400 -12 b 61 293 193 -12 68 119 l 172 293 b 403 85 183 175 246 85 b 626 276 558 85 626 160 b 417 469 626 404 557 469 l 342 469 l 342 571 l 411 571 b 601 740 540 571 601 632 b 424 907 601 835 544 907 b 207 719 300 907 219 832 l 101 719 b 424 1006 108 876 235 1006 b 719 743 613 1006 719 881 b 558 526 719 631 651 564 b 750 276 675 496 750 414 b 400 -12 750 96 606 -12 " }, "": { "ha": 833, "x_min": 0, "x_max": 0, "o": "m 540 208 l 57 208 l 57 247 l 497 993 l 658 993 l 658 307 l 775 307 l 775 208 l 658 208 l 658 0 l 540 0 m 540 307 l 540 894 l 207 307 " }, "": { "ha": 833, "x_min": 0, "x_max": 0, "o": "m 400 -12 b 69 268 186 -12 83 106 l 185 268 b 399 85 204 160 247 85 b 617 325 533 85 617 175 b 408 557 617 465 535 557 b 174 461 293 557 226 521 l 129 461 l 129 993 l 688 993 l 688 889 l 229 889 l 229 586 b 432 654 269 624 338 654 b 740 325 610 654 740 528 b 400 -12 740 115 589 -12 " }, "": { "ha": 833, "x_min": 0, "x_max": 0, "o": "m 428 -12 b 71 439 157 -12 71 190 l 71 463 b 460 1006 71 819 232 1006 b 750 765 614 1006 724 925 l 635 765 b 451 907 613 857 563 907 b 190 510 301 907 196 772 b 446 644 238 590 331 644 b 771 319 643 644 771 501 b 428 -12 771 121 638 -12 m 428 82 b 647 314 558 82 647 174 b 426 550 647 457 561 550 b 199 331 293 550 199 460 b 428 82 199 168 294 82 " }, "": { "ha": 833, "x_min": 0, "x_max": 0, "o": "m 596 896 l 97 896 l 97 993 l 751 993 l 751 976 l 354 0 l 231 0 " }, "": { "ha": 833, "x_min": 0, "x_max": 0, "o": "m 418 -12 b 75 282 256 -12 75 85 b 263 539 75 415 157 501 b 113 747 168 575 113 650 b 418 1006 113 908 265 1006 b 722 750 572 1006 722 906 b 569 540 722 650 661 581 b 760 285 685 499 760 413 b 418 -12 760 86 586 -12 m 418 86 b 636 289 540 86 636 157 b 421 486 636 419 539 486 b 199 286 303 486 199 418 b 418 86 199 156 303 86 m 422 582 b 600 749 528 582 600 643 b 418 911 600 844 521 911 b 235 746 315 911 235 849 b 422 582 235 642 321 582 " }, "": { "ha": 833, "x_min": 0, "x_max": 0, "o": "m 389 -11 b 69 244 206 -11 96 85 l 186 244 b 392 88 208 147 264 88 b 646 482 550 88 643 218 b 389 350 599 401 503 350 b 63 675 196 350 63 488 b 406 1007 63 874 196 1007 b 763 563 640 1007 763 849 l 763 500 b 389 -11 763 171 626 -11 m 407 444 b 635 660 540 444 635 531 b 406 913 635 822 539 913 b 186 681 275 913 186 821 b 407 444 186 538 272 444 " }, "": { "ha": 854, "x_min": 0, "x_max": 0, "o": "m 383 -12 b 63 349 210 -12 63 122 l 63 360 b 394 739 63 582 211 739 b 622 613 507 739 581 683 l 622 726 l 738 726 l 738 0 l 622 0 l 622 122 b 383 -12 581 51 481 -12 m 396 83 b 626 358 519 83 626 172 l 626 369 b 406 643 626 556 536 643 b 182 365 272 643 182 542 l 182 354 b 396 83 182 171 282 83 " }, "": { "ha": 469, "x_min": 0, "x_max": 0, "o": "m 151 629 l 38 629 l 38 726 l 151 726 l 151 892 l 267 892 l 267 726 l 426 726 l 426 629 l 267 629 l 267 0 l 151 0 " }, "ȷ": { "ha": 354, "x_min": 0, "x_max": 0, "o": "m 13 -168 b 119 -56 94 -161 119 -119 l 119 726 l 235 726 l 235 -46 b 13 -265 235 -185 174 -260 " }, " ": { "ha": 153, "x_min": 0, "x_max": 0, "o": "" }, "′": { "ha": 294, "x_min": 0, "x_max": 0, "o": "m 99 993 l 224 993 l 147 653 l 64 653 " }, "″": { "ha": 521, "x_min": 0, "x_max": 0, "o": "m 99 993 l 224 993 l 147 653 l 64 653 m 325 993 l 450 993 l 374 653 l 290 653 " }, "Ⓟ": { "ha": 1172, "x_min": 0, "x_max": 0, "o": "m 422 774 l 600 774 b 804 604 725 774 804 719 l 804 600 b 604 432 804 483 722 432 l 528 432 l 528 225 l 422 225 m 600 508 b 703 600 667 508 703 540 l 703 604 b 600 692 703 667 665 692 l 528 692 l 528 508 m 585 46 b 1029 499 821 46 1029 231 b 588 947 1029 763 828 947 b 143 496 344 947 143 761 b 585 46 143 228 353 46 m 585 -12 b 76 496 303 -12 76 208 b 588 1006 76 779 301 1006 b 1096 499 876 1006 1096 781 b 585 -12 1096 210 871 -12 " } }, "familyName": "Graphik Regular", "ascender": 1136, "descender": -253, "underlinePosition": -75, "underlineThickness": 50, "boundingBox": { "yMin": -220, "xMin": -230, "yMax": 1113, "xMax": 1092 }, "resolution": 1000, "original_font_information": { "format": 0, "copyright": "©2009 Commercial Type.", "fontFamily": "Graphik Regular", "fontSubfamily": "Regular", "uniqueID": "1.000;COM ;Graphik-Regular", "fullName": "Graphik Regular Regular", "version": "Version 1.000;PS 001.000;hotconv 1.0.72;makeotf.lib2.5.5900", "postScriptName": "Graphik-Regular", "trademark": "Graphik is a trademark of Commercial Type/Schwartzco Inc.", "manufacturer": "Commercial Type", "designer": "Christian Schwartz", "manufacturerURL": "http://commercialtype.com", "designerURL": "http://christianschwartz.com", "licence": "Commercial Type Font Software End User License Agreement\r\rPLEASE READ THIS DOCUMENT CAREFULLY and we recommend that you keep a copy for further reference. \r\rThis End User License Agreement (the \"Agreement\" \"EULA,\" \"License,\" \"Agreement\" or \"License Agreement\") is a legal agreement between you and Schwartzco, Inc., d/b/a Commercial Type, a/d/b/a St. Bride Type Foundry (collectively, \"Commercial Type\") and becomes a binding contract between you and Schwartzco. This Agreement governs the terms of use the Font Software and the design of the Fonts embodied therein (collectively, \"Font Software\"), together with any media, printed materials, electronic documentation, updates, add-ons, artwork, web services and any other material that may be associated with the product now or in the future. This Agreement becomes effective (a) when you \"ACCEPT LICENSE AGREEMENT,\" or (b) if you are acquire and accept the Font Software on a Compact Disc or Digital Video Disk (CD, DVD), or (c) when you open the compressed electronic file in which the Font Software is contained. If you do not wish to enter into this Agreement, do not purchase, access, download and/or install or otherwise use the Font Software.\r\r1. Upon payment in full, Commercial Type will grant you a non-exclusive terminable License to the Font Software that accompanies this EULA. Use of the Font Software is limited to Personal or Internal Business Use only. For the purposes of this Agreement, \"Font Software\" shall be defined as the design of the Fonts together with the Font Software which, when used generates the typeface, typographic designs and, if applicable, ornaments or other designs. Personal or Internal Business Use shall mean Use of the Font Software for your customary personal or internal business purposes and, except as may otherwise permitted herein, shall not mean or include the commercial distribution or use of Font Software, the design of the fonts or artwork embodied therein or any component thereof for any commercial use or in any Commercial Product for sale whatsoever. For the purposes of this Agreement, prohibited commercial uses include, by way of example not limitation, T-shirts, third-party software, electronic devices, mugs, animation, etc. and as may be further noted below. If you are unsure whether your use is not permitted, contact Commercial Type. Your failure to contact to seek permission or the lack of a specific prohibition in this Agreement shall not be interpreted or deemed a waiver or permissible use of any kind. You hereby agree that the Font Software shall further comprise all bitmap representations of typeface and typographic designs and ornaments created by or derived from the Font Software. The Font Software shall be deemed to include any upgrades, updates, related files, permitted modifications, if any, permitted copies, and related documentation.\r\r2. If you are a design consultancy, advertising agency or purchasing this license for use by or on behalf of such an entity, the ultimate end user should also purchase a license appropriate for their intended use of the Font Software, if their use of the Font Software is likely to involve uses not permitted under this Agreement. The license granted herein for personal use does not extend to uses by temporary employees or independent contractors using the Font Software as their use may relate to providing professional services or for other professional uses. Under such circumstances an employer and/or the ultimate end user are also required to purchase a license appropriate for their usage.\r\r3. For the purposes of this Agreement, \"Commercial Product\" shall also mean, among other things, a user editable electronic document created by Use of the Font Software which is offered for distribution to the general public (or to some subset of the general public), in Flash type software distributed or exhibited, in gaming products or software where the extraction of the Font Software or the designs embodied therein may be extracted; or use on goods for sale as a commercial product in exchange for a separate fee or other consideration. However, a document distributed in connection with a commercial transaction in which the consideration is unrelated to such a document (for example, printed advertising, a business letter or a receipt for purchase of tangible goods such as clothing), or as other design materials distributed incidental to the purchase of goods or services, shall not be considered a Commercial Product.\r\r4. a) Except as may be prohibited herein, you are permitted to electronically distribute a “Personal or Internal Business Use” document (that is, a document other than a Commercial Product as defined above) (i) that is in a static graphic image (for example, a “gif”) or in an embedded electronic document, and (ii) which is distributed in a format that permits only the viewing and printing (and not the editing, altering, enhancing, or modifying) of such static graphic image or embedded document. Personal or Internal Business Use shall not include any Use of the Font Software by persons that are not members of your immediate household, your authorized employees, or your authorized agents. All such household members, employees and agents shall be notified by you as to the terms and conditions of the Agreement and shall agree to be bound by it prior to use of the Font Software.\rb) Use of the Font Software in sIFR (Scalable Inman Font Replacement) is permitted. However, the use of Cufón or @font-face or other forms of web embedding or web font replacement technologies, (“Font Replacement Technologies”) other than pdf as otherwise expressly permitted herein, each require the purchase of a license upgrade.\r\r5. Commercial Type, its successors and assigns, expressly retain all right and title in and to the Font Software together with the design of the Font embodied therein together with any trademarks used in connection therewith. Except as may be otherwise expressly permitted herein, you agree not to copy the Font Software or create derivative works based upon the design of the Font or the Font Software. You hereby agree that the design of the Font and the Font Software are the exclusive property of Commercial Type and that the unauthorized use of the design of the Font or the Font Software is an infringement of Commercial Type's exclusive rights and causing significant monetary harm. All rights not expressly granted herein are reserved to Commercial Type. Commercial Type's rights and remedies in the event of an infringement shall be cumulative in nature. \r\r6. Except as is prohibited herein, you may install and Use the Font Software on a single file server for Use on a single local area network (\"LAN\") only when the Use of such Font Software is expressly for and limited to the number of total users disclosed and licensed under this Agreement, i.e., the total number of users who could use the Font Software, not the total number of users who might have access to the Font Software at any one time.\r\r7. Except as may be otherwise expressly permitted herein, you may not alter or copy the Font Software or the designs embodied therein in any manner whatsoever. Reformatting the Font Software into other formats for use in other operating systems is expressly prohibited. Upon payment of an additional fee and a separate written agreement Commercial Type may, if so agreed, provide the Font Software in alternate and/or additional font formats, contact Commercial Type for a quotation. Altering or amending the embedding bits characteristics of the Font Software is expressly prohibited. The Font Software may not be used to create or distribute any electronic document in which the Font Software or any part thereof, is embedded in a manner or format that permits editing, alterations, enhancements, or modifications by the recipient of such document. You may not knowingly transmit any electronic document or the Font Software to any party that intends or is likely to \"hack,\" edit, alter, enhance, or otherwise modify the Font Software or remove the Font Software from any document.\r\r8. You may make one (1) back-up copy of Font Software for archival purposes only, and you agree to retain exclusive custody and control over any such copy. Upon termination of the Agreement, you must destroy the original and any and all copies of the Font Software. The unauthorized sharing, lending, renting, sale, or other unauthorized use or misuse of the back-up copy is a material breach of this Agreement and will result in the immediate termination of this License.\r\r9. If no other option exists, you may take a digitized copy of the Font Software used for a particular document, or Font Software embedded in an electronic document that is sent to a commercial printer or service bureau for use by the printer or service bureau for preparing the document provided that the printer or service bureau represents that it shall destroy any and all copies of the Font Software upon completion of its work. Notwithstanding, you agree that the transmission of a \"print/preview\" PDF document is the first and preferred method of transmitting such documents to a service bureau or printer.\r\r10. The designs embodied and the Font Software and the Font Software and any trademarks associated therewith are the exclusive property of Commercial Type and their designers, where applicable and are protected by the copyright and other intellectual property laws of the United States, by the copyright and design laws of other nations, and by other international treaties. Any copies that you are expressly permitted to make pursuant to the Agreement must contain the same copyright, trademark, and other proprietary notices that appear on or in the Font Software.\r\r11. You agree not to create, assist in and/or cause the creation of modifications or additions to the Fonts or Font Software, including, but not limited to, creating additional weights; creating additional or deleting existing characters; modifying existing characters; modifying font spacing and kerning; or converting fonts to an alternate digital format, modify, adapt, translate, reverse engineer, decompile, disassemble, alter, or otherwise attempt to discover the source code of the Font Software without first obtaining written permission from Commercial Type. In the event that permission is given to you, any and all modifications and additions shall become and shall remain the sole and exclusive property of Commercial Type and you may not sell, lend or otherwise transmit any modifications or additions to the Font Software to any third party. Other jurisdictions may provide for additional rights, and if applicable, you may reverse engineer or decompile the Font Software only to the extent that sufficient information is not available for the purpose of creating an interoperable software program (but only for such purpose and only to the extent that sufficient information is not provided by Commercial Type upon written request). All trademarks shall be used in accordance with accepted trademark practice, including identification of the trademark owner's name. Use of the trademarks associated with the Font Software inures solely to the benefit of Commercial Type. \r\r12. Use of Commercial Type Font Software in the following circumstances and/or applications is NOT permitted without first obtaining the appropriate licensing upgrade. \r\ra) \tALPHABET OR LETTERFORM-RELATED PRODUCTS\r\t\tFOR RESALE OR LETTERFORM CREATION PRODUCTS OR DEVICES;\rb) \tEMBEDDING IN ELECTRONIC DEVICES; ALL GAMING USES AND/OR DEVICES;\rc) \tEMBEDDING IN SOFTWARE;\rd) \tSTORING AND/OR SERVING THE FONT SOFTWARE FOR THE PURPOSES OF MAKING THE FONT SOFTWARE\r\t\tAVAILABLE VIA THE INTERNET USING FONT REPLACEMENT TECHNOLOGIES.\r\r\ri) Letterform or Alphabet Products include, but are not limited to, signage and/or scrapbooking uses involving reproductions of individual letterforms, use in the creation of signage or numbering products, rubber stamps, die-cut products, stencil products, tattoo, flash, or adhesive sticker alphabet products or any other product containing any image of or derived from the design of the Font embodied in the Font Software of which any likeness of the alphabet can be reproduced.\r\rii) Embedding of the Fonts in a print/preview format is permitted. Notwithstanding, embedding or other use of the Fonts or the outlines thereof in any method which permits the extraction of the Font Software of the designs embodied therein is expressly prohibited. Any such use requires the express written permission of Commercial Type and may or may not require the purchase of a license upgrade at the sole discretion of Commercial Type.\r\riii) In the event any dingbats or other art forms are part of the Font Software, use of the artwork is further restricted. You may use the artwork, drawings and/or dingbats on goods for sale, in logo design, retail packaging or in point of sale uses only after the purchase of a license upgrade.\r\rIn order to obtain a license upgrade, you must contact Commercial Type at info@commercialtype.com for more information. If you are unsure whether your use of the Font Software is specifically permitted under this Agreement, contact Commercial Type.\r\r13. Embedded Electronic Devices includes the use of the Font Software for any on-screen display or on an electronic device outside a single location. For example, and not by way of limitation, such electronic devices include a kiosk, gaming devices, embroidery or sewing machines game playing or gambling devices, irrespective of whether the showing or creation of copies of the design embodied in the Font Software is created by use of the software or as an image of the design in tiff, gif or other format. \r\r14. Commercial Type Font Software is licensed for use by a specified number of users. Use of the Font Software in more than one geographic location or by means of server or central CPU outside of the terms of your license is permitted provided the each user or potential user is licensed. License upgrades may be purchased from Commercial Type at info@commercialtype.com.\r\r15. Except as may be otherwise expressly provided for herein, you expressly agree not to rent, lease, sublicense, give, lend, or further distribute the Font Software. You may transfer all your rights under this Agreement another person or entity provided that (i) the transferee accepts and agrees to be bound by all the terms and conditions of this Agreement, and (ii) you destroy all copies of the Font Software, including all copies stored in the memory of a hardware device.\r\r16. Commercial Type warrants that the Font Software will perform substantially in accordance with its documentation for ninety (90) days following delivery of the Font Software. To make a warranty claim, you must either return the Font Software to the location from which you obtained it together with a copy of your sales receipt or, if acquired on-line, contact the on-line provider with sufficient information regarding your acquisition of the Font Software to permit the confirmation of the effective date of this License. Schwartzco, Inc. and Commercial Type hereby EXPRESSLY DISCLAIMS ALL WARRANTIES, EXPRESS AND IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. COMMERCIAL TYPE DOES NOT WARRANT THAT THE OPERATION OF THE FONT SOFTWARE WILL BE UNINTERRUPTED OR ERROR-FREE, OR THAT THE FONT SOFTWARE IS WITHOUT DEFECTS. UNDER NO CIRCUMSTANCES SHALL COMMERCIAL TYPE BE LIABLE TO YOU OR ANY OTHER PARTY, WHETHER IN CONTRACT OR TORT (INCLUDING NEGLIGENCE) OR OTHERWISE, FOR ANY SPECIAL, CONSEQUENTIAL, OR INCIDENTAL DAMAGES, INCLUDING LOST PROFITS, SAVINGS OR BUSINESS INTERRUPTION AS A RESULT OF THE USE OF THE FONT SOFTWARE EVEN IF NOTIFIED IN ADVANCE OF SUCH POSSIBILITY. You hereby agree that your entire, exclusive, and cumulative liability and remedy shall be limited to the purchase price of this Font Software License. Under no circumstances shall Schwartzco, Inc.'s or Commercial Type's liability to you exceed either the refunding of the cost of the Font Software License or replacement of the Font Software either of which shall be at Commercial Type's sole discretion.\r\r17. OTHER LAW - CONSUMERS ONLY. Some jurisdictions do not allow the exclusion or limitation of incidental, consequential or special damages, implied warranties or implied warranties as they relate to sales to consumers. ANY IMPLIED WARRANTY OR OTHER RIGHT CREATED BY LAW IS ONLY EFFECTIVE FOR THE NINETY (90) DAY WARRANTY PERIOD. THERE ARE NO WARRANTIES OR CONDITIONS OF ANY KIND AFTER THE NINETY (90) DAY WARRANTY PERIOD. To the extent permissible by law, you agree that all implied warranties are not to be effective for more than thirty (30) days. \r\r18. You expressly agree that this Agreement shall be governed by the laws of the State of New York, U.S.A., as they apply to contracts entered into and wholly performed therein and without respect to its conflict of laws provisions or the conflict of laws provisions of any other jurisdiction. You expressly submit to the personal jurisdiction of the state and federal courts in the State of New York, USA, agree to waive any defenses arising out of the selection of jurisdiction or venue and further agree to service of process by mail. You hereby expressly agree that the application of the United Nations Convention of Contracts for the International Sale of Goods is expressly excluded.\r\r19. You acknowledge that you have read and understand this Agreement and that by using the software you agree to be bound by its terms and conditions. You further agree that it is the complete and exclusive statement of the agreement between Commercial Type and you which supersedes any proposal or prior agreement, oral or written, and any other communications relating to the subject matter of this Agreement. No variation of the terms of this Agreement or any different terms will be enforceable in the absence of an express written amendment, or consent, including a written express waiver of the affected terms of this Agreement. If any provision of this Agreement is declared by a court of competent jurisdiction to be invalid, void or unenforceable, the remaining provisions of this Agreement shall continue in full force and effect, and the invalid provision shall be replaced by Commercial Type with a provision that effects the intent of the invalid provision.\r\r20. Commercial Type expressly reserves the right to amend or modify its License Agreements at any time and without prior notification.\r\r21. The Agreement shall automatically terminate in the event you or any authorized user breaches any term or condition set forth herein. Notwithstanding any termination of this License, Commercial Type expressly reserves any and all other rights and remedies under equity or law. The Agreement may only be modified in a writing signed by an authorized officer of Commercial Type.\r\r22. You agree to be responsible for compliance with all laws, foreign and domestic relating to the control of exports or the transfer of technology. If you are purchasing this License for government use, or under a government contract, you agree to familiarize yourself with and follow any applicable rules and regulations relating to the purchase of a license to use software and the actual use thereof.\r\rAll inquiries and arrangements for returns, if any, may be sent via e-mail to info@commercialtype.com. The Commercial Type website is located at www.commercialtype.com\r\rv090815", "licenceURL": "http://commercialtype.com/license", "preferredFamily": "Graphik" }, "cssFontWeight": "normal", "cssFontStyle": "normal" };
//# sourceMappingURL=font.js.map

/***/ }),

/***/ 6009:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextGeometry = void 0;
const three_1 = __webpack_require__(39437);
class TextGeometry extends three_1.ExtrudeGeometry {
    constructor(text, parameters = {}) {
        const font = parameters.font;
        if (font === undefined) {
            super(); // generate default extrude geometry
        }
        else {
            const shapes = font.generateShapes(text, parameters.size);
            // translate parameters to ExtrudeGeometry API
            parameters.depth = parameters.height !== undefined ? parameters.height : 50;
            // defaults
            if (parameters.bevelThickness === undefined)
                parameters.bevelThickness = 10;
            if (parameters.bevelSize === undefined)
                parameters.bevelSize = 8;
            if (parameters.bevelEnabled === undefined)
                parameters.bevelEnabled = false;
            super(shapes, parameters);
        }
        this.type = 'TextGeometry';
    }
}
exports.TextGeometry = TextGeometry;
//# sourceMappingURL=TextGeometry.js.map

/***/ }),

/***/ 97328:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Font = exports.FontLoader = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const three_1 = __webpack_require__(39437);
class FontLoader extends three_1.Loader {
    constructor(manager) {
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const scope = this;
        const loader = new three_1.FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function (text) {
            let json;
            try {
                json = JSON.parse(text);
            }
            catch (e) {
                console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                json = JSON.parse(text.substring(65, text.length - 2));
            }
            const font = scope.parse(json);
            if (onLoad)
                onLoad(font);
        }, onProgress, onError);
    }
    parse(json) {
        return new Font(json);
    }
}
exports.FontLoader = FontLoader;
//
class Font {
    constructor(data) {
        this.isFont = true;
        this.type = 'Font';
        this.data = data;
    }
    generateShapes(text, size = 100) {
        const shapes = [];
        const paths = createPaths(text, size, this.data);
        for (let p = 0, pl = paths.length; p < pl; p++) {
            Array.prototype.push.apply(shapes, paths[p].toShapes());
        }
        return shapes;
    }
}
exports.Font = Font;
function createPaths(text, size, data) {
    const chars = Array.from(text);
    const scale = size / data.resolution;
    const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
    const paths = [];
    let offsetX = 0, offsetY = 0;
    for (let i = 0; i < chars.length; i++) {
        const char = chars[i];
        if (char === '\n') {
            offsetX = 0;
            offsetY -= line_height;
        }
        else {
            const ret = createPath(char, scale, offsetX, offsetY, data);
            offsetX += ret.offsetX;
            paths.push(ret.path);
        }
    }
    return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
    const glyph = data.glyphs[char] || data.glyphs['?'];
    if (!glyph) {
        console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
        return;
    }
    const path = new three_1.ShapePath();
    let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    if (glyph.o) {
        const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
        for (let i = 0, l = outline.length; i < l;) {
            const action = outline[i++];
            switch (action) {
                case 'm': // moveTo
                    x = outline[i++] * scale + offsetX;
                    y = outline[i++] * scale + offsetY;
                    path.moveTo(x, y);
                    break;
                case 'l': // lineTo
                    x = outline[i++] * scale + offsetX;
                    y = outline[i++] * scale + offsetY;
                    path.lineTo(x, y);
                    break;
                case 'q': // quadraticCurveTo
                    cpx = outline[i++] * scale + offsetX;
                    cpy = outline[i++] * scale + offsetY;
                    cpx1 = outline[i++] * scale + offsetX;
                    cpy1 = outline[i++] * scale + offsetY;
                    path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                    break;
                case 'b': // bezierCurveTo
                    cpx = outline[i++] * scale + offsetX;
                    cpy = outline[i++] * scale + offsetY;
                    cpx1 = outline[i++] * scale + offsetX;
                    cpy1 = outline[i++] * scale + offsetY;
                    cpx2 = outline[i++] * scale + offsetX;
                    cpy2 = outline[i++] * scale + offsetY;
                    path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                    break;
            }
        }
    }
    return { offsetX: glyph.ha * scale, path: path };
}
Font.prototype.isFont = true;
//# sourceMappingURL=FontLoader.js.map

/***/ }),

/***/ 10183:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RGBELoader = void 0;
/* eslint-disable no-case-declarations */
/* eslint-disable no-cond-assign */
/* eslint-disable @typescript-eslint/no-explicit-any */
const three_1 = __webpack_require__(39437);
// https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format
class RGBELoader extends three_1.DataTextureLoader {
    constructor(manager) {
        super(manager);
        this.type = three_1.HalfFloatType;
    }
    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
    parse(buffer) {
        const 
        /* return codes for rgbe routines */
        //RGBE_RETURN_SUCCESS = 0,
        RGBE_RETURN_FAILURE = -1, 
        /* default error routine.  change this to change error handling */
        rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function (rgbe_error_code, msg) {
            switch (rgbe_error_code) {
                case rgbe_read_error:
                    console.error('THREE.RGBELoader Read Error: ' + (msg || ''));
                    break;
                case rgbe_write_error:
                    console.error('THREE.RGBELoader Write Error: ' + (msg || ''));
                    break;
                case rgbe_format_error:
                    console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));
                    break;
                default:
                case rgbe_memory_error: console.error('THREE.RGBELoader: Error: ' + (msg || ''));
            }
            return RGBE_RETURN_FAILURE;
        }, 
        /* offsets to red, green, and blue components in a data (float) pixel */
        //RGBE_DATA_RED = 0,
        //RGBE_DATA_GREEN = 1,
        //RGBE_DATA_BLUE = 2,
        /* number of floats per pixel, use 4 since stored in rgba image format */
        //RGBE_DATA_SIZE = 4,
        /* flags indicating which fields in an rgbe_header_info are valid */
        RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = '\n', fgets = function (buffer, lineLimit, consume) {
            const chunkSize = 128;
            lineLimit = !lineLimit ? 1024 : lineLimit;
            let p = buffer.pos, i = -1, len = 0, s = '', chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
            while ((0 > (i = chunk.indexOf(NEWLINE))) && (len < lineLimit) && (p < buffer.byteLength)) {
                s += chunk;
                len += chunk.length;
                p += chunkSize;
                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
            }
            if (-1 < i) {
                /*for (i=l-1; i>=0; i--) {
                    byteCode = m.charCodeAt(i);
                    if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
                    else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
                    if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
                }*/
                if (false !== consume)
                    buffer.pos += len + i + 1;
                return s + chunk.slice(0, i);
            }
            return false;
        }, 
        /* minimal header reading.  modify if you want to parse more information */
        RGBE_ReadHeader = function (buffer) {
            // regexes to parse header info fields
            const magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, 
            // eslint-disable-next-line no-useless-escape
            dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, 
            // RGBE format header struct
            header = {
                valid: 0,
                string: '',
                comments: '',
                programtype: 'RGBE',
                format: '',
                gamma: 1.0,
                exposure: 1.0,
                width: 0, height: 0 /* image dimensions, width/height */
            };
            let line, match;
            if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer, undefined, undefined))) {
                return rgbe_error(rgbe_read_error, 'no header found');
            }
            /* if you want to require the magic token then uncomment the next line */
            if (!(match = line.match(magic_token_re))) {
                return rgbe_error(rgbe_format_error, 'bad initial token');
            }
            header.valid |= RGBE_VALID_PROGRAMTYPE;
            header.programtype = match[1];
            header.string += line + '\n';
            // eslint-disable-next-line no-constant-condition
            while (true) {
                line = fgets(buffer, undefined, undefined);
                if (false === line)
                    break;
                header.string += line + '\n';
                if ('#' === line.charAt(0)) {
                    header.comments += line + '\n';
                    continue; // comment line
                }
                if (match = line.match(gamma_re)) {
                    header.gamma = parseFloat(match[1]);
                }
                if (match = line.match(exposure_re)) {
                    header.exposure = parseFloat(match[1]);
                }
                if (match = line.match(format_re)) {
                    header.valid |= RGBE_VALID_FORMAT;
                    header.format = match[1]; //'32-bit_rle_rgbe';
                }
                if (match = line.match(dimensions_re)) {
                    header.valid |= RGBE_VALID_DIMENSIONS;
                    header.height = parseInt(match[1], 10);
                    header.width = parseInt(match[2], 10);
                }
                if ((header.valid & RGBE_VALID_FORMAT) && (header.valid & RGBE_VALID_DIMENSIONS))
                    break;
            }
            if (!(header.valid & RGBE_VALID_FORMAT)) {
                return rgbe_error(rgbe_format_error, 'missing format specifier');
            }
            if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
                return rgbe_error(rgbe_format_error, 'missing image size specifier');
            }
            return header;
        }, RGBE_ReadPixels_RLE = function (buffer, w, h) {
            const scanline_width = w;
            if (
            // run length encoding is not allowed so read flat
            ((scanline_width < 8) || (scanline_width > 0x7fff)) ||
                // this file is not run length encoded
                ((2 !== buffer[0]) || (2 !== buffer[1]) || (buffer[2] & 0x80))) {
                // return the flat buffer
                return new Uint8Array(buffer);
            }
            if (scanline_width !== ((buffer[2] << 8) | buffer[3])) {
                return rgbe_error(rgbe_format_error, 'wrong scanline width');
            }
            const data_rgba = new Uint8Array(4 * w * h);
            if (!data_rgba.length) {
                return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');
            }
            let offset = 0, pos = 0;
            const ptr_end = 4 * scanline_width;
            const rgbeStart = new Uint8Array(4);
            const scanline_buffer = new Uint8Array(ptr_end);
            let num_scanlines = h;
            // read in each successive scanline
            while ((num_scanlines > 0) && (pos < buffer.byteLength)) {
                if (pos + 4 > buffer.byteLength) {
                    return rgbe_error(rgbe_read_error, undefined);
                }
                rgbeStart[0] = buffer[pos++];
                rgbeStart[1] = buffer[pos++];
                rgbeStart[2] = buffer[pos++];
                rgbeStart[3] = buffer[pos++];
                if ((2 != rgbeStart[0]) || (2 != rgbeStart[1]) || (((rgbeStart[2] << 8) | rgbeStart[3]) != scanline_width)) {
                    return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');
                }
                // read each of the four channels for the scanline into the buffer
                // first red, then green, then blue, then exponent
                let ptr = 0, count;
                while ((ptr < ptr_end) && (pos < buffer.byteLength)) {
                    count = buffer[pos++];
                    const isEncodedRun = count > 128;
                    if (isEncodedRun)
                        count -= 128;
                    if ((0 === count) || (ptr + count > ptr_end)) {
                        return rgbe_error(rgbe_format_error, 'bad scanline data');
                    }
                    if (isEncodedRun) {
                        // a (encoded) run of the same value
                        const byteValue = buffer[pos++];
                        for (let i = 0; i < count; i++) {
                            scanline_buffer[ptr++] = byteValue;
                        }
                        //ptr += count;
                    }
                    else {
                        // a literal-run
                        scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);
                        ptr += count;
                        pos += count;
                    }
                }
                // now convert data from buffer into rgba
                // first red, then green, then blue, then exponent (alpha)
                const l = scanline_width; //scanline_buffer.byteLength;
                for (let i = 0; i < l; i++) {
                    let off = 0;
                    data_rgba[offset] = scanline_buffer[i + off];
                    off += scanline_width; //1;
                    data_rgba[offset + 1] = scanline_buffer[i + off];
                    off += scanline_width; //1;
                    data_rgba[offset + 2] = scanline_buffer[i + off];
                    off += scanline_width; //1;
                    data_rgba[offset + 3] = scanline_buffer[i + off];
                    offset += 4;
                }
                num_scanlines--;
            }
            return data_rgba;
        };
        const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {
            const e = sourceArray[sourceOffset + 3];
            const scale = Math.pow(2.0, e - 128.0) / 255.0;
            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
            destArray[destOffset + 3] = 1;
        };
        const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {
            const e = sourceArray[sourceOffset + 3];
            const scale = Math.pow(2.0, e - 128.0) / 255.0;
            // clamping to 65504, the maximum representable value in float16
            destArray[destOffset + 0] = three_1.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
            destArray[destOffset + 1] = three_1.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
            destArray[destOffset + 2] = three_1.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
            destArray[destOffset + 3] = three_1.DataUtils.toHalfFloat(1);
        };
        const byteArray = new Uint8Array(buffer);
        byteArray.pos = 0;
        const rgbe_header_info = RGBE_ReadHeader(byteArray);
        if (RGBE_RETURN_FAILURE !== rgbe_header_info) {
            const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
            if (RGBE_RETURN_FAILURE !== image_rgba_data) {
                let data, format, type;
                let numElements;
                switch (this.type) {
                    case three_1.FloatType:
                        numElements = image_rgba_data.length / 4;
                        const floatArray = new Float32Array(numElements * 4);
                        for (let j = 0; j < numElements; j++) {
                            RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);
                        }
                        data = floatArray;
                        type = three_1.FloatType;
                        break;
                    case three_1.HalfFloatType:
                        numElements = image_rgba_data.length / 4;
                        const halfArray = new Uint16Array(numElements * 4);
                        for (let j = 0; j < numElements; j++) {
                            RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);
                        }
                        data = halfArray;
                        type = three_1.HalfFloatType;
                        break;
                    default:
                        console.error('THREE.RGBELoader: unsupported type: ', this.type);
                        break;
                }
                return {
                    width: w, height: h,
                    data: data,
                    header: rgbe_header_info.string,
                    gamma: rgbe_header_info.gamma,
                    exposure: rgbe_header_info.exposure,
                    format: format,
                    type: type
                };
            }
        }
        return null;
    }
    setDataType(value) {
        this.type = value;
        return this;
    }
    load(url, onLoad, onProgress, onError) {
        function onLoadCallback(texture, texData) {
            switch (texture.type) {
                case three_1.FloatType:
                    texture.colorSpace = three_1.LinearSRGBColorSpace;
                    texture.minFilter = three_1.LinearFilter;
                    texture.magFilter = three_1.LinearFilter;
                    texture.generateMipmaps = false;
                    texture.flipY = true;
                    break;
                case three_1.HalfFloatType:
                    texture.colorSpace = three_1.LinearSRGBColorSpace;
                    texture.minFilter = three_1.LinearFilter;
                    texture.magFilter = three_1.LinearFilter;
                    texture.generateMipmaps = false;
                    texture.flipY = true;
                    break;
            }
            if (onLoad)
                onLoad(texture, texData);
        }
        return super.load(url, onLoadCallback, onProgress, onError);
    }
}
exports.RGBELoader = RGBELoader;
//# sourceMappingURL=RGBELoader.js.map

/***/ }),

/***/ 54609:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ThreejsData_obj;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ThreejsData = void 0;
const viewer_shared_node_tree_1 = __webpack_require__(41652);
class ThreejsData extends viewer_shared_node_tree_1.AbstractTreeNodeData {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(obj, id) {
        super(id);
        // #region Properties (1)
        _ThreejsData_obj.set(this, void 0);
        __classPrivateFieldSet(this, _ThreejsData_obj, obj, "f");
    }
    // #endregion Constructors (1)
    // #region Public Accessors (2)
    get obj() {
        return __classPrivateFieldGet(this, _ThreejsData_obj, "f");
    }
    set obj(value) {
        __classPrivateFieldSet(this, _ThreejsData_obj, value, "f");
    }
    // #endregion Public Accessors (2)
    // #region Public Methods (1)
    clone() {
        return new ThreejsData(this.obj, this.id);
    }
}
exports.ThreejsData = ThreejsData;
_ThreejsData_obj = new WeakMap();
//# sourceMappingURL=ThreejsData.js.map

/***/ }),

/***/ 81155:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VISIBILITY_MODE = exports.TONE_MAPPING = exports.TEXTURE_ENCODING = exports.SPINNER_POSITIONING = exports.RENDERER_TYPE = exports.FLAG_TYPE = exports.BUSY_MODE_DISPLAY = void 0;
// #endregion Interfaces (1)
// #region Enums (7)
/**
 * Modes used to indicate that a viewport is busy.
 */
var BUSY_MODE_DISPLAY;
(function (BUSY_MODE_DISPLAY) {
    /** The viewport will be blurred when a session is busy. */
    BUSY_MODE_DISPLAY["BLUR"] = "blur";
    /** A spinner will be shown when a session is busy. */
    BUSY_MODE_DISPLAY["SPINNER"] = "spinner";
    /** Nothing happens when a session is busy. */
    BUSY_MODE_DISPLAY["NONE"] = "none";
})(BUSY_MODE_DISPLAY = exports.BUSY_MODE_DISPLAY || (exports.BUSY_MODE_DISPLAY = {}));
/**
 * Types of flags used to influence the render loop.
 */
var FLAG_TYPE;
(function (FLAG_TYPE) {
    /** The flag for the busy mode. */
    FLAG_TYPE["BUSY_MODE"] = "busy_mode";
    /** The flag to freeze the camera. */
    FLAG_TYPE["CAMERA_FREEZE"] = "camera_freeze";
    /** The flag to continuously render the scene. */
    FLAG_TYPE["CONTINUOUS_RENDERING"] = "continuous_rendering";
    /** The flag to continuously update the shadow map. */
    FLAG_TYPE["CONTINUOUS_SHADOW_MAP_UPDATE"] = "continuous_shadow_map_update";
})(FLAG_TYPE = exports.FLAG_TYPE || (exports.FLAG_TYPE = {}));
var RENDERER_TYPE;
(function (RENDERER_TYPE) {
    /** The standard rendering engine */
    RENDERER_TYPE["STANDARD"] = "standard";
    /** A basic version of the rendering engine */
    RENDERER_TYPE["ATTRIBUTES"] = "attributes";
})(RENDERER_TYPE = exports.RENDERER_TYPE || (exports.RENDERER_TYPE = {}));
var SPINNER_POSITIONING;
(function (SPINNER_POSITIONING) {
    SPINNER_POSITIONING["CENTER"] = "center";
    SPINNER_POSITIONING["TOP_LEFT"] = "top_left";
    SPINNER_POSITIONING["TOP_RIGHT"] = "top_right";
    SPINNER_POSITIONING["BOTTOM_LEFT"] = "bottom_left";
    SPINNER_POSITIONING["BOTTOM_RIGHT"] = "bottom_right";
})(SPINNER_POSITIONING = exports.SPINNER_POSITIONING || (exports.SPINNER_POSITIONING = {}));
var TEXTURE_ENCODING;
(function (TEXTURE_ENCODING) {
    TEXTURE_ENCODING["LINEAR"] = "linear";
    TEXTURE_ENCODING["SRGB"] = "srgb";
    TEXTURE_ENCODING["RGBE"] = "rgbe";
    TEXTURE_ENCODING["RGBM7"] = "rgbm7";
    TEXTURE_ENCODING["RGBM16"] = "rgbm16";
    TEXTURE_ENCODING["RGBD"] = "rgbd";
    TEXTURE_ENCODING["GAMMA"] = "gamma";
})(TEXTURE_ENCODING = exports.TEXTURE_ENCODING || (exports.TEXTURE_ENCODING = {}));
var TONE_MAPPING;
(function (TONE_MAPPING) {
    TONE_MAPPING["NONE"] = "none";
    TONE_MAPPING["LINEAR"] = "linear";
    TONE_MAPPING["REINHARD"] = "reinhard";
    TONE_MAPPING["CINEON"] = "cineon";
    TONE_MAPPING["ACES_FILMIC"] = "aces_filmic";
})(TONE_MAPPING = exports.TONE_MAPPING || (exports.TONE_MAPPING = {}));
var VISIBILITY_MODE;
(function (VISIBILITY_MODE) {
    /** The viewer shows the scene instantly */
    VISIBILITY_MODE["INSTANT"] = "instant";
    /** The viewer shows the scene after the first session loading */
    VISIBILITY_MODE["SESSION"] = "session";
    /** The viewer is shown once the 'show' property is set to true */
    VISIBILITY_MODE["MANUAL"] = "manual";
})(VISIBILITY_MODE = exports.VISIBILITY_MODE || (exports.VISIBILITY_MODE = {}));
// #endregion Enums (7)
//# sourceMappingURL=IRenderingEngine.js.map

/***/ }),

/***/ 45850:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SPINNER_POSITIONING = exports.FLAG_TYPE = exports.BUSY_MODE_DISPLAY = exports.TONE_MAPPING = exports.TEXTURE_ENCODING = exports.VISIBILITY_MODE = exports.RENDERER_TYPE = void 0;
const IRenderingEngine_1 = __webpack_require__(81155);
Object.defineProperty(exports, "BUSY_MODE_DISPLAY", ({ enumerable: true, get: function () { return IRenderingEngine_1.BUSY_MODE_DISPLAY; } }));
Object.defineProperty(exports, "FLAG_TYPE", ({ enumerable: true, get: function () { return IRenderingEngine_1.FLAG_TYPE; } }));
Object.defineProperty(exports, "RENDERER_TYPE", ({ enumerable: true, get: function () { return IRenderingEngine_1.RENDERER_TYPE; } }));
Object.defineProperty(exports, "TEXTURE_ENCODING", ({ enumerable: true, get: function () { return IRenderingEngine_1.TEXTURE_ENCODING; } }));
Object.defineProperty(exports, "TONE_MAPPING", ({ enumerable: true, get: function () { return IRenderingEngine_1.TONE_MAPPING; } }));
Object.defineProperty(exports, "VISIBILITY_MODE", ({ enumerable: true, get: function () { return IRenderingEngine_1.VISIBILITY_MODE; } }));
Object.defineProperty(exports, "SPINNER_POSITIONING", ({ enumerable: true, get: function () { return IRenderingEngine_1.SPINNER_POSITIONING; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 18592:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutputDelayException = void 0;
class OutputDelayException extends Error {
    // #region Constructors (1)
    /**
     * Exception that is thrown when there is an output with a delay property.
     *
     * @param _delay the milliseconds to wait
     */
    constructor(_delay) {
        super();
        this._delay = _delay;
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (1)
    get delay() {
        return this._delay;
    }
}
exports.OutputDelayException = OutputDelayException;
//# sourceMappingURL=OutputDelayException.js.map

/***/ }),

/***/ 16447:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutputLoader = void 0;
const viewer_shared_types_1 = __webpack_require__(64766);
const viewer_shared_services_1 = __webpack_require__(8389);
const viewer_shared_global_access_objects_1 = __webpack_require__(50069);
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const OutputDelayException_1 = __webpack_require__(18592);
const SessionOutputData_1 = __webpack_require__(77124);
const SessionTreeNode_1 = __webpack_require__(26401);
// #endregion Type aliases (1)
// #region Classes (1)
class OutputLoader {
    // #endregion Properties (6)
    // #region Constructors (1)
    /**
     * The output loader takes care of loading the outputs of a session, storing them and returning stored or newly loaded nodes.
     *
     * @param _session the session for this output loader
     */
    constructor(_sessionEngine) {
        this._sessionEngine = _sessionEngine;
        // #region Properties (6)
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._globalAccessObjects = viewer_shared_global_access_objects_1.GlobalAccessObjects.instance;
        this._lastOutputNodes = {};
        this._loadedOutputNodes = {};
        this._performanceEvaluator = viewer_shared_services_1.PerformanceEvaluator.instance;
        this._reloadSdtf = false;
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (1)
    set reloadSdtf(value) {
        this._reloadSdtf = value;
    }
    // #endregion Public Getters And Setters (1)
    // #region Public Methods (2)
    getCurrentOutputVersions() {
        const versions = {};
        for (const o in this._lastOutputNodes)
            versions[o] = Object.keys(this._lastOutputNodes[o])[0];
        return versions;
    }
    /**
     * Load the outputs and return the scene graph node of the result.
     * In case the outputs have a delay property, it throws an OutputDelayException.
     *
     * @param outputs the outputs to load
     * @returns promise with a scene graph node
     */
    loadOutputs(nodeName, outputs, outputsFreeze, taskEventInfo, throwDelay = true) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this._performanceEvaluator.startSection('outputLoading');
            const node = new SessionTreeNode_1.SessionTreeNode(nodeName);
            const currentNodes = {};
            const outputInfo = {};
            const promises = [];
            const promisesNodes = [];
            let maxDelay = 0;
            const progress = {};
            const outputIDs = Object.keys(outputs);
            const cb = (e) => {
                const taskEvent = e;
                if (outputIDs.find(oId => taskEvent.id.startsWith(oId))) {
                    progress[taskEvent.id] = taskEvent.progress;
                    let sum = 0;
                    Object.values(progress).forEach(p => { sum += p; });
                    const outputLoadingProgress = (taskEventInfo.progressRange.max - taskEventInfo.progressRange.min) * (sum / outputIDs.length) + taskEventInfo.progressRange.min;
                    const eventProgressUpdate = { type: taskEventInfo.type, id: taskEventInfo.eventId, progress: outputLoadingProgress, data: taskEventInfo.data, status: 'Output content loading progress.' };
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventProgressUpdate);
                }
            };
            const listenerTokens = [];
            listenerTokens.push(this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, cb));
            listenerTokens.push(this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, cb));
            listenerTokens.push(this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, cb));
            listenerTokens.push(this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, cb));
            for (const outputID in outputs) {
                // we store some necessary information as this data may have been changed after the await (see warning below)
                outputInfo[outputID] = {
                    version: outputs[outputID].version,
                    contentFormat: outputs[outputID].content ? outputs[outputID].content.map(c => c.format) : []
                };
                currentNodes[outputID] = {};
                if (!this._loadedOutputNodes[outputID])
                    this._loadedOutputNodes[outputID] = {};
                if (this._reloadSdtf && outputs[outputID].content) {
                    const sdtfContents = (_a = outputs[outputID].content) === null || _a === void 0 ? void 0 : _a.filter(c => c.format === 'sdtf');
                    if (sdtfContents && sdtfContents.length > 0)
                        delete this._loadedOutputNodes[outputID][outputInfo[outputID].version];
                }
                if (outputsFreeze[outputID]) {
                    currentNodes[outputID][outputInfo[outputID].version] = this._lastOutputNodes[outputID][outputInfo[outputID].version];
                    // no loading necessary, progress done
                    progress[outputID] = 1;
                }
                else if (outputs[outputID].delay) {
                    maxDelay = Math.max(maxDelay, outputs[outputID].delay);
                }
                else if (!this._loadedOutputNodes[outputID][outputInfo[outputID].version]) {
                    currentNodes[outputID][outputInfo[outputID].version] = new SessionTreeNode_1.SessionTreeNode(outputID);
                    currentNodes[outputID][outputInfo[outputID].version].data.push(new SessionOutputData_1.SessionOutputData(outputs[outputID]));
                    if (outputs[outputID].content) {
                        for (let i = 0, len = outputs[outputID].content.length; i < len; i++) {
                            if (outputs[outputID].content[i].format === 'sdtf' && !this._sessionEngine.loadSdtf)
                                continue;
                            if (this._globalAccessObjects.loadContent)
                                promises.push(this._globalAccessObjects.loadContent(outputs[outputID].content[i], this._sessionEngine.jwtToken, outputID + '_' + outputInfo[outputID].version + '_' + i));
                            promisesNodes.push(currentNodes[outputID][outputInfo[outputID].version]);
                        }
                    }
                }
                else {
                    currentNodes[outputID][outputInfo[outputID].version] = this._loadedOutputNodes[outputID][outputInfo[outputID].version];
                    // no loading necessary, progress done
                    progress[outputID] = 1;
                }
            }
            if (maxDelay && throwDelay)
                throw new OutputDelayException_1.OutputDelayException(maxDelay);
            /**
             * WARNING: After this point outputs object cannot be used anymore.
             * This can happen when fast consecutive scene updates are done.
             * Therefore, we stored the data in the outputInfo.
             */
            yield Promise.all(promises);
            listenerTokens.forEach(t => this._eventEngine.removeListener(t));
            // all promises are resolved, await in the next lines is just for structural purposes
            for (let i = 0; i < promises.length; i++)
                promisesNodes[i].addChild(yield promises[i]);
            // here we assign all outputs just to the node and return it
            for (const outputID in outputInfo)
                if (currentNodes[outputID][outputInfo[outputID].version])
                    node.addChild(currentNodes[outputID][outputInfo[outputID].version]);
            // save the nodes as the last available version
            for (const outputID in outputInfo) {
                if (!currentNodes[outputID][outputInfo[outputID].version])
                    continue;
                this._loadedOutputNodes[outputID] = {};
                this._loadedOutputNodes[outputID][outputInfo[outputID].version] = currentNodes[outputID][outputInfo[outputID].version];
                this._lastOutputNodes[outputID] = {};
                this._lastOutputNodes[outputID][outputInfo[outputID].version] = currentNodes[outputID][outputInfo[outputID].version];
            }
            for (const outputID in outputInfo) {
                if (!currentNodes[outputID][outputInfo[outputID].version])
                    continue;
                if (currentNodes[outputID][outputInfo[outputID].version].children.length > 1) {
                    for (let i = 0, len = outputInfo[outputID].contentFormat.length; i < len; i++) {
                        if (outputInfo[outputID].contentFormat[i] === 'sdtf' && this._sessionEngine.loadSdtf === true) {
                            this.mergeContentNodes(currentNodes[outputID][outputInfo[outputID].version]);
                            break;
                        }
                    }
                }
            }
            this.assignMaterials(node);
            this._performanceEvaluator.endSection('outputLoading');
            return node;
        });
    }
    // #endregion Public Methods (2)
    // #region Private Methods (2)
    assignMaterials(node) {
        const addMaterialToGeometry = (node, material) => {
            for (let i = 0; i < node.data.length; i++) {
                if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {
                    const geometry = node.data[i];
                    const currentMaterial = geometry.material;
                    if (currentMaterial === null || currentMaterial.materialOutput === true) {
                        geometry.material = material;
                    }
                }
            }
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if (child)
                    addMaterialToGeometry(child, material);
            }
        };
        const getMaterialData = (node, materials = []) => {
            for (let k = 0; k < node.data.length; k++) {
                if (node.data[k] instanceof viewer_shared_types_1.AbstractMaterialData) {
                    const material = node.data[k];
                    material.materialOutput = true;
                    materials.push(material);
                }
            }
            for (let k = 0; k < node.children.length; k++) {
                const child = node.children[k];
                if (!child)
                    continue;
                materials.push(...getMaterialData(child));
            }
            return materials;
        };
        for (let m = 0; m < node.children.length; m++) {
            // per output node, we go through the material assignment process
            const outputNode = node.children[m];
            if (!outputNode)
                continue;
            // we go through all data properties, normally, there should ony one, but we just make sure
            for (let i = 0; i < outputNode.data.length; i++) {
                if (!(outputNode.data[i] instanceof SessionOutputData_1.SessionOutputData))
                    continue;
                // the session output data contains information about this Output
                // most importantly the SessionOutput property with the material and content in it
                const sessionOutputData = outputNode.data[i];
                // case 1: we have a specific material id defined, let's use that
                if (sessionOutputData.responseOutput.material) {
                    let materialNodes = [];
                    // now we have id
                    // get material with it    
                    for (let n = 0; n < node.children.length; n++) {
                        const materialNode = node.children[n];
                        if (!materialNode)
                            continue;
                        if (materialNode.name === sessionOutputData.responseOutput.material)
                            materialNodes = materialNode.children;
                    }
                    const geometryNodes = outputNode.children;
                    if (materialNodes.length >= geometryNodes.length) {
                        for (let n = 0; n < geometryNodes.length; n++) {
                            addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[n])[0]);
                        }
                    }
                    else {
                        if (materialNodes.length >= 1)
                            for (let n = 0; n < geometryNodes.length; n++) {
                                addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[0])[0]);
                            }
                    }
                }
                // case 2: there is no specific material id defined, maybe in the content we can match geometries to ids
                else {
                    // now we hope that in our content, there are exactly the amount of geometries and material, this will be interesting :)
                    const sessionOutputContent = sessionOutputData.responseOutput.content;
                    if (sessionOutputContent === undefined)
                        continue;
                    const materialNodes = [];
                    const geometryNodes = [];
                    for (let i = 0; i < sessionOutputContent.length; i++) {
                        if (sessionOutputContent[i].format === 'material') {
                            if (outputNode.children[i])
                                materialNodes.push(outputNode.children[i]);
                        }
                        else {
                            if (outputNode.children[i])
                                geometryNodes.push(outputNode.children[i]);
                        }
                    }
                    if (materialNodes.length >= geometryNodes.length) {
                        for (let n = 0; n < geometryNodes.length; n++) {
                            addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[n])[0]);
                        }
                    }
                    else {
                        if (materialNodes.length >= 1)
                            for (let n = 0; n < geometryNodes.length; n++) {
                                addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[0])[0]);
                            }
                    }
                }
            }
        }
    }
    mergeContentNodes(node) {
        if (!(node.children.length > 1))
            return;
        const children = [];
        while (node.children.length > 0) {
            children.push(...node.children[0].children);
            node.removeChild(node.children[0]);
        }
        const mergeNodes = (node1, node2) => {
            for (let i = 0; i < node1.data.length; i++)
                node2.data.push(node1.data[i]);
            for (let i = 0; i < node1.children.length; i++) {
                let childNode;
                for (let j = 0; j < node2.children.length; j++) {
                    if (node1.children[i].name === node2.children[j].name) {
                        childNode = node2.children[j];
                        break;
                    }
                }
                if (!childNode) {
                    childNode = new viewer_shared_node_tree_1.TreeNode(node1.children[i].name);
                    node2.addChild(childNode);
                }
                mergeNodes(node1.children[i], childNode);
            }
        };
        const newChild = new viewer_shared_node_tree_1.TreeNode('content_array');
        node.addChild(newChild);
        for (let i = 0; i < children.length; i++)
            mergeNodes(children[i], newChild);
    }
}
exports.OutputLoader = OutputLoader;
// #endregion Classes (1)
//# sourceMappingURL=OutputLoader.js.map

/***/ }),

/***/ 72265:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SessionData_responseDto;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionData = void 0;
const viewer_shared_node_tree_1 = __webpack_require__(41652);
class SessionData extends viewer_shared_node_tree_1.AbstractTreeNodeData {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(responseDto, id, version) {
        super(id, version);
        // #region Properties (1)
        _SessionData_responseDto.set(this, void 0);
        __classPrivateFieldSet(this, _SessionData_responseDto, responseDto, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (2)
    get responseDto() {
        return __classPrivateFieldGet(this, _SessionData_responseDto, "f");
    }
    set responseDto(value) {
        __classPrivateFieldSet(this, _SessionData_responseDto, value, "f");
    }
    // #endregion Public Getters And Setters (2)
    // #region Public Methods (1)
    clone() {
        return new SessionData(this.responseDto, this.id, this.version);
    }
}
exports.SessionData = SessionData;
_SessionData_responseDto = new WeakMap();
//# sourceMappingURL=SessionData.js.map

/***/ }),

/***/ 42475:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _SessionEngine_customizationBusyModes, _SessionEngine_customizationProcess, _SessionEngine_parameterHistory, _SessionEngine_parameterHistoryCall, _SessionEngine_parameterHistoryForward;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionEngine = void 0;
const viewer_settings_1 = __webpack_require__(65199);
const viewer_shared_services_1 = __webpack_require__(8389);
const sdk_geometry_api_sdk_v2_1 = __webpack_require__(50059);
const DrawingParameter_1 = __webpack_require__(35330);
const Export_1 = __webpack_require__(40457);
const FileParameter_1 = __webpack_require__(66906);
const GumballParameter_1 = __webpack_require__(76827);
const viewer_shared_types_1 = __webpack_require__(64766);
const viewer_shared_node_tree_1 = __webpack_require__(41652);
const Output_1 = __webpack_require__(774);
const OutputDelayException_1 = __webpack_require__(18592);
const OutputLoader_1 = __webpack_require__(16447);
const Parameter_1 = __webpack_require__(14036);
const SelectionParameter_1 = __webpack_require__(22967);
const SessionData_1 = __webpack_require__(72265);
const SessionTreeNode_1 = __webpack_require__(26401);
/* eslint-disable @typescript-eslint/no-empty-function */
class SessionEngine {
    // #endregion Properties (50)
    // #region Constructors (1)
    /**
     * Can be use to initialize a session with the ticket/guid and modelViewUrl and returns a scene graph node with the result.
     * Can be use to customize the session with updated parameters to get the updated scene graph node.
     */
    constructor(properties) {
        // #region Properties (50)
        this._converter = viewer_shared_services_1.Converter.instance;
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._exports = {};
        this._httpClient = viewer_shared_services_1.HttpClient.instance;
        this._logger = viewer_shared_services_1.Logger.instance;
        this._outputs = {};
        this._outputsFreeze = {};
        this._parameterValues = {};
        this._parameters = {};
        this._performanceEvaluator = viewer_shared_services_1.PerformanceEvaluator.instance;
        this._sceneTree = viewer_shared_node_tree_1.Tree.instance;
        this._sessionEngineId = (viewer_shared_services_1.UuidGenerator.instance).create();
        this._settingsEngine = new viewer_shared_services_1.SettingsEngine();
        this._stateEngine = viewer_shared_services_1.StateEngine.instance;
        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;
        _SessionEngine_customizationBusyModes.set(this, []);
        _SessionEngine_customizationProcess.set(this, void 0);
        _SessionEngine_parameterHistory.set(this, []);
        _SessionEngine_parameterHistoryCall.set(this, false);
        _SessionEngine_parameterHistoryForward.set(this, []);
        this._allowOutputLoading = true;
        this._automaticSceneUpdate = true;
        this._closeOnFailure = () => __awaiter(this, void 0, void 0, function* () { });
        this._closed = false;
        this._customizeOnParameterChange = false;
        this._dataCache = {};
        this._excludeViewports = [];
        this._headers = {
            'X-ShapeDiver-Origin': (viewer_shared_services_1.SystemInfo.instance).origin,
            'X-ShapeDiver-SessionEngineId': this._sessionEngineId,
            'X-ShapeDiver-BuildVersion': '',
            'X-ShapeDiver-BuildDate': ''
        };
        this._initialized = false;
        this._loadSdtf = false;
        this._retryCounter = 0;
        this._updateCallback = null;
        this._viewerSettingsVersion = viewer_settings_1.latestVersion;
        this._viewerSettingsVersionBackend = viewer_settings_1.latestVersion;
        this._id = properties.id;
        this._node = new viewer_shared_node_tree_1.TreeNode(properties.id);
        this._guid = properties.guid;
        this._ticket = properties.ticket;
        this._modelViewUrl = properties.modelViewUrl;
        this._excludeViewports = properties.excludeViewports || [];
        this._jwtToken = properties.jwtToken;
        this._allowOutputLoading = properties.allowOutputLoading;
        this._loadSdtf = properties.loadSdtf;
        this._modelStateId = properties.modelStateId;
        this._modelStateValidationMode = properties.modelStateValidationMode;
        this._headers['X-ShapeDiver-BuildDate'] = properties.buildDate;
        this._headers['X-ShapeDiver-BuildVersion'] = properties.buildVersion;
        this._outputLoader = new OutputLoader_1.OutputLoader(this);
        try {
            this._sdk = (0, sdk_geometry_api_sdk_v2_1.create)(this._modelViewUrl, this._jwtToken);
            this._sdk.setConfigurationValue(sdk_geometry_api_sdk_v2_1.ShapeDiverSdkConfigType.REQUEST_HEADERS, this._headers);
        }
        catch (e) {
            throw this._httpClient.convertError(e);
        }
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (28)
    get automaticSceneUpdate() {
        return this._automaticSceneUpdate;
    }
    set automaticSceneUpdate(value) {
        this._automaticSceneUpdate = value;
        value && this._closed === false ? this.addToSceneTree(this._node) : this.removeFromSceneTree(this._node);
    }
    get canUploadGLTF() {
        try {
            this.checkAvailability('gltf-upload');
            return true;
        }
        catch (e) {
            return false;
        }
    }
    get customizeOnParameterChange() {
        return this._customizeOnParameterChange;
    }
    set customizeOnParameterChange(value) {
        this._customizeOnParameterChange = value;
    }
    get excludeViewports() {
        return this._excludeViewports;
    }
    set excludeViewports(value) {
        this._excludeViewports = JSON.parse(JSON.stringify(value));
        this._node.excludeViewports = JSON.parse(JSON.stringify(value));
    }
    get exports() {
        return this._exports;
    }
    get guid() {
        return this._guid;
    }
    get id() {
        return this._id;
    }
    get initialized() {
        return this._initialized;
    }
    get jwtToken() {
        return this._jwtToken;
    }
    get loadSdtf() {
        return this._loadSdtf;
    }
    set loadSdtf(value) {
        this._loadSdtf = value;
        if (this._initialized === true && this._loadSdtf === true) {
            (() => __awaiter(this, void 0, void 0, function* () {
                this._outputLoader.reloadSdtf = true;
                yield this.updateOutputs();
                this._outputLoader.reloadSdtf = false;
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SESSION.SESSION_SDTF_DELAYED_LOADED, { sessionId: this.id });
            }))();
        }
    }
    get modelState() {
        return this._modelState;
    }
    get modelViewUrl() {
        return this._modelViewUrl;
    }
    get node() {
        return this._node;
    }
    get outputs() {
        return this._outputs;
    }
    get outputsFreeze() {
        return this._outputsFreeze;
    }
    get parameterValues() {
        return this._parameterValues;
    }
    get parameters() {
        return this._parameters;
    }
    get refreshJwtToken() {
        return this._refreshJwtToken;
    }
    set refreshJwtToken(value) {
        this._refreshJwtToken = value;
    }
    get settingsEngine() {
        return this._settingsEngine;
    }
    get ticket() {
        return this._ticket;
    }
    get updateCallback() {
        return this._updateCallback;
    }
    set updateCallback(value) {
        this._updateCallback = value;
    }
    get viewerSettings() {
        return this._viewerSettings;
    }
    // #endregion Public Getters And Setters (28)
    // #region Public Methods (31)
    applySettings(response, sections) {
        sections = sections || {};
        if (sections.session === undefined) {
            sections.session = {
                parameter: { displayname: false, order: false, hidden: false },
                export: { displayname: false, order: false, hidden: false }
            };
        }
        if (sections.session.parameter === undefined)
            sections.session.parameter = { displayname: false, order: false, hidden: false, value: false };
        if (sections.session.export === undefined)
            sections.session.export = { displayname: false, order: false, hidden: false };
        if (sections.viewport === undefined)
            sections.viewport = { ar: false, scene: false, camera: false, light: false, environment: false, general: false, postprocessing: false };
        let config;
        if (response.viewer !== undefined) {
            config = response.viewer.config;
        }
        else {
            throw new viewer_shared_services_1.ShapeDiverViewerSettingsError('Session.applySettings: No config object available.');
        }
        try {
            (0, viewer_settings_1.validate)(config);
        }
        catch (e) {
            throw new viewer_shared_services_1.ShapeDiverViewerSettingsError('Session.applySettings: Was not able to validate config object.');
        }
        const settings = (0, viewer_settings_1.convert)(config, viewer_settings_1.latestVersion);
        const exportMappingUid = {};
        if (sections.session.export.displayname || sections.session.export.order || sections.session.export.hidden)
            if (response.exports)
                for (const exportId in response.exports)
                    if (response.exports[exportId].uid !== undefined)
                        exportMappingUid[response.exports[exportId].uid] = exportId;
        const currentSettings = this._settingsEngine.settings;
        // apply parameter settings
        if (sections.session.parameter.displayname || sections.session.parameter.order || sections.session.parameter.hidden || sections.session.parameter.value) {
            for (const p in this.parameters) {
                if (settings.session[p]) {
                    if (sections.session.parameter.displayname)
                        this.parameters[p].displayname = settings.session[p].displayname;
                    if (sections.session.parameter.order)
                        this.parameters[p].order = settings.session[p].order;
                    if (sections.session.parameter.hidden)
                        this.parameters[p].hidden = settings.session[p].hidden || false;
                }
                if (response.parameters && response.parameters[p] && !((this.parameters[p] instanceof FileParameter_1.FileParameter) || this.parameters[p].type.startsWith('s'))) {
                    if (sections.session.parameter.value)
                        this.parameters[p].value = response.parameters[p].defval !== undefined ? response.parameters[p].defval : this.parameters[p].value;
                }
            }
        }
        // apply export settings
        if (sections.session.export.displayname || sections.session.export.order || sections.session.export.hidden) {
            for (const p in this.exports) {
                let idForSettings = '';
                if (settings.session[p]) {
                    idForSettings = p;
                }
                else {
                    const uid = this.exports[p].uid;
                    if (!uid)
                        continue;
                    if (!exportMappingUid[uid])
                        continue;
                    idForSettings = exportMappingUid[uid];
                }
                if (settings.session[idForSettings]) {
                    if (sections.session.export.displayname)
                        this.exports[p].displayname = settings.session[idForSettings].displayname;
                    if (sections.session.export.order)
                        this.exports[p].order = settings.session[idForSettings].order;
                    if (sections.session.export.hidden)
                        this.exports[p].hidden = settings.session[idForSettings].hidden || false;
                }
            }
        }
        // apply ar settings
        if (sections.viewport.ar) {
            currentSettings.ar = settings.ar;
            currentSettings.general.transformation = settings.general.transformation;
        }
        // apply camera settings
        if (sections.viewport.camera)
            currentSettings.camera = settings.camera;
        // apply light settings
        if (sections.viewport.light)
            currentSettings.light = settings.light;
        // apply scene settings
        if (sections.viewport.scene) {
            currentSettings.environmentGeometry.gridColor = settings.environmentGeometry.gridColor;
            currentSettings.environmentGeometry.gridVisibility = settings.environmentGeometry.gridVisibility;
            currentSettings.environmentGeometry.groundPlaneColor = settings.environmentGeometry.groundPlaneColor;
            currentSettings.environmentGeometry.groundPlaneVisibility = settings.environmentGeometry.groundPlaneVisibility;
            currentSettings.environmentGeometry.groundPlaneShadowColor = settings.environmentGeometry.groundPlaneShadowColor;
            currentSettings.environmentGeometry.groundPlaneShadowVisibility = settings.environmentGeometry.groundPlaneShadowVisibility;
            currentSettings.rendering.shadows = settings.rendering.shadows;
            currentSettings.rendering.softShadows = settings.rendering.softShadows;
            currentSettings.rendering.automaticColorAdjustment = settings.rendering.automaticColorAdjustment;
            currentSettings.rendering.textureEncoding = settings.rendering.textureEncoding;
            currentSettings.rendering.outputEncoding = settings.rendering.outputEncoding;
            currentSettings.rendering.physicallyCorrectLights = settings.rendering.physicallyCorrectLights;
            currentSettings.rendering.toneMapping = settings.rendering.toneMapping;
            currentSettings.rendering.toneMappingExposure = settings.rendering.toneMappingExposure;
        }
        if (sections.viewport.general) {
            currentSettings.general.defaultMaterialColor = settings.general.defaultMaterialColor;
            currentSettings.general.commitParameters = settings.general.commitParameters;
            currentSettings.general.pointSize = settings.general.pointSize;
        }
        // apply postprocessing settings
        if (sections.viewport.postprocessing)
            currentSettings.postprocessing = settings.postprocessing;
        // apply environment settings
        if (sections.viewport.environment) {
            currentSettings.environment.clearAlpha = settings.environment.clearAlpha;
            currentSettings.environment.clearColor = settings.environment.clearColor;
            currentSettings.environment.map = settings.environment.map;
            currentSettings.environment.mapAsBackground = settings.environment.mapAsBackground;
            currentSettings.environment.rotation = settings.environment.rotation;
            currentSettings.environment.blurriness = settings.environment.blurriness;
            currentSettings.environment.intensity = settings.environment.intensity;
        }
    }
    canGoBack() {
        // the first entry is always the one from the init call
        // all additional entries can be undone
        return __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").length > 1;
    }
    canGoForward() {
        return __classPrivateFieldGet(this, _SessionEngine_parameterHistoryForward, "f").length > 0;
    }
    cancelCustomization() {
        if (__classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f"))
            this.removeBusyMode(__classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f"));
        for (const busyId of __classPrivateFieldGet(this, _SessionEngine_customizationBusyModes, "f")) {
            for (const r in this._stateEngine.viewportEngines) {
                if (this._stateEngine.viewportEngines[r] && this._stateEngine.viewportEngines[r].busy.includes(busyId))
                    this._stateEngine.viewportEngines[r].busy.splice(this._stateEngine.viewportEngines[r].busy.indexOf(busyId), 1);
            }
        }
        __classPrivateFieldSet(this, _SessionEngine_customizationBusyModes, [], "f");
        __classPrivateFieldSet(this, _SessionEngine_customizationProcess, undefined, "f");
    }
    close(retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('close');
            try {
                this._httpClient.removeDataLoading(this._sessionId);
                yield this._sdk.session.close(this._sessionId);
                if (this._automaticSceneUpdate)
                    this.removeFromSceneTree(this._node);
                this._closed = true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.close(true);
            }
        });
    }
    createModelState(parameterValues = {}, omitSessionParameterValues = false, image, data, arScene) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            try {
                const promises = [];
                // process the parameters
                const parameterSet = {};
                promises.push(this.uploadFileParameters(parameterValues).then(() => {
                    // create a set of the current validated parameter values
                    for (const parameterId in this.parameters) {
                        // if the parameter has not been set, we do not include it in the parameter set if the omitSessionParameterValues flag is set
                        if (!(omitSessionParameterValues === true && parameterValues[parameterId] === undefined)) {
                            parameterSet[parameterId] = (' ' + this.parameters[parameterId].stringify(parameterValues[parameterId])).slice(1);
                        }
                    }
                }));
                // process the image input
                let imageData;
                let imageArrayBuffer;
                if (image) {
                    promises.push(this.processImageInput(image)
                        .then(result => {
                        imageData = result === null || result === void 0 ? void 0 : result.imageData;
                        imageArrayBuffer = result === null || result === void 0 ? void 0 : result.arrayBuffer;
                    }));
                }
                // process the arScene input
                let arSceneId;
                if (arScene) {
                    promises.push(this._converter.convertToArrayBuffer(arScene)
                        .then(arSceneArrayBuffer => this._sdk.gltf.upload(this._sessionId, arSceneArrayBuffer, 'model/gltf-binary', sdk_geometry_api_sdk_v2_1.ShapeDiverRequestGltfUploadQueryConversion.SCENE))
                        .then(arSceneResponseDto => {
                        var _a;
                        arSceneId = (_a = arSceneResponseDto.gltf) === null || _a === void 0 ? void 0 : _a.sceneId;
                    }));
                }
                // wait for all promises to resolve
                yield Promise.all(promises);
                // create the model state
                const response = yield this._sdk.modelState.create(this._sessionId, {
                    parameters: parameterSet,
                    data: data,
                    image: imageData,
                    arSceneId: arSceneId
                });
                if (imageData && imageArrayBuffer)
                    yield this._sdk.utils.uploadAsset(response.asset.modelState.href, imageArrayBuffer, response.asset.modelState.headers);
                return response.modelState.id;
            }
            catch (e) {
                throw this._httpClient.convertError(e);
            }
        });
    }
    /**
     * Customizes the session with updated parameters to get the updated scene graph node.
     *
     * @param parameters the parameter set to update the session
     * @returns promise with a scene graph node
     */
    customize(force = false, waitForViewportUpdate = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = this._uuidGenerator.create();
            const customizationId = this._uuidGenerator.create();
            try {
                // we check if something changed
                if (force === false) {
                    let changes = false;
                    for (const parameterId in this.parameters)
                        if (this.parameters[parameterId].sessionValue !== this.parameters[parameterId].value)
                            changes = true;
                    if (changes === false)
                        return this.node;
                }
                const eventStart = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 0, data: { sessionId: this.id }, status: 'Customizing session' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);
                const oldNode = this.node;
                __classPrivateFieldSet(this, _SessionEngine_customizationProcess, customizationId, "f");
                this._logger.debugLow(`Session(${this.id}).customize: Customizing session.`);
                this.addBusyMode(customizationId);
                const eventFileUpload = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 0.1, data: { sessionId: this.id }, status: 'Uploading file parameters' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventFileUpload);
                // upload file parameters
                yield this.uploadFileParameters();
                // OPTION TO SKIP - PART 1b
                const cancelResult = this.cancelProcess(customizationId, eventId, viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, 1, { sessionId: this.id });
                if (cancelResult)
                    return cancelResult;
                const parameterSet = {};
                // create a set of the current validated parameter values
                for (const parameterId in this.parameters) {
                    parameterSet[parameterId] = {
                        value: this.parameters[parameterId].value,
                        valueString: this.parameters[parameterId].stringify()
                    };
                }
                // update the session engine parameter values if everything succeeded
                for (const parameterId in this.parameters)
                    this.parameterValues[parameterId] = parameterSet[parameterId].valueString;
                this._logger.info(`Session(${this.id}).customize: Customizing session with parameters ${JSON.stringify(this.parameterValues)}.`);
                const eventRequest = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 0.1, data: { sessionId: this.id }, status: 'Sending customization request' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventRequest);
                const oldOutputVersions = this._outputLoader.getCurrentOutputVersions();
                const newNode = yield this.customizeInternal(() => __classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f") !== customizationId, {
                    eventId,
                    type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                    progressRange: {
                        min: 0.1,
                        max: 0.9
                    },
                    data: { sessionId: this.id }
                });
                // OPTION TO SKIP - PART 2
                const cancelResult2 = this.cancelProcess(customizationId, eventId, viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, 1, { sessionId: this.id });
                if (cancelResult2)
                    return cancelResult2;
                const newOutputVersions = this._outputLoader.getCurrentOutputVersions();
                const eventSceneUpdate = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 0.9, data: { sessionId: this.id }, status: 'Updating scene' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventSceneUpdate);
                // call the update callbacks
                if (waitForViewportUpdate === false) {
                    for (const outputId in this.outputs) {
                        if (oldOutputVersions[outputId] !== newOutputVersions[outputId]) {
                            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.OUTPUT.OUTPUT_UPDATED, {
                                outputId: outputId,
                                outputVersion: newOutputVersions[outputId],
                                newNode: newNode.children.find(c => c.name === outputId),
                                oldNode: oldNode.children.find(c => c.name === outputId)
                            });
                        }
                    }
                    yield this.waitForUpdateCallbacks(newOutputVersions, oldOutputVersions, newNode, oldNode);
                    const cancelResult = this.cancelProcess(customizationId, eventId, viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, 1, { sessionId: this.id });
                    if (cancelResult)
                        return cancelResult;
                }
                // if this is not a call by the goBack or goForward functions, add the parameter values to the history and delete the forward history
                if (!__classPrivateFieldGet(this, _SessionEngine_parameterHistoryCall, "f")) {
                    __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").push(parameterSet);
                    __classPrivateFieldSet(this, _SessionEngine_parameterHistoryForward, [], "f");
                }
                if (this.automaticSceneUpdate)
                    this.removeFromSceneTree(this.node);
                this._node = newNode;
                if (this.automaticSceneUpdate && this._closed === false)
                    this.addToSceneTree(this.node);
                this._logger.debug(`Session(${this.id}).customize: Customization request finished, updating geometry.`);
                // set the session values to the current ones in all parameters
                for (const parameterId in this.parameters)
                    this.parameters[parameterId].sessionValue = parameterSet[parameterId].value;
                // set the output content to what has been updated
                for (const outputId in this.outputs)
                    this.outputs[outputId].updateOutput(newNode.children.find(c => c.name === outputId), oldNode.children.find(c => c.name === outputId));
                // set the export definitions
                for (const exportId in this.exports)
                    this.exports[exportId].updateExport();
                this._warningCreator();
                this.node.excludeViewports = JSON.parse(JSON.stringify(this._excludeViewports));
                this.removeBusyMode(customizationId);
                this._logger.debug(`Session(${this.id}).customize: Session customized.`);
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SESSION.SESSION_CUSTOMIZED, { sessionId: this.id });
                const eventEnd = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 1, data: { sessionId: this.id }, status: 'Session customized' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);
                // update the viewports
                if (waitForViewportUpdate) {
                    for (const r in this._stateEngine.viewportEngines)
                        if (this._stateEngine.viewportEngines[r] && !this.excludeViewports.includes(this._stateEngine.viewportEngines[r].id))
                            this._stateEngine.viewportEngines[r].update(`SessionEngine(${this.id}).customize`);
                    for (const outputId in this.outputs) {
                        if (oldOutputVersions[outputId] !== newOutputVersions[outputId]) {
                            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.OUTPUT.OUTPUT_UPDATED, {
                                outputId: outputId,
                                outputVersion: newOutputVersions[outputId],
                                newNode: newNode.children.find(c => c.name === outputId),
                                oldNode: oldNode.children.find(c => c.name === outputId)
                            });
                        }
                    }
                    // call the update callbacks
                    yield this.waitForUpdateCallbacks(newOutputVersions, oldOutputVersions, newNode, oldNode);
                    const cancelResult = this.cancelProcess(customizationId, eventId, viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, 1, { sessionId: this.id });
                    if (cancelResult)
                        return cancelResult;
                }
                if (!waitForViewportUpdate) {
                    setTimeout(() => {
                        for (const r in this._stateEngine.viewportEngines)
                            if (this._stateEngine.viewportEngines[r] && !this.excludeViewports.includes(this._stateEngine.viewportEngines[r].id))
                                this._stateEngine.viewportEngines[r].update(`SessionEngine(${this.id}).customize`);
                    }, 0);
                }
                return this.node;
            }
            catch (e) {
                const eventCancel = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 1, data: { sessionId: this.id }, status: 'Session customization failed' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel);
                this.removeBusyMode(customizationId);
                throw this._httpClient.convertError(e);
            }
        });
    }
    customizeParallel(parameterValues, loadOutputs = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = this._uuidGenerator.create();
            const eventStart = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 0, data: { sessionId: this.id }, status: 'Customizing session' };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);
            // upload file parameters
            yield this.uploadFileParameters(parameterValues);
            const parameterSet = {};
            // create a set of the current validated parameter values
            for (const parameterId in this.parameters)
                parameterSet[parameterId] = (' ' + this.parameters[parameterId].stringify(parameterValues[parameterId])).slice(1);
            const result = yield this.customizeSession(parameterSet, () => false, {
                eventId,
                type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                progressRange: {
                    min: 0.0,
                    max: 1
                },
                data: { sessionId: this.id }
            }, true, loadOutputs);
            if (result instanceof SessionTreeNode_1.SessionTreeNode)
                result.excludeViewports = JSON.parse(JSON.stringify(this._excludeViewports));
            const eventEnd = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 1, data: { sessionId: this.id }, status: 'Session customized' };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);
            return result;
        });
    }
    customizeWithModelState(modelState) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            try {
                // get the model state if it is not already a response
                let response;
                if (typeof modelState === 'string') {
                    response = yield this._sdk.modelState.get(modelState);
                }
                else {
                    response = modelState;
                }
                if (!response.modelState)
                    return new viewer_shared_node_tree_1.TreeNode();
                // read out the parameter values from the model state
                for (const parameterId in response.modelState.parameters)
                    this.parameters[parameterId].value = response.modelState.parameters[parameterId];
                return this.customize();
            }
            catch (e) {
                throw this._httpClient.convertError(e);
            }
        });
    }
    getFileInfo(parameterId, fileId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            try {
                return yield this._sdk.file.info(this._sessionId, parameterId, fileId);
            }
            catch (e) {
                throw this._httpClient.convertError(e);
            }
        });
    }
    goBack() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.canGoBack()) {
                this._logger.debug(`Session(${this.id}).goBack: Cannot go further back.`);
                return new viewer_shared_node_tree_1.TreeNode();
            }
            // get the current parameter set and store it in the forward history later on
            const currentParameterSet = __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").pop();
            // adjust the parameters according to the last parameter set
            const lastParameterSet = __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f")[__classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").length - 1];
            for (const parameterId in lastParameterSet)
                this.parameters[parameterId].value = lastParameterSet[parameterId].value;
            // call the customization function with the parameterHistoryCall value set to true
            __classPrivateFieldSet(this, _SessionEngine_parameterHistoryCall, true, "f");
            const node = yield this.customize();
            __classPrivateFieldSet(this, _SessionEngine_parameterHistoryCall, false, "f");
            // add the current (not anymore current) parameter set to the forward history
            __classPrivateFieldGet(this, _SessionEngine_parameterHistoryForward, "f").push(currentParameterSet);
            return node;
        });
    }
    goForward() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.canGoForward()) {
                this._logger.debug(`Session(${this.id}).goForward: Cannot go further forward.`);
                return new viewer_shared_node_tree_1.TreeNode();
            }
            // get the last undone parameter set and apply the values to the parameters
            const lastParameterSet = __classPrivateFieldGet(this, _SessionEngine_parameterHistoryForward, "f").pop();
            for (const parameterId in lastParameterSet)
                this.parameters[parameterId].value = lastParameterSet[parameterId].value;
            // call the customization function with the parameterHistoryCall value set to true
            __classPrivateFieldSet(this, _SessionEngine_parameterHistoryCall, true, "f");
            const node = yield this.customize();
            __classPrivateFieldSet(this, _SessionEngine_parameterHistoryCall, false, "f");
            // add the current parameter set to the history
            __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").push(lastParameterSet);
            return node;
        });
    }
    /**
     * Initializes the session with the ticket and modelViewUrl.
     *
     * @returns promise with a scene graph node
     */
    init(parameterValues, retry = false) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._initialized === true)
                throw new viewer_shared_services_1.ShapeDiverViewerSessionError('Session.init: Session already initialized.');
            try {
                this._performanceEvaluator.startSection('sessionResponse');
                const parameterSet = {};
                // the slice here is done as a way for deep copying the string values
                for (const parameterNameOrId in parameterValues)
                    parameterSet[parameterNameOrId] = (' ' + parameterValues[parameterNameOrId]).slice(1);
                if (this._ticket) {
                    this._responseDto = yield this._sdk.session.init(this._ticket, parameterSet, this._modelStateId, this._modelStateValidationMode);
                }
                else if (this._guid) {
                    this._responseDto = yield this._sdk.session.initForModel(this._guid, parameterSet, this._modelStateId, this._modelStateValidationMode);
                }
                else {
                    // we should never get here
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError('Session.init: Initialization of session failed. Neither a ticket nor a guid are available.');
                }
                this._performanceEvaluator.endSection('sessionResponse');
                this._viewerSettings = (_a = this._responseDto.viewer) === null || _a === void 0 ? void 0 : _a.config;
                this._viewerSettingsVersionBackend = this._responseDto.viewerSettingsVersion || viewer_settings_1.latestVersion;
                this._sessionId = this._responseDto.sessionId;
                this._modelId = (_b = this._responseDto.model) === null || _b === void 0 ? void 0 : _b.id;
                this._modelState = this._responseDto.modelState;
                this._httpClient.addDataLoading(this._sessionId, {
                    getAsset: this._sdk.asset.getAsset.bind(this._sdk.asset),
                    downloadTexture: this._sdk.asset.downloadImage.bind(this._sdk.asset),
                });
                this._settingsEngine.loadSettings(this._viewerSettings);
                if (!this._sessionId)
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError('Session.init: Initialization of session failed. ResponseDto did not have a sessionId.');
                if (!this._modelId)
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError('Session.init: Initialization of session failed. ResponseDto did not have a model.id.');
                this.updateResponseDto(this._responseDto, parameterSet);
                this._initialized = true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.init(parameterValues, true);
            }
        });
    }
    loadCachedOutputsParallel(outputMapping, taskEventInfo, retry = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            // if there is already task event info, use it
            // this happens after a retry
            const eventId = taskEventInfo ? taskEventInfo.eventId : this._uuidGenerator.create();
            const eventType = taskEventInfo ? taskEventInfo.type : viewer_shared_types_1.TASK_TYPE.SESSION_OUTPUTS_LOADING;
            const eventData = taskEventInfo ? taskEventInfo.data : { sessionId: this.id };
            taskEventInfo = taskEventInfo ? taskEventInfo : {
                eventId,
                type: eventType,
                progressRange: {
                    min: 0,
                    max: 1
                },
                data: eventData
            };
            try {
                // send start event if this function was called initially
                if (!taskEventInfo) {
                    const eventStart = { type: eventType, id: eventId, progress: 0, data: eventData, status: 'Loading cached outputs' };
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);
                }
                // get the cached outputs
                const responseDto = yield this._sdk.output.getCache(this._sessionId, outputMapping);
                // create atomic output api objects for them
                const outputs = {};
                for (const outputId in responseDto.outputs) {
                    responseDto.outputs[outputId].id = outputId;
                    outputs[outputId] = new Output_1.Output(responseDto.outputs[outputId], this);
                }
                // process the output data
                const node = yield this._outputLoader.loadOutputs(((_a = this._responseDto.model) === null || _a === void 0 ? void 0 : _a.name) || 'model', outputs, {}, taskEventInfo, false);
                // send the end event once done
                const eventEnd = { type: eventType, id: eventId, progress: 1, data: eventData, status: 'Loaded cached outputs' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);
                // create a mapping with a dictionary for the id of the outputs
                const outputNodeMapping = {};
                for (const outputId in outputMapping)
                    outputNodeMapping[outputId] = node.children.find(n => n.name === outputId);
                return outputNodeMapping;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.loadCachedOutputsParallel(outputMapping, taskEventInfo, true);
            }
        });
    }
    /**
     * Load the outputs and return the scene graph node of the result.
     * In case the outputs have a delay property, another customization request with the parameter set is sent.
     *
     * @param parameters the parameter set to update the session
     * @param outputs the outputs to load
     * @returns promise with a scene graph node
     */
    loadOutputs(cancelRequest = () => false, taskEventInfo, retry = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            const o = Object.assign({}, this._outputs);
            const of = Object.assign({}, this._outputsFreeze);
            try {
                const node = yield this._outputLoader.loadOutputs(((_a = this._responseDto.model) === null || _a === void 0 ? void 0 : _a.name) || 'model', o, of, taskEventInfo);
                node.data.push(new SessionData_1.SessionData(this._responseDto));
                if (cancelRequest())
                    return node;
                node.excludeViewports = JSON.parse(JSON.stringify(this._excludeViewports));
                return node;
            }
            catch (e) {
                if (e instanceof OutputDelayException_1.OutputDelayException) {
                    yield this.timeout(e.delay);
                }
                else {
                    yield this.handleError(e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputs(cancelRequest, taskEventInfo, true);
                }
                if (cancelRequest())
                    return new SessionTreeNode_1.SessionTreeNode();
                const outputMapping = {};
                for (const output in o)
                    outputMapping[output] = o[output].version;
                try {
                    const responseDto = yield this._sdk.output.getCache(this._sessionId, outputMapping);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    this.updateResponseDto(responseDto);
                    return yield this.loadOutputs(cancelRequest, taskEventInfo);
                }
                catch (e) {
                    yield this.handleError(e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputs(cancelRequest, taskEventInfo, true);
                }
            }
        });
    }
    /**
     * Load the outputs and return the scene graph node of the result.
     * In case the outputs have a delay property, another customization request with the parameter set is sent.
     *
     * @param parameters the parameter set to update the session
     * @param outputs the outputs to load
     * @returns promise with a scene graph node
     */
    loadOutputsParallel(responseDto, cancelRequest = () => false, taskEventInfo, retry = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            const outputs = {};
            const outputsFreeze = {};
            for (const outputId in responseDto.outputs) {
                responseDto.outputs[outputId].id = outputId;
                if (this.outputsFreeze[outputId] === undefined)
                    outputsFreeze[outputId] = false;
                outputs[outputId] = new Output_1.Output(responseDto.outputs[outputId], this);
            }
            try {
                const node = yield this._outputLoader.loadOutputs(((_a = this._responseDto.model) === null || _a === void 0 ? void 0 : _a.name) || 'model', outputs, outputsFreeze, taskEventInfo);
                node.data.push(new SessionData_1.SessionData(responseDto));
                return node;
            }
            catch (e) {
                if (e instanceof OutputDelayException_1.OutputDelayException) {
                    yield this.timeout(e.delay);
                }
                else {
                    yield this.handleError(e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputsParallel(responseDto, cancelRequest, taskEventInfo, true);
                }
                if (cancelRequest())
                    return new SessionTreeNode_1.SessionTreeNode();
                const outputMapping = {};
                for (const output in outputs)
                    outputMapping[output] = outputs[output].version;
                try {
                    const responseDto = yield this._sdk.output.getCache(this._sessionId, outputMapping);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    this.updateResponseDto(responseDto);
                    return yield this.loadOutputsParallel(responseDto, cancelRequest, taskEventInfo);
                }
                catch (e) {
                    yield this.handleError(e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputsParallel(responseDto, cancelRequest, taskEventInfo, true);
                }
            }
        });
    }
    requestExport(exportId, parameters, maxWaitTime, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('export');
            try {
                yield this.uploadFileParameters(parameters);
                const requestParameterSet = this.cleanExportParameters(parameters);
                const responseDto = yield this._sdk.utils.submitAndWaitForExport(this._sdk, this._sessionId, { exports: { id: exportId }, parameters: requestParameterSet }, maxWaitTime);
                this.updateResponseDto(responseDto);
                return this.exports[exportId];
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.requestExport(exportId, parameters, maxWaitTime, true);
            }
        });
    }
    requestExports(body, loadOutputs = false, maxWaitMsec, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let processId;
            this.checkAvailability('export');
            try {
                // activate the busy mode if outputs are loaded
                if (loadOutputs === true && this._allowOutputLoading === true &&
                    body.outputs && Object.keys(body.outputs).length > 0) {
                    processId = this._uuidGenerator.create();
                    this.addBusyMode(processId);
                }
                yield this.uploadFileParameters(body.parameters);
                const requestParameterSet = this.cleanExportParameters(body.parameters);
                const responseDto = yield this._sdk.utils.submitAndWaitForExport(this._sdk, this._sessionId, { exports: body.exports, parameters: requestParameterSet, outputs: body.outputs, max_wait_time: body.max_wait_time }, maxWaitMsec);
                this.updateResponseDto(responseDto);
                if (loadOutputs === true && this._allowOutputLoading === true)
                    this.updateOutputs();
                if (processId)
                    this.removeBusyMode(processId);
                return responseDto;
            }
            catch (e) {
                if (processId)
                    this.removeBusyMode(processId);
                yield this.handleError(e, retry);
                return yield this.requestExports(body, loadOutputs, maxWaitMsec, true);
            }
        });
    }
    resetSettings(sections) {
        if (!this._responseDto)
            throw new viewer_shared_services_1.ShapeDiverViewerSessionError('Session.resetSettings: responseDto not available.');
        sections = sections || {};
        if (sections.session === undefined) {
            sections.session = {
                parameter: { displayname: true, order: true, hidden: true },
                export: { displayname: true, order: true, hidden: true }
            };
        }
        if (sections.session.parameter === undefined)
            sections.session.parameter = { displayname: true, order: true, hidden: true, value: true };
        if (sections.session.export === undefined)
            sections.session.export = { displayname: true, order: true, hidden: true };
        if (sections.viewport === undefined)
            sections.viewport = { ar: true, scene: true, camera: true, light: true, environment: true, general: true, postprocessing: true };
        return this.applySettings(this._responseDto, sections);
    }
    saveDefaultParameterValues() {
        return __awaiter(this, void 0, void 0, function* () {
            this._logger.debugLow(`Session(${this.id}).saveDefaultParameters: Saving default parameters.`);
            const response = yield this.saveDefaultParameters();
            if (response) {
                this._logger.debug(`Session(${this.id}).saveDefaultParameters: Saved default parameters.`);
            }
            else {
                throw new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session(${this.id}).saveDefaultParameters: Could not save default parameters.`);
            }
            return response;
        });
    }
    saveDefaultParameters(retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('defaultparam', true);
            try {
                yield this._sdk.model.setDefaultParams(this._modelId, this._parameterValues);
                return true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.saveDefaultParameters(true);
            }
        });
    }
    /**
     * Save the export properties for displayname, order, tooltip and hidden
     *
     * @param exports
     * @returns
     */
    saveExportProperties(exports, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('export-definition', true);
            try {
                yield this._sdk.export.updateDefinitions(this._modelId, exports);
                return true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.saveExportProperties(exports, true);
            }
        });
    }
    /**
     * Save the output properties for displayname, order, tooltip and hidden
     *
     * @param outputs
     * @returns
     */
    saveOutputProperties(outputs, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('output-definition', true);
            try {
                yield this._sdk.output.updateDefinitions(this._modelId, outputs);
                return true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.saveOutputProperties(outputs, true);
            }
        });
    }
    /**
     * Save the parameter properties for displayname, order, tooltip and hidden
     *
     * @param parameters
     * @returns
     */
    saveParameterProperties(parameters, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('parameter-definition', true);
            try {
                yield this._sdk.model.updateParameterDefinitions(this._modelId, parameters);
                return true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.saveParameterProperties(parameters, true);
            }
        });
    }
    saveSettings(json, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('configure', true);
            try {
                (0, viewer_settings_1.validate)(json, this._viewerSettingsVersion);
                // if viewer settings version is higher than backend settings version
                // convert to backend settings version
                if (+this._viewerSettingsVersion > +this._viewerSettingsVersionBackend)
                    json = (0, viewer_settings_1.convert)(json, this._viewerSettingsVersionBackend);
            }
            catch (e) {
                throw new viewer_shared_services_1.ShapeDiverViewerSettingsError('Session.saveSettings: Settings could not be validated. ' + e.message, e);
            }
            try {
                yield this._sdk.model.updateConfig(this._modelId, json);
                return true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.saveSettings(json, true);
            }
        });
    }
    saveUiProperties(saveInSettings = true) {
        return __awaiter(this, void 0, void 0, function* () {
            this._logger.debugLow(`Session(${this.id}).saveSessionProperties: Saving session properties.`);
            // settings saving 
            this._saveSessionSettings();
            let properties = {};
            for (const p in this.parameters) {
                properties[p] = {
                    displayname: this.parameters[p].displayname !== undefined ? this.parameters[p].displayname : '',
                    hidden: this.parameters[p].hidden !== undefined ? this.parameters[p].hidden : false,
                    order: this.parameters[p].order !== undefined ? this.parameters[p].order : 0,
                    tooltip: this.parameters[p].tooltip !== undefined ? this.parameters[p].tooltip : '',
                };
            }
            const responseP = Object.values(properties).length !== 0 ? yield this.saveParameterProperties(properties) : true;
            properties = {};
            for (const e in this.exports) {
                properties[e] = {
                    displayname: this.exports[e].displayname !== undefined ? this.exports[e].displayname : '',
                    hidden: this.exports[e].hidden !== undefined ? this.exports[e].hidden : false,
                    order: this.exports[e].order !== undefined ? this.exports[e].order : 0,
                    tooltip: this.exports[e].tooltip !== undefined ? this.exports[e].tooltip : '',
                };
            }
            const responseE = Object.values(properties).length !== 0 ? yield this.saveExportProperties(properties) : true;
            properties = {};
            for (const o in this.outputs) {
                properties[o] = {
                    displayname: this.outputs[o].displayname !== undefined ? this.outputs[o].displayname : '',
                    hidden: this.outputs[o].hidden !== undefined ? this.outputs[o].hidden : false,
                    order: this.outputs[o].order !== undefined ? this.outputs[o].order : 0,
                    tooltip: this.outputs[o].tooltip !== undefined ? this.outputs[o].tooltip : '',
                };
            }
            const responseO = Object.values(properties).length !== 0 ? yield this.saveOutputProperties(properties) : true;
            // save partial settings
            const response = saveInSettings ? yield this.saveSettings(this._settingsEngine.settings) : true;
            if (response && responseP && responseO && responseE) {
                this._logger.debug(`Session(${this.id}).saveSessionProperties: Saved session properties.`);
            }
            else {
                this._logger.warn(`Session(${this.id}).saveSessionProperties: Could not save session properties.`);
            }
            return response && responseP && responseO && responseE;
        });
    }
    setJwtToken(value) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            this._jwtToken = value;
            try {
                this._sdk.setConfigurationValue(sdk_geometry_api_sdk_v2_1.ShapeDiverSdkConfigType.JWT_TOKEN, value);
                const responseDto = yield this._sdk.session.default(this._sessionId);
                if (this._responseDto)
                    this._responseDto.actions = responseDto.actions;
            }
            catch (e) {
                throw this._httpClient.convertError(e);
            }
        });
    }
    updateOutputs(taskEventInfo, waitForViewportUpdate = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = taskEventInfo ? taskEventInfo.eventId : this._uuidGenerator.create();
            const eventType = taskEventInfo ? taskEventInfo.type : viewer_shared_types_1.TASK_TYPE.SESSION_OUTPUTS_UPDATE;
            const eventData = taskEventInfo ? taskEventInfo.data : { sessionId: this.id };
            if (!taskEventInfo) {
                const eventStart = { type: eventType, id: eventId, progress: 0, data: eventData, status: 'Updating outputs' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);
            }
            const customizationId = this._uuidGenerator.create();
            const oldNode = this.node;
            __classPrivateFieldSet(this, _SessionEngine_customizationProcess, customizationId, "f");
            this._logger.debugLow(`Session(${this.id}).updateOutputs: Updating Outputs.`);
            this.addBusyMode(customizationId);
            const eventRequest = { type: eventType, id: eventId, progress: taskEventInfo ? (taskEventInfo.progressRange.max - taskEventInfo.progressRange.min) * 0.1 + taskEventInfo.progressRange.min : 0.1, data: eventData, status: 'Loading outputs' };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventRequest);
            const oldOutputVersions = this._outputLoader.getCurrentOutputVersions();
            const newNode = yield this.loadOutputs(() => __classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f") !== customizationId, {
                eventId,
                type: eventType,
                progressRange: {
                    min: taskEventInfo ? (taskEventInfo.progressRange.max - taskEventInfo.progressRange.min) * 0.1 + taskEventInfo.progressRange.min : 0.1,
                    max: taskEventInfo ? (taskEventInfo.progressRange.max - taskEventInfo.progressRange.min) * 0.9 + taskEventInfo.progressRange.min : 0.9
                },
                data: eventData
            });
            const newOutputVersions = this._outputLoader.getCurrentOutputVersions();
            const eventSceneUpdate = { type: eventType, id: eventId, progress: taskEventInfo ? (taskEventInfo.progressRange.max - taskEventInfo.progressRange.min) * 0.9 + taskEventInfo.progressRange.min : 0.9, data: eventData, status: 'Updating scene' };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventSceneUpdate);
            // OPTION TO SKIP - PART 1
            const cancelResult = this.cancelProcess(customizationId, eventId, eventType, taskEventInfo ? (taskEventInfo.progressRange.max - taskEventInfo.progressRange.min) * 1 + taskEventInfo.progressRange.min : 1, eventData, newNode);
            if (cancelResult)
                return cancelResult;
            // call the update callbacks
            if (waitForViewportUpdate === false) {
                for (const outputId in this.outputs) {
                    if (oldOutputVersions[outputId] !== newOutputVersions[outputId]) {
                        this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.OUTPUT.OUTPUT_UPDATED, {
                            outputId: outputId,
                            outputVersion: newOutputVersions[outputId],
                            newNode: newNode.children.find(c => c.name === outputId),
                            oldNode: oldNode.children.find(c => c.name === outputId)
                        });
                    }
                }
                yield this.waitForUpdateCallbacks(newOutputVersions, oldOutputVersions, newNode, oldNode);
                // OPTION TO SKIP - PART 2
                const cancelResult = this.cancelProcess(customizationId, eventId, eventType, taskEventInfo ? (taskEventInfo.progressRange.max - taskEventInfo.progressRange.min) * 1 + taskEventInfo.progressRange.min : 1, eventData, newNode);
                if (cancelResult)
                    return cancelResult;
            }
            if (this.automaticSceneUpdate)
                this.removeFromSceneTree(this.node);
            this._node = newNode;
            if (this.automaticSceneUpdate && this._closed === false)
                this.addToSceneTree(this.node);
            this._logger.debug(`Session(${this.id}).updateOutputs: Updating outputs finished, updating geometry.`);
            // set the output content to what has been updated
            for (const outputId in this.outputs) {
                this.outputs[outputId].updateOutput(newNode.children.find(c => c.name === outputId), oldNode.children.find(c => c.name === outputId));
            }
            // set the export definitions
            for (const exportId in this.exports)
                this.exports[exportId].updateExport();
            this._warningCreator();
            this.node.excludeViewports = JSON.parse(JSON.stringify(this._excludeViewports));
            this.removeBusyMode(customizationId);
            this._logger.debug(`Session(${this.id}).updateOutputs: Updated outputs.`);
            if (!taskEventInfo) {
                const eventEnd = { type: eventType, id: eventId, progress: 1, data: eventData, status: 'Outputs updated' };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);
            }
            // update the viewports
            if (waitForViewportUpdate) {
                for (const r in this._stateEngine.viewportEngines)
                    if (this._stateEngine.viewportEngines[r] && !this.excludeViewports.includes(this._stateEngine.viewportEngines[r].id))
                        this._stateEngine.viewportEngines[r].update(`SessionEngine(${this.id}).updateOutputs`);
                for (const outputId in this.outputs) {
                    if (oldOutputVersions[outputId] !== newOutputVersions[outputId]) {
                        this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.OUTPUT.OUTPUT_UPDATED, {
                            outputId: outputId,
                            outputVersion: newOutputVersions[outputId],
                            newNode: newNode.children.find(c => c.name === outputId),
                            oldNode: oldNode.children.find(c => c.name === outputId)
                        });
                    }
                }
                yield this.waitForUpdateCallbacks(newOutputVersions, oldOutputVersions, newNode, oldNode);
                // OPTION TO SKIP - PART 3
                const cancelResult = this.cancelProcess(customizationId, eventId, eventType, taskEventInfo ? (taskEventInfo.progressRange.max - taskEventInfo.progressRange.min) * 1 + taskEventInfo.progressRange.min : 1, eventData, newNode);
                if (cancelResult)
                    return cancelResult;
            }
            return this.node;
        });
    }
    uploadFile(parameterId, data, type, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('file-upload');
            try {
                const result = yield this._sdk.file.requestUpload(this._sessionId, {
                    [parameterId]: {
                        size: data.size,
                        format: type,
                        filename: data.name === '' ? undefined : data.name
                    }
                });
                if (result && result.asset && result.asset.file && result.asset.file[parameterId]) {
                    const fileAsset = result.asset.file[parameterId];
                    yield this._sdk.utils.uploadAsset(fileAsset.href, yield data.arrayBuffer(), fileAsset.headers);
                    return fileAsset.id;
                }
                else {
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError('Session.uploadFile: Upload reply has not the required format.');
                }
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.uploadFile(parameterId, data, type, true);
            }
        });
    }
    /**
     * Uploads all file parameters and returns the file parameter values.
     * If parameterValues is provided, the file parameter values are added to it.
     *
     * @param parameterValues
     * @returns
     */
    uploadFileParameters(parameterValues) {
        return __awaiter(this, void 0, void 0, function* () {
            const parameterValueSet = parameterValues !== undefined ? this.getFileParameterSet(parameterValues) : undefined;
            const fileParameterValues = {};
            // load file parameter first
            for (const parameterId in this.parameters) {
                if (this.parameters[parameterId] instanceof FileParameter_1.FileParameter) {
                    fileParameterValues[parameterId] = yield this.parameters[parameterId].upload(parameterValueSet ? parameterValueSet[parameterId] : undefined);
                    if (parameterValues) {
                        parameterValues[parameterId] = fileParameterValues[parameterId];
                        // if the parameter value of the file parameter was used, set the value to the parameter
                        if (parameterValues[parameterId] === undefined && this.parameters[parameterId].value !== fileParameterValues[parameterId])
                            this.parameters[parameterId].value = fileParameterValues[parameterId];
                    }
                    else if (this.parameters[parameterId].value !== fileParameterValues[parameterId]) {
                        this.parameters[parameterId].value = fileParameterValues[parameterId];
                    }
                }
            }
            return fileParameterValues;
        });
    }
    uploadGLTF(blob, conversion = sdk_geometry_api_sdk_v2_1.ShapeDiverRequestGltfUploadQueryConversion.NONE, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('gltf-upload');
            try {
                const responseDto = yield this._sdk.gltf.upload(this._sessionId, yield blob.arrayBuffer(), 'model/gltf-binary', conversion);
                if (!responseDto || !responseDto.gltf || !responseDto.gltf.href)
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError('Session.uploadGLTF: Upload reply has not the required format.');
                return responseDto;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.uploadGLTF(blob, conversion, true);
            }
        });
    }
    // #endregion Public Methods (31)
    // #region Private Methods (18)
    _saveSessionSettings() {
        const parameters = this.parameters;
        const exports = this.exports;
        const sessionProperties = {};
        for (const p in parameters) {
            sessionProperties[p] = {
                order: parameters[p].order || 0,
                displayname: parameters[p].displayname || '',
                hidden: parameters[p].hidden
            };
        }
        for (const e in exports) {
            sessionProperties[e] = {
                order: exports[e].order || 0,
                displayname: exports[e].displayname || '',
                hidden: exports[e].hidden
            };
        }
        this._settingsEngine.session = sessionProperties;
    }
    _warningCreator() {
        // set the output content to what has been updated
        for (const outputId in this.outputs) {
            let warning = '';
            if (this.outputs[outputId].msg)
                warning += `\n\t- ${this.outputs[outputId].msg}`;
            if (this.outputs[outputId].status_collect && this.outputs[outputId].status_collect !== sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)
                warning += `\n\t- status_collect is ${this.outputs[outputId].status_collect}`;
            if (this.outputs[outputId].status_computation && this.outputs[outputId].status_computation !== sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)
                warning += `\n\t- status_computation is ${this.outputs[outputId].status_computation}`;
            if (warning)
                this._logger.warn(`\nOutput(${outputId}):${warning}`);
        }
        // set the export definitions
        for (const exportId in this.exports) {
            let warning = '';
            if (this.exports[exportId].msg)
                warning += `\n\t- ${this.exports[exportId].msg}`;
            if (this.exports[exportId].status_collect && this.exports[exportId].status_collect !== sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)
                warning += `\n\t- status_collect is ${this.exports[exportId].status_collect}`;
            if (this.exports[exportId].status_computation && this.exports[exportId].status_computation !== sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)
                warning += `\n\t- status_computation is ${this.exports[exportId].status_computation}`;
            if (warning)
                this._logger.warn(`\nExport(${exportId}):${warning}`);
        }
    }
    addBusyMode(busyId) {
        for (const r in this._stateEngine.viewportEngines) {
            if (this._stateEngine.viewportEngines[r] && !this.excludeViewports.includes(r)) {
                this._stateEngine.viewportEngines[r].busy.push(busyId);
                __classPrivateFieldGet(this, _SessionEngine_customizationBusyModes, "f").push(busyId);
            }
        }
    }
    addToSceneTree(node) {
        this._sceneTree.addNode(node);
        this._sceneTree.root.updateVersion();
    }
    cancelProcess(customizationId, eventId, eventType, eventProgress, eventData, newNode = new SessionTreeNode_1.SessionTreeNode()) {
        if (__classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f") !== customizationId) {
            this.removeBusyMode(customizationId);
            const eventCancel = {
                type: eventType,
                id: eventId,
                progress: eventProgress,
                data: eventData,
                status: 'The request was exceeded by another customization request'
            };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel);
            this._logger.debug(`Session(${this.id}).cancelProcess: The request was was exceeded by another request.`);
            return newNode;
        }
        else if (this._closed === true) {
            this.removeBusyMode(customizationId);
            this._logger.debug(`Session(${this.id}).cancelProcess: The session was closed during the request.`);
            const eventCancel = { type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, id: eventId, progress: 1, data: { sessionId: this.id }, status: 'The session was closed during the request.' };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel);
            return new SessionTreeNode_1.SessionTreeNode();
        }
    }
    checkAvailability(action, checkForModelId = false) {
        var _a;
        if (!this._responseDto)
            throw new viewer_shared_services_1.ShapeDiverViewerSessionError('Session.checkAvailability: responseDto not available.');
        if (!this._sessionId)
            throw new viewer_shared_services_1.ShapeDiverViewerSessionError('Session.checkAvailability: sessionId not available.');
        if (checkForModelId && !this._modelId)
            throw new viewer_shared_services_1.ShapeDiverViewerSessionError('Session.checkAvailability: modelId not available.');
        if (action && !this._responseDto.actions)
            throw new viewer_shared_services_1.ShapeDiverViewerSessionError('Session.checkAvailability: actions not available.');
        const responseDtoAction = (_a = this._responseDto.actions) === null || _a === void 0 ? void 0 : _a.find(a => a.name === action);
        if (action && !responseDtoAction)
            throw new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.checkAvailability: action ${action} not available.`);
    }
    cleanExportParameters(parameters) {
        const requestParameterSet = {};
        // first step, we convert all our names and displaynames to ids
        for (const parameterIdOrName in parameters) {
            // we prioritize id, then name and then displayname
            // if there are two parameters with the same name or displayname, we take the one that is found first (no way for us to evaluate which one the user meant)
            const parameterObject = Object.values(this._parameters).find(p => p.id === parameterIdOrName || p.name === parameterIdOrName || p.displayname === parameterIdOrName);
            // in case the key of the key value pair was neither the id, name or displayname, skip
            if (!parameterObject)
                continue;
            // copy into new dictionary
            requestParameterSet[parameterObject.id] = (' ' + parameterObject.stringify(parameters[parameterIdOrName])).slice(1);
        }
        // seconds step, fill all other parameter values that are currently not set
        const currentParameters = this.parameterValues;
        for (const parameterId in currentParameters) {
            // if already set by input values, skip
            if (requestParameterSet[parameterId] !== undefined)
                continue;
            // deep copy into new dictionary
            requestParameterSet[parameterId] = (' ' + currentParameters[parameterId]).slice(1);
        }
        return requestParameterSet;
    }
    /**
     * Create an interaction parameter based on the parameter definition.
     *
     * @param parameter
     * @returns
     */
    createInteractionParameter(parameter) {
        const result = (0, viewer_shared_types_1.validateInteractionParameterSettings)(parameter.settings);
        if (result.success) {
            switch (parameter.settings.type) {
                case 'selection':
                    return new SelectionParameter_1.SelectionParameter(parameter, this);
                case 'gumball':
                    return new GumballParameter_1.GumballParameter(parameter, this);
            }
        }
        else {
            this._logger.warn(`SessionEngine.createInteractionParameter: The value ${parameter.settings} is not a valid InteractionParameter: ${result.error.message}`);
        }
        return new Parameter_1.Parameter(parameter, this);
    }
    customizeInternal(cancelRequest, taskEventInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.customizeSession(this._parameterValues, cancelRequest, taskEventInfo);
        });
    }
    customizeSession(parameters, cancelRequest, taskEventInfo, parallel = false, loadOutputs = true, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('customize');
            try {
                this._performanceEvaluator.startSection('sessionResponse');
                const responseDto = yield this._sdk.utils.submitAndWaitForCustomization(this._sdk, this._sessionId, parameters);
                this._performanceEvaluator.endSection('sessionResponse');
                if (loadOutputs === true && this._allowOutputLoading === true) {
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    if (parallel === true) {
                        // special case, we load the outputs put don't add them to the scene
                        return this.loadOutputsParallel(responseDto, cancelRequest, taskEventInfo);
                    }
                    else {
                        // default case, we load the outputs and return the nodes
                        this.updateResponseDto(responseDto);
                        return this.loadOutputs(cancelRequest, taskEventInfo);
                    }
                }
                else {
                    // special case, we don't load the outputs and only return the responseDto
                    const node = new SessionTreeNode_1.SessionTreeNode();
                    node.data.push(new SessionData_1.SessionData(responseDto));
                    return node;
                }
            }
            catch (e) {
                yield this.handleError(e, retry);
                if (cancelRequest())
                    return new SessionTreeNode_1.SessionTreeNode();
                return yield this.customizeSession(parameters, cancelRequest, taskEventInfo, parallel, loadOutputs, true);
            }
        });
    }
    /**
     * Get all file parameters from the parameter set.
     * If the parameter is not set in the parameter set, the value from the parameter object is used.
     *
     * @param parameters
     * @returns
     */
    getFileParameterSet(parameters) {
        const fileParameterSet = {};
        for (const parameterId in this.parameters) {
            if (this.parameters[parameterId] instanceof FileParameter_1.FileParameter) {
                fileParameterSet[parameterId] = parameters[parameterId] !== undefined ? parameters[parameterId] : this.parameters[parameterId].value;
            }
        }
        return fileParameterSet;
    }
    handleError(e, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((0, sdk_geometry_api_sdk_v2_1.isGBResponseError)(e)) {
                if (e.error === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseErrorType.SESSION_GONE_ERROR) {
                    // case 1: the session is no longer available
                    // we try to re-initialize the session 3 times, if that does not work, we close it
                    this._logger.warn('The session has been closed, trying to re-initialize.');
                    if (this._sessionId)
                        this._httpClient.removeDataLoading(this._sessionId);
                    if (this._retryCounter < 3) {
                        // we retry this 3 times, the `retry` option in the init function is set to true and passed on 
                        this._retryCounter = retry ? this._retryCounter + 1 : 1;
                        this._initialized = false;
                        yield this.init(this.parameterValues, true);
                    }
                    else {
                        // the retries were exceeded, we close the session
                        this._logger.warn('Tried to retry the connect multiple times, bearer token still not valid. Closing Session.');
                        // eslint-disable-next-line no-empty
                        try {
                            yield this._closeOnFailure();
                        }
                        catch (e) { }
                        throw this._httpClient.convertError(e);
                    }
                }
                else if (e.error === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseErrorType.JWT_VALIDATION_ERROR) {
                    // if any of the above errors occur, we try to get a new bearer token
                    // if we get a new one, we retry 3 times (by requiring new bearer tokens every time)
                    if (this._retryCounter < 3) {
                        if (this._refreshJwtToken) {
                            yield this.setJwtToken(yield this._refreshJwtToken());
                            this._retryCounter = retry ? this._retryCounter + 1 : 1;
                            this._logger.warn('Re-trying with new bearer token.');
                        }
                        else {
                            // no bearer tokens are supplied, we close the session
                            this._logger.warn('No retry possible, no new bearer token was supplied. Closing Session.');
                            // eslint-disable-next-line no-empty
                            try {
                                yield this._closeOnFailure();
                            }
                            catch (e) { }
                            throw this._httpClient.convertError(e);
                        }
                    }
                    else {
                        // the retries were exceeded, we close the session
                        this._logger.warn('Tried to retry the connect multiple times, bearer token still not valid. Closing Session.');
                        // eslint-disable-next-line no-empty
                        try {
                            yield this._closeOnFailure();
                        }
                        catch (e) { }
                        throw this._httpClient.convertError(e);
                    }
                }
                else {
                    throw this._httpClient.convertError(e);
                }
            }
            else {
                throw this._httpClient.convertError(e);
            }
        });
    }
    /**
     * Process the image input and return the image data and array buffer.
     *
     * In the case of the image being a Blob or File, the image data is constructed from the Blob or File.
     * In the case of the image being a string, we check if it is a data URL or a URL.
     * If it is a data URL, we convert it to a Blob and construct the image data from the Blob.
     * If it is a URL, we download the image and return the image data and array buffer.
     *
     * @param image
     * @returns
     */
    processImageInput(image) {
        return __awaiter(this, void 0, void 0, function* () {
            if (image instanceof File || image instanceof Blob)
                return this._converter.constructImageData(image);
            let imageString;
            if (typeof image === 'function') {
                imageString = image();
            }
            else {
                imageString = image;
            }
            if (imageString.startsWith('data:')) {
                // case where the image is a data URL
                const { blob, arrayBuffer } = this._converter.dataURLtoBlob(imageString);
                return {
                    imageData: {
                        format: blob.type,
                        size: blob.size
                    },
                    arrayBuffer
                };
            }
            else {
                // case where the image is a URL
                const [arrayBuffer, type] = yield this._sdk.asset.downloadImage(this._sessionId, imageString);
                return {
                    imageData: {
                        format: type,
                        size: arrayBuffer.byteLength
                    },
                    arrayBuffer
                };
            }
        });
    }
    removeBusyMode(busyId) {
        for (const r in this._stateEngine.viewportEngines) {
            if (this._stateEngine.viewportEngines[r] && this._stateEngine.viewportEngines[r].busy.includes(busyId))
                this._stateEngine.viewportEngines[r].busy.splice(this._stateEngine.viewportEngines[r].busy.indexOf(busyId), 1);
            if (__classPrivateFieldGet(this, _SessionEngine_customizationBusyModes, "f").includes(busyId))
                __classPrivateFieldGet(this, _SessionEngine_customizationBusyModes, "f").splice(__classPrivateFieldGet(this, _SessionEngine_customizationBusyModes, "f").indexOf(busyId), 1);
        }
    }
    removeFromSceneTree(node) {
        this._sceneTree.removeNode(node);
        this._sceneTree.root.updateVersion();
    }
    /**
     * Returns a promise that resolves after the amount of milliseconds provided.
     *
     * @param ms the milliseconds
     * @returns promise that resolve after specified milliseconds
     */
    timeout(ms) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => setTimeout(resolve, ms));
        });
    }
    updateResponseDto(responseDto, initialParameters) {
        var _a, _b, _c, _d;
        if (!this._responseDto) {
            this._responseDto = responseDto;
            return;
        }
        // convert parameters
        if (responseDto.parameters) {
            for (const parameterId in responseDto.parameters) {
                this._responseDto.parameters = this._responseDto.parameters || {};
                this._responseDto.parameters[parameterId] = this._responseDto.parameters[parameterId] || responseDto.parameters[parameterId];
            }
        }
        // convert outputs
        if (responseDto.outputs) {
            for (const outputId in responseDto.outputs) {
                this._responseDto.outputs = this._responseDto.outputs || {};
                if ('version' in responseDto.outputs[outputId] || !(this._responseDto.outputs[outputId] && 'version' in this._responseDto.outputs[outputId]))
                    this._responseDto.outputs[outputId] = responseDto.outputs[outputId];
            }
        }
        // convert exports
        if (responseDto.exports) {
            for (const exportId in responseDto.exports) {
                this._responseDto.exports = this._responseDto.exports || {};
                if ('version' in responseDto.exports[exportId] || !(this._responseDto.exports[exportId] && 'version' in this._responseDto.exports[exportId]))
                    this._responseDto.exports[exportId] = responseDto.exports[exportId];
            }
        }
        const parameterSet = {};
        for (const parameterId in this._responseDto.parameters) {
            if (this.parameters[parameterId])
                continue;
            this._responseDto.parameters[parameterId].id = parameterId;
            /**
             *
             * REMOVE THIS LOGIC - START
             *
             */
            const fakeSelectionParameterName = 'FAKE_SELECTION_PARAMETER';
            const nameStartsWithFakeSelectionParameter = this._responseDto.parameters[parameterId].name.startsWith(fakeSelectionParameterName);
            const displaynameStartsWithFakeSelectionParameter = (_a = this._responseDto.parameters[parameterId].displayname) === null || _a === void 0 ? void 0 : _a.startsWith(fakeSelectionParameterName);
            if (nameStartsWithFakeSelectionParameter || displaynameStartsWithFakeSelectionParameter) {
                this._responseDto.parameters[parameterId].type = viewer_shared_types_1.PARAMETER_TYPE.INTERACTION;
                const name = nameStartsWithFakeSelectionParameter ? this._responseDto.parameters[parameterId].name : this._responseDto.parameters[parameterId].displayname;
                const urlParams = new URLSearchParams(name.replace(fakeSelectionParameterName + '?', ''));
                const jsonString = urlParams.get('settings');
                if (jsonString)
                    this._responseDto.parameters[parameterId].settings = JSON.parse(jsonString + '');
            }
            const fakeGumballParameterName = 'FAKE_GUMBALL_PARAMETER';
            const nameStartsWithFakeGumballParameter = this._responseDto.parameters[parameterId].name.startsWith(fakeGumballParameterName);
            const displaynameStartsWithFakeGumballParameter = (_b = this._responseDto.parameters[parameterId].displayname) === null || _b === void 0 ? void 0 : _b.startsWith(fakeGumballParameterName);
            if (nameStartsWithFakeGumballParameter || displaynameStartsWithFakeGumballParameter) {
                this._responseDto.parameters[parameterId].type = viewer_shared_types_1.PARAMETER_TYPE.INTERACTION;
                const name = nameStartsWithFakeGumballParameter ? this._responseDto.parameters[parameterId].name : this._responseDto.parameters[parameterId].displayname;
                const urlParams = new URLSearchParams(name.replace(fakeGumballParameterName + '?', ''));
                const jsonString = urlParams.get('settings');
                if (jsonString)
                    this._responseDto.parameters[parameterId].settings = JSON.parse(jsonString + '');
            }
            const fakeDrawingParameterName = 'FAKE_DRAWING_PARAMETER';
            const nameStartsWithFakeDrawingParameter = this._responseDto.parameters[parameterId].name.startsWith(fakeDrawingParameterName);
            const displaynameStartsWithFakeDrawingParameter = (_c = this._responseDto.parameters[parameterId].displayname) === null || _c === void 0 ? void 0 : _c.startsWith(fakeDrawingParameterName);
            if (nameStartsWithFakeDrawingParameter || displaynameStartsWithFakeDrawingParameter) {
                this._responseDto.parameters[parameterId].type = viewer_shared_types_1.PARAMETER_TYPE.DRAWING;
                const name = nameStartsWithFakeDrawingParameter ? this._responseDto.parameters[parameterId].name : this._responseDto.parameters[parameterId].displayname;
                const urlParams = new URLSearchParams(name.replace(fakeDrawingParameterName + '?', ''));
                const jsonString = urlParams.get('settings');
                if (jsonString)
                    this._responseDto.parameters[parameterId].settings = JSON.parse(jsonString + '');
            }
            const fakeDrawingFixParameterName = 'FAKE_DRAWING_FIX';
            const nameStartsWithFakeDrawingFixParameter = this._responseDto.parameters[parameterId].name.startsWith(fakeDrawingFixParameterName);
            const displaynameStartsWithFakeDrawingFixParameter = (_d = this._responseDto.parameters[parameterId].displayname) === null || _d === void 0 ? void 0 : _d.startsWith(fakeDrawingFixParameterName);
            if (nameStartsWithFakeDrawingFixParameter || displaynameStartsWithFakeDrawingFixParameter) {
                this._responseDto.parameters[parameterId].type = viewer_shared_types_1.PARAMETER_TYPE.DRAWING;
            }
            /**
             *
             * REMOVE THIS LOGIC - END
             *
             */
            switch (true) {
                case this._responseDto.parameters[parameterId].type === viewer_shared_types_1.PARAMETER_TYPE.BOOL:
                    this.parameters[parameterId] = new Parameter_1.Parameter(this._responseDto.parameters[parameterId], this);
                    break;
                case this._responseDto.parameters[parameterId].type === viewer_shared_types_1.PARAMETER_TYPE.COLOR:
                    this.parameters[parameterId] = new Parameter_1.Parameter(this._responseDto.parameters[parameterId], this);
                    break;
                case this._responseDto.parameters[parameterId].type === viewer_shared_types_1.PARAMETER_TYPE.FILE:
                    this.parameters[parameterId] = new FileParameter_1.FileParameter(this._responseDto.parameters[parameterId], this);
                    break;
                case this._responseDto.parameters[parameterId].type === viewer_shared_types_1.PARAMETER_TYPE.EVEN || this._responseDto.parameters[parameterId].type === viewer_shared_types_1.PARAMETER_TYPE.FLOAT || this._responseDto.parameters[parameterId].type === viewer_shared_types_1.PARAMETER_TYPE.INT || this._responseDto.parameters[parameterId].type === viewer_shared_types_1.PARAMETER_TYPE.ODD:
                    this.parameters[parameterId] = new Parameter_1.Parameter(this._responseDto.parameters[parameterId], this);
                    break;
                case this._responseDto.parameters[parameterId].type === viewer_shared_types_1.PARAMETER_TYPE.INTERACTION:
                    this.parameters[parameterId] = this.createInteractionParameter(this._responseDto.parameters[parameterId]);
                    break;
                case this._responseDto.parameters[parameterId].type === viewer_shared_types_1.PARAMETER_TYPE.DRAWING:
                    this.parameters[parameterId] = new DrawingParameter_1.DrawingParameter(this._responseDto.parameters[parameterId], this);
                    break;
                default:
                    this.parameters[parameterId] = new Parameter_1.Parameter(this._responseDto.parameters[parameterId], this);
                    break;
            }
            // we don't have to do larger restrictions for this as the backend would have already thrown an error if the values were not correct
            if (initialParameters) {
                // check if the id is within the initial parameters
                if (initialParameters[parameterId] !== undefined) {
                    this.parameters[parameterId].value = initialParameters[parameterId];
                }
                // check if the name is within the initial parameters
                else if (initialParameters[this.parameters[parameterId].name] !== undefined) {
                    this.parameters[parameterId].value = initialParameters[this.parameters[parameterId].name];
                }
                // NOTE: At some point the checking may also be done with the displayname, this is the code for it
                // // check if the displayname is within the initial parameters
                // else if(this.parameters[parameterId].displayname && initialParameters[this.parameters[parameterId].displayname!] !== undefined) {
                //     this.parameters[parameterId].value = initialParameters[this.parameters[parameterId].displayname!];
                // }
            }
            parameterSet[parameterId] = {
                value: this.parameters[parameterId].value,
                valueString: this.parameters[parameterId].stringify()
            };
            if (!this.initialized)
                this.parameterValues[parameterId] = parameterSet[parameterId].valueString;
        }
        // store the initialization as the first parameter set in the history
        if (!this.initialized)
            __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").push(parameterSet);
        for (const exportId in this._responseDto.exports) {
            if (this._responseDto.exports[exportId].type === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseExportDefinitionType.EMAIL || this._responseDto.exports[exportId].type === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseExportDefinitionType.DOWNLOAD) {
                if (!this.exports[exportId]) {
                    this._responseDto.exports[exportId].id = exportId;
                    this.exports[exportId] = new Export_1.Export(this._responseDto.exports[exportId], this);
                }
                else {
                    this.exports[exportId].updateExportDefinition(this._responseDto.exports[exportId]);
                }
            }
        }
        for (const outputId in this._responseDto.outputs) {
            if (!this.outputs[outputId]) {
                this._responseDto.outputs[outputId].id = outputId;
                if (this.outputsFreeze[outputId] === undefined)
                    this.outputsFreeze[outputId] = false;
                this.outputs[outputId] = new Output_1.Output(this._responseDto.outputs[outputId], this);
            }
            else {
                this.outputs[outputId].updateOutputDefinition(this._responseDto.outputs[outputId]);
            }
        }
    }
    waitForUpdateCallbacks(newOutputVersions, oldOutputVersions, newNode, oldNode) {
        return __awaiter(this, void 0, void 0, function* () {
            // call the update callback function on the session
            if (this._updateCallback)
                yield Promise.resolve(this._updateCallback(newNode, oldNode));
            const promises = [];
            // call the update callback functions on the outputs
            for (const outputId in this.outputs) {
                if (oldOutputVersions[outputId] !== newOutputVersions[outputId]) {
                    promises.push(this.outputs[outputId].triggerUpdateCallback(newNode.children.find(c => c.name === outputId), oldNode.children.find(c => c.name === outputId)));
                }
            }
            yield Promise.all(promises);
        });
    }
}
exports.SessionEngine = SessionEngine;
_SessionEngine_customizationBusyModes = new WeakMap(), _SessionEngine_customizationProcess = new WeakMap(), _SessionEngine_parameterHistory = new WeakMap(), _SessionEngine_parameterHistoryCall = new WeakMap(), _SessionEngine_parameterHistoryForward = new WeakMap();
//# sourceMappingURL=SessionEngine.js.map

/***/ }),

/***/ 77124:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SessionOutputData_responseOutput;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionOutputData = void 0;
const viewer_shared_node_tree_1 = __webpack_require__(41652);
class SessionOutputData extends viewer_shared_node_tree_1.AbstractTreeNodeData {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(responseOutput, id, version) {
        super(id, version);
        // #region Properties (1)
        _SessionOutputData_responseOutput.set(this, void 0);
        __classPrivateFieldSet(this, _SessionOutputData_responseOutput, responseOutput, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (2)
    get responseOutput() {
        return __classPrivateFieldGet(this, _SessionOutputData_responseOutput, "f");
    }
    set responseOutput(value) {
        __classPrivateFieldSet(this, _SessionOutputData_responseOutput, value, "f");
    }
    // #endregion Public Getters And Setters (2)
    // #region Public Methods (1)
    clone() {
        return new SessionOutputData(this.responseOutput, this.id, this.version);
    }
}
exports.SessionOutputData = SessionOutputData;
_SessionOutputData_responseOutput = new WeakMap();
//# sourceMappingURL=SessionOutputData.js.map

/***/ }),

/***/ 26401:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SessionTreeNode_sessionNode;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionTreeNode = void 0;
const viewer_shared_node_tree_1 = __webpack_require__(41652);
class SessionTreeNode extends viewer_shared_node_tree_1.TreeNode {
    // #endregion Properties (1)
    // #region Constructors (1)
    /**
     * Special scene graph node for session data. Only to be created internally.
     *
     * @param name the name of the node
     * @param parent the parent of this node
     * @param data the array of data
     * @param transformation the array of transformations
     */
    constructor(name, parent, data, transformations) {
        super(name, parent, data, transformations);
        // #region Properties (1)
        _SessionTreeNode_sessionNode.set(this, true);
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (1)
    get sessionNode() {
        return __classPrivateFieldGet(this, _SessionTreeNode_sessionNode, "f");
    }
}
exports.SessionTreeNode = SessionTreeNode;
_SessionTreeNode_sessionNode = new WeakMap();
//# sourceMappingURL=SessionTreeNode.js.map

/***/ }),

/***/ 35330:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _DrawingParameter_sessionEngine;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DrawingParameter = void 0;
const Parameter_1 = __webpack_require__(14036);
const viewer_shared_types_1 = __webpack_require__(64766);
class DrawingParameter extends Parameter_1.Parameter {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(paramDef, sessionEngine) {
        super(paramDef, sessionEngine);
        // #region Properties (1)
        _DrawingParameter_sessionEngine.set(this, void 0);
        __classPrivateFieldSet(this, _DrawingParameter_sessionEngine, sessionEngine, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (2)
    get geometry() {
        var _a;
        return (_a = this.getDrawingProperties()) === null || _a === void 0 ? void 0 : _a.geometry;
    }
    get restrictions() {
        var _a;
        return (_a = this.getDrawingProperties()) === null || _a === void 0 ? void 0 : _a.restrictions;
    }
    // #endregion Public Getters And Setters (2)
    // #region Private Methods (1)
    getDrawingProperties() {
        const result = (0, viewer_shared_types_1.validateDrawingParameterSettings)(this.settings);
        if (result.success) {
            return this.settings;
        }
    }
}
exports.DrawingParameter = DrawingParameter;
_DrawingParameter_sessionEngine = new WeakMap();
//# sourceMappingURL=DrawingParameter.js.map

/***/ }),

/***/ 40457:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Export_eventEngine, _Export_id, _Export_inputValidator, _Export_logger, _Export_name, _Export_sessionEngine, _Export_type, _Export_uuidGenerator, _Export_content, _Export_delay, _Export_dependency, _Export_displayname, _Export_filename, _Export_group, _Export_hidden, _Export_maxWaitTime, _Export_msg, _Export_order, _Export_result, _Export_status_collect, _Export_status_computation, _Export_tooltip, _Export_uid, _Export_version;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Export = void 0;
const viewer_shared_services_1 = __webpack_require__(8389);
const viewer_shared_types_1 = __webpack_require__(64766);
class Export {
    // #endregion Properties (24)
    // #region Constructors (1)
    constructor(exportDef, sessionEngine) {
        // #region Properties (24)
        _Export_eventEngine.set(this, viewer_shared_services_1.EventEngine.instance);
        _Export_id.set(this, void 0);
        _Export_inputValidator.set(this, viewer_shared_services_1.InputValidator.instance);
        _Export_logger.set(this, viewer_shared_services_1.Logger.instance);
        _Export_name.set(this, void 0);
        _Export_sessionEngine.set(this, void 0);
        _Export_type.set(this, void 0);
        _Export_uuidGenerator.set(this, viewer_shared_services_1.UuidGenerator.instance);
        _Export_content.set(this, void 0);
        _Export_delay.set(this, void 0);
        _Export_dependency.set(this, void 0);
        _Export_displayname.set(this, void 0);
        _Export_filename.set(this, void 0);
        _Export_group.set(this, void 0);
        _Export_hidden.set(this, false);
        _Export_maxWaitTime.set(this, 300000);
        _Export_msg.set(this, void 0);
        _Export_order.set(this, void 0);
        _Export_result.set(this, void 0);
        _Export_status_collect.set(this, void 0);
        _Export_status_computation.set(this, void 0);
        _Export_tooltip.set(this, void 0);
        _Export_uid.set(this, void 0);
        _Export_version.set(this, void 0);
        __classPrivateFieldSet(this, _Export_sessionEngine, sessionEngine, "f");
        __classPrivateFieldSet(this, _Export_id, exportDef.id, "f");
        __classPrivateFieldSet(this, _Export_name, exportDef.name, "f");
        __classPrivateFieldSet(this, _Export_type, exportDef.type, "f");
        this.updateExportDefinition(exportDef);
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (24)
    get content() {
        return __classPrivateFieldGet(this, _Export_content, "f");
    }
    get delay() {
        return __classPrivateFieldGet(this, _Export_delay, "f");
    }
    get dependency() {
        return __classPrivateFieldGet(this, _Export_dependency, "f");
    }
    get displayname() {
        return __classPrivateFieldGet(this, _Export_displayname, "f");
    }
    set displayname(value) {
        __classPrivateFieldSet(this, _Export_displayname, value, "f");
    }
    get filename() {
        return __classPrivateFieldGet(this, _Export_filename, "f");
    }
    get group() {
        return __classPrivateFieldGet(this, _Export_group, "f");
    }
    get hidden() {
        return __classPrivateFieldGet(this, _Export_hidden, "f");
    }
    set hidden(value) {
        __classPrivateFieldSet(this, _Export_hidden, value, "f");
    }
    get id() {
        return __classPrivateFieldGet(this, _Export_id, "f");
    }
    get maxWaitTime() {
        return __classPrivateFieldGet(this, _Export_maxWaitTime, "f");
    }
    set maxWaitTime(value) {
        __classPrivateFieldSet(this, _Export_maxWaitTime, value, "f");
    }
    get msg() {
        return __classPrivateFieldGet(this, _Export_msg, "f");
    }
    get name() {
        return __classPrivateFieldGet(this, _Export_name, "f");
    }
    get order() {
        return __classPrivateFieldGet(this, _Export_order, "f");
    }
    set order(value) {
        __classPrivateFieldSet(this, _Export_order, value, "f");
    }
    get result() {
        return __classPrivateFieldGet(this, _Export_result, "f");
    }
    get status_collect() {
        return __classPrivateFieldGet(this, _Export_status_collect, "f");
    }
    get status_computation() {
        return __classPrivateFieldGet(this, _Export_status_computation, "f");
    }
    get tooltip() {
        return __classPrivateFieldGet(this, _Export_tooltip, "f");
    }
    set tooltip(value) {
        __classPrivateFieldSet(this, _Export_tooltip, value, "f");
    }
    get type() {
        return __classPrivateFieldGet(this, _Export_type, "f");
    }
    get uid() {
        return __classPrivateFieldGet(this, _Export_uid, "f");
    }
    get version() {
        return __classPrivateFieldGet(this, _Export_version, "f");
    }
    // #endregion Public Getters And Setters (24)
    // #region Public Methods (3)
    request(parameterValues = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = __classPrivateFieldGet(this, _Export_uuidGenerator, "f").create();
            try {
                const event = { type: viewer_shared_types_1.TASK_TYPE.EXPORT_REQUEST, id: eventId, progress: 0, status: 'Requesting export' };
                __classPrivateFieldGet(this, _Export_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, event);
                if (Object.keys(parameterValues).length === 0) {
                    __classPrivateFieldGet(this, _Export_logger, "f").info(`Export(${__classPrivateFieldGet(this, _Export_id, "f")}).request: Sending export request with parameters ${JSON.stringify(parameterValues)}.`);
                }
                else {
                    __classPrivateFieldGet(this, _Export_logger, "f").debugLow(`Export(${__classPrivateFieldGet(this, _Export_id, "f")}).request: Sending export request.`);
                }
                const exportDef = yield __classPrivateFieldGet(this, _Export_sessionEngine, "f").requestExport(this.id, parameterValues, __classPrivateFieldGet(this, _Export_maxWaitTime, "f"));
                this.updateExportDefinition(exportDef);
                const eventEnd = { type: viewer_shared_types_1.TASK_TYPE.EXPORT_REQUEST, id: eventId, progress: 1, status: 'Returning export' };
                __classPrivateFieldGet(this, _Export_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);
                return exportDef;
            }
            catch (e) {
                const eventEnd = { type: viewer_shared_types_1.TASK_TYPE.EXPORT_REQUEST, id: eventId, progress: 1, status: 'Export request failed' };
                __classPrivateFieldGet(this, _Export_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventEnd);
                throw e;
            }
        });
    }
    updateExport() {
        const exportDef = __classPrivateFieldGet(this, _Export_sessionEngine, "f").exports[this.id];
        __classPrivateFieldSet(this, _Export_dependency, exportDef.dependency, "f");
        __classPrivateFieldSet(this, _Export_uid, exportDef.uid, "f");
        __classPrivateFieldSet(this, _Export_displayname, exportDef.displayname, "f");
        __classPrivateFieldSet(this, _Export_order, exportDef.order, "f");
        __classPrivateFieldSet(this, _Export_hidden, exportDef.hidden, "f");
        __classPrivateFieldSet(this, _Export_tooltip, exportDef.tooltip, "f");
        __classPrivateFieldSet(this, _Export_version, exportDef.version, "f");
        __classPrivateFieldSet(this, _Export_delay, exportDef.delay, "f");
        __classPrivateFieldSet(this, _Export_content, exportDef.content, "f");
        __classPrivateFieldSet(this, _Export_msg, exportDef.msg, "f");
        __classPrivateFieldSet(this, _Export_filename, exportDef.filename, "f");
        __classPrivateFieldSet(this, _Export_result, exportDef.result, "f");
        __classPrivateFieldSet(this, _Export_status_computation, exportDef.status_computation, "f");
        __classPrivateFieldSet(this, _Export_status_collect, exportDef.status_collect, "f");
        __classPrivateFieldSet(this, _Export_group, exportDef.group, "f");
    }
    updateExportDefinition(exportDef) {
        __classPrivateFieldSet(this, _Export_dependency, exportDef.dependency, "f");
        __classPrivateFieldSet(this, _Export_uid, exportDef.uid, "f");
        __classPrivateFieldSet(this, _Export_displayname, exportDef.displayname, "f");
        __classPrivateFieldSet(this, _Export_order, exportDef.order, "f");
        __classPrivateFieldSet(this, _Export_hidden, exportDef.hidden, "f");
        __classPrivateFieldSet(this, _Export_tooltip, exportDef.tooltip, "f");
        __classPrivateFieldSet(this, _Export_version, exportDef.version, "f");
        __classPrivateFieldSet(this, _Export_delay, exportDef.delay, "f");
        __classPrivateFieldSet(this, _Export_content, exportDef.content, "f");
        __classPrivateFieldSet(this, _Export_msg, exportDef.msg, "f");
        __classPrivateFieldSet(this, _Export_filename, exportDef.filename, "f");
        __classPrivateFieldSet(this, _Export_result, exportDef.result, "f");
        __classPrivateFieldSet(this, _Export_status_computation, exportDef.status_computation, "f");
        __classPrivateFieldSet(this, _Export_status_collect, exportDef.status_collect, "f");
        __classPrivateFieldSet(this, _Export_group, exportDef.group, "f");
    }
}
exports.Export = Export;
_Export_eventEngine = new WeakMap(), _Export_id = new WeakMap(), _Export_inputValidator = new WeakMap(), _Export_logger = new WeakMap(), _Export_name = new WeakMap(), _Export_sessionEngine = new WeakMap(), _Export_type = new WeakMap(), _Export_uuidGenerator = new WeakMap(), _Export_content = new WeakMap(), _Export_delay = new WeakMap(), _Export_dependency = new WeakMap(), _Export_displayname = new WeakMap(), _Export_filename = new WeakMap(), _Export_group = new WeakMap(), _Export_hidden = new WeakMap(), _Export_maxWaitTime = new WeakMap(), _Export_msg = new WeakMap(), _Export_order = new WeakMap(), _Export_result = new WeakMap(), _Export_status_collect = new WeakMap(), _Export_status_computation = new WeakMap(), _Export_tooltip = new WeakMap(), _Export_uid = new WeakMap(), _Export_version = new WeakMap();
//# sourceMappingURL=Export.js.map

/***/ }),

/***/ 66906:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FileParameter_logger, _FileParameter_sessionEngine, _FileParameter_uuidGenerator;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileParameter = void 0;
const MimeTypeUtils = __importStar(__webpack_require__(56434));
const viewer_shared_services_1 = __webpack_require__(8389);
const Parameter_1 = __webpack_require__(14036);
class FileParameter extends Parameter_1.Parameter {
    // #endregion Properties (3)
    // #region Constructors (1)
    constructor(paramDef, sessionEngine) {
        super(paramDef, sessionEngine);
        // #region Properties (3)
        _FileParameter_logger.set(this, viewer_shared_services_1.Logger.instance);
        _FileParameter_sessionEngine.set(this, void 0);
        _FileParameter_uuidGenerator.set(this, viewer_shared_services_1.UuidGenerator.instance);
        __classPrivateFieldSet(this, _FileParameter_sessionEngine, sessionEngine, "f");
    }
    // #endregion Constructors (1)
    // #region Public Methods (2)
    getFilename(fileId) {
        return __awaiter(this, void 0, void 0, function* () {
            // if fileId is undefined and value is undefined, return undefined
            if (fileId === undefined && this.value === undefined)
                return;
            // if fileId is undefined and value is a string and is a valid uuid, use the value as fileId
            if (fileId === undefined && typeof this.value === 'string' && ((this.value.length === 36 && __classPrivateFieldGet(this, _FileParameter_uuidGenerator, "f").validate(this.value)) || this.value === ''))
                return (yield __classPrivateFieldGet(this, _FileParameter_sessionEngine, "f").getFileInfo(this.id, this.value)).filename;
            // if fileId is undefined, return undefined
            if (fileId === undefined)
                return;
            return (yield __classPrivateFieldGet(this, _FileParameter_sessionEngine, "f").getFileInfo(this.id, fileId)).filename;
        });
    }
    upload(v) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const value = v !== undefined ? v : this.value;
            if (value === undefined)
                return this.defval;
            if (typeof value === 'string' && ((value.length === 36 && __classPrivateFieldGet(this, _FileParameter_uuidGenerator, "f").validate(value)) || value === ''))
                return value;
            // get the type of the file
            let fileType;
            if (value instanceof File) {
                if (value.type === '') {
                    // try to get type from file name
                    const types = MimeTypeUtils.guessMimeTypeFromFilename(value.name);
                    if (types.length === 0) {
                        throw new viewer_shared_services_1.ShapeDiverViewerSessionError(`Parameter(${this.id}).upload: Error uploading FileParameter, provided File has no type and could not be guessed from filename. Has to be ${this.format}.`);
                    }
                    else {
                        fileType = types;
                    }
                }
                else {
                    fileType = value.type;
                }
            }
            else if (value instanceof Blob) {
                if (value.type === '') {
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError(`Parameter(${this.id}).upload: Error uploading FileParameter, provided File has no type and could not be guessed from filename. Has to be ${this.format}.`);
                }
                else {
                    fileType = value.type;
                }
            }
            else {
                fileType = 'text/plain';
            }
            /**
             * Get all possible mime types for the provided fileType.
             */
            let types = typeof fileType === 'string' ? [fileType] : fileType;
            // get all endings that are possible for this type
            const endings = MimeTypeUtils.mapMimeTypeToFileEndings(types);
            // get all mimeTypes that are possible for these endings
            endings.forEach((e) => types = types.concat(MimeTypeUtils.guessMimeTypeFromFilename(e)));
            /**
             * Check if the provided fileType is allowed for this parameter.
             * If not, throw an error.
             */
            let type = undefined;
            // check if one of the mime types is allowed
            let allowedType = false;
            for (let i = 0; i < types.length; i++) {
                if ((_a = this.format) === null || _a === void 0 ? void 0 : _a.includes(types[i])) {
                    allowedType = true;
                    type = types[i];
                    break;
                }
            }
            // if the type is not allowed, throw an error
            if (allowedType === false || type === undefined)
                throw new viewer_shared_services_1.ShapeDiverViewerSessionError(`Parameter(${this.id}).upload: Error uploading FileParameter, type of data (${fileType}) is not a valid type. Has to be ${this.format}.`);
            // create a File object
            const data = new File([
                typeof value === 'string' ?
                    new Blob([value], { type: 'text/plain' }) :
                    value
            ], value instanceof File && value.name !== undefined ? value.name : '', { type });
            __classPrivateFieldGet(this, _FileParameter_logger, "f").debug(`Parameter(${this.id}).upload: Uploading FileParameter.`);
            return yield __classPrivateFieldGet(this, _FileParameter_sessionEngine, "f").uploadFile(this.id, data, type);
        });
    }
}
exports.FileParameter = FileParameter;
_FileParameter_logger = new WeakMap(), _FileParameter_sessionEngine = new WeakMap(), _FileParameter_uuidGenerator = new WeakMap();
//# sourceMappingURL=FileParameter.js.map

/***/ }),

/***/ 774:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Output_id, _Output_inputValidator, _Output_logger, _Output_name, _Output_sessionEngine, _Output_uuidGenerator, _Output_bbmax, _Output_bbmin, _Output_chunks, _Output_content, _Output_delay, _Output_dependency, _Output_displayname, _Output_hidden, _Output_material, _Output_msg, _Output_order, _Output_status_collect, _Output_status_computation, _Output_tooltip, _Output_uid, _Output_updateCallback, _Output_version;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Output = void 0;
const viewer_shared_services_1 = __webpack_require__(8389);
class Output {
    // #endregion Properties (23)
    // #region Constructors (1)
    constructor(outputDef, sessionEngine) {
        // #region Properties (23)
        _Output_id.set(this, void 0);
        _Output_inputValidator.set(this, viewer_shared_services_1.InputValidator.instance);
        _Output_logger.set(this, viewer_shared_services_1.Logger.instance);
        _Output_name.set(this, void 0);
        _Output_sessionEngine.set(this, void 0);
        _Output_uuidGenerator.set(this, viewer_shared_services_1.UuidGenerator.instance);
        _Output_bbmax.set(this, void 0);
        _Output_bbmin.set(this, void 0);
        _Output_chunks.set(this, void 0);
        _Output_content.set(this, void 0);
        _Output_delay.set(this, void 0);
        _Output_dependency.set(this, void 0);
        _Output_displayname.set(this, void 0);
        _Output_hidden.set(this, false);
        _Output_material.set(this, void 0);
        _Output_msg.set(this, void 0);
        _Output_order.set(this, void 0);
        _Output_status_collect.set(this, void 0);
        _Output_status_computation.set(this, void 0);
        _Output_tooltip.set(this, void 0);
        _Output_uid.set(this, void 0);
        _Output_updateCallback.set(this, null);
        _Output_version.set(this, void 0);
        __classPrivateFieldSet(this, _Output_sessionEngine, sessionEngine, "f");
        __classPrivateFieldSet(this, _Output_id, outputDef.id, "f");
        __classPrivateFieldSet(this, _Output_name, outputDef.name, "f");
        __classPrivateFieldSet(this, _Output_version, outputDef.version, "f");
        this.updateOutputDefinition(outputDef);
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (30)
    get bbmax() {
        return __classPrivateFieldGet(this, _Output_bbmax, "f");
    }
    get bbmin() {
        return __classPrivateFieldGet(this, _Output_bbmin, "f");
    }
    get chunks() {
        return __classPrivateFieldGet(this, _Output_chunks, "f");
    }
    get content() {
        return __classPrivateFieldGet(this, _Output_content, "f");
    }
    set content(value) {
        __classPrivateFieldSet(this, _Output_content, value, "f");
    }
    get delay() {
        return __classPrivateFieldGet(this, _Output_delay, "f");
    }
    get dependency() {
        return __classPrivateFieldGet(this, _Output_dependency, "f");
    }
    get displayname() {
        return __classPrivateFieldGet(this, _Output_displayname, "f");
    }
    set displayname(value) {
        __classPrivateFieldSet(this, _Output_displayname, value, "f");
    }
    get format() {
        return __classPrivateFieldGet(this, _Output_content, "f") ? __classPrivateFieldGet(this, _Output_content, "f").map(c => c.format) : [];
    }
    get freeze() {
        return __classPrivateFieldGet(this, _Output_sessionEngine, "f").outputsFreeze[__classPrivateFieldGet(this, _Output_id, "f")];
    }
    set freeze(value) {
        __classPrivateFieldGet(this, _Output_sessionEngine, "f").outputsFreeze[__classPrivateFieldGet(this, _Output_id, "f")] = value;
    }
    get hidden() {
        return __classPrivateFieldGet(this, _Output_hidden, "f");
    }
    set hidden(value) {
        __classPrivateFieldSet(this, _Output_hidden, value, "f");
    }
    get id() {
        return __classPrivateFieldGet(this, _Output_id, "f");
    }
    get material() {
        return __classPrivateFieldGet(this, _Output_material, "f");
    }
    get msg() {
        return __classPrivateFieldGet(this, _Output_msg, "f");
    }
    get name() {
        return __classPrivateFieldGet(this, _Output_name, "f");
    }
    get node() {
        return __classPrivateFieldGet(this, _Output_sessionEngine, "f").node.children.find(c => c.name === this.id);
    }
    get order() {
        return __classPrivateFieldGet(this, _Output_order, "f");
    }
    set order(value) {
        __classPrivateFieldSet(this, _Output_order, value, "f");
    }
    get status_collect() {
        return __classPrivateFieldGet(this, _Output_status_collect, "f");
    }
    get status_computation() {
        return __classPrivateFieldGet(this, _Output_status_computation, "f");
    }
    get tooltip() {
        return __classPrivateFieldGet(this, _Output_tooltip, "f");
    }
    set tooltip(value) {
        __classPrivateFieldSet(this, _Output_tooltip, value, "f");
    }
    get uid() {
        return __classPrivateFieldGet(this, _Output_uid, "f");
    }
    get updateCallback() {
        return __classPrivateFieldGet(this, _Output_updateCallback, "f");
    }
    set updateCallback(value) {
        __classPrivateFieldSet(this, _Output_updateCallback, value, "f");
    }
    get version() {
        return __classPrivateFieldGet(this, _Output_version, "f");
    }
    set version(value) {
        __classPrivateFieldSet(this, _Output_version, value, "f");
    }
    // #endregion Public Getters And Setters (30)
    // #region Public Methods (4)
    triggerUpdateCallback(newNode, oldNode) {
        return __awaiter(this, void 0, void 0, function* () {
            if (__classPrivateFieldGet(this, _Output_updateCallback, "f"))
                yield Promise.resolve(__classPrivateFieldGet(this, _Output_updateCallback, "f").call(this, newNode, oldNode));
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateOutput(newNode, oldNode) {
        const outputDef = __classPrivateFieldGet(this, _Output_sessionEngine, "f").outputs[this.id];
        this.updateOutputDefinition(outputDef);
        // add chunk nodes
        if (this.chunks && newNode) {
            for (let i = 0; i < newNode.children.length; i++) {
                for (let j = 0; j < this.chunks.length; j++) {
                    this.chunks[j].node = newNode.children[i].children.find(child => child.name === this.chunks[j].id);
                }
            }
        }
    }
    updateOutputContent(outputContent, preventUpdate = false, waitForViewportUpdate = false) {
        return __awaiter(this, void 0, void 0, function* () {
            __classPrivateFieldGet(this, _Output_sessionEngine, "f").outputs[this.id].content = outputContent;
            __classPrivateFieldGet(this, _Output_sessionEngine, "f").outputs[this.id].version = __classPrivateFieldGet(this, _Output_uuidGenerator, "f").create();
            if (!preventUpdate)
                yield __classPrivateFieldGet(this, _Output_sessionEngine, "f").updateOutputs(undefined, waitForViewportUpdate);
            return this.node;
        });
    }
    updateOutputDefinition(outputDef) {
        __classPrivateFieldSet(this, _Output_dependency, outputDef.dependency, "f");
        __classPrivateFieldSet(this, _Output_uid, outputDef.uid, "f");
        __classPrivateFieldSet(this, _Output_material, outputDef.material, "f");
        __classPrivateFieldSet(this, _Output_chunks, outputDef.chunks, "f");
        __classPrivateFieldSet(this, _Output_msg, outputDef.msg, "f");
        if (__classPrivateFieldGet(this, _Output_msg, "f") !== undefined)
            __classPrivateFieldGet(this, _Output_logger, "f").warn(`Output(${this.id}): ${__classPrivateFieldGet(this, _Output_msg, "f")}`);
        __classPrivateFieldSet(this, _Output_bbmin, outputDef.bbmin, "f");
        __classPrivateFieldSet(this, _Output_bbmax, outputDef.bbmax, "f");
        __classPrivateFieldSet(this, _Output_status_computation, outputDef.status_computation, "f");
        __classPrivateFieldSet(this, _Output_status_collect, outputDef.status_collect, "f");
        __classPrivateFieldSet(this, _Output_content, outputDef.content, "f");
        __classPrivateFieldSet(this, _Output_delay, outputDef.delay, "f");
        __classPrivateFieldSet(this, _Output_version, outputDef.version, "f");
        __classPrivateFieldSet(this, _Output_displayname, outputDef.displayname, "f");
        __classPrivateFieldSet(this, _Output_order, outputDef.order, "f");
        __classPrivateFieldSet(this, _Output_hidden, outputDef.hidden, "f");
    }
}
exports.Output = Output;
_Output_id = new WeakMap(), _Output_inputValidator = new WeakMap(), _Output_logger = new WeakMap(), _Output_name = new WeakMap(), _Output_sessionEngine = new WeakMap(), _Output_uuidGenerator = new WeakMap(), _Output_bbmax = new WeakMap(), _Output_bbmin = new WeakMap(), _Output_chunks = new WeakMap(), _Output_content = new WeakMap(), _Output_delay = new WeakMap(), _Output_dependency = new WeakMap(), _Output_displayname = new WeakMap(), _Output_hidden = new WeakMap(), _Output_material = new WeakMap(), _Output_msg = new WeakMap(), _Output_order = new WeakMap(), _Output_status_collect = new WeakMap(), _Output_status_computation = new WeakMap(), _Output_tooltip = new WeakMap(), _Output_uid = new WeakMap(), _Output_updateCallback = new WeakMap(), _Output_version = new WeakMap();
//# sourceMappingURL=Output.js.map

/***/ }),

/***/ 14036:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Parameter_choices, _Parameter_converter, _Parameter_decimalplaces, _Parameter_defaultValue, _Parameter_defval, _Parameter_eventEngine, _Parameter_expression, _Parameter_format, _Parameter_group, _Parameter_id, _Parameter_inputValidator, _Parameter_logger, _Parameter_max, _Parameter_min, _Parameter_name, _Parameter_paramDef, _Parameter_sessionEngine, _Parameter_settings, _Parameter_structure, _Parameter_type, _Parameter_visualization, _Parameter_displayname, _Parameter_hidden, _Parameter_lastValidatedValue, _Parameter_order, _Parameter_sessionValue, _Parameter_tooltip, _Parameter_value;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parameter = void 0;
const MimeTypeUtils = __importStar(__webpack_require__(56434));
const viewer_shared_services_1 = __webpack_require__(8389);
const viewer_shared_types_1 = __webpack_require__(64766);
class Parameter {
    // #endregion Properties (28)
    // #region Constructors (1)
    constructor(paramDef, sessionEngine) {
        // #region Properties (28)
        _Parameter_choices.set(this, void 0);
        _Parameter_converter.set(this, viewer_shared_services_1.Converter.instance);
        _Parameter_decimalplaces.set(this, void 0);
        _Parameter_defaultValue.set(this, void 0);
        _Parameter_defval.set(this, void 0);
        _Parameter_eventEngine.set(this, viewer_shared_services_1.EventEngine.instance);
        _Parameter_expression.set(this, void 0);
        _Parameter_format.set(this, void 0);
        _Parameter_group.set(this, void 0);
        _Parameter_id.set(this, void 0);
        _Parameter_inputValidator.set(this, viewer_shared_services_1.InputValidator.instance);
        _Parameter_logger.set(this, viewer_shared_services_1.Logger.instance);
        _Parameter_max.set(this, void 0);
        _Parameter_min.set(this, void 0);
        _Parameter_name.set(this, void 0);
        _Parameter_paramDef.set(this, void 0);
        _Parameter_sessionEngine.set(this, void 0);
        _Parameter_settings.set(this, void 0);
        _Parameter_structure.set(this, void 0);
        _Parameter_type.set(this, void 0);
        _Parameter_visualization.set(this, void 0);
        _Parameter_displayname.set(this, void 0);
        _Parameter_hidden.set(this, false);
        _Parameter_lastValidatedValue.set(this, void 0);
        _Parameter_order.set(this, void 0);
        _Parameter_sessionValue.set(this, void 0);
        _Parameter_tooltip.set(this, void 0);
        _Parameter_value.set(this, void 0);
        __classPrivateFieldSet(this, _Parameter_sessionEngine, sessionEngine, "f");
        __classPrivateFieldSet(this, _Parameter_paramDef, paramDef, "f");
        __classPrivateFieldSet(this, _Parameter_id, paramDef.id, "f");
        __classPrivateFieldSet(this, _Parameter_defval, paramDef.defval, "f");
        __classPrivateFieldSet(this, _Parameter_name, paramDef.name, "f");
        __classPrivateFieldSet(this, _Parameter_type, paramDef.type, "f");
        if (paramDef.choices !== undefined)
            __classPrivateFieldSet(this, _Parameter_choices, paramDef.choices, "f");
        if (paramDef.decimalplaces !== undefined)
            __classPrivateFieldSet(this, _Parameter_decimalplaces, +paramDef.decimalplaces, "f");
        if (paramDef.expression !== undefined)
            __classPrivateFieldSet(this, _Parameter_expression, paramDef.expression, "f");
        if (paramDef.format !== undefined)
            __classPrivateFieldSet(this, _Parameter_format, MimeTypeUtils.extendMimeTypes(paramDef.format), "f");
        if (paramDef.min !== undefined)
            __classPrivateFieldSet(this, _Parameter_min, +paramDef.min, "f");
        if (paramDef.max !== undefined)
            __classPrivateFieldSet(this, _Parameter_max, +paramDef.max, "f");
        if (paramDef.visualization !== undefined)
            __classPrivateFieldSet(this, _Parameter_visualization, paramDef.visualization, "f");
        if (paramDef.structure !== undefined)
            __classPrivateFieldSet(this, _Parameter_structure, paramDef.structure, "f");
        if (paramDef.group !== undefined)
            __classPrivateFieldSet(this, _Parameter_group, paramDef.group, "f");
        if (paramDef.settings !== undefined)
            __classPrivateFieldSet(this, _Parameter_settings, paramDef.settings, "f");
        if (paramDef.tooltip !== undefined)
            __classPrivateFieldSet(this, _Parameter_tooltip, paramDef.tooltip, "f");
        if (paramDef.displayname !== undefined)
            __classPrivateFieldSet(this, _Parameter_displayname, paramDef.displayname, "f");
        if (paramDef.order !== undefined)
            __classPrivateFieldSet(this, _Parameter_order, paramDef.order, "f");
        if (paramDef.hidden !== undefined)
            __classPrivateFieldSet(this, _Parameter_hidden, paramDef.hidden, "f");
        if (__classPrivateFieldGet(this, _Parameter_type, "f") === viewer_shared_types_1.PARAMETER_TYPE.BOOL) {
            __classPrivateFieldSet(this, _Parameter_defaultValue, (__classPrivateFieldGet(this, _Parameter_defval, "f") === 'true'), "f");
        }
        else if (__classPrivateFieldGet(this, _Parameter_type, "f") === viewer_shared_types_1.PARAMETER_TYPE.EVEN || __classPrivateFieldGet(this, _Parameter_type, "f") === viewer_shared_types_1.PARAMETER_TYPE.FLOAT || __classPrivateFieldGet(this, _Parameter_type, "f") === viewer_shared_types_1.PARAMETER_TYPE.INT || __classPrivateFieldGet(this, _Parameter_type, "f") === viewer_shared_types_1.PARAMETER_TYPE.ODD) {
            __classPrivateFieldSet(this, _Parameter_defaultValue, +__classPrivateFieldGet(this, _Parameter_defval, "f"), "f");
        }
        else {
            __classPrivateFieldSet(this, _Parameter_defaultValue, __classPrivateFieldGet(this, _Parameter_defval, "f"), "f");
        }
        if (__classPrivateFieldGet(this, _Parameter_type, "f") === viewer_shared_types_1.PARAMETER_TYPE.COLOR) {
            this.convertColor = (color) => {
                return __classPrivateFieldGet(this, _Parameter_converter, "f").toHexColor(color);
            };
        }
        __classPrivateFieldSet(this, _Parameter_value, __classPrivateFieldGet(this, _Parameter_defaultValue, "f"), "f");
        __classPrivateFieldSet(this, _Parameter_sessionValue, __classPrivateFieldGet(this, _Parameter_value, "f"), "f");
        __classPrivateFieldSet(this, _Parameter_lastValidatedValue, __classPrivateFieldGet(this, _Parameter_value, "f"), "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (27)
    get choices() {
        return __classPrivateFieldGet(this, _Parameter_choices, "f");
    }
    get decimalplaces() {
        return __classPrivateFieldGet(this, _Parameter_decimalplaces, "f");
    }
    get defval() {
        return __classPrivateFieldGet(this, _Parameter_defval, "f");
    }
    get displayname() {
        return __classPrivateFieldGet(this, _Parameter_displayname, "f");
    }
    set displayname(value) {
        __classPrivateFieldSet(this, _Parameter_displayname, value, "f");
    }
    get expression() {
        return __classPrivateFieldGet(this, _Parameter_expression, "f");
    }
    get format() {
        return __classPrivateFieldGet(this, _Parameter_format, "f");
    }
    get group() {
        return __classPrivateFieldGet(this, _Parameter_group, "f");
    }
    get hidden() {
        return __classPrivateFieldGet(this, _Parameter_hidden, "f");
    }
    set hidden(value) {
        __classPrivateFieldSet(this, _Parameter_hidden, value, "f");
    }
    get id() {
        return __classPrivateFieldGet(this, _Parameter_id, "f");
    }
    get lastValidatedValue() {
        return __classPrivateFieldGet(this, _Parameter_lastValidatedValue, "f");
    }
    get max() {
        return __classPrivateFieldGet(this, _Parameter_max, "f");
    }
    get min() {
        return __classPrivateFieldGet(this, _Parameter_min, "f");
    }
    get name() {
        return __classPrivateFieldGet(this, _Parameter_name, "f");
    }
    get order() {
        return __classPrivateFieldGet(this, _Parameter_order, "f");
    }
    set order(value) {
        __classPrivateFieldSet(this, _Parameter_order, value, "f");
    }
    get sessionValue() {
        return __classPrivateFieldGet(this, _Parameter_sessionValue, "f");
    }
    set sessionValue(value) {
        __classPrivateFieldSet(this, _Parameter_sessionValue, value, "f");
        // emit event
        __classPrivateFieldGet(this, _Parameter_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE_PARAMETER.PARAMETER_SESSION_VALUE_CHANGED, {
            sessionId: __classPrivateFieldGet(this, _Parameter_sessionEngine, "f").id,
            parameterId: __classPrivateFieldGet(this, _Parameter_id, "f"),
            value: value
        });
    }
    get settings() {
        return __classPrivateFieldGet(this, _Parameter_settings, "f");
    }
    get structure() {
        return __classPrivateFieldGet(this, _Parameter_structure, "f");
    }
    get tooltip() {
        return __classPrivateFieldGet(this, _Parameter_tooltip, "f");
    }
    set tooltip(value) {
        __classPrivateFieldSet(this, _Parameter_tooltip, value, "f");
    }
    get type() {
        return __classPrivateFieldGet(this, _Parameter_type, "f");
    }
    get value() {
        return __classPrivateFieldGet(this, _Parameter_value, "f");
    }
    set value(value) {
        __classPrivateFieldSet(this, _Parameter_value, value, "f");
        // emit event
        __classPrivateFieldGet(this, _Parameter_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE_PARAMETER.PARAMETER_VALUE_CHANGED, {
            sessionId: __classPrivateFieldGet(this, _Parameter_sessionEngine, "f").id,
            parameterId: __classPrivateFieldGet(this, _Parameter_id, "f"),
            value: value
        });
        // if customizeOnParameterChange is true, customize the session
        if (__classPrivateFieldGet(this, _Parameter_sessionEngine, "f").customizeOnParameterChange)
            __classPrivateFieldGet(this, _Parameter_sessionEngine, "f").customize();
    }
    get visualization() {
        return __classPrivateFieldGet(this, _Parameter_visualization, "f");
    }
    // #endregion Public Getters And Setters (27)
    // #region Public Methods (4)
    isValid(value, throwError) {
        return (0, viewer_shared_services_1.isValid)(__classPrivateFieldGet(this, _Parameter_paramDef, "f"), value, throwError);
    }
    resetToDefaultValue() {
        __classPrivateFieldSet(this, _Parameter_value, __classPrivateFieldGet(this, _Parameter_defaultValue, "f"), "f");
    }
    resetToSessionValue() {
        __classPrivateFieldSet(this, _Parameter_value, this.sessionValue, "f");
    }
    stringify(val) {
        const value = val !== undefined ? val : this.value;
        return (0, viewer_shared_services_1.stringify)(__classPrivateFieldGet(this, _Parameter_paramDef, "f"), value);
    }
}
exports.Parameter = Parameter;
_Parameter_choices = new WeakMap(), _Parameter_converter = new WeakMap(), _Parameter_decimalplaces = new WeakMap(), _Parameter_defaultValue = new WeakMap(), _Parameter_defval = new WeakMap(), _Parameter_eventEngine = new WeakMap(), _Parameter_expression = new WeakMap(), _Parameter_format = new WeakMap(), _Parameter_group = new WeakMap(), _Parameter_id = new WeakMap(), _Parameter_inputValidator = new WeakMap(), _Parameter_logger = new WeakMap(), _Parameter_max = new WeakMap(), _Parameter_min = new WeakMap(), _Parameter_name = new WeakMap(), _Parameter_paramDef = new WeakMap(), _Parameter_sessionEngine = new WeakMap(), _Parameter_settings = new WeakMap(), _Parameter_structure = new WeakMap(), _Parameter_type = new WeakMap(), _Parameter_visualization = new WeakMap(), _Parameter_displayname = new WeakMap(), _Parameter_hidden = new WeakMap(), _Parameter_lastValidatedValue = new WeakMap(), _Parameter_order = new WeakMap(), _Parameter_sessionValue = new WeakMap(), _Parameter_tooltip = new WeakMap(), _Parameter_value = new WeakMap();
//# sourceMappingURL=Parameter.js.map

/***/ }),

/***/ 76827:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _GumballParameter_sessionEngine;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GumballParameter = void 0;
const viewer_shared_types_1 = __webpack_require__(64766);
const Parameter_1 = __webpack_require__(14036);
class GumballParameter extends Parameter_1.Parameter {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(paramDef, sessionEngine) {
        super(paramDef, sessionEngine);
        // #region Properties (1)
        _GumballParameter_sessionEngine.set(this, void 0);
        __classPrivateFieldSet(this, _GumballParameter_sessionEngine, sessionEngine, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (9)
    get enableRotation() {
        var _a;
        return (_a = this.getGumballProperties()) === null || _a === void 0 ? void 0 : _a.enableRotation;
    }
    get enableScaling() {
        var _a;
        return (_a = this.getGumballProperties()) === null || _a === void 0 ? void 0 : _a.enableScaling;
    }
    get enableTranslation() {
        var _a;
        return (_a = this.getGumballProperties()) === null || _a === void 0 ? void 0 : _a.enableTranslation;
    }
    get hover() {
        var _a;
        return (_a = this.getGumballProperties()) === null || _a === void 0 ? void 0 : _a.hover;
    }
    get interactionType() {
        return 'gumball';
    }
    get nameFilter() {
        var _a;
        return (_a = this.getGumballProperties()) === null || _a === void 0 ? void 0 : _a.nameFilter;
    }
    get scale() {
        var _a;
        return (_a = this.getGumballProperties()) === null || _a === void 0 ? void 0 : _a.scale;
    }
    get selectionColor() {
        var _a;
        return (_a = this.getGumballProperties()) === null || _a === void 0 ? void 0 : _a.selectionColor;
    }
    get space() {
        var _a;
        return (_a = this.getGumballProperties()) === null || _a === void 0 ? void 0 : _a.space;
    }
    // #endregion Public Getters And Setters (9)
    // #region Private Methods (1)
    getGumballProperties() {
        const result = (0, viewer_shared_types_1.validateGumballParameterSettings)(this.settings);
        if (result.success) {
            return this.settings.props;
        }
    }
}
exports.GumballParameter = GumballParameter;
_GumballParameter_sessionEngine = new WeakMap();
//# sourceMappingURL=GumballParameter.js.map

/***/ }),

/***/ 22967:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _SelectionParameter_sessionEngine;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionParameter = void 0;
const viewer_shared_types_1 = __webpack_require__(64766);
const Parameter_1 = __webpack_require__(14036);
class SelectionParameter extends Parameter_1.Parameter {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(paramDef, sessionEngine) {
        super(paramDef, sessionEngine);
        // #region Properties (1)
        _SelectionParameter_sessionEngine.set(this, void 0);
        __classPrivateFieldSet(this, _SelectionParameter_sessionEngine, sessionEngine, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (6)
    get hover() {
        var _a;
        return (_a = this.getSelectionProperties()) === null || _a === void 0 ? void 0 : _a.hover;
    }
    get interactionType() {
        return 'selection';
    }
    get maximumSelection() {
        var _a;
        return (_a = this.getSelectionProperties()) === null || _a === void 0 ? void 0 : _a.maximumSelection;
    }
    get minimumSelection() {
        var _a;
        return (_a = this.getSelectionProperties()) === null || _a === void 0 ? void 0 : _a.minimumSelection;
    }
    get nameFilter() {
        var _a;
        return (_a = this.getSelectionProperties()) === null || _a === void 0 ? void 0 : _a.nameFilter;
    }
    get selectionColor() {
        var _a;
        return (_a = this.getSelectionProperties()) === null || _a === void 0 ? void 0 : _a.selectionColor;
    }
    // #endregion Public Getters And Setters (6)
    // #region Private Methods (1)
    getSelectionProperties() {
        const result = (0, viewer_shared_types_1.validateSelectionParameterSettings)(this.settings);
        if (result.success) {
            return this.settings.props;
        }
    }
}
exports.SelectionParameter = SelectionParameter;
_SelectionParameter_sessionEngine = new WeakMap();
//# sourceMappingURL=SelectionParameter.js.map

/***/ }),

/***/ 4466:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Export = exports.DrawingParameter = exports.GumballParameter = exports.SelectionParameter = exports.FileParameter = exports.Parameter = exports.Output = exports.SessionEngine = exports.SessionOutputData = exports.SessionData = void 0;
const DrawingParameter_1 = __webpack_require__(35330);
Object.defineProperty(exports, "DrawingParameter", ({ enumerable: true, get: function () { return DrawingParameter_1.DrawingParameter; } }));
const Export_1 = __webpack_require__(40457);
Object.defineProperty(exports, "Export", ({ enumerable: true, get: function () { return Export_1.Export; } }));
const FileParameter_1 = __webpack_require__(66906);
Object.defineProperty(exports, "FileParameter", ({ enumerable: true, get: function () { return FileParameter_1.FileParameter; } }));
const GumballParameter_1 = __webpack_require__(76827);
Object.defineProperty(exports, "GumballParameter", ({ enumerable: true, get: function () { return GumballParameter_1.GumballParameter; } }));
const Output_1 = __webpack_require__(774);
Object.defineProperty(exports, "Output", ({ enumerable: true, get: function () { return Output_1.Output; } }));
const Parameter_1 = __webpack_require__(14036);
Object.defineProperty(exports, "Parameter", ({ enumerable: true, get: function () { return Parameter_1.Parameter; } }));
const SelectionParameter_1 = __webpack_require__(22967);
Object.defineProperty(exports, "SelectionParameter", ({ enumerable: true, get: function () { return SelectionParameter_1.SelectionParameter; } }));
const SessionData_1 = __webpack_require__(72265);
Object.defineProperty(exports, "SessionData", ({ enumerable: true, get: function () { return SessionData_1.SessionData; } }));
const SessionEngine_1 = __webpack_require__(42475);
Object.defineProperty(exports, "SessionEngine", ({ enumerable: true, get: function () { return SessionEngine_1.SessionEngine; } }));
const SessionOutputData_1 = __webpack_require__(77124);
Object.defineProperty(exports, "SessionOutputData", ({ enumerable: true, get: function () { return SessionOutputData_1.SessionOutputData; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 89459:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ExportApi_export, _ExportApi_inputValidator, _ExportApi_logger;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExportApi = void 0;
const viewer_shared_services_1 = __webpack_require__(8389);
class ExportApi {
    // #endregion Properties (3)
    // #region Constructors (1)
    constructor(exportD) {
        // #region Properties (3)
        _ExportApi_export.set(this, void 0);
        _ExportApi_inputValidator.set(this, viewer_shared_services_1.InputValidator.instance);
        _ExportApi_logger.set(this, viewer_shared_services_1.Logger.instance);
        __classPrivateFieldSet(this, _ExportApi_export, exportD, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (24)
    get content() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").content;
    }
    get delay() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").delay;
    }
    get dependency() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").dependency;
    }
    get displayname() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").displayname;
    }
    set displayname(value) {
        const scope = 'displayname';
        __classPrivateFieldGet(this, _ExportApi_inputValidator, "f").validateAndError(`ExportApi.${scope}`, value, 'string', false);
        __classPrivateFieldGet(this, _ExportApi_export, "f").displayname = value;
        __classPrivateFieldGet(this, _ExportApi_logger, "f").debug(`ExportApi.${scope}: ${scope} was updated to ${__classPrivateFieldGet(this, _ExportApi_export, "f").displayname}.`);
    }
    get filename() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").filename;
    }
    get group() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").group;
    }
    get hidden() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").hidden;
    }
    set hidden(value) {
        const scope = 'hidden';
        __classPrivateFieldGet(this, _ExportApi_inputValidator, "f").validateAndError(`ExportApi.${scope}`, value, 'boolean');
        __classPrivateFieldGet(this, _ExportApi_export, "f").hidden = value;
        __classPrivateFieldGet(this, _ExportApi_logger, "f").debug(`ExportApi.${scope}: ${scope} was updated to ${__classPrivateFieldGet(this, _ExportApi_export, "f").hidden}.`);
    }
    get id() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").id;
    }
    get maxWaitTime() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").maxWaitTime;
    }
    set maxWaitTime(value) {
        const scope = 'maxWaitTime';
        __classPrivateFieldGet(this, _ExportApi_inputValidator, "f").validateAndError(`ExportApi.${scope}`, value, 'number');
        __classPrivateFieldGet(this, _ExportApi_export, "f").maxWaitTime = value;
        __classPrivateFieldGet(this, _ExportApi_logger, "f").debug(`ExportApi.${scope}: ${scope} was updated to ${__classPrivateFieldGet(this, _ExportApi_export, "f").maxWaitTime}.`);
    }
    get msg() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").msg;
    }
    get name() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").name;
    }
    get order() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").order;
    }
    set order(value) {
        const scope = 'order';
        __classPrivateFieldGet(this, _ExportApi_inputValidator, "f").validateAndError(`ExportApi.${scope}`, value, 'number', false);
        __classPrivateFieldGet(this, _ExportApi_export, "f").order = value;
        __classPrivateFieldGet(this, _ExportApi_logger, "f").debug(`ExportApi.${scope}: ${scope} was updated to ${__classPrivateFieldGet(this, _ExportApi_export, "f").order}.`);
    }
    get result() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").result;
    }
    get status_collect() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").status_collect;
    }
    get status_computation() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").status_computation;
    }
    get tooltip() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").tooltip;
    }
    set tooltip(value) {
        const scope = 'tooltip';
        __classPrivateFieldGet(this, _ExportApi_inputValidator, "f").validateAndError(`ExportApi.${scope}`, value, 'string', false);
        __classPrivateFieldGet(this, _ExportApi_export, "f").tooltip = value;
        __classPrivateFieldGet(this, _ExportApi_logger, "f").debug(`ExportApi.${scope}: ${scope} was updated to ${__classPrivateFieldGet(this, _ExportApi_export, "f").tooltip}.`);
    }
    get type() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").type;
    }
    get uid() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").uid;
    }
    get version() {
        return __classPrivateFieldGet(this, _ExportApi_export, "f").version;
    }
    // #endregion Public Getters And Setters (24)
    // #region Public Methods (2)
    request(parameters = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const scope = 'request';
            __classPrivateFieldGet(this, _ExportApi_inputValidator, "f").validateAndError(`ExportApi.${scope}`, parameters, 'object');
            return __classPrivateFieldGet(this, _ExportApi_export, "f").request(parameters);
        });
    }
    updateExport() {
        __classPrivateFieldGet(this, _ExportApi_export, "f").updateExport();
    }
}
exports.ExportApi = ExportApi;
_ExportApi_export = new WeakMap(), _ExportApi_inputValidator = new WeakMap(), _ExportApi_logger = new WeakMap();
//# sourceMappingURL=ExportApi.js.map

/***/ }),

/***/ 56590:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _OutputApi_inputValidator, _OutputApi_logger, _OutputApi_output;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutputApi = void 0;
const viewer_shared_services_1 = __webpack_require__(8389);
const OutputApiData_1 = __webpack_require__(85149);
class OutputApi {
    // #endregion Properties (3)
    // #region Constructors (1)
    constructor(output) {
        // #region Properties (3)
        _OutputApi_inputValidator.set(this, viewer_shared_services_1.InputValidator.instance);
        _OutputApi_logger.set(this, viewer_shared_services_1.Logger.instance);
        _OutputApi_output.set(this, void 0);
        __classPrivateFieldSet(this, _OutputApi_output, output, "f");
        __classPrivateFieldGet(this, _OutputApi_output, "f").updateCallback = (newNode) => {
            if (newNode && newNode.data.findIndex(d => d instanceof OutputApiData_1.OutputApiData) === -1)
                newNode.addData(new OutputApiData_1.OutputApiData(this));
        };
        __classPrivateFieldGet(this, _OutputApi_output, "f").updateCallback(this.node);
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (28)
    get bbmax() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").bbmax;
    }
    get bbmin() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").bbmin;
    }
    get chunks() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").chunks;
    }
    get content() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").content;
    }
    get delay() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").delay;
    }
    get dependency() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").dependency;
    }
    get displayname() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").displayname;
    }
    set displayname(value) {
        const scope = 'displayname';
        __classPrivateFieldGet(this, _OutputApi_inputValidator, "f").validateAndError(`OutputApi.${scope}`, value, 'string', false);
        __classPrivateFieldGet(this, _OutputApi_output, "f").displayname = value;
        __classPrivateFieldGet(this, _OutputApi_logger, "f").debug(`OutputApi.${scope}: ${scope} was updated to ${__classPrivateFieldGet(this, _OutputApi_output, "f").displayname}.`);
    }
    get format() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").format;
    }
    get freeze() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").freeze;
    }
    set freeze(value) {
        const scope = 'freeze';
        __classPrivateFieldGet(this, _OutputApi_inputValidator, "f").validateAndError(`OutputApi.${scope}`, value, 'boolean');
        __classPrivateFieldGet(this, _OutputApi_output, "f").freeze = value;
        __classPrivateFieldGet(this, _OutputApi_logger, "f").debug(`OutputApi.${scope}: ${scope} was updated to ${__classPrivateFieldGet(this, _OutputApi_output, "f").freeze}.`);
    }
    get hidden() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").hidden;
    }
    set hidden(value) {
        const scope = 'hidden';
        __classPrivateFieldGet(this, _OutputApi_inputValidator, "f").validateAndError(`OutputApi.${scope}`, value, 'boolean');
        __classPrivateFieldGet(this, _OutputApi_output, "f").hidden = value;
        __classPrivateFieldGet(this, _OutputApi_logger, "f").debug(`OutputApi.${scope}: ${scope} was updated to ${__classPrivateFieldGet(this, _OutputApi_output, "f").hidden}.`);
    }
    get id() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").id;
    }
    get material() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").material;
    }
    get msg() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").msg;
    }
    get name() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").name;
    }
    get node() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").node;
    }
    get order() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").order;
    }
    set order(value) {
        const scope = 'order';
        __classPrivateFieldGet(this, _OutputApi_inputValidator, "f").validateAndError(`OutputApi.${scope}`, value, 'number', false);
        __classPrivateFieldGet(this, _OutputApi_output, "f").order = value;
        __classPrivateFieldGet(this, _OutputApi_logger, "f").debug(`OutputApi.${scope}: ${scope} was updated to ${__classPrivateFieldGet(this, _OutputApi_output, "f").order}.`);
    }
    get status_collect() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").status_collect;
    }
    get status_computation() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").status_computation;
    }
    get tooltip() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").tooltip;
    }
    set tooltip(value) {
        const scope = 'tooltip';
        __classPrivateFieldGet(this, _OutputApi_inputValidator, "f").validateAndError(`OutputApi.${scope}`, value, 'string', false);
        __classPrivateFieldGet(this, _OutputApi_output, "f").tooltip = value;
        __classPrivateFieldGet(this, _OutputApi_logger, "f").debug(`OutputApi.${scope}: ${scope} was updated to ${__classPrivateFieldGet(this, _OutputApi_output, "f").tooltip}.`);
    }
    get uid() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").uid;
    }
    get updateCallback() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").updateCallback;
    }
    set updateCallback(value) {
        const scope = 'updateCallback';
        if (value)
            __classPrivateFieldGet(this, _OutputApi_inputValidator, "f").validateAndError(`OutputApi.${scope}`, value, 'function', false);
        __classPrivateFieldGet(this, _OutputApi_output, "f").updateCallback = (newNode, oldNode) => __awaiter(this, void 0, void 0, function* () {
            if (newNode && newNode.data.findIndex(d => d instanceof OutputApiData_1.OutputApiData) === -1)
                newNode.addData(new OutputApiData_1.OutputApiData(this));
            if (value)
                yield Promise.resolve(value(newNode, oldNode));
        });
        __classPrivateFieldGet(this, _OutputApi_logger, "f").debug(`OutputApi.${scope}: ${scope} was updated to ${value}.`);
    }
    get version() {
        return __classPrivateFieldGet(this, _OutputApi_output, "f").version;
    }
    // #endregion Public Getters And Setters (28)
    // #region Public Methods (1)
    updateOutputContent(outputContent, preventUpdate = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const scope = 'updateOutputContent';
            __classPrivateFieldGet(this, _OutputApi_inputValidator, "f").validateAndError(`OutputApi.${scope}`, outputContent, 'array');
            __classPrivateFieldGet(this, _OutputApi_inputValidator, "f").validateAndError(`OutputApi.${scope}`, preventUpdate, 'boolean');
            return __classPrivateFieldGet(this, _OutputApi_output, "f").updateOutputContent(outputContent, preventUpdate);
        });
    }
}
exports.OutputApi = OutputApi;
_OutputApi_inputValidator = new WeakMap(), _OutputApi_logger = new WeakMap(), _OutputApi_output = new WeakMap();
//# sourceMappingURL=OutputApi.js.map

/***/ }),

/***/ 30377:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SessionApi_creationControlCenterSession, _SessionApi_exports, _SessionApi_gltfConverter, _SessionApi_inputValidator, _SessionApi_logger, _SessionApi_outputs, _SessionApi_parameters, _SessionApi_sessionEngine, _SessionApi_stateEngine;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionApi = void 0;
const viewer_creation_control_center_session_1 = __webpack_require__(71479);
const viewer_session_engine_session_engine_1 = __webpack_require__(4466);
const DrawingParameterApi_1 = __webpack_require__(89242);
const ExportApi_1 = __webpack_require__(89459);
const FileParameterApi_1 = __webpack_require__(43234);
const viewer_data_engine_gltf_converter_1 = __webpack_require__(17187);
const GumballParameterApi_1 = __webpack_require__(85942);
const viewer_shared_services_1 = __webpack_require__(8389);
const OutputApi_1 = __webpack_require__(56590);
const ParameterApi_1 = __webpack_require__(46892);
const SelectionParameterApi_1 = __webpack_require__(64322);
const SessionApiData_1 = __webpack_require__(14812);
class SessionApi {
    // #endregion Properties (9)
    // #region Constructors (1)
    constructor(sessionEngine) {
        // #region Properties (9)
        _SessionApi_creationControlCenterSession.set(this, viewer_creation_control_center_session_1.CreationControlCenterSession.instance);
        _SessionApi_exports.set(this, {});
        _SessionApi_gltfConverter.set(this, viewer_data_engine_gltf_converter_1.GLTFConverter.instance);
        _SessionApi_inputValidator.set(this, viewer_shared_services_1.InputValidator.instance);
        _SessionApi_logger.set(this, viewer_shared_services_1.Logger.instance);
        _SessionApi_outputs.set(this, {});
        _SessionApi_parameters.set(this, {});
        _SessionApi_sessionEngine.set(this, void 0);
        _SessionApi_stateEngine.set(this, viewer_shared_services_1.StateEngine.instance);
        __classPrivateFieldSet(this, _SessionApi_sessionEngine, sessionEngine, "f");
        if (!__classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").initialized)
            throw new viewer_shared_services_1.ShapeDiverViewerSessionError('Session could not be initialized.');
        __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").updateCallback = (newNode) => {
            if (!newNode)
                return;
            if (newNode.data.findIndex(d => d instanceof SessionApiData_1.SessionApiData) === -1)
                newNode.addData(new SessionApiData_1.SessionApiData(this));
        };
        __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").updateCallback(this.node, this.node);
        for (const o in __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").outputs)
            __classPrivateFieldGet(this, _SessionApi_outputs, "f")[o] = new OutputApi_1.OutputApi(__classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").outputs[o]);
        for (const e in __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").exports)
            __classPrivateFieldGet(this, _SessionApi_exports, "f")[e] = new ExportApi_1.ExportApi(__classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").exports[e]);
        for (const p in __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").parameters) {
            if (__classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").parameters[p] instanceof viewer_session_engine_session_engine_1.FileParameter) {
                __classPrivateFieldGet(this, _SessionApi_parameters, "f")[p] = new FileParameterApi_1.FileParameterApi(__classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").parameters[p]);
            }
            else if (__classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").parameters[p] instanceof viewer_session_engine_session_engine_1.SelectionParameter) {
                __classPrivateFieldGet(this, _SessionApi_parameters, "f")[p] = new SelectionParameterApi_1.SelectionParameterApi(__classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").parameters[p]);
            }
            else if (__classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").parameters[p] instanceof viewer_session_engine_session_engine_1.GumballParameter) {
                __classPrivateFieldGet(this, _SessionApi_parameters, "f")[p] = new GumballParameterApi_1.GumballParameterApi(__classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").parameters[p]);
            }
            else if (__classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").parameters[p] instanceof viewer_session_engine_session_engine_1.DrawingParameter) {
                __classPrivateFieldGet(this, _SessionApi_parameters, "f")[p] = new DrawingParameterApi_1.DrawingParameterApi(__classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").parameters[p]);
            }
            else {
                __classPrivateFieldGet(this, _SessionApi_parameters, "f")[p] = new ParameterApi_1.ParameterApi(__classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").parameters[p]);
            }
        }
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (30)
    get automaticSceneUpdate() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").automaticSceneUpdate;
    }
    set automaticSceneUpdate(value) {
        const scope = 'automaticSceneUpdate';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, value, 'boolean');
        __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").automaticSceneUpdate = value;
        __classPrivateFieldGet(this, _SessionApi_logger, "f").debug(`SessionApi.${scope}: ${scope} was set to ${value}`);
    }
    get commitParameters() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").settingsEngine.general.commitParameters;
    }
    set commitParameters(value) {
        const scope = 'commitParameters';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, value, 'boolean');
        __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").settingsEngine.general.commitParameters = value;
        __classPrivateFieldGet(this, _SessionApi_logger, "f").debug(`SessionApi.${scope}: ${scope} was set to ${value}`);
    }
    get commitSettings() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").settingsEngine.general.commitSettings;
    }
    set commitSettings(value) {
        const scope = 'commitSettings';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, value, 'boolean');
        __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").settingsEngine.general.commitSettings = value;
        __classPrivateFieldGet(this, _SessionApi_logger, "f").debug(`SessionApi.${scope}: ${scope} was set to ${value}`);
    }
    get customizeOnParameterChange() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").customizeOnParameterChange;
    }
    set customizeOnParameterChange(value) {
        const scope = 'customizeOnParameterChange';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, value, 'boolean');
        __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").customizeOnParameterChange = value;
        __classPrivateFieldGet(this, _SessionApi_logger, "f").debug(`SessionApi.${scope}: ${scope} was set to ${value}`);
    }
    get excludeViewports() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").excludeViewports;
    }
    set excludeViewports(value) {
        const scope = 'excludeViewports';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, value, 'stringArray');
        __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").excludeViewports = value;
        __classPrivateFieldGet(this, _SessionApi_logger, "f").debug(`SessionApi.${scope}: ${scope} was set to ${value}`);
    }
    get exports() {
        return __classPrivateFieldGet(this, _SessionApi_exports, "f");
    }
    get guid() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").guid;
    }
    get id() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").id;
    }
    get initialized() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").initialized;
    }
    get jwtToken() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").jwtToken;
    }
    get loadSdtf() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").loadSdtf;
    }
    set loadSdtf(value) {
        const scope = 'loadSdtf';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, value, 'boolean');
        __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").loadSdtf = value;
        __classPrivateFieldGet(this, _SessionApi_logger, "f").debug(`SessionApi.${scope}: ${scope} was set to ${value}`);
    }
    get modelState() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").modelState;
    }
    get modelViewUrl() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").modelViewUrl;
    }
    get node() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").node;
    }
    get outputs() {
        return __classPrivateFieldGet(this, _SessionApi_outputs, "f");
    }
    get parameterDefaultValues() {
        const parameterDefaultValues = {};
        for (const key in this.parameters)
            parameterDefaultValues[key] = this.parameters[key].defval;
        return parameterDefaultValues;
    }
    get parameterSessionValues() {
        const parameterSessionValues = {};
        for (const key in this.parameters)
            parameterSessionValues[key] = this.parameters[key].sessionValue;
        return parameterSessionValues;
    }
    get parameterValues() {
        const parameterValues = {};
        for (const key in this.parameters)
            parameterValues[key] = this.parameters[key].value;
        return parameterValues;
    }
    get parameters() {
        return __classPrivateFieldGet(this, _SessionApi_parameters, "f");
    }
    get refreshJwtToken() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").refreshJwtToken;
    }
    set refreshJwtToken(value) {
        const scope = 'refreshJwtToken';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, value, 'function', false);
        __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").refreshJwtToken = value;
        __classPrivateFieldGet(this, _SessionApi_logger, "f").debug(`SessionApi.${scope}: ${scope} was set to ${value}`);
    }
    get ticket() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").ticket;
    }
    get updateCallback() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").updateCallback;
    }
    set updateCallback(value) {
        const scope = 'updateCallback';
        if (value)
            __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, value, 'function', false);
        __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").updateCallback = (newNode, oldNode) => __awaiter(this, void 0, void 0, function* () {
            if (newNode.data.findIndex(d => d instanceof SessionApiData_1.SessionApiData) === -1)
                newNode.addData(new SessionApiData_1.SessionApiData(this));
            if (value)
                yield Promise.resolve(value(newNode, oldNode));
        });
        __classPrivateFieldGet(this, _SessionApi_logger, "f").debug(`SessionApi.${scope}: ${scope} was updated to ${value}.`);
    }
    // #endregion Public Getters And Setters (30)
    // #region Public Methods (31)
    applySettings(response, sections) {
        const scope = 'applySettings';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, response, 'object');
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, sections, 'object', false);
        return __classPrivateFieldGet(this, _SessionApi_creationControlCenterSession, "f").applySettings(this.id, response, sections);
    }
    canGoBack() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").canGoBack();
    }
    canGoForward() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").canGoForward();
    }
    cancelCustomization() {
        __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").cancelCustomization();
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield __classPrivateFieldGet(this, _SessionApi_creationControlCenterSession, "f").closeSessionEngine(this.id);
        });
    }
    convertToGlTF(convertForAr = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            for (const r in __classPrivateFieldGet(this, _SessionApi_stateEngine, "f").viewportEngines)
                (_a = __classPrivateFieldGet(this, _SessionApi_stateEngine, "f").viewportEngines[r]) === null || _a === void 0 ? void 0 : _a.update('SessionApi.convertToGlTF');
            const result = yield __classPrivateFieldGet(this, _SessionApi_gltfConverter, "f").convert(this.node, convertForAr);
            return new Blob([result], { type: 'application/octet-stream' });
        });
    }
    createModelState(parameterValues, omitSessionParameterValues, image, data, arScene) {
        return __awaiter(this, void 0, void 0, function* () {
            const scope = 'createModelState';
            __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, parameterValues, 'object', false);
            __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, omitSessionParameterValues, 'boolean', false);
            return yield __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").createModelState(parameterValues, omitSessionParameterValues, image, data, arScene);
        });
    }
    customize(parameterValues, force = false, waitForViewportUpdate = false) {
        const scope = 'customize';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, parameterValues, 'object', false);
        // if there are parameter values specified, we set them directly
        // the validation happens in the setter of the ParameterApi
        if (parameterValues)
            for (const p in parameterValues)
                this.parameters[p].value = parameterValues[p];
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, force, 'boolean', false);
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, waitForViewportUpdate, 'boolean', false);
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").customize(force, waitForViewportUpdate);
    }
    customizeParallel(parameterValues) {
        const scope = 'customizeParallel';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, parameterValues, 'object');
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").customizeParallel(parameterValues);
    }
    customizeResult(parameterValues) {
        const scope = 'customizeResult';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, parameterValues, 'object');
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").customizeParallel(parameterValues, false);
    }
    customizeWithModelState(modelState) {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").customizeWithModelState(modelState);
    }
    getExportById(id) {
        const scope = 'getExportById';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, id, 'string');
        return __classPrivateFieldGet(this, _SessionApi_exports, "f")[id];
    }
    getExportByName(name) {
        const scope = 'getExportByName';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, name, 'string');
        return Object.values(__classPrivateFieldGet(this, _SessionApi_exports, "f")).filter(e => e.name === name);
    }
    getExportByType(type) {
        const scope = 'getExportByType';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, type, 'string');
        return Object.values(__classPrivateFieldGet(this, _SessionApi_exports, "f")).filter(e => e.type === type);
    }
    getOutputByFormat(format) {
        const scope = 'getOutputByFormat';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, format, 'string');
        return Object.values(__classPrivateFieldGet(this, _SessionApi_outputs, "f")).filter(o => o.format.includes(format));
    }
    getOutputById(id) {
        const scope = 'getOutputById';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, id, 'string');
        return __classPrivateFieldGet(this, _SessionApi_outputs, "f")[id];
    }
    getOutputByName(name) {
        const scope = 'getOutputByName';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, name, 'string');
        return Object.values(__classPrivateFieldGet(this, _SessionApi_outputs, "f")).filter(o => o.name === name);
    }
    getParameterById(id) {
        const scope = 'getParameterById';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, id, 'string');
        return __classPrivateFieldGet(this, _SessionApi_parameters, "f")[id];
    }
    getParameterByName(name) {
        const scope = 'getParameterByName';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, name, 'string');
        return Object.values(__classPrivateFieldGet(this, _SessionApi_parameters, "f")).filter(p => p.name === name);
    }
    getParameterByType(type) {
        const scope = 'getParameterByType';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, type, 'string');
        return Object.values(__classPrivateFieldGet(this, _SessionApi_parameters, "f")).filter(p => p.type === type);
    }
    goBack() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").goBack();
    }
    goForward() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").goForward();
    }
    loadCachedOutputs(outputs) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").loadCachedOutputsParallel(outputs);
        });
    }
    requestExports(body, loadOutputs, maxWaitMsec) {
        return __awaiter(this, void 0, void 0, function* () {
            const scope = 'requestExports';
            __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, body, 'object');
            __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, loadOutputs, 'boolean', false);
            __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, maxWaitMsec, 'number', false);
            return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").requestExports(body, loadOutputs, maxWaitMsec);
        });
    }
    resetParameterValues(force = false, waitForViewportUpdate = false) {
        const scope = 'resetParameterValues';
        for (const p in this.parameters)
            this.parameters[p].value = this.parameters[p].defval;
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, force, 'boolean', false);
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").customize(force, waitForViewportUpdate);
    }
    resetSettings(sections) {
        const scope = 'applySettings';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, sections, 'object', false);
        return __classPrivateFieldGet(this, _SessionApi_creationControlCenterSession, "f").resetSettings(this.id, sections);
    }
    saveDefaultParameterValues() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").saveDefaultParameterValues();
    }
    saveSettings(viewportId) {
        const scope = 'saveDefaultParameterValues';
        __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, viewportId, 'string', false);
        return __classPrivateFieldGet(this, _SessionApi_creationControlCenterSession, "f").saveSettings(this.id, viewportId);
    }
    saveUiProperties() {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").saveUiProperties();
    }
    setJwtToken(value) {
        return __awaiter(this, void 0, void 0, function* () {
            const scope = 'setJwtToken';
            __classPrivateFieldGet(this, _SessionApi_inputValidator, "f").validateAndError(`SessionApi.${scope}`, value, 'string', false);
            yield __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").setJwtToken(value);
            __classPrivateFieldGet(this, _SessionApi_logger, "f").debug(`SessionApi.${scope}: ${scope} was set to ${value}`);
            return;
        });
    }
    updateOutputs(waitForViewportUpdate = false) {
        return __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").updateOutputs(undefined, waitForViewportUpdate);
    }
    uploadFileParameters(values) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileParameters = values || {};
            const fileParameterIds = yield __classPrivateFieldGet(this, _SessionApi_sessionEngine, "f").uploadFileParameters(fileParameters);
            return fileParameterIds;
        });
    }
}
exports.SessionApi = SessionApi;
_SessionApi_creationControlCenterSession = new WeakMap(), _SessionApi_exports = new WeakMap(), _SessionApi_gltfConverter = new WeakMap(), _SessionApi_inputValidator = new WeakMap(), _SessionApi_logger = new WeakMap(), _SessionApi_outputs = new WeakMap(), _SessionApi_parameters = new WeakMap(), _SessionApi_sessionEngine = new WeakMap(), _SessionApi_stateEngine = new WeakMap();
//# sourceMappingURL=SessionApi.js.map

/***/ }),

/***/ 85149:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _OutputApiData_api;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutputApiData = void 0;
const viewer_shared_node_tree_1 = __webpack_require__(41652);
class OutputApiData extends viewer_shared_node_tree_1.AbstractTreeNodeData {
    // #endregion Properties (1)
    // #region Constructors (1)
    /**
     * Creates a OutputApi data node.
     *
     * @param _data the data as key- value pairs
     * @param id the id
     */
    constructor(api, id, version) {
        super(id, version);
        // #region Properties (1)
        _OutputApiData_api.set(this, void 0);
        __classPrivateFieldSet(this, _OutputApiData_api, api, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (2)
    get api() {
        return __classPrivateFieldGet(this, _OutputApiData_api, "f");
    }
    set api(value) {
        __classPrivateFieldSet(this, _OutputApiData_api, value, "f");
    }
    // #endregion Public Getters And Setters (2)
    // #region Public Methods (1)
    /**
     * Clones the scene graph data.
     */
    clone() {
        return new OutputApiData(this.api, this.id, this.version);
    }
}
exports.OutputApiData = OutputApiData;
_OutputApiData_api = new WeakMap();
//# sourceMappingURL=OutputApiData.js.map

/***/ }),

/***/ 14812:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SessionApiData_api;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionApiData = void 0;
const viewer_shared_node_tree_1 = __webpack_require__(41652);
class SessionApiData extends viewer_shared_node_tree_1.AbstractTreeNodeData {
    // #endregion Properties (1)
    // #region Constructors (1)
    /**
     * Creates a SessionApi data node.
     *
     * @param _data the data as key- value pairs
     * @param id the id
     */
    constructor(api, id, version) {
        super(id, version);
        // #region Properties (1)
        _SessionApiData_api.set(this, void 0);
        __classPrivateFieldSet(this, _SessionApiData_api, api, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (2)
    get api() {
        return __classPrivateFieldGet(this, _SessionApiData_api, "f");
    }
    set api(value) {
        __classPrivateFieldSet(this, _SessionApiData_api, value, "f");
    }
    // #endregion Public Getters And Setters (2)
    // #region Public Methods (1)
    /**
     * Clones the scene graph data.
     */
    clone() {
        return new SessionApiData(this.api, this.id, this.version);
    }
}
exports.SessionApiData = SessionApiData;
_SessionApiData_api = new WeakMap();
//# sourceMappingURL=SessionApiData.js.map

/***/ }),

/***/ 89242:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DrawingParameterApi_parameter;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DrawingParameterApi = void 0;
const ParameterApi_1 = __webpack_require__(46892);
class DrawingParameterApi extends ParameterApi_1.ParameterApi {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(parameter) {
        super(parameter);
        // #region Properties (1)
        _DrawingParameterApi_parameter.set(this, void 0);
        __classPrivateFieldSet(this, _DrawingParameterApi_parameter, parameter, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (2)
    get geometry() {
        return __classPrivateFieldGet(this, _DrawingParameterApi_parameter, "f").geometry;
    }
    get restrictions() {
        return __classPrivateFieldGet(this, _DrawingParameterApi_parameter, "f").restrictions;
    }
}
exports.DrawingParameterApi = DrawingParameterApi;
_DrawingParameterApi_parameter = new WeakMap();
//# sourceMappingURL=DrawingParameterApi.js.map

/***/ }),

/***/ 43234:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FileParameterApi_logger, _FileParameterApi_parameter;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileParameterApi = void 0;
const viewer_shared_services_1 = __webpack_require__(8389);
const ParameterApi_1 = __webpack_require__(46892);
class FileParameterApi extends ParameterApi_1.ParameterApi {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(parameter) {
        super(parameter);
        // #region Properties (2)
        _FileParameterApi_logger.set(this, viewer_shared_services_1.Logger.instance);
        _FileParameterApi_parameter.set(this, void 0);
        __classPrivateFieldSet(this, _FileParameterApi_parameter, parameter, "f");
    }
    // #endregion Constructors (1)
    // #region Public Methods (2)
    getFilename(fileId) {
        return __awaiter(this, void 0, void 0, function* () {
            return __classPrivateFieldGet(this, _FileParameterApi_parameter, "f").getFilename(fileId);
        });
    }
    upload() {
        return __classPrivateFieldGet(this, _FileParameterApi_parameter, "f").upload();
    }
}
exports.FileParameterApi = FileParameterApi;
_FileParameterApi_logger = new WeakMap(), _FileParameterApi_parameter = new WeakMap();
//# sourceMappingURL=FileParameterApi.js.map

/***/ }),

/***/ 85942:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GumballParameterApi_parameter;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GumballParameterApi = void 0;
const ParameterApi_1 = __webpack_require__(46892);
class GumballParameterApi extends ParameterApi_1.ParameterApi {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(parameter) {
        super(parameter);
        // #region Properties (1)
        _GumballParameterApi_parameter.set(this, void 0);
        __classPrivateFieldSet(this, _GumballParameterApi_parameter, parameter, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (9)
    get enableRotation() {
        return __classPrivateFieldGet(this, _GumballParameterApi_parameter, "f").enableRotation;
    }
    get enableScaling() {
        return __classPrivateFieldGet(this, _GumballParameterApi_parameter, "f").enableScaling;
    }
    get enableTranslation() {
        return __classPrivateFieldGet(this, _GumballParameterApi_parameter, "f").enableTranslation;
    }
    get hover() {
        return __classPrivateFieldGet(this, _GumballParameterApi_parameter, "f").hover;
    }
    get interactionType() {
        return __classPrivateFieldGet(this, _GumballParameterApi_parameter, "f").interactionType;
    }
    get nameFilter() {
        return __classPrivateFieldGet(this, _GumballParameterApi_parameter, "f").nameFilter;
    }
    get scale() {
        return __classPrivateFieldGet(this, _GumballParameterApi_parameter, "f").scale;
    }
    get selectionColor() {
        return __classPrivateFieldGet(this, _GumballParameterApi_parameter, "f").selectionColor;
    }
    get space() {
        return __classPrivateFieldGet(this, _GumballParameterApi_parameter, "f").space;
    }
}
exports.GumballParameterApi = GumballParameterApi;
_GumballParameterApi_parameter = new WeakMap();
//# sourceMappingURL=GumballParameterApi.js.map

/***/ }),

/***/ 46892:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ParameterApi_inputValidator, _ParameterApi_logger, _ParameterApi_parameter;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParameterApi = void 0;
const viewer_shared_services_1 = __webpack_require__(8389);
class ParameterApi {
    // #endregion Properties (3)
    // #region Constructors (1)
    constructor(parameter) {
        // #region Properties (3)
        _ParameterApi_inputValidator.set(this, viewer_shared_services_1.InputValidator.instance);
        _ParameterApi_logger.set(this, viewer_shared_services_1.Logger.instance);
        _ParameterApi_parameter.set(this, void 0);
        __classPrivateFieldSet(this, _ParameterApi_parameter, parameter, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (25)
    get choices() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").choices;
    }
    get decimalplaces() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").decimalplaces;
    }
    get defval() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").defval;
    }
    get displayname() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").displayname;
    }
    set displayname(value) {
        const scope = 'displayname';
        __classPrivateFieldGet(this, _ParameterApi_inputValidator, "f").validateAndError(`ParameterApi.${scope}`, value, 'string', false);
        __classPrivateFieldGet(this, _ParameterApi_parameter, "f").displayname = value;
        __classPrivateFieldGet(this, _ParameterApi_logger, "f").debug(`ParameterApi.${scope}: ${scope} was set to ${__classPrivateFieldGet(this, _ParameterApi_parameter, "f").displayname}.`);
    }
    get expression() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").expression;
    }
    get format() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").format;
    }
    get group() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").group;
    }
    get hidden() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").hidden;
    }
    set hidden(value) {
        const scope = 'hidden';
        __classPrivateFieldGet(this, _ParameterApi_inputValidator, "f").validateAndError(`ParameterApi.${scope}`, value, 'boolean');
        __classPrivateFieldGet(this, _ParameterApi_parameter, "f").hidden = value;
        __classPrivateFieldGet(this, _ParameterApi_logger, "f").debug(`ParameterApi.${scope}: ${scope} was set to ${__classPrivateFieldGet(this, _ParameterApi_parameter, "f").hidden}.`);
    }
    get id() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").id;
    }
    get max() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").max;
    }
    get min() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").min;
    }
    get name() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").name;
    }
    get order() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").order;
    }
    set order(value) {
        const scope = 'order';
        __classPrivateFieldGet(this, _ParameterApi_inputValidator, "f").validateAndError(`ParameterApi.${scope}`, value, 'number', false);
        __classPrivateFieldGet(this, _ParameterApi_parameter, "f").order = value;
        __classPrivateFieldGet(this, _ParameterApi_logger, "f").debug(`ParameterApi.${scope}: ${scope} was set to ${__classPrivateFieldGet(this, _ParameterApi_parameter, "f").order}.`);
    }
    get sessionValue() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").sessionValue;
    }
    set sessionValue(value) {
        const scope = 'sessionValue';
        __classPrivateFieldGet(this, _ParameterApi_parameter, "f").sessionValue = value;
        __classPrivateFieldGet(this, _ParameterApi_logger, "f").debug(`ParameterApi.${scope}: ${scope} was set to ${__classPrivateFieldGet(this, _ParameterApi_parameter, "f").value}.`);
    }
    get settings() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").settings;
    }
    get structure() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").structure;
    }
    get tooltip() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").tooltip;
    }
    set tooltip(value) {
        const scope = 'tooltip';
        __classPrivateFieldGet(this, _ParameterApi_inputValidator, "f").validateAndError(`ParameterApi.${scope}`, value, 'string', false);
        __classPrivateFieldGet(this, _ParameterApi_parameter, "f").tooltip = value;
        __classPrivateFieldGet(this, _ParameterApi_logger, "f").debug(`ParameterApi.${scope}: ${scope} was set to ${__classPrivateFieldGet(this, _ParameterApi_parameter, "f").tooltip}.`);
    }
    get type() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").type;
    }
    get value() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").value;
    }
    set value(value) {
        const scope = 'value';
        this.isValid(value, true);
        __classPrivateFieldGet(this, _ParameterApi_parameter, "f").value = value;
        __classPrivateFieldGet(this, _ParameterApi_logger, "f").debug(`ParameterApi.${scope}: ${scope} was set to ${__classPrivateFieldGet(this, _ParameterApi_parameter, "f").value}.`);
    }
    get visualization() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").visualization;
    }
    // #endregion Public Getters And Setters (25)
    // #region Public Methods (4)
    isValid(value, throwError) {
        const scope = 'isValid';
        __classPrivateFieldGet(this, _ParameterApi_inputValidator, "f").validateAndError(`ParameterApi.${scope}`, throwError, 'boolean', false);
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").isValid(value, throwError);
    }
    resetToDefaultValue() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").resetToDefaultValue();
    }
    resetToSessionValue() {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").resetToSessionValue();
    }
    stringify(value) {
        return __classPrivateFieldGet(this, _ParameterApi_parameter, "f").stringify(value);
    }
}
exports.ParameterApi = ParameterApi;
_ParameterApi_inputValidator = new WeakMap(), _ParameterApi_logger = new WeakMap(), _ParameterApi_parameter = new WeakMap();
//# sourceMappingURL=ParameterApi.js.map

/***/ }),

/***/ 64322:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SelectionParameterApi_parameter;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionParameterApi = void 0;
const ParameterApi_1 = __webpack_require__(46892);
class SelectionParameterApi extends ParameterApi_1.ParameterApi {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(parameter) {
        super(parameter);
        // #region Properties (1)
        _SelectionParameterApi_parameter.set(this, void 0);
        __classPrivateFieldSet(this, _SelectionParameterApi_parameter, parameter, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (5)
    get hover() {
        return __classPrivateFieldGet(this, _SelectionParameterApi_parameter, "f").hover;
    }
    get interactionType() {
        return __classPrivateFieldGet(this, _SelectionParameterApi_parameter, "f").interactionType;
    }
    get maximumSelection() {
        return __classPrivateFieldGet(this, _SelectionParameterApi_parameter, "f").maximumSelection;
    }
    get minimumSelection() {
        return __classPrivateFieldGet(this, _SelectionParameterApi_parameter, "f").minimumSelection;
    }
    get nameFilter() {
        return __classPrivateFieldGet(this, _SelectionParameterApi_parameter, "f").nameFilter;
    }
    get selectionColor() {
        return __classPrivateFieldGet(this, _SelectionParameterApi_parameter, "f").selectionColor;
    }
}
exports.SelectionParameterApi = SelectionParameterApi;
_SelectionParameterApi_parameter = new WeakMap();
//# sourceMappingURL=SelectionParameterApi.js.map

/***/ }),

/***/ 64718:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MaterialGemData = exports.MaterialSpecularGlossinessData = exports.MaterialShadowData = exports.MaterialUnlitData = exports.MaterialStandardData = exports.ShapeDiverResponseModelComputationStatus = exports.Sphere = exports.Box = exports.EVENTTYPE_TASK = exports.EVENTTYPE_DRAWING_TOOLS = exports.EVENTTYPE_GUMBALL = exports.EVENTTYPE_INTERACTION = exports.EVENTTYPE_VIEWPORT = exports.EVENTTYPE_SESSION = exports.EVENTTYPE_SCENE = exports.EVENTTYPE_RENDERING = exports.EVENTTYPE_PARAMETER = exports.EVENTTYPE_OUTPUT = exports.EVENTTYPE_CAMERA = exports.EVENTTYPE = exports.TASK_TYPE = exports.SESSION_SETTINGS_MODE = exports.SDTF_TYPEHINT = exports.TEXTURE_FILTERING = exports.TEXTURE_WRAPPING = exports.MATERIAL_TYPE = exports.MATERIAL_SHADING = exports.MATERIAL_ALPHA = exports.MATERIAL_SIDE = exports.PRIMITIVE_MODE = exports.LOGGING_LEVEL = exports.TAG3D_JUSTIFICATION = exports.PARAMETER_VISUALIZATION = exports.EXPORT_TYPE = exports.PARAMETER_TYPE = exports.TreeNode = exports.Tree = exports.version = exports.generalOptions = exports.sceneTree = exports.removeListener = exports.addListener = exports.sessions = exports.createSession = exports.OutputApiData = exports.SessionApiData = exports.IDrawingParameterJsonSchema = exports.IGumballParameterJsonSchema = exports.ISelectionParameterJsonSchema = exports.IInteractionParameterJsonSchema = void 0;
exports.isViewerCameraError = exports.isViewerLightError = exports.isViewerViewportError = exports.isViewerSessionError = exports.isViewerSettingsError = exports.isViewerWebGLError = exports.isViewerEnvironmentMapError = exports.isViewerDataProcessingError = exports.isViewerUnknownError = exports.isViewerError = exports.ShapeDiverGeometryBackendResponseErrorType = exports.ShapeDiverGeometryBackendResponseError = exports.ShapeDiverGeometryBackendRequestError = exports.ShapeDiverGeometryBackendError = exports.ShapeDiverViewerDrawingToolsError = exports.ShapeDiverViewerInteractionError = exports.ShapeDiverViewerValidationError = exports.ShapeDiverViewerCameraError = exports.ShapeDiverViewerLightError = exports.ShapeDiverViewerArError = exports.ShapeDiverViewerUnknownError = exports.ShapeDiverViewerViewportError = exports.ShapeDiverViewerSessionError = exports.ShapeDiverViewerSettingsError = exports.ShapeDiverViewerWebGLError = exports.ShapeDiverViewerEnvironmentMapError = exports.ShapeDiverViewerDataProcessingError = exports.ShapeDiverViewerError = exports.ShapeDiverViewerErrorType = exports.SessionOutputData = exports.SessionData = exports.SdtfPrimitiveTypeGuard = exports.SDTFItemData = exports.SDTFAttributeData = exports.SDTFAttributesData = exports.SDTFOverviewData = exports.CustomData = exports.HTMLElementAnchorData = exports.HTMLElementAnchorImageData = exports.HTMLElementAnchorTextData = exports.HTMLElementAnchorCustomData = exports.MaterialVariantsData = exports.PrimitiveData = exports.AttributeData = exports.GeometryData = exports.AnimationData = exports.MapData = exports.MaterialBasicLineData = exports.MaterialMultiPointData = exports.MaterialPointData = void 0;
exports.stringify = exports.isValid = exports.isViewerGeometryBackendResponseError = exports.isViewerGeometryBackendRequestError = exports.isViewerGeometryBackendGenericError = exports.isViewerGeometryBackendError = exports.isViewerDrawingToolsError = exports.isViewerInteractionError = exports.isViewerValidationError = exports.isARError = void 0;
const viewer_api_general_1 = __webpack_require__(27444);
Object.defineProperty(exports, "addListener", ({ enumerable: true, get: function () { return viewer_api_general_1.addListener; } }));
Object.defineProperty(exports, "generalOptions", ({ enumerable: true, get: function () { return viewer_api_general_1.generalOptions; } }));
Object.defineProperty(exports, "removeListener", ({ enumerable: true, get: function () { return viewer_api_general_1.removeListener; } }));
Object.defineProperty(exports, "sceneTree", ({ enumerable: true, get: function () { return viewer_api_general_1.sceneTree; } }));
Object.defineProperty(exports, "version", ({ enumerable: true, get: function () { return viewer_api_general_1.version; } }));
const viewer_shared_types_1 = __webpack_require__(64766);
Object.defineProperty(exports, "AnimationData", ({ enumerable: true, get: function () { return viewer_shared_types_1.AnimationData; } }));
Object.defineProperty(exports, "AttributeData", ({ enumerable: true, get: function () { return viewer_shared_types_1.AttributeData; } }));
Object.defineProperty(exports, "CustomData", ({ enumerable: true, get: function () { return viewer_shared_types_1.CustomData; } }));
Object.defineProperty(exports, "GeometryData", ({ enumerable: true, get: function () { return viewer_shared_types_1.GeometryData; } }));
Object.defineProperty(exports, "HTMLElementAnchorCustomData", ({ enumerable: true, get: function () { return viewer_shared_types_1.HTMLElementAnchorCustomData; } }));
Object.defineProperty(exports, "HTMLElementAnchorData", ({ enumerable: true, get: function () { return viewer_shared_types_1.HTMLElementAnchorData; } }));
Object.defineProperty(exports, "HTMLElementAnchorImageData", ({ enumerable: true, get: function () { return viewer_shared_types_1.HTMLElementAnchorImageData; } }));
Object.defineProperty(exports, "HTMLElementAnchorTextData", ({ enumerable: true, get: function () { return viewer_shared_types_1.HTMLElementAnchorTextData; } }));
Object.defineProperty(exports, "IDrawingParameterJsonSchema", ({ enumerable: true, get: function () { return viewer_shared_types_1.IDrawingParameterJsonSchema; } }));
Object.defineProperty(exports, "IGumballParameterJsonSchema", ({ enumerable: true, get: function () { return viewer_shared_types_1.IGumballParameterJsonSchema; } }));
Object.defineProperty(exports, "IInteractionParameterJsonSchema", ({ enumerable: true, get: function () { return viewer_shared_types_1.IInteractionParameterJsonSchema; } }));
Object.defineProperty(exports, "ISelectionParameterJsonSchema", ({ enumerable: true, get: function () { return viewer_shared_types_1.ISelectionParameterJsonSchema; } }));
Object.defineProperty(exports, "MapData", ({ enumerable: true, get: function () { return viewer_shared_types_1.MapData; } }));
Object.defineProperty(exports, "MATERIAL_ALPHA", ({ enumerable: true, get: function () { return viewer_shared_types_1.MATERIAL_ALPHA; } }));
Object.defineProperty(exports, "MATERIAL_SHADING", ({ enumerable: true, get: function () { return viewer_shared_types_1.MATERIAL_SHADING; } }));
Object.defineProperty(exports, "MATERIAL_SIDE", ({ enumerable: true, get: function () { return viewer_shared_types_1.MATERIAL_SIDE; } }));
Object.defineProperty(exports, "MATERIAL_TYPE", ({ enumerable: true, get: function () { return viewer_shared_types_1.MATERIAL_TYPE; } }));
Object.defineProperty(exports, "MaterialBasicLineData", ({ enumerable: true, get: function () { return viewer_shared_types_1.MaterialBasicLineData; } }));
Object.defineProperty(exports, "MaterialGemData", ({ enumerable: true, get: function () { return viewer_shared_types_1.MaterialGemData; } }));
Object.defineProperty(exports, "MaterialMultiPointData", ({ enumerable: true, get: function () { return viewer_shared_types_1.MaterialMultiPointData; } }));
Object.defineProperty(exports, "MaterialPointData", ({ enumerable: true, get: function () { return viewer_shared_types_1.MaterialPointData; } }));
Object.defineProperty(exports, "MaterialShadowData", ({ enumerable: true, get: function () { return viewer_shared_types_1.MaterialShadowData; } }));
Object.defineProperty(exports, "MaterialSpecularGlossinessData", ({ enumerable: true, get: function () { return viewer_shared_types_1.MaterialSpecularGlossinessData; } }));
Object.defineProperty(exports, "MaterialStandardData", ({ enumerable: true, get: function () { return viewer_shared_types_1.MaterialStandardData; } }));
Object.defineProperty(exports, "MaterialUnlitData", ({ enumerable: true, get: function () { return viewer_shared_types_1.MaterialUnlitData; } }));
Object.defineProperty(exports, "MaterialVariantsData", ({ enumerable: true, get: function () { return viewer_shared_types_1.MaterialVariantsData; } }));
Object.defineProperty(exports, "PARAMETER_TYPE", ({ enumerable: true, get: function () { return viewer_shared_types_1.PARAMETER_TYPE; } }));
Object.defineProperty(exports, "PARAMETER_VISUALIZATION", ({ enumerable: true, get: function () { return viewer_shared_types_1.PARAMETER_VISUALIZATION; } }));
Object.defineProperty(exports, "PRIMITIVE_MODE", ({ enumerable: true, get: function () { return viewer_shared_types_1.PRIMITIVE_MODE; } }));
Object.defineProperty(exports, "PrimitiveData", ({ enumerable: true, get: function () { return viewer_shared_types_1.PrimitiveData; } }));
Object.defineProperty(exports, "SDTF_TYPEHINT", ({ enumerable: true, get: function () { return viewer_shared_types_1.SDTF_TYPEHINT; } }));
Object.defineProperty(exports, "SDTFAttributeData", ({ enumerable: true, get: function () { return viewer_shared_types_1.SDTFAttributeData; } }));
Object.defineProperty(exports, "SDTFAttributesData", ({ enumerable: true, get: function () { return viewer_shared_types_1.SDTFAttributesData; } }));
Object.defineProperty(exports, "SDTFItemData", ({ enumerable: true, get: function () { return viewer_shared_types_1.SDTFItemData; } }));
Object.defineProperty(exports, "SDTFOverviewData", ({ enumerable: true, get: function () { return viewer_shared_types_1.SDTFOverviewData; } }));
Object.defineProperty(exports, "SdtfPrimitiveTypeGuard", ({ enumerable: true, get: function () { return viewer_shared_types_1.SdtfPrimitiveTypeGuard; } }));
Object.defineProperty(exports, "TASK_TYPE", ({ enumerable: true, get: function () { return viewer_shared_types_1.TASK_TYPE; } }));
Object.defineProperty(exports, "TEXTURE_FILTERING", ({ enumerable: true, get: function () { return viewer_shared_types_1.TEXTURE_FILTERING; } }));
Object.defineProperty(exports, "TEXTURE_WRAPPING", ({ enumerable: true, get: function () { return viewer_shared_types_1.TEXTURE_WRAPPING; } }));
const viewer_shared_math_1 = __webpack_require__(67275);
Object.defineProperty(exports, "Box", ({ enumerable: true, get: function () { return viewer_shared_math_1.Box; } }));
Object.defineProperty(exports, "Sphere", ({ enumerable: true, get: function () { return viewer_shared_math_1.Sphere; } }));
const main_1 = __webpack_require__(28081);
Object.defineProperty(exports, "createSession", ({ enumerable: true, get: function () { return main_1.createSession; } }));
Object.defineProperty(exports, "sessions", ({ enumerable: true, get: function () { return main_1.sessions; } }));
const viewer_shared_services_1 = __webpack_require__(8389);
Object.defineProperty(exports, "EVENTTYPE", ({ enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE; } }));
Object.defineProperty(exports, "EVENTTYPE_CAMERA", ({ enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_CAMERA; } }));
Object.defineProperty(exports, "EVENTTYPE_DRAWING_TOOLS", ({ enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_DRAWING_TOOLS; } }));
Object.defineProperty(exports, "EVENTTYPE_GUMBALL", ({ enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_GUMBALL; } }));
Object.defineProperty(exports, "EVENTTYPE_INTERACTION", ({ enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_INTERACTION; } }));
Object.defineProperty(exports, "EVENTTYPE_OUTPUT", ({ enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_OUTPUT; } }));
Object.defineProperty(exports, "EVENTTYPE_PARAMETER", ({ enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_PARAMETER; } }));
Object.defineProperty(exports, "EVENTTYPE_RENDERING", ({ enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_RENDERING; } }));
Object.defineProperty(exports, "EVENTTYPE_SCENE", ({ enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_SCENE; } }));
Object.defineProperty(exports, "EVENTTYPE_SESSION", ({ enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_SESSION; } }));
Object.defineProperty(exports, "EVENTTYPE_TASK", ({ enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_TASK; } }));
Object.defineProperty(exports, "EVENTTYPE_VIEWPORT", ({ enumerable: true, get: function () { return viewer_shared_services_1.EVENTTYPE_VIEWPORT; } }));
Object.defineProperty(exports, "isARError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isARError; } }));
Object.defineProperty(exports, "isValid", ({ enumerable: true, get: function () { return viewer_shared_services_1.isValid; } }));
Object.defineProperty(exports, "isViewerCameraError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerCameraError; } }));
Object.defineProperty(exports, "isViewerDataProcessingError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerDataProcessingError; } }));
Object.defineProperty(exports, "isViewerDrawingToolsError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerDrawingToolsError; } }));
Object.defineProperty(exports, "isViewerEnvironmentMapError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerEnvironmentMapError; } }));
Object.defineProperty(exports, "isViewerError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerError; } }));
Object.defineProperty(exports, "isViewerGeometryBackendError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerGeometryBackendError; } }));
Object.defineProperty(exports, "isViewerGeometryBackendGenericError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerGeometryBackendGenericError; } }));
Object.defineProperty(exports, "isViewerGeometryBackendRequestError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerGeometryBackendRequestError; } }));
Object.defineProperty(exports, "isViewerGeometryBackendResponseError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerGeometryBackendResponseError; } }));
Object.defineProperty(exports, "isViewerInteractionError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerInteractionError; } }));
Object.defineProperty(exports, "isViewerLightError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerLightError; } }));
Object.defineProperty(exports, "isViewerSessionError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerSessionError; } }));
Object.defineProperty(exports, "isViewerSettingsError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerSettingsError; } }));
Object.defineProperty(exports, "isViewerUnknownError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerUnknownError; } }));
Object.defineProperty(exports, "isViewerValidationError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerValidationError; } }));
Object.defineProperty(exports, "isViewerViewportError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerViewportError; } }));
Object.defineProperty(exports, "isViewerWebGLError", ({ enumerable: true, get: function () { return viewer_shared_services_1.isViewerWebGLError; } }));
Object.defineProperty(exports, "LOGGING_LEVEL", ({ enumerable: true, get: function () { return viewer_shared_services_1.LOGGING_LEVEL; } }));
Object.defineProperty(exports, "SESSION_SETTINGS_MODE", ({ enumerable: true, get: function () { return viewer_shared_services_1.SESSION_SETTINGS_MODE; } }));
Object.defineProperty(exports, "ShapeDiverGeometryBackendError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverGeometryBackendError; } }));
Object.defineProperty(exports, "ShapeDiverGeometryBackendRequestError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverGeometryBackendRequestError; } }));
Object.defineProperty(exports, "ShapeDiverGeometryBackendResponseError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverGeometryBackendResponseError; } }));
Object.defineProperty(exports, "ShapeDiverGeometryBackendResponseErrorType", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverGeometryBackendResponseErrorType; } }));
Object.defineProperty(exports, "ShapeDiverViewerArError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerArError; } }));
Object.defineProperty(exports, "ShapeDiverViewerCameraError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerCameraError; } }));
Object.defineProperty(exports, "ShapeDiverViewerDataProcessingError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerDataProcessingError; } }));
Object.defineProperty(exports, "ShapeDiverViewerDrawingToolsError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerDrawingToolsError; } }));
Object.defineProperty(exports, "ShapeDiverViewerEnvironmentMapError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerEnvironmentMapError; } }));
Object.defineProperty(exports, "ShapeDiverViewerError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerError; } }));
Object.defineProperty(exports, "ShapeDiverViewerErrorType", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerErrorType; } }));
Object.defineProperty(exports, "ShapeDiverViewerInteractionError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerInteractionError; } }));
Object.defineProperty(exports, "ShapeDiverViewerLightError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerLightError; } }));
Object.defineProperty(exports, "ShapeDiverViewerSessionError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerSessionError; } }));
Object.defineProperty(exports, "ShapeDiverViewerSettingsError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerSettingsError; } }));
Object.defineProperty(exports, "ShapeDiverViewerUnknownError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerUnknownError; } }));
Object.defineProperty(exports, "ShapeDiverViewerValidationError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerValidationError; } }));
Object.defineProperty(exports, "ShapeDiverViewerViewportError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerViewportError; } }));
Object.defineProperty(exports, "ShapeDiverViewerWebGLError", ({ enumerable: true, get: function () { return viewer_shared_services_1.ShapeDiverViewerWebGLError; } }));
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return viewer_shared_services_1.stringify; } }));
const viewer_data_engine_shared_types_1 = __webpack_require__(3816);
Object.defineProperty(exports, "TAG3D_JUSTIFICATION", ({ enumerable: true, get: function () { return viewer_data_engine_shared_types_1.TAG3D_JUSTIFICATION; } }));
const viewer_session_engine_session_engine_1 = __webpack_require__(4466);
Object.defineProperty(exports, "SessionData", ({ enumerable: true, get: function () { return viewer_session_engine_session_engine_1.SessionData; } }));
Object.defineProperty(exports, "SessionOutputData", ({ enumerable: true, get: function () { return viewer_session_engine_session_engine_1.SessionOutputData; } }));
const viewer_shared_node_tree_1 = __webpack_require__(41652);
Object.defineProperty(exports, "Tree", ({ enumerable: true, get: function () { return viewer_shared_node_tree_1.Tree; } }));
Object.defineProperty(exports, "TreeNode", ({ enumerable: true, get: function () { return viewer_shared_node_tree_1.TreeNode; } }));
const OutputApiData_1 = __webpack_require__(85149);
Object.defineProperty(exports, "OutputApiData", ({ enumerable: true, get: function () { return OutputApiData_1.OutputApiData; } }));
const SessionApiData_1 = __webpack_require__(14812);
Object.defineProperty(exports, "SessionApiData", ({ enumerable: true, get: function () { return SessionApiData_1.SessionApiData; } }));
const sdk_geometry_api_sdk_v2_1 = __webpack_require__(50059);
Object.defineProperty(exports, "ShapeDiverResponseModelComputationStatus", ({ enumerable: true, get: function () { return sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus; } }));
const sdk_geometry_api_sdk_v2_2 = __webpack_require__(50059);
Object.defineProperty(exports, "EXPORT_TYPE", ({ enumerable: true, get: function () { return sdk_geometry_api_sdk_v2_2.ShapeDiverResponseExportDefinitionType; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 28081:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createSession = exports.sessions = void 0;
const viewer_creation_control_center_session_1 = __webpack_require__(71479);
const viewer_shared_services_1 = __webpack_require__(8389);
const SessionApi_1 = __webpack_require__(30377);
const viewer_api_general_1 = __webpack_require__(27444);
const creationControlCenterSession = viewer_creation_control_center_session_1.CreationControlCenterSession.instance;
const inputValidator = viewer_shared_services_1.InputValidator.instance;
const logger = viewer_shared_services_1.Logger.instance;
/**
 * The sessions that are currently being used.
 */
exports.sessions = {};
// Whenever a session or viewport is added or removed, this update is called.
creationControlCenterSession.updateSessions = (sessionEngines) => {
    for (const s in sessionEngines)
        if (!exports.sessions[s])
            exports.sessions[s] = new SessionApi_1.SessionApi(sessionEngines[s]);
    for (const s in exports.sessions)
        if (!sessionEngines[s])
            delete exports.sessions[s];
};
/**
 * Create and initialize a session with a model hosted on a
 * {@link https://help.shapediver.com/doc/Geometry-Backend.1863942173.html|ShapeDiver Geometry Backend},
 * using the provided ticket/guid and modelViewUrl.
 * Returns a session api object allowing to control the session.
 *
 * A JWT can be specified for authorizing the API calls to the Geometry Backend.
 * The model's settings on the Geometry Backend might require a JWT to be provided.
 *
 * By default the outputs of the model for its default parameter values will be loaded.
 *
 * An optional identifier for the session can be provided. This identifier can be used to retrieve the
 * api object from {@link sessions}. In case no identifier is provided, a unique one will be generated.
 *
 * @param properties.ticket The ticket for direct embedding of the model represented by the session. This identifies the model on the Geometry Backend. If no ticket was provided, a {@link guid} has to be provided instead.
 * @param properties.guid The geometry backend model id (guid). This identifies the model on the Geometry Backend. A {@link jwtToken} is needed for authentication. If no guid was provided, a {@link ticket} has to be provided instead.
 * @param properties.modelViewUrl The modelViewUrl of the {@link https://help.shapediver.com/doc/Geometry-Backend.1863942173.html|ShapeDiver Geometry Backend} hosting the model.
 * @param properties.jwtToken The JWT to use for authorizing the API calls to the Geometry Backend.
 * @param properties.id The unique identifier to use for the session.
 * @param properties.waitForOutputs Option to wait for the outputs to be loaded, or return immediately after creation of the session. (default: true)
 * @param properties.loadOutputs Option to load the outputs, or not load them until the first call of {@link ISession.customize}. (default: true)
 * @param properties.loadSdtf Option to load the SDTF data. The data is not loaded by default as it can be quite large. (default: false)
 * @param properties.excludeViewports Option to exclude some viewports from the start. Can be accessed via {@link ISession.excludeViewports}.
 * @param properties.initialParameterValues The initial set of parameter values to use. Map from parameter id to parameter value. The default value will be used for any parameter not specified.
 * @param properties.allowOutputLoading Option to allow the outputs to be loaded, or to prevent them from being loaded. (default: true)
 * @param properties.modelStateId The optional model state id to use for the session. If not provided, no model state will be loaded.
 * @param properties.modelStateValidationMode The optional model state validation mode to use for the session. If not provided, the default validation mode of the Geometry SDK will be used.
 * @returns
 */
const createSession = (properties) => __awaiter(void 0, void 0, void 0, function* () {
    (0, viewer_api_general_1.showConsoleMessage)();
    logger.debug(`createSession: Creating and initializing session with properties ${JSON.stringify(properties)}.`);
    // input validation
    inputValidator.validateAndError('createSession', properties, 'object');
    inputValidator.validateAndError('createSession', properties.ticket, 'string', false);
    inputValidator.validateAndError('createSession', properties.guid, 'string', false);
    inputValidator.validateAndError('createSession', properties.modelViewUrl, 'string');
    inputValidator.validateAndError('createSession', properties.jwtToken, 'string', false);
    inputValidator.validateAndError('createSession', properties.id, 'string', false);
    inputValidator.validateAndError('createSession', properties.waitForOutputs, 'boolean', false);
    inputValidator.validateAndError('createSession', properties.loadOutputs, 'boolean', false);
    inputValidator.validateAndError('createSession', properties.loadSdtf, 'boolean', false);
    inputValidator.validateAndError('createSession', properties.excludeViewports, 'stringArray', false);
    inputValidator.validateAndError('createSession', properties.initialParameterValues, 'object', false);
    inputValidator.validateAndError('createSession', properties.allowOutputLoading, 'boolean', false);
    inputValidator.validateAndError('createSession', properties.modelStateId, 'string', false);
    inputValidator.validateAndError('createSession', properties.modelStateValidationMode, 'boolean', false);
    if (properties.initialParameterValues)
        for (const p in properties.initialParameterValues)
            inputValidator.validateAndError('createSession', properties.initialParameterValues[p], 'string');
    // we either expect a ticket or guid + jwtToken, error if we get both
    if (properties.ticket !== undefined && properties.guid !== undefined)
        throw new viewer_shared_services_1.ShapeDiverViewerSessionError('createSession: A ticket and a guid were provided for the session creation. Please only provide one or the other. The session was not created.');
    // we either expect a ticket or guid + jwtToken, error if we get none
    if (properties.ticket === undefined && properties.guid === undefined)
        throw new viewer_shared_services_1.ShapeDiverViewerSessionError('createSession: Neither a ticket nor a guid were provided for the session creation. Please provide one or the other. The session was not created.');
    // we either expect a guid + jwtToken, error if the jwtToken is missing
    if (properties.guid !== undefined && properties.jwtToken === undefined)
        throw new viewer_shared_services_1.ShapeDiverViewerSessionError('createSession: When creating a session with a guid, a jwtToken is required, please provide one. The session was not created.');
    if (properties.waitForOutputs === undefined)
        properties.waitForOutputs = true;
    if (properties.loadOutputs === undefined)
        properties.loadOutputs = true;
    const sessionEngine = yield creationControlCenterSession.createSessionEngine(properties);
    exports.sessions[sessionEngine.id] = new SessionApi_1.SessionApi(sessionEngine);
    return exports.sessions[sessionEngine.id];
});
exports.createSession = createSession;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 66739:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * postprocessing v6.35.3 build Sat Mar 30 2024
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2024 Raoul van Rüschen
 * @license Zlib
 */

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.js
var src_exports = {};
__export(src_exports, {
  AdaptiveLuminanceMaterial: () => AdaptiveLuminanceMaterial,
  AdaptiveLuminancePass: () => AdaptiveLuminancePass,
  BlendFunction: () => BlendFunction,
  BlendMode: () => BlendMode,
  BloomEffect: () => BloomEffect,
  BlurPass: () => KawaseBlurPass,
  BokehEffect: () => BokehEffect,
  BokehMaterial: () => BokehMaterial,
  BoxBlurMaterial: () => BoxBlurMaterial,
  BoxBlurPass: () => BoxBlurPass,
  BrightnessContrastEffect: () => BrightnessContrastEffect,
  ChromaticAberrationEffect: () => ChromaticAberrationEffect,
  CircleOfConfusionMaterial: () => CircleOfConfusionMaterial,
  ClearMaskPass: () => ClearMaskPass,
  ClearPass: () => ClearPass,
  ColorAverageEffect: () => ColorAverageEffect,
  ColorChannel: () => ColorChannel,
  ColorDepthEffect: () => ColorDepthEffect,
  ColorEdgesMaterial: () => EdgeDetectionMaterial,
  ConvolutionMaterial: () => KawaseBlurMaterial,
  CopyMaterial: () => CopyMaterial,
  CopyPass: () => CopyPass,
  DepthComparisonMaterial: () => DepthComparisonMaterial,
  DepthCopyMaterial: () => DepthCopyMaterial,
  DepthCopyMode: () => DepthCopyMode,
  DepthCopyPass: () => DepthCopyPass,
  DepthDownsamplingMaterial: () => DepthDownsamplingMaterial,
  DepthDownsamplingPass: () => DepthDownsamplingPass,
  DepthEffect: () => DepthEffect,
  DepthMaskMaterial: () => DepthMaskMaterial,
  DepthOfFieldEffect: () => DepthOfFieldEffect,
  DepthPass: () => DepthPass,
  DepthPickingPass: () => DepthPickingPass,
  DepthSavePass: () => DepthCopyPass,
  DepthTestStrategy: () => DepthTestStrategy,
  Disposable: () => Disposable,
  DotScreenEffect: () => DotScreenEffect,
  DownsamplingMaterial: () => DownsamplingMaterial,
  EdgeDetectionMaterial: () => EdgeDetectionMaterial,
  EdgeDetectionMode: () => EdgeDetectionMode,
  Effect: () => Effect,
  EffectAttribute: () => EffectAttribute,
  EffectComposer: () => EffectComposer,
  EffectMaterial: () => EffectMaterial,
  EffectPass: () => EffectPass,
  EffectShaderData: () => EffectShaderData,
  EffectShaderSection: () => EffectShaderSection,
  FXAAEffect: () => FXAAEffect,
  GammaCorrectionEffect: () => GammaCorrectionEffect,
  GaussKernel: () => GaussKernel,
  GaussianBlurMaterial: () => GaussianBlurMaterial,
  GaussianBlurPass: () => GaussianBlurPass,
  GlitchEffect: () => GlitchEffect,
  GlitchMode: () => GlitchMode,
  GodRaysEffect: () => GodRaysEffect,
  GodRaysMaterial: () => GodRaysMaterial,
  GridEffect: () => GridEffect,
  HueSaturationEffect: () => HueSaturationEffect,
  ImmutableTimer: () => ImmutableTimer,
  Initializable: () => Initializable,
  KawaseBlurMaterial: () => KawaseBlurMaterial,
  KawaseBlurPass: () => KawaseBlurPass,
  KernelSize: () => KernelSize,
  LUT1DEffect: () => LUT1DEffect,
  LUT3DEffect: () => LUT3DEffect,
  LUT3dlLoader: () => LUT3dlLoader,
  LUTCubeLoader: () => LUTCubeLoader,
  LUTEffect: () => LUT3DEffect,
  LUTOperation: () => LUTOperation,
  LambdaPass: () => LambdaPass,
  LensDistortionEffect: () => LensDistortionEffect,
  LookupTexture: () => LookupTexture,
  LookupTexture3D: () => LookupTexture,
  LuminanceMaterial: () => LuminanceMaterial,
  LuminancePass: () => LuminancePass,
  MaskFunction: () => MaskFunction,
  MaskMaterial: () => MaskMaterial,
  MaskPass: () => MaskPass,
  MipmapBlurPass: () => MipmapBlurPass,
  NoiseEffect: () => NoiseEffect,
  NoiseTexture: () => NoiseTexture,
  NormalPass: () => NormalPass,
  OutlineEdgesMaterial: () => OutlineMaterial,
  OutlineEffect: () => OutlineEffect,
  OutlineMaterial: () => OutlineMaterial,
  OverrideMaterialManager: () => OverrideMaterialManager,
  Pass: () => Pass,
  PixelationEffect: () => PixelationEffect,
  PredicationMode: () => PredicationMode,
  RawImageData: () => RawImageData,
  RealisticBokehEffect: () => RealisticBokehEffect,
  RenderPass: () => RenderPass,
  Resizable: () => Resizable,
  Resizer: () => Resolution,
  Resolution: () => Resolution,
  SMAAAreaImageData: () => SMAAAreaImageData,
  SMAAEffect: () => SMAAEffect,
  SMAAImageGenerator: () => SMAAImageGenerator,
  SMAAImageLoader: () => SMAAImageLoader,
  SMAAPreset: () => SMAAPreset,
  SMAASearchImageData: () => SMAASearchImageData,
  SMAAWeightsMaterial: () => SMAAWeightsMaterial,
  SSAOEffect: () => SSAOEffect,
  SSAOMaterial: () => SSAOMaterial,
  SavePass: () => CopyPass,
  ScanlineEffect: () => ScanlineEffect,
  Section: () => EffectShaderSection,
  Selection: () => Selection,
  SelectiveBloomEffect: () => SelectiveBloomEffect,
  SepiaEffect: () => SepiaEffect,
  ShaderPass: () => ShaderPass,
  ShockWaveEffect: () => ShockWaveEffect,
  TetrahedralUpscaler: () => TetrahedralUpscaler,
  TextureEffect: () => TextureEffect,
  TiltShiftBlurMaterial: () => TiltShiftBlurMaterial,
  TiltShiftBlurPass: () => TiltShiftBlurPass,
  TiltShiftEffect: () => TiltShiftEffect,
  Timer: () => Timer,
  ToneMappingEffect: () => ToneMappingEffect,
  ToneMappingMode: () => ToneMappingMode,
  UpsamplingMaterial: () => UpsamplingMaterial,
  VignetteEffect: () => VignetteEffect,
  VignetteTechnique: () => VignetteTechnique,
  WebGLExtension: () => WebGLExtension,
  version: () => version
});
module.exports = __toCommonJS(src_exports);

// package.json
var version = "6.35.3";

// src/core/Disposable.js
var Disposable = class {
  /**
   * Frees internal resources.
   */
  dispose() {
  }
};

// src/core/EffectComposer.js
var import_three6 = __webpack_require__(39437);

// src/core/Timer.js
var MILLISECONDS_TO_SECONDS = 1 / 1e3;
var SECONDS_TO_MILLISECONDS = 1e3;
var Timer = class {
  /**
   * Constructs a new timer.
   */
  constructor() {
    this.startTime = performance.now();
    this.previousTime = 0;
    this.currentTime = 0;
    this._delta = 0;
    this._elapsed = 0;
    this._fixedDelta = 1e3 / 60;
    this.timescale = 1;
    this.useFixedDelta = false;
    this._autoReset = false;
  }
  /**
   * Enables or disables auto reset based on page visibility.
   *
   * If enabled, the timer will be reset when the page becomes visible. This effectively pauses the timer when the page
   * is hidden. Has no effect if the API is not supported.
   *
   * @type {Boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API
   */
  get autoReset() {
    return this._autoReset;
  }
  set autoReset(value) {
    if (typeof document !== "undefined" && document.hidden !== void 0) {
      if (value) {
        document.addEventListener("visibilitychange", this);
      } else {
        document.removeEventListener("visibilitychange", this);
      }
      this._autoReset = value;
    }
  }
  get delta() {
    return this._delta * MILLISECONDS_TO_SECONDS;
  }
  get fixedDelta() {
    return this._fixedDelta * MILLISECONDS_TO_SECONDS;
  }
  set fixedDelta(value) {
    this._fixedDelta = value * SECONDS_TO_MILLISECONDS;
  }
  get elapsed() {
    return this._elapsed * MILLISECONDS_TO_SECONDS;
  }
  /**
   * Updates this timer.
   *
   * @param {Boolean} [timestamp] - The current time in milliseconds.
   */
  update(timestamp) {
    if (this.useFixedDelta) {
      this._delta = this.fixedDelta;
    } else {
      this.previousTime = this.currentTime;
      this.currentTime = (timestamp !== void 0 ? timestamp : performance.now()) - this.startTime;
      this._delta = this.currentTime - this.previousTime;
    }
    this._delta *= this.timescale;
    this._elapsed += this._delta;
  }
  /**
   * Resets this timer.
   */
  reset() {
    this._delta = 0;
    this._elapsed = 0;
    this.currentTime = performance.now() - this.startTime;
  }
  getDelta() {
    return this.delta;
  }
  getElapsed() {
    return this.elapsed;
  }
  handleEvent(e) {
    if (!document.hidden) {
      this.currentTime = performance.now() - this.startTime;
    }
  }
  dispose() {
    this.autoReset = false;
  }
};

// src/passes/Pass.js
var import_three = __webpack_require__(39437);
var dummyCamera = /* @__PURE__ */ new import_three.Camera();
var geometry = null;
function getFullscreenTriangle() {
  if (geometry === null) {
    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
    geometry = new import_three.BufferGeometry();
    if (geometry.setAttribute !== void 0) {
      geometry.setAttribute("position", new import_three.BufferAttribute(vertices, 3));
      geometry.setAttribute("uv", new import_three.BufferAttribute(uvs, 2));
    } else {
      geometry.addAttribute("position", new import_three.BufferAttribute(vertices, 3));
      geometry.addAttribute("uv", new import_three.BufferAttribute(uvs, 2));
    }
  }
  return geometry;
}
var Pass = class _Pass {
  /**
   * Constructs a new pass.
   *
   * @param {String} [name] - The name of this pass. Does not have to be unique.
   * @param {Scene} [scene] - The scene to render. The default scene contains a single mesh that fills the screen.
   * @param {Camera} [camera] - A camera. Fullscreen effect passes don't require a camera.
   */
  constructor(name = "Pass", scene = new import_three.Scene(), camera = dummyCamera) {
    this.name = name;
    this.renderer = null;
    this.scene = scene;
    this.camera = camera;
    this.screen = null;
    this.rtt = true;
    this.needsSwap = true;
    this.needsDepthTexture = false;
    this.enabled = true;
  }
  /**
   * Sets the render to screen flag.
   *
   * If this flag is changed, the fullscreen material will be updated as well.
   *
   * @type {Boolean}
   */
  get renderToScreen() {
    return !this.rtt;
  }
  set renderToScreen(value) {
    if (this.rtt === value) {
      const material = this.fullscreenMaterial;
      if (material !== null) {
        material.needsUpdate = true;
      }
      this.rtt = !value;
    }
  }
  /**
   * Sets the main scene.
   *
   * @type {Scene}
   */
  set mainScene(value) {
  }
  /**
   * Sets the main camera.
   *
   * @type {Camera}
   */
  set mainCamera(value) {
  }
  /**
   * Sets the renderer
   *
   * @deprecated
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  /**
   * Indicates whether this pass is enabled.
   *
   * @deprecated Use enabled instead.
   * @return {Boolean} Whether this pass is enabled.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables this pass.
   *
   * @deprecated Use enabled instead.
   * @param {Boolean} value - Whether the pass should be enabled.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * The fullscreen material.
   *
   * @type {Material}
   */
  get fullscreenMaterial() {
    return this.screen !== null ? this.screen.material : null;
  }
  set fullscreenMaterial(value) {
    let screen = this.screen;
    if (screen !== null) {
      screen.material = value;
    } else {
      screen = new import_three.Mesh(getFullscreenTriangle(), value);
      screen.frustumCulled = false;
      if (this.scene === null) {
        this.scene = new import_three.Scene();
      }
      this.scene.add(screen);
      this.screen = screen;
    }
  }
  /**
   * Returns the current fullscreen material.
   *
   * @deprecated Use fullscreenMaterial instead.
   * @return {Material} The current fullscreen material, or null if there is none.
   */
  getFullscreenMaterial() {
    return this.fullscreenMaterial;
  }
  /**
   * Sets the fullscreen material.
   *
   * @deprecated Use fullscreenMaterial instead.
   * @protected
   * @param {Material} value - A fullscreen material.
   */
  setFullscreenMaterial(value) {
    this.fullscreenMaterial = value;
  }
  /**
   * Returns the current depth texture.
   *
   * @return {Texture} The current depth texture, or null if there is none.
   */
  getDepthTexture() {
    return null;
  }
  /**
   * Sets the depth texture.
   *
   * This method will be called automatically by the {@link EffectComposer}.
   * You may override this method if your pass relies on the depth information of a preceding {@link RenderPass}.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategy} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = import_three.BasicDepthPacking) {
  }
  /**
   * Renders this pass.
   *
   * This is an abstract method that must be overridden.
   *
   * @abstract
   * @throws {Error} An error is thrown if the method is not overridden.
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    throw new Error("Render method not implemented!");
  }
  /**
   * Sets the size.
   *
   * You may override this method if you want to be informed about the size of the backbuffer/canvas.
   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
  }
  /**
   * Performs initialization tasks.
   *
   * This method is called when this pass is added to an {@link EffectComposer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
  }
  /**
   * Performs a shallow search for disposable properties and deletes them.
   *
   * The {@link EffectComposer} calls this method when it is being destroyed. You can use it independently to free
   * memory when you're certain that you don't need this pass anymore.
   */
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof import_three.WebGLRenderTarget || property instanceof import_three.Material || property instanceof import_three.Texture || property instanceof _Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
  }
};

// src/passes/ClearMaskPass.js
var ClearMaskPass = class extends Pass {
  /**
   * Constructs a new clear mask pass.
   */
  constructor() {
    super("ClearMaskPass", null, null);
    this.needsSwap = false;
  }
  /**
   * Disables the global stencil test.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const stencil = renderer.state.buffers.stencil;
    stencil.setLocked(false);
    stencil.setTest(false);
  }
};

// src/passes/CopyPass.js
var import_three4 = __webpack_require__(39437);

// src/materials/CopyMaterial.js
var import_three3 = __webpack_require__(39437);

// src/utils/BackCompat.js
var import_three2 = __webpack_require__(39437);
var revision = Number(import_three2.REVISION.replace(/\D+/g, ""));
function updateFragmentShader(fragmentShader) {
  if (revision < 154) {
    return fragmentShader.replace("colorspace_fragment", "encodings_fragment");
  }
  return fragmentShader;
}

// src/materials/glsl/copy.frag
var copy_default = "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}";

// src/materials/glsl/common.vert
var common_default = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/CopyMaterial.js
var CopyMaterial = class extends import_three3.ShaderMaterial {
  /**
   * Constructs a new copy material.
   */
  constructor() {
    super({
      name: "CopyMaterial",
      uniforms: {
        inputBuffer: new import_three3.Uniform(null),
        opacity: new import_three3.Uniform(1)
      },
      blending: import_three3.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: copy_default,
      vertexShader: common_default
    });
    this.fragmentShader = updateFragmentShader(this.fragmentShader);
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Number} value - The buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Returns the opacity.
   *
   * @deprecated Use opacity instead.
   * @return {Number} The opacity.
   */
  getOpacity(value) {
    return this.uniforms.opacity.value;
  }
  /**
   * Sets the opacity.
   *
   * @deprecated Use opacity instead.
   * @param {Number} value - The opacity.
   */
  setOpacity(value) {
    this.uniforms.opacity.value = value;
  }
};

// src/passes/CopyPass.js
var CopyPass = class extends Pass {
  /**
   * Constructs a new save pass.
   *
   * @param {WebGLRenderTarget} [renderTarget] - A render target.
   * @param {Boolean} [autoResize=true] - Whether the render target size should be updated automatically.
   */
  constructor(renderTarget, autoResize = true) {
    super("CopyPass");
    this.fullscreenMaterial = new CopyMaterial();
    this.needsSwap = false;
    this.renderTarget = renderTarget;
    if (renderTarget === void 0) {
      this.renderTarget = new import_three4.WebGLRenderTarget(1, 1, {
        minFilter: import_three4.LinearFilter,
        magFilter: import_three4.LinearFilter,
        stencilBuffer: false,
        depthBuffer: false
      });
      this.renderTarget.texture.name = "CopyPass.Target";
    }
    this.autoResize = autoResize;
  }
  /**
   * Enables or disables auto resizing of the render target.
   *
   * @deprecated Use autoResize instead.
   * @type {Boolean}
   */
  get resize() {
    return this.autoResize;
  }
  set resize(value) {
    this.autoResize = value;
  }
  /**
   * The output texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the output texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Enables or disables auto resizing of the render target.
   *
   * @deprecated Use autoResize instead.
   * @param {Boolean} value - Whether the render target size should be updated automatically.
   */
  setAutoResizeEnabled(value) {
    this.autoResize = value;
  }
  /**
   * Saves the input buffer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    this.fullscreenMaterial.inputBuffer = inputBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    if (this.autoResize) {
      this.renderTarget.setSize(width, height);
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (frameBufferType !== import_three4.UnsignedByteType) {
        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === import_three4.SRGBColorSpace) {
        this.renderTarget.texture.colorSpace = import_three4.SRGBColorSpace;
      }
    }
  }
};

// src/passes/ClearPass.js
var import_three5 = __webpack_require__(39437);
var color = /* @__PURE__ */ new import_three5.Color();
var ClearPass = class extends Pass {
  /**
   * Constructs a new clear pass.
   *
   * @param {Boolean} [color=true] - Determines whether the color buffer should be cleared.
   * @param {Boolean} [depth=true] - Determines whether the depth buffer should be cleared.
   * @param {Boolean} [stencil=false] - Determines whether the stencil buffer should be cleared.
   */
  constructor(color2 = true, depth = true, stencil = false) {
    super("ClearPass", null, null);
    this.needsSwap = false;
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
    this.overrideClearColor = null;
    this.overrideClearAlpha = -1;
  }
  /**
   * Sets the clear flags.
   *
   * @param {Boolean} color - Whether the color buffer should be cleared.
   * @param {Boolean} depth - Whether the depth buffer should be cleared.
   * @param {Boolean} stencil - Whether the stencil buffer should be cleared.
   */
  setClearFlags(color2, depth, stencil) {
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
  }
  /**
   * Returns the override clear color. Default is null.
   *
   * @deprecated Use overrideClearColor instead.
   * @return {Color} The clear color.
   */
  getOverrideClearColor() {
    return this.overrideClearColor;
  }
  /**
   * Sets the override clear color.
   *
   * @deprecated Use overrideClearColor instead.
   * @param {Color} value - The clear color.
   */
  setOverrideClearColor(value) {
    this.overrideClearColor = value;
  }
  /**
   * Returns the override clear alpha. Default is -1.
   *
   * @deprecated Use overrideClearAlpha instead.
   * @return {Number} The clear alpha.
   */
  getOverrideClearAlpha() {
    return this.overrideClearAlpha;
  }
  /**
   * Sets the override clear alpha.
   *
   * @deprecated Use overrideClearAlpha instead.
   * @param {Number} value - The clear alpha.
   */
  setOverrideClearAlpha(value) {
    this.overrideClearAlpha = value;
  }
  /**
   * Clears the input buffer or the screen.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const overrideClearColor = this.overrideClearColor;
    const overrideClearAlpha = this.overrideClearAlpha;
    const clearAlpha = renderer.getClearAlpha();
    const hasOverrideClearColor = overrideClearColor !== null;
    const hasOverrideClearAlpha = overrideClearAlpha >= 0;
    if (hasOverrideClearColor) {
      renderer.getClearColor(color);
      renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(overrideClearAlpha);
    }
    renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);
    renderer.clear(this.color, this.depth, this.stencil);
    if (hasOverrideClearColor) {
      renderer.setClearColor(color, clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(clearAlpha);
    }
  }
};

// src/passes/MaskPass.js
var MaskPass = class extends Pass {
  /**
   * Constructs a new mask pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use.
   */
  constructor(scene, camera) {
    super("MaskPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass(false, false, true);
    this.inverse = false;
  }
  set mainScene(value) {
    this.scene = value;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  /**
   * Indicates whether the mask should be inverted.
   *
   * @type {Boolean}
   */
  get inverted() {
    return this.inverse;
  }
  set inverted(value) {
    this.inverse = value;
  }
  /**
   * Indicates whether this pass should clear the stencil buffer.
   *
   * @type {Boolean}
   * @deprecated Use clearPass.enabled instead.
   */
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  /**
   * Returns the internal clear pass.
   *
   * @deprecated Use clearPass.enabled instead.
   * @return {ClearPass} The clear pass.
   */
  getClearPass() {
    return this.clearPass;
  }
  /**
   * Indicates whether the mask is inverted.
   *
   * @deprecated Use inverted instead.
   * @return {Boolean} Whether the mask is inverted.
   */
  isInverted() {
    return this.inverted;
  }
  /**
   * Enables or disable mask inversion.
   *
   * @deprecated Use inverted instead.
   * @param {Boolean} value - Whether the mask should be inverted.
   */
  setInverted(value) {
    this.inverted = value;
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const context = renderer.getContext();
    const buffers = renderer.state.buffers;
    const scene = this.scene;
    const camera = this.camera;
    const clearPass = this.clearPass;
    const writeValue = this.inverted ? 0 : 1;
    const clearValue = 1 - writeValue;
    buffers.color.setMask(false);
    buffers.depth.setMask(false);
    buffers.color.setLocked(true);
    buffers.depth.setLocked(true);
    buffers.stencil.setTest(true);
    buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    buffers.stencil.setClear(clearValue);
    buffers.stencil.setLocked(true);
    if (this.clearPass.enabled) {
      if (this.renderToScreen) {
        clearPass.render(renderer, null);
      } else {
        clearPass.render(renderer, inputBuffer);
        clearPass.render(renderer, outputBuffer);
      }
    }
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      renderer.render(scene, camera);
    } else {
      renderer.setRenderTarget(inputBuffer);
      renderer.render(scene, camera);
      renderer.setRenderTarget(outputBuffer);
      renderer.render(scene, camera);
    }
    buffers.color.setLocked(false);
    buffers.depth.setLocked(false);
    buffers.stencil.setLocked(false);
    buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    buffers.stencil.setLocked(true);
  }
};

// src/core/EffectComposer.js
var EffectComposer = class {
  /**
   * Constructs a new effect composer.
   *
   * @param {WebGLRenderer} renderer - The renderer that should be used.
   * @param {Object} [options] - The options.
   * @param {Boolean} [options.depthBuffer=true] - Whether the main render targets should have a depth buffer.
   * @param {Boolean} [options.stencilBuffer=false] - Whether the main render targets should have a stencil buffer.
   * @param {Boolean} [options.alpha] - Deprecated. Buffers are always RGBA since three r137.
   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.
   * @param {Number} [options.frameBufferType] - The type of the internal frame buffers. It's recommended to use HalfFloatType if possible.
   */
  constructor(renderer = null, {
    depthBuffer = true,
    stencilBuffer = false,
    multisampling = 0,
    frameBufferType
  } = {}) {
    this.renderer = null;
    this.inputBuffer = this.createBuffer(depthBuffer, stencilBuffer, frameBufferType, multisampling);
    this.outputBuffer = this.inputBuffer.clone();
    this.copyPass = new CopyPass();
    this.depthTexture = null;
    this.passes = [];
    this.timer = new Timer();
    this.autoRenderToScreen = true;
    this.setRenderer(renderer);
  }
  /**
   * The current amount of samples used for multisample anti-aliasing.
   *
   * @type {Number}
   */
  get multisampling() {
    return this.inputBuffer.samples || 0;
  }
  /**
   * Sets the amount of MSAA samples.
   *
   * Requires WebGL 2. Set to zero to disable multisampling.
   *
   * @type {Number}
   */
  set multisampling(value) {
    const buffer = this.inputBuffer;
    const multisampling = this.multisampling;
    if (multisampling > 0 && value > 0) {
      this.inputBuffer.samples = value;
      this.outputBuffer.samples = value;
      this.inputBuffer.dispose();
      this.outputBuffer.dispose();
    } else if (multisampling !== value) {
      this.inputBuffer.dispose();
      this.outputBuffer.dispose();
      this.inputBuffer = this.createBuffer(
        buffer.depthBuffer,
        buffer.stencilBuffer,
        buffer.texture.type,
        value
      );
      this.inputBuffer.depthTexture = this.depthTexture;
      this.outputBuffer = this.inputBuffer.clone();
    }
  }
  /**
   * Returns the internal timer.
   *
   * @return {Timer} The timer.
   */
  getTimer() {
    return this.timer;
  }
  /**
   * Returns the renderer.
   *
   * @return {WebGLRenderer} The renderer.
   */
  getRenderer() {
    return this.renderer;
  }
  /**
   * Sets the renderer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
    if (renderer !== null) {
      const size = renderer.getSize(new import_three6.Vector2());
      const alpha = renderer.getContext().getContextAttributes().alpha;
      const frameBufferType = this.inputBuffer.texture.type;
      if (frameBufferType === import_three6.UnsignedByteType && renderer.outputColorSpace === import_three6.SRGBColorSpace) {
        this.inputBuffer.texture.colorSpace = import_three6.SRGBColorSpace;
        this.outputBuffer.texture.colorSpace = import_three6.SRGBColorSpace;
        this.inputBuffer.dispose();
        this.outputBuffer.dispose();
      }
      renderer.autoClear = false;
      this.setSize(size.width, size.height);
      for (const pass of this.passes) {
        pass.initialize(renderer, alpha, frameBufferType);
      }
    }
  }
  /**
   * Replaces the current renderer with the given one.
   *
   * The auto clear mechanism of the provided renderer will be disabled. If the new render size differs from the
   * previous one, all passes will be updated.
   *
   * By default, the DOM element of the current renderer will automatically be removed from its parent node and the DOM
   * element of the new renderer will take its place.
   *
   * @deprecated Use setRenderer instead.
   * @param {WebGLRenderer} renderer - The new renderer.
   * @param {Boolean} updateDOM - Indicates whether the old canvas should be replaced by the new one in the DOM.
   * @return {WebGLRenderer} The old renderer.
   */
  replaceRenderer(renderer, updateDOM = true) {
    const oldRenderer = this.renderer;
    const parent = oldRenderer.domElement.parentNode;
    this.setRenderer(renderer);
    if (updateDOM && parent !== null) {
      parent.removeChild(oldRenderer.domElement);
      parent.appendChild(renderer.domElement);
    }
    return oldRenderer;
  }
  /**
   * Creates a depth texture attachment that will be provided to all passes.
   *
   * Note: When a shader reads from a depth texture and writes to a render target that uses the same depth texture
   * attachment, the depth information will be lost. This happens even if `depthWrite` is disabled.
   *
   * @private
   * @return {DepthTexture} The depth texture.
   */
  createDepthTexture() {
    const depthTexture = this.depthTexture = new import_three6.DepthTexture();
    this.inputBuffer.depthTexture = depthTexture;
    this.inputBuffer.dispose();
    if (this.inputBuffer.stencilBuffer) {
      depthTexture.format = import_three6.DepthStencilFormat;
      depthTexture.type = import_three6.UnsignedInt248Type;
    } else {
      depthTexture.type = import_three6.UnsignedIntType;
    }
    return depthTexture;
  }
  /**
   * Deletes the current depth texture.
   *
   * @private
   */
  deleteDepthTexture() {
    if (this.depthTexture !== null) {
      this.depthTexture.dispose();
      this.depthTexture = null;
      this.inputBuffer.depthTexture = null;
      this.inputBuffer.dispose();
      for (const pass of this.passes) {
        pass.setDepthTexture(null);
      }
    }
  }
  /**
   * Creates a new render target.
   *
   * @deprecated Create buffers manually via WebGLRenderTarget instead.
   * @param {Boolean} depthBuffer - Whether the render target should have a depth buffer.
   * @param {Boolean} stencilBuffer - Whether the render target should have a stencil buffer.
   * @param {Number} type - The frame buffer type.
   * @param {Number} multisampling - The number of samples to use for antialiasing.
   * @return {WebGLRenderTarget} A new render target that equals the renderer's canvas.
   */
  createBuffer(depthBuffer, stencilBuffer, type, multisampling) {
    const renderer = this.renderer;
    const size = renderer === null ? new import_three6.Vector2() : renderer.getDrawingBufferSize(new import_three6.Vector2());
    const options = {
      minFilter: import_three6.LinearFilter,
      magFilter: import_three6.LinearFilter,
      stencilBuffer,
      depthBuffer,
      type
    };
    const renderTarget = new import_three6.WebGLRenderTarget(size.width, size.height, options);
    if (multisampling > 0) {
      renderTarget.ignoreDepthForMultisampleCopy = false;
      renderTarget.samples = multisampling;
    }
    if (type === import_three6.UnsignedByteType && renderer !== null && renderer.outputColorSpace === import_three6.SRGBColorSpace) {
      renderTarget.texture.colorSpace = import_three6.SRGBColorSpace;
    }
    renderTarget.texture.name = "EffectComposer.Buffer";
    renderTarget.texture.generateMipmaps = false;
    return renderTarget;
  }
  /**
   * Can be used to change the main scene for all registered passes and effects.
   *
   * @param {Scene} scene - The scene.
   */
  setMainScene(scene) {
    for (const pass of this.passes) {
      pass.mainScene = scene;
    }
  }
  /**
   * Can be used to change the main camera for all registered passes and effects.
   *
   * @param {Camera} camera - The camera.
   */
  setMainCamera(camera) {
    for (const pass of this.passes) {
      pass.mainCamera = camera;
    }
  }
  /**
   * Adds a pass, optionally at a specific index.
   *
   * @param {Pass} pass - A new pass.
   * @param {Number} [index] - An index at which the pass should be inserted.
   */
  addPass(pass, index) {
    const passes = this.passes;
    const renderer = this.renderer;
    const drawingBufferSize = renderer.getDrawingBufferSize(new import_three6.Vector2());
    const alpha = renderer.getContext().getContextAttributes().alpha;
    const frameBufferType = this.inputBuffer.texture.type;
    pass.setRenderer(renderer);
    pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    pass.initialize(renderer, alpha, frameBufferType);
    if (this.autoRenderToScreen) {
      if (passes.length > 0) {
        passes[passes.length - 1].renderToScreen = false;
      }
      if (pass.renderToScreen) {
        this.autoRenderToScreen = false;
      }
    }
    if (index !== void 0) {
      passes.splice(index, 0, pass);
    } else {
      passes.push(pass);
    }
    if (this.autoRenderToScreen) {
      passes[passes.length - 1].renderToScreen = true;
    }
    if (pass.needsDepthTexture || this.depthTexture !== null) {
      if (this.depthTexture === null) {
        const depthTexture = this.createDepthTexture();
        for (pass of passes) {
          pass.setDepthTexture(depthTexture);
        }
      } else {
        pass.setDepthTexture(this.depthTexture);
      }
    }
  }
  /**
   * Removes a pass.
   *
   * @param {Pass} pass - The pass.
   */
  removePass(pass) {
    const passes = this.passes;
    const index = passes.indexOf(pass);
    const exists = index !== -1;
    const removed = exists && passes.splice(index, 1).length > 0;
    if (removed) {
      if (this.depthTexture !== null) {
        const reducer = (a, b) => a || b.needsDepthTexture;
        const depthTextureRequired = passes.reduce(reducer, false);
        if (!depthTextureRequired) {
          if (pass.getDepthTexture() === this.depthTexture) {
            pass.setDepthTexture(null);
          }
          this.deleteDepthTexture();
        }
      }
      if (this.autoRenderToScreen) {
        if (index === passes.length) {
          pass.renderToScreen = false;
          if (passes.length > 0) {
            passes[passes.length - 1].renderToScreen = true;
          }
        }
      }
    }
  }
  /**
   * Removes all passes.
   */
  removeAllPasses() {
    const passes = this.passes;
    this.deleteDepthTexture();
    if (passes.length > 0) {
      if (this.autoRenderToScreen) {
        passes[passes.length - 1].renderToScreen = false;
      }
      this.passes = [];
    }
  }
  /**
   * Renders all enabled passes in the order in which they were added.
   *
   * @param {Number} [deltaTime] - The time since the last frame in seconds.
   */
  render(deltaTime) {
    const renderer = this.renderer;
    const copyPass = this.copyPass;
    let inputBuffer = this.inputBuffer;
    let outputBuffer = this.outputBuffer;
    let stencilTest = false;
    let context, stencil, buffer;
    if (deltaTime === void 0) {
      this.timer.update();
      deltaTime = this.timer.getDelta();
    }
    for (const pass of this.passes) {
      if (pass.enabled) {
        pass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
        if (pass.needsSwap) {
          if (stencilTest) {
            copyPass.renderToScreen = pass.renderToScreen;
            context = renderer.getContext();
            stencil = renderer.state.buffers.stencil;
            stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
            copyPass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
            stencil.setFunc(context.EQUAL, 1, 4294967295);
          }
          buffer = inputBuffer;
          inputBuffer = outputBuffer;
          outputBuffer = buffer;
        }
        if (pass instanceof MaskPass) {
          stencilTest = true;
        } else if (pass instanceof ClearMaskPass) {
          stencilTest = false;
        }
      }
    }
  }
  /**
   * Sets the size of the buffers, passes and the renderer.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   * @param {Boolean} [updateStyle] - Determines whether the style of the canvas should be updated.
   */
  setSize(width, height, updateStyle) {
    const renderer = this.renderer;
    const currentSize = renderer.getSize(new import_three6.Vector2());
    if (width === void 0 || height === void 0) {
      width = currentSize.width;
      height = currentSize.height;
    }
    if (currentSize.width !== width || currentSize.height !== height) {
      renderer.setSize(width, height, updateStyle);
    }
    const drawingBufferSize = renderer.getDrawingBufferSize(new import_three6.Vector2());
    this.inputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    this.outputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    for (const pass of this.passes) {
      pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    }
  }
  /**
   * Resets this composer by deleting all passes and creating new buffers.
   */
  reset() {
    this.dispose();
    this.autoRenderToScreen = true;
  }
  /**
   * Disposes this composer and all passes.
   */
  dispose() {
    for (const pass of this.passes) {
      pass.dispose();
    }
    this.passes = [];
    if (this.inputBuffer !== null) {
      this.inputBuffer.dispose();
    }
    if (this.outputBuffer !== null) {
      this.outputBuffer.dispose();
    }
    this.deleteDepthTexture();
    this.copyPass.dispose();
    this.timer.dispose();
  }
};

// src/core/EffectShaderData.js
var import_three7 = __webpack_require__(39437);

// src/enums/EffectAttribute.js
var EffectAttribute = {
  NONE: 0,
  DEPTH: 1,
  CONVOLUTION: 2
};

// src/enums/EffectShaderSection.js
var EffectShaderSection = {
  FRAGMENT_HEAD: "FRAGMENT_HEAD",
  FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
  FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
  VERTEX_HEAD: "VERTEX_HEAD",
  VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
};

// src/core/EffectShaderData.js
var EffectShaderData = class {
  /**
   * Constructs new shader data.
   */
  constructor() {
    this.shaderParts = /* @__PURE__ */ new Map([
      [EffectShaderSection.FRAGMENT_HEAD, null],
      [EffectShaderSection.FRAGMENT_MAIN_UV, null],
      [EffectShaderSection.FRAGMENT_MAIN_IMAGE, null],
      [EffectShaderSection.VERTEX_HEAD, null],
      [EffectShaderSection.VERTEX_MAIN_SUPPORT, null]
    ]);
    this.defines = /* @__PURE__ */ new Map();
    this.uniforms = /* @__PURE__ */ new Map();
    this.blendModes = /* @__PURE__ */ new Map();
    this.extensions = /* @__PURE__ */ new Set();
    this.attributes = EffectAttribute.NONE;
    this.varyings = /* @__PURE__ */ new Set();
    this.uvTransformation = false;
    this.readDepth = false;
    this.colorSpace = import_three7.LinearSRGBColorSpace;
  }
};

// src/core/GaussKernel.js
function getCoefficients(n) {
  let result;
  if (n === 0) {
    result = new Float64Array(0);
  } else if (n === 1) {
    result = new Float64Array([1]);
  } else if (n > 1) {
    let row0 = new Float64Array(n);
    let row1 = new Float64Array(n);
    for (let y = 1; y <= n; ++y) {
      for (let x = 0; x < y; ++x) {
        row1[x] = x === 0 || x === y - 1 ? 1 : row0[x - 1] + row0[x];
      }
      result = row1;
      row1 = row0;
      row0 = result;
    }
  }
  return result;
}
var GaussKernel = class {
  /**
   * Constructs a new Gauss kernel.
   *
   * @param {Number} kernelSize - The kernel size. Should be an odd number in the range [3, 1020].
   * @param {Number} [edgeBias=2] - Determines how many edge coefficients should be cut off for increased accuracy.
   */
  constructor(kernelSize, edgeBias = 2) {
    this.weights = null;
    this.offsets = null;
    this.linearWeights = null;
    this.linearOffsets = null;
    this.generate(kernelSize, edgeBias);
  }
  /**
   * The number of steps for discrete sampling.
   *
   * @type {Number}
   */
  get steps() {
    return this.offsets === null ? 0 : this.offsets.length;
  }
  /**
   * The number of steps for linear sampling.
   *
   * @type {Number}
   */
  get linearSteps() {
    return this.linearOffsets === null ? 0 : this.linearOffsets.length;
  }
  /**
   * Generates the kernel.
   *
   * @private
   * @param {Number} kernelSize - The kernel size.
   * @param {Number} edgeBias - The amount of edge coefficients to ignore.
   */
  generate(kernelSize, edgeBias) {
    if (kernelSize < 3 || kernelSize > 1020) {
      throw new Error("The kernel size must be in the range [3, 1020]");
    }
    const n = kernelSize + edgeBias * 2;
    const coefficients = edgeBias > 0 ? getCoefficients(n).slice(edgeBias, -edgeBias) : getCoefficients(n);
    const mid = Math.floor((coefficients.length - 1) / 2);
    const sum = coefficients.reduce((a, b) => a + b, 0);
    const weights = coefficients.slice(mid);
    const offsets = [...Array(mid + 1).keys()];
    const linearWeights = new Float64Array(Math.floor(offsets.length / 2));
    const linearOffsets = new Float64Array(linearWeights.length);
    linearWeights[0] = weights[0] / sum;
    for (let i = 1, j = 1, l = offsets.length - 1; i < l; i += 2, ++j) {
      const offset0 = offsets[i], offset1 = offsets[i + 1];
      const weight0 = weights[i], weight1 = weights[i + 1];
      const w = weight0 + weight1;
      const o = (offset0 * weight0 + offset1 * weight1) / w;
      linearWeights[j] = w / sum;
      linearOffsets[j] = o;
    }
    for (let i = 0, l = weights.length, s = 1 / sum; i < l; ++i) {
      weights[i] *= s;
    }
    const linearWeightSum = (linearWeights.reduce((a, b) => a + b, 0) - linearWeights[0] * 0.5) * 2;
    if (linearWeightSum !== 0) {
      for (let i = 0, l = linearWeights.length, s = 1 / linearWeightSum; i < l; ++i) {
        linearWeights[i] *= s;
      }
    }
    this.offsets = offsets;
    this.weights = weights;
    this.linearOffsets = linearOffsets;
    this.linearWeights = linearWeights;
  }
};

// src/core/ImmutableTimer.js
var ImmutableTimer = class {
  /**
   * The current delta time in seconds.
   *
   * @type {Number}
   */
  getDelta() {
    return NaN;
  }
  /**
   * The elapsed time in seconds.
   *
   * @type {Number}
   */
  getElapsed() {
    return NaN;
  }
};

// src/core/Initializable.js
var Initializable = class {
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
  }
};

// src/core/OverrideMaterialManager.js
var import_three8 = __webpack_require__(39437);
var workaroundEnabled = false;
var OverrideMaterialManager = class {
  /**
   * Constructs a new override material manager.
   *
   * @param {Material} [material=null] - An override material.
   */
  constructor(material = null) {
    this.originalMaterials = /* @__PURE__ */ new Map();
    this.material = null;
    this.materials = null;
    this.materialsBackSide = null;
    this.materialsDoubleSide = null;
    this.materialsFlatShaded = null;
    this.materialsFlatShadedBackSide = null;
    this.materialsFlatShadedDoubleSide = null;
    this.setMaterial(material);
    this.meshCount = 0;
    this.replaceMaterial = (node) => {
      if (node.isMesh) {
        let materials;
        if (node.material.flatShading) {
          switch (node.material.side) {
            case import_three8.DoubleSide:
              materials = this.materialsFlatShadedDoubleSide;
              break;
            case import_three8.BackSide:
              materials = this.materialsFlatShadedBackSide;
              break;
            default:
              materials = this.materialsFlatShaded;
              break;
          }
        } else {
          switch (node.material.side) {
            case import_three8.DoubleSide:
              materials = this.materialsDoubleSide;
              break;
            case import_three8.BackSide:
              materials = this.materialsBackSide;
              break;
            default:
              materials = this.materials;
              break;
          }
        }
        this.originalMaterials.set(node, node.material);
        if (node.isSkinnedMesh) {
          node.material = materials[2];
        } else if (node.isInstancedMesh) {
          node.material = materials[1];
        } else {
          node.material = materials[0];
        }
        ++this.meshCount;
      }
    };
  }
  /**
   * Clones the given material.
   *
   * @private
   * @param {Material} material - The material.
   * @return {Material} The cloned material.
   */
  cloneMaterial(material) {
    if (!(material instanceof import_three8.ShaderMaterial)) {
      return material.clone();
    }
    const uniforms = material.uniforms;
    const textureUniforms = /* @__PURE__ */ new Map();
    for (const key in uniforms) {
      const value = uniforms[key].value;
      if (value.isRenderTargetTexture) {
        uniforms[key].value = null;
        textureUniforms.set(key, value);
      }
    }
    const clone = material.clone();
    for (const entry of textureUniforms) {
      uniforms[entry[0]].value = entry[1];
      clone.uniforms[entry[0]].value = entry[1];
    }
    return clone;
  }
  /**
   * Sets the override material.
   *
   * @param {Material} material - The material.
   */
  setMaterial(material) {
    this.disposeMaterials();
    this.material = material;
    if (material !== null) {
      const materials = this.materials = [
        this.cloneMaterial(material),
        this.cloneMaterial(material),
        this.cloneMaterial(material)
      ];
      for (const m2 of materials) {
        m2.uniforms = Object.assign({}, material.uniforms);
        m2.side = import_three8.FrontSide;
      }
      materials[2].skinning = true;
      this.materialsBackSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = import_three8.BackSide;
        return c2;
      });
      this.materialsDoubleSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = import_three8.DoubleSide;
        return c2;
      });
      this.materialsFlatShaded = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        return c2;
      });
      this.materialsFlatShadedBackSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = import_three8.BackSide;
        return c2;
      });
      this.materialsFlatShadedDoubleSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = import_three8.DoubleSide;
        return c2;
      });
    }
  }
  /**
   * Renders the scene with the override material.
   *
   * @private
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Scene} scene - A scene.
   * @param {Camera} camera - A camera.
   */
  render(renderer, scene, camera) {
    const shadowMapEnabled = renderer.shadowMap.enabled;
    renderer.shadowMap.enabled = false;
    if (workaroundEnabled) {
      const originalMaterials = this.originalMaterials;
      this.meshCount = 0;
      scene.traverse(this.replaceMaterial);
      renderer.render(scene, camera);
      for (const entry of originalMaterials) {
        entry[0].material = entry[1];
      }
      if (this.meshCount !== originalMaterials.size) {
        originalMaterials.clear();
      }
    } else {
      const overrideMaterial = scene.overrideMaterial;
      scene.overrideMaterial = this.material;
      renderer.render(scene, camera);
      scene.overrideMaterial = overrideMaterial;
    }
    renderer.shadowMap.enabled = shadowMapEnabled;
  }
  /**
   * Deletes cloned override materials.
   *
   * @private
   */
  disposeMaterials() {
    if (this.material !== null) {
      const materials = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
      for (const m2 of materials) {
        m2.dispose();
      }
    }
  }
  /**
   * Performs cleanup tasks.
   */
  dispose() {
    this.originalMaterials.clear();
    this.disposeMaterials();
  }
  /**
   * Indicates whether the override material workaround is enabled.
   *
   * @type {Boolean}
   */
  static get workaroundEnabled() {
    return workaroundEnabled;
  }
  /**
   * Enables or disables the override material workaround globally.
   *
   * This only affects post processing passes and effects.
   *
   * @type {Boolean}
   */
  static set workaroundEnabled(value) {
    workaroundEnabled = value;
  }
};

// src/core/Resizable.js
var Resizable = class {
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
  }
};

// src/core/Resolution.js
var import_three9 = __webpack_require__(39437);
var AUTO_SIZE = -1;
var Resolution = class extends import_three9.EventDispatcher {
  /**
   * Constructs a new resolution.
   *
   * TODO Remove resizable param.
   * @param {Resizable} resizable - A resizable object.
   * @param {Number} [width=Resolution.AUTO_SIZE] - The preferred width.
   * @param {Number} [height=Resolution.AUTO_SIZE] - The preferred height.
   * @param {Number} [scale=1.0] - A resolution scale.
   */
  constructor(resizable, width = AUTO_SIZE, height = AUTO_SIZE, scale = 1) {
    super();
    this.resizable = resizable;
    this.baseSize = new import_three9.Vector2(1, 1);
    this.preferredSize = new import_three9.Vector2(width, height);
    this.target = this.preferredSize;
    this.s = scale;
    this.effectiveSize = new import_three9.Vector2();
    this.addEventListener("change", () => this.updateEffectiveSize());
    this.updateEffectiveSize();
  }
  /**
   * Calculates the effective size.
   *
   * @private
   */
  updateEffectiveSize() {
    const base = this.baseSize;
    const preferred = this.preferredSize;
    const effective = this.effectiveSize;
    const scale = this.scale;
    if (preferred.width !== AUTO_SIZE) {
      effective.width = preferred.width;
    } else if (preferred.height !== AUTO_SIZE) {
      effective.width = Math.round(preferred.height * (base.width / Math.max(base.height, 1)));
    } else {
      effective.width = Math.round(base.width * scale);
    }
    if (preferred.height !== AUTO_SIZE) {
      effective.height = preferred.height;
    } else if (preferred.width !== AUTO_SIZE) {
      effective.height = Math.round(preferred.width / Math.max(base.width / Math.max(base.height, 1), 1));
    } else {
      effective.height = Math.round(base.height * scale);
    }
  }
  /**
   * The effective width.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.
   *
   * @type {Number}
   */
  get width() {
    return this.effectiveSize.width;
  }
  set width(value) {
    this.preferredWidth = value;
  }
  /**
   * The effective height.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.
   *
   * @type {Number}
   */
  get height() {
    return this.effectiveSize.height;
  }
  set height(value) {
    this.preferredHeight = value;
  }
  /**
   * Returns the effective width.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.
   *
   * @deprecated Use width instead.
   * @return {Number} The effective width.
   */
  getWidth() {
    return this.width;
  }
  /**
   * Returns the effective height.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.
   *
   * @deprecated Use height instead.
   * @return {Number} The effective height.
   */
  getHeight() {
    return this.height;
  }
  /**
   * The resolution scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.s;
  }
  set scale(value) {
    if (this.s !== value) {
      this.s = value;
      this.preferredSize.setScalar(AUTO_SIZE);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the current resolution scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * Also sets the preferred resolution to {@link Resizer.AUTO_SIZE}.
   *
   * @deprecated Use scale instead.
   * @param {Number} value - The scale.
   */
  setScale(value) {
    this.scale = value;
  }
  /**
   * The base width.
   *
   * @type {Number}
   */
  get baseWidth() {
    return this.baseSize.width;
  }
  set baseWidth(value) {
    if (this.baseSize.width !== value) {
      this.baseSize.width = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the base width.
   *
   * @deprecated Use baseWidth instead.
   * @return {Number} The base width.
   */
  getBaseWidth() {
    return this.baseWidth;
  }
  /**
   * Sets the base width.
   *
   * @deprecated Use baseWidth instead.
   * @param {Number} value - The width.
   */
  setBaseWidth(value) {
    this.baseWidth = value;
  }
  /**
   * The base height.
   *
   * @type {Number}
   */
  get baseHeight() {
    return this.baseSize.height;
  }
  set baseHeight(value) {
    if (this.baseSize.height !== value) {
      this.baseSize.height = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the base height.
   *
   * @deprecated Use baseHeight instead.
   * @return {Number} The base height.
   */
  getBaseHeight() {
    return this.baseHeight;
  }
  /**
   * Sets the base height.
   *
   * @deprecated Use baseHeight instead.
   * @param {Number} value - The height.
   */
  setBaseHeight(value) {
    this.baseHeight = value;
  }
  /**
   * Sets the base size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setBaseSize(width, height) {
    if (this.baseSize.width !== width || this.baseSize.height !== height) {
      this.baseSize.set(width, height);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * The preferred width.
   *
   * @type {Number}
   */
  get preferredWidth() {
    return this.preferredSize.width;
  }
  set preferredWidth(value) {
    if (this.preferredSize.width !== value) {
      this.preferredSize.width = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the preferred width.
   *
   * @deprecated Use preferredWidth instead.
   * @return {Number} The preferred width.
   */
  getPreferredWidth() {
    return this.preferredWidth;
  }
  /**
   * Sets the preferred width.
   *
   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the width based on the height and aspect ratio.
   *
   * @deprecated Use preferredWidth instead.
   * @param {Number} value - The width.
   */
  setPreferredWidth(value) {
    this.preferredWidth = value;
  }
  /**
   * The preferred height.
   *
   * @type {Number}
   */
  get preferredHeight() {
    return this.preferredSize.height;
  }
  set preferredHeight(value) {
    if (this.preferredSize.height !== value) {
      this.preferredSize.height = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the preferred height.
   *
   * @deprecated Use preferredHeight instead.
   * @return {Number} The preferred height.
   */
  getPreferredHeight() {
    return this.preferredHeight;
  }
  /**
   * Sets the preferred height.
   *
   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the height based on the width and aspect ratio.
   *
   * @deprecated Use preferredHeight instead.
   * @param {Number} value - The height.
   */
  setPreferredHeight(value) {
    this.preferredHeight = value;
  }
  /**
   * Sets the preferred size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setPreferredSize(width, height) {
    if (this.preferredSize.width !== width || this.preferredSize.height !== height) {
      this.preferredSize.set(width, height);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Copies the given resolution.
   *
   * @param {Resolution} resolution - The resolution.
   */
  copy(resolution) {
    this.s = resolution.scale;
    this.baseSize.set(resolution.baseWidth, resolution.baseHeight);
    this.preferredSize.set(resolution.preferredWidth, resolution.preferredHeight);
    this.dispatchEvent({ type: "change" });
    this.resizable.setSize(this.baseSize.width, this.baseSize.height);
  }
  /**
   * An auto sizing constant.
   *
   * Can be used to automatically calculate the width or height based on the original aspect ratio.
   *
   * @type {Number}
   */
  static get AUTO_SIZE() {
    return AUTO_SIZE;
  }
};

// src/core/Selection.js
var Selection = class extends Set {
  /**
   * Constructs a new selection.
   *
   * @param {Iterable<Object3D>} [iterable] - A collection of objects that should be added to this selection.
   * @param {Number} [layer=10] - A dedicated render layer for selected objects.
   */
  constructor(iterable, layer = 10) {
    super();
    this.l = layer;
    this.exclusive = false;
    if (iterable !== void 0) {
      this.set(iterable);
    }
  }
  /**
   * The render layer for selected objects.
   *
   * @type {Number}
   */
  get layer() {
    return this.l;
  }
  set layer(value) {
    const currentLayer = this.l;
    for (const object of this) {
      object.layers.disable(currentLayer);
      object.layers.enable(value);
    }
    this.l = value;
  }
  /**
   * Returns the current render layer for selected objects.
   *
   * The default layer is 10. If this collides with your own custom layers, please change it before rendering!
   *
   * @deprecated Use layer instead.
   * @return {Number} The layer.
   */
  getLayer() {
    return this.layer;
  }
  /**
   * Sets the render layer for selected objects.
   *
   * The current selection will be updated accordingly.
   *
   * @deprecated Use layer instead.
   * @param {Number} value - The layer. Range is [0, 31].
   */
  setLayer(value) {
    this.layer = value;
  }
  /**
   * Indicates whether objects that are added to this selection will be removed from all other layers.
   *
   * @deprecated Use exclusive instead.
   * @return {Number} Whether this selection is exclusive. Default is false.
   */
  isExclusive() {
    return this.exclusive;
  }
  /**
   * Controls whether objects that are added to this selection should be removed from all other layers.
   *
   * @deprecated Use exclusive instead.
   * @param {Number} value - Whether this selection should be exclusive.
   */
  setExclusive(value) {
    this.exclusive = value;
  }
  /**
   * Clears this selection.
   *
   * @return {Selection} This selection.
   */
  clear() {
    const layer = this.layer;
    for (const object of this) {
      object.layers.disable(layer);
    }
    return super.clear();
  }
  /**
   * Clears this selection and adds the given objects.
   *
   * @param {Iterable<Object3D>} objects - The objects that should be selected.
   * @return {Selection} This selection.
   */
  set(objects) {
    this.clear();
    for (const object of objects) {
      this.add(object);
    }
    return this;
  }
  /**
   * An alias for {@link has}.
   *
   * @param {Object3D} object - An object.
   * @return {Number} Returns 0 if the given object is currently selected, or -1 otherwise.
   * @deprecated Added for backward-compatibility.
   */
  indexOf(object) {
    return this.has(object) ? 0 : -1;
  }
  /**
   * Adds an object to this selection.
   *
   * If {@link exclusive} is set to `true`, the object will also be removed from all other layers.
   *
   * @param {Object3D} object - The object that should be selected.
   * @return {Selection} This selection.
   */
  add(object) {
    if (this.exclusive) {
      object.layers.set(this.layer);
    } else {
      object.layers.enable(this.layer);
    }
    return super.add(object);
  }
  /**
   * Removes an object from this selection.
   *
   * @param {Object3D} object - The object that should be deselected.
   * @return {Boolean} Returns true if an object has successfully been removed from this selection; otherwise false.
   */
  delete(object) {
    if (this.has(object)) {
      object.layers.disable(this.layer);
    }
    return super.delete(object);
  }
  /**
   * Removes an existing object from the selection. If the object doesn't exist it's added instead.
   *
   * @param {Object3D} object - The object.
   * @return {Boolean} Returns true if the object is added, false otherwise.
   */
  toggle(object) {
    let result;
    if (this.has(object)) {
      this.delete(object);
      result = false;
    } else {
      this.add(object);
      result = true;
    }
    return result;
  }
  /**
   * Sets the visibility of all selected objects.
   *
   * This method enables or disables render layer 0 of all selected objects.
   *
   * @param {Boolean} visible - Whether the selected objects should be visible.
   * @return {Selection} This selection.
   */
  setVisible(visible) {
    for (const object of this) {
      if (visible) {
        object.layers.enable(0);
      } else {
        object.layers.disable(0);
      }
    }
    return this;
  }
};

// src/effects/blending/BlendMode.js
var import_three10 = __webpack_require__(39437);

// src/enums/BlendFunction.js
var BlendFunction = {
  SKIP: 9,
  SET: 30,
  ADD: 0,
  ALPHA: 1,
  AVERAGE: 2,
  COLOR: 3,
  COLOR_BURN: 4,
  COLOR_DODGE: 5,
  DARKEN: 6,
  DIFFERENCE: 7,
  DIVIDE: 8,
  DST: 9,
  EXCLUSION: 10,
  HARD_LIGHT: 11,
  HARD_MIX: 12,
  HUE: 13,
  INVERT: 14,
  INVERT_RGB: 15,
  LIGHTEN: 16,
  LINEAR_BURN: 17,
  LINEAR_DODGE: 18,
  LINEAR_LIGHT: 19,
  LUMINOSITY: 20,
  MULTIPLY: 21,
  NEGATION: 22,
  NORMAL: 23,
  OVERLAY: 24,
  PIN_LIGHT: 25,
  REFLECT: 26,
  SATURATION: 27,
  SCREEN: 28,
  SOFT_LIGHT: 29,
  SRC: 30,
  SUBTRACT: 31,
  VIVID_LIGHT: 32
};

// src/effects/blending/glsl/add.frag
var add_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}";

// src/effects/blending/glsl/alpha.frag
var alpha_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}";

// src/effects/blending/glsl/average.frag
var average_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}";

// src/effects/blending/glsl/color.frag
var color_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/color-burn.frag
var color_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}";

// src/effects/blending/glsl/color-dodge.frag
var color_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}";

// src/effects/blending/glsl/darken.frag
var darken_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}";

// src/effects/blending/glsl/difference.frag
var difference_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}";

// src/effects/blending/glsl/divide.frag
var divide_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}";

// src/effects/blending/glsl/exclusion.frag
var exclusion_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}";

// src/effects/blending/glsl/hard-light.frag
var hard_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}";

// src/effects/blending/glsl/hard-mix.frag
var hard_mix_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}";

// src/effects/blending/glsl/hue.frag
var hue_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/invert.frag
var invert_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}";

// src/effects/blending/glsl/invert-rgb.frag
var invert_rgb_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}";

// src/effects/blending/glsl/lighten.frag
var lighten_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}";

// src/effects/blending/glsl/linear-burn.frag
var linear_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}";

// src/effects/blending/glsl/linear-dodge.frag
var linear_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}";

// src/effects/blending/glsl/linear-light.frag
var linear_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}";

// src/effects/blending/glsl/luminosity.frag
var luminosity_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/multiply.frag
var multiply_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}";

// src/effects/blending/glsl/negation.frag
var negation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}";

// src/effects/blending/glsl/normal.frag
var normal_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}";

// src/effects/blending/glsl/overlay.frag
var overlay_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}";

// src/effects/blending/glsl/pin-light.frag
var pin_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}";

// src/effects/blending/glsl/reflect.frag
var reflect_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}";

// src/effects/blending/glsl/saturation.frag
var saturation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/screen.frag
var screen_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}";

// src/effects/blending/glsl/soft-light.frag
var soft_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}";

// src/effects/blending/glsl/src.frag
var src_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}";

// src/effects/blending/glsl/subtract.frag
var subtract_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}";

// src/effects/blending/glsl/vivid-light.frag
var vivid_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}";

// src/effects/blending/BlendMode.js
var blendFunctions = /* @__PURE__ */ new Map([
  [BlendFunction.ADD, add_default],
  [BlendFunction.ALPHA, alpha_default],
  [BlendFunction.AVERAGE, average_default],
  [BlendFunction.COLOR, color_default],
  [BlendFunction.COLOR_BURN, color_burn_default],
  [BlendFunction.COLOR_DODGE, color_dodge_default],
  [BlendFunction.DARKEN, darken_default],
  [BlendFunction.DIFFERENCE, difference_default],
  [BlendFunction.DIVIDE, divide_default],
  [BlendFunction.DST, null],
  [BlendFunction.EXCLUSION, exclusion_default],
  [BlendFunction.HARD_LIGHT, hard_light_default],
  [BlendFunction.HARD_MIX, hard_mix_default],
  [BlendFunction.HUE, hue_default],
  [BlendFunction.INVERT, invert_default],
  [BlendFunction.INVERT_RGB, invert_rgb_default],
  [BlendFunction.LIGHTEN, lighten_default],
  [BlendFunction.LINEAR_BURN, linear_burn_default],
  [BlendFunction.LINEAR_DODGE, linear_dodge_default],
  [BlendFunction.LINEAR_LIGHT, linear_light_default],
  [BlendFunction.LUMINOSITY, luminosity_default],
  [BlendFunction.MULTIPLY, multiply_default],
  [BlendFunction.NEGATION, negation_default],
  [BlendFunction.NORMAL, normal_default],
  [BlendFunction.OVERLAY, overlay_default],
  [BlendFunction.PIN_LIGHT, pin_light_default],
  [BlendFunction.REFLECT, reflect_default],
  [BlendFunction.SATURATION, saturation_default],
  [BlendFunction.SCREEN, screen_default],
  [BlendFunction.SOFT_LIGHT, soft_light_default],
  [BlendFunction.SRC, src_default],
  [BlendFunction.SUBTRACT, subtract_default],
  [BlendFunction.VIVID_LIGHT, vivid_light_default]
]);
var BlendMode = class extends import_three10.EventDispatcher {
  /**
   * Constructs a new blend mode.
   *
   * @param {BlendFunction} blendFunction - The blend function.
   * @param {Number} opacity - The opacity of the color that will be blended with the base color.
   */
  constructor(blendFunction, opacity = 1) {
    super();
    this._blendFunction = blendFunction;
    this.opacity = new import_three10.Uniform(opacity);
  }
  /**
   * Returns the opacity.
   *
   * @return {Number} The opacity.
   */
  getOpacity() {
    return this.opacity.value;
  }
  /**
   * Sets the opacity.
   *
   * @param {Number} value - The opacity.
   */
  setOpacity(value) {
    this.opacity.value = value;
  }
  /**
   * The blend function.
   *
   * @type {BlendFunction}
   */
  get blendFunction() {
    return this._blendFunction;
  }
  set blendFunction(value) {
    this._blendFunction = value;
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Returns the blend function.
   *
   * @deprecated Use blendFunction instead.
   * @return {BlendFunction} The blend function.
   */
  getBlendFunction() {
    return this.blendFunction;
  }
  /**
   * Sets the blend function.
   *
   * @deprecated Use blendFunction instead.
   * @param {BlendFunction} value - The blend function.
   */
  setBlendFunction(value) {
    this.blendFunction = value;
  }
  /**
   * Returns the blend function shader code.
   *
   * @return {String} The blend function shader code.
   */
  getShaderCode() {
    return blendFunctions.get(this.blendFunction);
  }
};

// src/effects/BloomEffect.js
var import_three19 = __webpack_require__(39437);

// src/enums/KernelSize.js
var KernelSize = {
  VERY_SMALL: 0,
  SMALL: 1,
  MEDIUM: 2,
  LARGE: 3,
  VERY_LARGE: 4,
  HUGE: 5
};

// src/passes/KawaseBlurPass.js
var import_three12 = __webpack_require__(39437);

// src/materials/KawaseBlurMaterial.js
var import_three11 = __webpack_require__(39437);

// src/materials/glsl/convolution.kawase.frag
var convolution_kawase_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}";

// src/materials/glsl/convolution.kawase.vert
var convolution_kawase_default2 = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/KawaseBlurMaterial.js
var kernelPresets = [
  new Float32Array([0, 0]),
  new Float32Array([0, 1, 1]),
  new Float32Array([0, 1, 1, 2]),
  new Float32Array([0, 1, 2, 2, 3]),
  new Float32Array([0, 1, 2, 3, 4, 4, 5]),
  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
];
var KawaseBlurMaterial = class extends import_three11.ShaderMaterial {
  /**
   * Constructs a new convolution material.
   *
   * TODO Remove texelSize param.
   * @param {Vector4} [texelSize] - Deprecated.
   */
  constructor(texelSize = new import_three11.Vector4()) {
    super({
      name: "KawaseBlurMaterial",
      uniforms: {
        inputBuffer: new import_three11.Uniform(null),
        texelSize: new import_three11.Uniform(new import_three11.Vector4()),
        scale: new import_three11.Uniform(1),
        kernel: new import_three11.Uniform(0)
      },
      blending: import_three11.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_kawase_default,
      vertexShader: convolution_kawase_default2
    });
    this.fragmentShader = updateFragmentShader(this.fragmentShader);
    this.setTexelSize(texelSize.x, texelSize.y);
    this.kernelSize = KernelSize.MEDIUM;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.inputBuffer = value;
  }
  /**
   * The kernel sequence for the current kernel size.
   *
   * @type {Float32Array}
   */
  get kernelSequence() {
    return kernelPresets[this.kernelSize];
  }
  /**
   * The blur scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Returns the blur scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.uniforms.scale.value;
  }
  /**
   * Sets the blur scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} value - The scale.
   */
  setScale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Returns the kernel.
   *
   * @return {Float32Array} The kernel.
   * @deprecated Implementation detail, removed with no replacement.
   */
  getKernel() {
    return null;
  }
  /**
   * The current kernel.
   *
   * @type {Number}
   */
  get kernel() {
    return this.uniforms.kernel.value;
  }
  set kernel(value) {
    this.uniforms.kernel.value = value;
  }
  /**
   * Sets the current kernel.
   *
   * @deprecated Use kernel instead.
   * @param {Number} value - The kernel.
   */
  setKernel(value) {
    this.kernel = value;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const x = 1 / width, y = 1 / height;
    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);
  }
};

// src/passes/KawaseBlurPass.js
var KawaseBlurPass = class extends Pass {
  /**
   * Constructs a new Kawase blur pass.
   *
   * @param {Object} [options] - The options.
   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    kernelSize = KernelSize.MEDIUM,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("KawaseBlurPass");
    this.renderTargetA = new import_three12.WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetA.texture.name = "Blur.Target.A";
    this.renderTargetB = this.renderTargetA.clone();
    this.renderTargetB.texture.name = "Blur.Target.B";
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this._blurMaterial = new KawaseBlurMaterial();
    this._blurMaterial.kernelSize = kernelSize;
    this.copyMaterial = new CopyMaterial();
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * The blur material.
   *
   * @type {KawaseBlurMaterial}
   */
  get blurMaterial() {
    return this._blurMaterial;
  }
  /**
   * The blur material.
   *
   * @type {KawaseBlurMaterial}
   * @protected
   */
  set blurMaterial(value) {
    this._blurMaterial = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated Use copyMaterial.dithering instead.
   */
  get dithering() {
    return this.copyMaterial.dithering;
  }
  set dithering(value) {
    this.copyMaterial.dithering = value;
  }
  /**
   * The kernel size.
   *
   * @type {KernelSize}
   * @deprecated Use blurMaterial.kernelSize instead.
   */
  get kernelSize() {
    return this.blurMaterial.kernelSize;
  }
  set kernelSize(value) {
    this.blurMaterial.kernelSize = value;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.width instead.
   */
  get width() {
    return this.resolution.width;
  }
  /**
   * Sets the render width.
   *
   * @type {Number}
   * @deprecated Use resolution.preferredWidth instead.
   */
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.height instead.
   */
  get height() {
    return this.resolution.height;
  }
  /**
   * Sets the render height.
   *
   * @type {Number}
   * @deprecated Use resolution.preferredHeight instead.
   */
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * The current blur scale.
   *
   * @type {Number}
   * @deprecated Use blurMaterial.scale instead.
   */
  get scale() {
    return this.blurMaterial.scale;
  }
  set scale(value) {
    this.blurMaterial.scale = value;
  }
  /**
   * Returns the current blur scale.
   *
   * @deprecated Use blurMaterial.scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.blurMaterial.scale;
  }
  /**
   * Sets the blur scale.
   *
   * @deprecated Use blurMaterial.scale instead.
   * @param {Number} value - The scale.
   */
  setScale(value) {
    this.blurMaterial.scale = value;
  }
  /**
   * Returns the kernel size.
   *
   * @deprecated Use blurMaterial.kernelSize instead.
   * @return {KernelSize} The kernel size.
   */
  getKernelSize() {
    return this.kernelSize;
  }
  /**
   * Sets the kernel size.
   *
   * Larger kernels require more processing power but scale well with larger render resolutions.
   *
   * @deprecated Use blurMaterial.kernelSize instead.
   * @param {KernelSize} value - The kernel size.
   */
  setKernelSize(value) {
    this.kernelSize = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Renders the blur.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    const material = this.blurMaterial;
    const kernelSequence = material.kernelSequence;
    let previousBuffer = inputBuffer;
    this.fullscreenMaterial = material;
    for (let i = 0, l = kernelSequence.length; i < l; ++i) {
      const buffer = (i & 1) === 0 ? renderTargetA : renderTargetB;
      material.kernel = kernelSequence[i];
      material.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(buffer);
      renderer.render(scene, camera);
      previousBuffer = buffer;
    }
    this.fullscreenMaterial = this.copyMaterial;
    this.copyMaterial.inputBuffer = previousBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(scene, camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.renderTargetA.setSize(w, h);
    this.renderTargetB.setSize(w, h);
    this.blurMaterial.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      this.renderTargetA.texture.type = frameBufferType;
      this.renderTargetB.texture.type = frameBufferType;
      if (frameBufferType !== import_three12.UnsignedByteType) {
        this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === import_three12.SRGBColorSpace) {
        this.renderTargetA.texture.colorSpace = import_three12.SRGBColorSpace;
        this.renderTargetB.texture.colorSpace = import_three12.SRGBColorSpace;
      }
    }
  }
  /**
   * An auto sizing flag.
   *
   * @type {Number}
   * @deprecated Use {@link Resolution.AUTO_SIZE} instead.
   */
  static get AUTO_SIZE() {
    return Resolution.AUTO_SIZE;
  }
};

// src/passes/LuminancePass.js
var import_three14 = __webpack_require__(39437);

// src/materials/LuminanceMaterial.js
var import_three13 = __webpack_require__(39437);

// src/materials/glsl/luminance.frag
var luminance_default = "#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}";

// src/materials/LuminanceMaterial.js
var LuminanceMaterial = class extends import_three13.ShaderMaterial {
  /**
   * Constructs a new luminance material.
   *
   * @param {Boolean} [colorOutput=false] - Defines whether the shader should output colors scaled with their luminance value.
   * @param {Vector2} [luminanceRange] - If provided, the shader will mask out texels that aren't in the specified luminance range.
   */
  constructor(colorOutput = false, luminanceRange = null) {
    super({
      name: "LuminanceMaterial",
      defines: {
        THREE_REVISION: import_three13.REVISION.replace(/\D+/g, "")
      },
      uniforms: {
        inputBuffer: new import_three13.Uniform(null),
        threshold: new import_three13.Uniform(0),
        smoothing: new import_three13.Uniform(1),
        range: new import_three13.Uniform(null)
      },
      blending: import_three13.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: luminance_default,
      vertexShader: common_default
    });
    this.colorOutput = colorOutput;
    this.luminanceRange = luminanceRange;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The luminance threshold.
   *
   * @type {Number}
   */
  get threshold() {
    return this.uniforms.threshold.value;
  }
  set threshold(value) {
    if (this.smoothing > 0 || value > 0) {
      this.defines.THRESHOLD = "1";
    } else {
      delete this.defines.THRESHOLD;
    }
    this.uniforms.threshold.value = value;
  }
  /**
   * Returns the luminance threshold.
   *
   * @deprecated Use threshold instead.
   * @return {Number} The threshold.
   */
  getThreshold() {
    return this.threshold;
  }
  /**
   * Sets the luminance threshold.
   *
   * @deprecated Use threshold instead.
   * @param {Number} value - The threshold.
   */
  setThreshold(value) {
    this.threshold = value;
  }
  /**
   * The luminance threshold smoothing.
   *
   * @type {Number}
   */
  get smoothing() {
    return this.uniforms.smoothing.value;
  }
  set smoothing(value) {
    if (this.threshold > 0 || value > 0) {
      this.defines.THRESHOLD = "1";
    } else {
      delete this.defines.THRESHOLD;
    }
    this.uniforms.smoothing.value = value;
  }
  /**
   * Returns the luminance threshold smoothing factor.
   *
   * @deprecated Use smoothing instead.
   * @return {Number} The smoothing factor.
   */
  getSmoothingFactor() {
    return this.smoothing;
  }
  /**
   * Sets the luminance threshold smoothing factor.
   *
   * @deprecated Use smoothing instead.
   * @param {Number} value - The smoothing factor.
   */
  setSmoothingFactor(value) {
    this.smoothing = value;
  }
  /**
   * Indicates whether the luminance threshold is enabled.
   *
   * @type {Boolean}
   * @deprecated Adjust the threshold or smoothing factor instead.
   */
  get useThreshold() {
    return this.threshold > 0 || this.smoothing > 0;
  }
  set useThreshold(value) {
  }
  /**
   * Indicates whether color output is enabled.
   *
   * @type {Boolean}
   */
  get colorOutput() {
    return this.defines.COLOR !== void 0;
  }
  set colorOutput(value) {
    if (value) {
      this.defines.COLOR = "1";
    } else {
      delete this.defines.COLOR;
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether color output is enabled.
   *
   * @deprecated Use colorOutput instead.
   * @return {Boolean} Whether color output is enabled.
   */
  isColorOutputEnabled(value) {
    return this.colorOutput;
  }
  /**
   * Enables or disables color output.
   *
   * @deprecated Use colorOutput instead.
   * @param {Boolean} value - Whether color output should be enabled.
   */
  setColorOutputEnabled(value) {
    this.colorOutput = value;
  }
  /**
   * Indicates whether luminance masking is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get useRange() {
    return this.luminanceRange !== null;
  }
  set useRange(value) {
    this.luminanceRange = null;
  }
  /**
   * The luminance range. Set to null to disable.
   *
   * @type {Boolean}
   */
  get luminanceRange() {
    return this.uniforms.range.value;
  }
  set luminanceRange(value) {
    if (value !== null) {
      this.defines.RANGE = "1";
    } else {
      delete this.defines.RANGE;
    }
    this.uniforms.range.value = value;
    this.needsUpdate = true;
  }
  /**
   * Returns the current luminance range.
   *
   * @deprecated Use luminanceRange instead.
   * @return {Vector2} The luminance range.
   */
  getLuminanceRange() {
    return this.luminanceRange;
  }
  /**
   * Sets a luminance range. Set to null to disable.
   *
   * @deprecated Use luminanceRange instead.
   * @param {Vector2} value - The luminance range.
   */
  setLuminanceRange(value) {
    this.luminanceRange = value;
  }
};

// src/passes/LuminancePass.js
var LuminancePass = class extends Pass {
  /**
   * Constructs a new luminance pass.
   *
   * @param {Object} [options] - The options. See {@link LuminanceMaterial} for additional options.
   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    renderTarget,
    luminanceRange,
    colorOutput,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("LuminancePass");
    this.fullscreenMaterial = new LuminanceMaterial(colorOutput, luminanceRange);
    this.needsSwap = false;
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new import_three14.WebGLRenderTarget(1, 1, { depthBuffer: false });
      this.renderTarget.texture.name = "LuminancePass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * The luminance texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the luminance texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Renders the luminance.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const material = this.fullscreenMaterial;
    material.inputBuffer = inputBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== import_three14.UnsignedByteType) {
      this.renderTarget.texture.type = frameBufferType;
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};

// src/passes/MipmapBlurPass.js
var import_three17 = __webpack_require__(39437);

// src/materials/DownsamplingMaterial.js
var import_three15 = __webpack_require__(39437);

// src/materials/glsl/convolution.downsampling.frag
var convolution_downsampling_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}";

// src/materials/glsl/convolution.downsampling.vert
var convolution_downsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/DownsamplingMaterial.js
var DownsamplingMaterial = class extends import_three15.ShaderMaterial {
  /**
   * Constructs a new downsampling material.
   */
  constructor() {
    super({
      name: "DownsamplingMaterial",
      uniforms: {
        inputBuffer: new import_three15.Uniform(null),
        texelSize: new import_three15.Uniform(new import_three15.Vector2())
      },
      blending: import_three15.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_downsampling_default,
      vertexShader: convolution_downsampling_default2
    });
    this.fragmentShader = updateFragmentShader(this.fragmentShader);
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/materials/UpsamplingMaterial.js
var import_three16 = __webpack_require__(39437);

// src/materials/glsl/convolution.upsampling.frag
var convolution_upsampling_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}";

// src/materials/glsl/convolution.upsampling.vert
var convolution_upsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/UpsamplingMaterial.js
var UpsamplingMaterial = class extends import_three16.ShaderMaterial {
  /**
   * Constructs a new upsampling material.
   */
  constructor() {
    super({
      name: "UpsamplingMaterial",
      uniforms: {
        inputBuffer: new import_three16.Uniform(null),
        supportBuffer: new import_three16.Uniform(null),
        texelSize: new import_three16.Uniform(new import_three16.Vector2()),
        radius: new import_three16.Uniform(0.85)
      },
      blending: import_three16.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_upsampling_default,
      vertexShader: convolution_upsampling_default2
    });
    this.fragmentShader = updateFragmentShader(this.fragmentShader);
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * A support buffer.
   *
   * @type {Texture}
   */
  set supportBuffer(value) {
    this.uniforms.supportBuffer.value = value;
  }
  /**
   * The blur radius.
   *
   * @type {Number}
   */
  get radius() {
    return this.uniforms.radius.value;
  }
  set radius(value) {
    this.uniforms.radius.value = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/passes/MipmapBlurPass.js
var MipmapBlurPass = class extends Pass {
  /**
   * Constructs a new mipmap blur pass.
   *
   * @param {Object} [options] - The options.
   */
  constructor() {
    super("MipmapBlurPass");
    this.needsSwap = false;
    this.renderTarget = new import_three17.WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "Upsampling.Mipmap0";
    this.downsamplingMipmaps = [];
    this.upsamplingMipmaps = [];
    this.downsamplingMaterial = new DownsamplingMaterial();
    this.upsamplingMaterial = new UpsamplingMaterial();
    this.resolution = new import_three17.Vector2();
  }
  /**
   * A texture that contains the blurred result.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * The MIP levels. Default is 8.
   *
   * @type {Number}
   */
  get levels() {
    return this.downsamplingMipmaps.length;
  }
  set levels(value) {
    if (this.levels !== value) {
      const renderTarget = this.renderTarget;
      this.dispose();
      this.downsamplingMipmaps = [];
      this.upsamplingMipmaps = [];
      for (let i = 0; i < value; ++i) {
        const mipmap = renderTarget.clone();
        mipmap.texture.name = "Downsampling.Mipmap" + i;
        this.downsamplingMipmaps.push(mipmap);
      }
      this.upsamplingMipmaps.push(renderTarget);
      for (let i = 1, l = value - 1; i < l; ++i) {
        const mipmap = renderTarget.clone();
        mipmap.texture.name = "Upsampling.Mipmap" + i;
        this.upsamplingMipmaps.push(mipmap);
      }
      this.setSize(this.resolution.x, this.resolution.y);
    }
  }
  /**
   * The blur radius.
   *
   * @type {Number}
   */
  get radius() {
    return this.upsamplingMaterial.radius;
  }
  set radius(value) {
    this.upsamplingMaterial.radius = value;
  }
  /**
   * Renders the blur.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const { scene, camera } = this;
    const { downsamplingMaterial, upsamplingMaterial } = this;
    const { downsamplingMipmaps, upsamplingMipmaps } = this;
    let previousBuffer = inputBuffer;
    this.fullscreenMaterial = downsamplingMaterial;
    for (let i = 0, l = downsamplingMipmaps.length; i < l; ++i) {
      const mipmap = downsamplingMipmaps[i];
      downsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);
      downsamplingMaterial.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(mipmap);
      renderer.render(scene, camera);
      previousBuffer = mipmap;
    }
    this.fullscreenMaterial = upsamplingMaterial;
    for (let i = upsamplingMipmaps.length - 1; i >= 0; --i) {
      const mipmap = upsamplingMipmaps[i];
      upsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);
      upsamplingMaterial.inputBuffer = previousBuffer.texture;
      upsamplingMaterial.supportBuffer = downsamplingMipmaps[i].texture;
      renderer.setRenderTarget(mipmap);
      renderer.render(scene, camera);
      previousBuffer = mipmap;
    }
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.set(width, height);
    let w = resolution.width, h = resolution.height;
    for (let i = 0, l = this.downsamplingMipmaps.length; i < l; ++i) {
      w = Math.round(w * 0.5);
      h = Math.round(h * 0.5);
      this.downsamplingMipmaps[i].setSize(w, h);
      if (i < this.upsamplingMipmaps.length) {
        this.upsamplingMipmaps[i].setSize(w, h);
      }
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      const mipmaps = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
      for (const mipmap of mipmaps) {
        mipmap.texture.type = frameBufferType;
      }
      if (frameBufferType !== import_three17.UnsignedByteType) {
        this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === import_three17.SRGBColorSpace) {
        for (const mipmap of mipmaps) {
          mipmap.texture.colorSpace = import_three17.SRGBColorSpace;
        }
      }
    }
  }
  /**
   * Deletes internal render targets and textures.
   */
  dispose() {
    super.dispose();
    for (const mipmap of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) {
      mipmap.dispose();
    }
  }
};

// src/effects/Effect.js
var import_three18 = __webpack_require__(39437);
var Effect = class extends import_three18.EventDispatcher {
  /**
   * Constructs a new effect.
   *
   * @param {String} name - The name of this effect. Doesn't have to be unique.
   * @param {String} fragmentShader - The fragment shader. This shader is required.
   * @param {Object} [options] - Additional options.
   * @param {EffectAttribute} [options.attributes=EffectAttribute.NONE] - The effect attributes that determine the execution priority and resource requirements.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
   * @param {Map<String, String>} [options.defines] - Custom preprocessor macro definitions. Keys are names and values are code.
   * @param {Map<String, Uniform>} [options.uniforms] - Custom shader uniforms. Keys are names and values are uniforms.
   * @param {Set<WebGLExtension>} [options.extensions] - WebGL extensions.
   * @param {String} [options.vertexShader=null] - The vertex shader. Most effects don't need one.
   */
  constructor(name, fragmentShader, {
    attributes = EffectAttribute.NONE,
    blendFunction = BlendFunction.NORMAL,
    defines = /* @__PURE__ */ new Map(),
    uniforms = /* @__PURE__ */ new Map(),
    extensions = null,
    vertexShader = null
  } = {}) {
    super();
    this.name = name;
    this.renderer = null;
    this.attributes = attributes;
    this.fragmentShader = fragmentShader;
    this.vertexShader = vertexShader;
    this.defines = defines;
    this.uniforms = uniforms;
    this.extensions = extensions;
    this.blendMode = new BlendMode(blendFunction);
    this.blendMode.addEventListener("change", (event) => this.setChanged());
    this._inputColorSpace = import_three18.LinearSRGBColorSpace;
    this._outputColorSpace = import_three18.NoColorSpace;
  }
  /**
   * The input color space.
   *
   * @type {ColorSpace}
   * @experimental
   */
  get inputColorSpace() {
    return this._inputColorSpace;
  }
  /**
   * @type {ColorSpace}
   * @protected
   * @experimental
   */
  set inputColorSpace(value) {
    this._inputColorSpace = value;
    this.setChanged();
  }
  /**
   * The output color space.
   *
   * Should only be changed if this effect converts the input colors to a different color space.
   *
   * @type {ColorSpace}
   * @experimental
   */
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  /**
   * @type {ColorSpace}
   * @protected
   * @experimental
   */
  set outputColorSpace(value) {
    this._outputColorSpace = value;
    this.setChanged();
  }
  /**
   * Sets the main scene.
   *
   * @type {Scene}
   */
  set mainScene(value) {
  }
  /**
   * Sets the main camera.
   *
   * @type {Camera}
   */
  set mainCamera(value) {
  }
  /**
   * Returns the name of this effect.
   *
   * @deprecated Use name instead.
   * @return {String} The name.
   */
  getName() {
    return this.name;
  }
  /**
   * Sets the renderer.
   *
   * @deprecated
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  /**
   * Returns the preprocessor macro definitions.
   *
   * @deprecated Use defines instead.
   * @return {Map<String, String>} The extensions.
   */
  getDefines() {
    return this.defines;
  }
  /**
   * Returns the uniforms of this effect.
   *
   * @deprecated Use uniforms instead.
   * @return {Map<String, Uniform>} The extensions.
   */
  getUniforms() {
    return this.uniforms;
  }
  /**
   * Returns the WebGL extensions that are required by this effect.
   *
   * @deprecated Use extensions instead.
   * @return {Set<WebGLExtension>} The extensions.
   */
  getExtensions() {
    return this.extensions;
  }
  /**
   * Returns the blend mode.
   *
   * The result of this effect will be blended with the result of the previous effect using this blend mode.
   *
   * @deprecated Use blendMode instead.
   * @return {BlendMode} The blend mode.
   */
  getBlendMode() {
    return this.blendMode;
  }
  /**
   * Returns the effect attributes.
   *
   * @return {EffectAttribute} The attributes.
   */
  getAttributes() {
    return this.attributes;
  }
  /**
   * Sets the effect attributes.
   *
   * Effects that have the same attributes will be executed in the order in which they were registered. Some attributes
   * imply a higher priority.
   *
   * @protected
   * @param {EffectAttribute} attributes - The attributes.
   */
  setAttributes(attributes) {
    this.attributes = attributes;
    this.setChanged();
  }
  /**
   * Returns the fragment shader.
   *
   * @return {String} The fragment shader.
   */
  getFragmentShader() {
    return this.fragmentShader;
  }
  /**
   * Sets the fragment shader.
   *
   * @protected
   * @param {String} fragmentShader - The fragment shader.
   */
  setFragmentShader(fragmentShader) {
    this.fragmentShader = fragmentShader;
    this.setChanged();
  }
  /**
   * Returns the vertex shader.
   *
   * @return {String} The vertex shader.
   */
  getVertexShader() {
    return this.vertexShader;
  }
  /**
   * Sets the vertex shader.
   *
   * @protected
   * @param {String} vertexShader - The vertex shader.
   */
  setVertexShader(vertexShader) {
    this.vertexShader = vertexShader;
    this.setChanged();
  }
  /**
   * Informs the associated {@link EffectPass} that this effect requires a shader recompilation.
   *
   * Should be called after changing macros or extensions and after adding/removing uniforms.
   *
   * @protected
   */
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Sets the depth texture.
   *
   * You may override this method if your effect requires direct access to the depth texture that is bound to the
   * associated {@link EffectPass}.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = import_three18.BasicDepthPacking) {
  }
  /**
   * Updates this effect by performing supporting operations.
   *
   * This method is called by the {@link EffectPass} right before the main fullscreen render operation, even if the
   * blend function is set to `SKIP`.
   *
   * You may override this method if you need to update custom uniforms or render additional off-screen textures.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
  }
  /**
   * Updates the size of this effect.
   *
   * You may override this method if you want to be informed about the size of the backbuffer/canvas.
   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
  }
  /**
   * Performs initialization tasks.
   *
   * This method is called when the associated {@link EffectPass} is added to an {@link EffectComposer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   * @example if(!alpha && frameBufferType === UnsignedByteType) { this.myRenderTarget.texture.format = RGBFormat; }
   */
  initialize(renderer, alpha, frameBufferType) {
  }
  /**
   * Performs a shallow search for properties that define a dispose method and deletes them.
   *
   * The {@link EffectComposer} calls this method when it is being destroyed.
   */
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof import_three18.WebGLRenderTarget || property instanceof import_three18.Material || property instanceof import_three18.Texture || property instanceof Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
  }
};

// src/effects/glsl/bloom.frag
var bloom_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}";

// src/effects/BloomEffect.js
var BloomEffect = class extends Effect {
  /**
   * Constructs a new bloom effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.
   * @param {Number} [options.luminanceThreshold=0.9] - The luminance threshold. Raise this value to mask out darker elements in the scene.
   * @param {Number} [options.luminanceSmoothing=0.025] - Controls the smoothness of the luminance threshold.
   * @param {Boolean} [options.mipmapBlur=false] - Enables or disables mipmap blur.
   * @param {Number} [options.intensity=1.0] - The bloom intensity.
   * @param {Number} [options.radius=0.85] - The blur radius. Only applies to mipmap blur.
   * @param {Number} [options.levels=8] - The amount of MIP levels. Only applies to mipmap blur.
   * @param {KernelSize} [options.kernelSize=KernelSize.LARGE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionScale=0.5] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   */
  constructor({
    blendFunction = BlendFunction.SCREEN,
    luminanceThreshold = 0.9,
    luminanceSmoothing = 0.025,
    mipmapBlur = false,
    intensity = 1,
    radius = 0.85,
    levels = 8,
    kernelSize = KernelSize.LARGE,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("BloomEffect", bloom_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["map", new import_three19.Uniform(null)],
        ["intensity", new import_three19.Uniform(intensity)]
      ])
    });
    this.renderTarget = new import_three19.WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "Bloom.Target";
    this.blurPass = new KawaseBlurPass({ kernelSize });
    this.luminancePass = new LuminancePass({ colorOutput: true });
    this.luminanceMaterial.threshold = luminanceThreshold;
    this.luminanceMaterial.smoothing = luminanceSmoothing;
    this.mipmapBlurPass = new MipmapBlurPass();
    this.mipmapBlurPass.enabled = mipmapBlur;
    this.mipmapBlurPass.radius = radius;
    this.mipmapBlurPass.levels = levels;
    this.uniforms.get("map").value = mipmapBlur ? this.mipmapBlurPass.texture : this.renderTarget.texture;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * A texture that contains the intermediate result of this effect.
   *
   * @type {Texture}
   */
  get texture() {
    return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;
  }
  /**
   * Returns the generated bloom texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Returns the blur pass.
   *
   * @deprecated
   * @return {KawaseBlurPass} The blur pass.
   */
  getBlurPass() {
    return this.blurPass;
  }
  /**
   * Returns the luminance pass.
   *
   * @deprecated Use luminancePass instead.
   * @return {LuminancePass} The luminance pass.
   */
  getLuminancePass() {
    return this.luminancePass;
  }
  /**
   * The luminance material.
   *
   * @type {LuminanceMaterial}
   */
  get luminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  /**
   * Returns the luminance material.
   *
   * @deprecated Use luminanceMaterial instead.
   * @return {LuminanceMaterial} The material.
   */
  getLuminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated
   */
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated
   */
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated Use EffectPass.dithering instead.
   */
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(value) {
    this.blurPass.dithering = value;
  }
  /**
   * The blur kernel size.
   *
   * @type {KernelSize}
   * @deprecated
   */
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(value) {
    this.blurPass.kernelSize = value;
  }
  /**
   * @type {Number}
   * @deprecated
   */
  get distinction() {
    console.warn(this.name, "distinction was removed");
    return 1;
  }
  set distinction(value) {
    console.warn(this.name, "distinction was removed");
  }
  /**
   * The bloom intensity.
   *
   * @type {Number}
   */
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(value) {
    this.uniforms.get("intensity").value = value;
  }
  /**
   * The bloom intensity.
   *
   * @deprecated Use intensity instead.
   * @return {Number} The intensity.
   */
  getIntensity() {
    return this.intensity;
  }
  /**
   * Sets the bloom intensity.
   *
   * @deprecated Use intensity instead.
   * @param {Number} value - The intensity.
   */
  setIntensity(value) {
    this.intensity = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget = this.renderTarget;
    const luminancePass = this.luminancePass;
    if (luminancePass.enabled) {
      luminancePass.render(renderer, inputBuffer);
      if (this.mipmapBlurPass.enabled) {
        this.mipmapBlurPass.render(renderer, luminancePass.renderTarget);
      } else {
        this.blurPass.render(renderer, luminancePass.renderTarget, renderTarget);
      }
    } else {
      if (this.mipmapBlurPass.enabled) {
        this.mipmapBlurPass.render(renderer, inputBuffer);
      } else {
        this.blurPass.render(renderer, inputBuffer, renderTarget);
      }
    }
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.blurPass.resolution.copy(resolution);
    this.luminancePass.setSize(width, height);
    this.mipmapBlurPass.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.blurPass.initialize(renderer, alpha, frameBufferType);
    this.luminancePass.initialize(renderer, alpha, frameBufferType);
    this.mipmapBlurPass.initialize(renderer, alpha, frameBufferType);
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (renderer !== null && renderer.outputColorSpace === import_three19.SRGBColorSpace) {
        this.renderTarget.texture.colorSpace = import_three19.SRGBColorSpace;
      }
    }
  }
};

// src/effects/BokehEffect.js
var import_three20 = __webpack_require__(39437);

// src/effects/glsl/bokeh.frag
var bokeh_default = "uniform float focus;uniform float dof;uniform float aperture;uniform float maxBlur;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec2 aspectCorrection=vec2(1.0,aspect);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat focusNear=clamp(focus-dof,0.0,1.0);float focusFar=clamp(focus+dof,0.0,1.0);float low=step(linearDepth,focusNear);float high=step(focusFar,linearDepth);float factor=(linearDepth-focusNear)*low+(linearDepth-focusFar)*high;vec2 dofBlur=vec2(clamp(factor*aperture,-maxBlur,maxBlur));vec2 dofblur9=dofBlur*0.9;vec2 dofblur7=dofBlur*0.7;vec2 dofblur4=dofBlur*0.4;vec4 color=inputColor;color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.37,0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.40,0.0)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.37,-0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.15,-0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.15,0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.37,0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.37,-0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,-0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.37,0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.37,-0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.15,-0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.15,0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.37,0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.37,-0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.15,-0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.40,0.0)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.4,0.0)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofblur4);outputColor=color/41.0;}";

// src/effects/BokehEffect.js
var BokehEffect = class extends Effect {
  /**
   * Constructs a new bokeh effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
   * @param {Number} [options.focus=0.5] - The focus distance ratio, ranging from 0.0 to 1.0.
   * @param {Number} [options.dof=0.02] - Depth of field. An area in front of and behind the focal point that still appears sharp.
   * @param {Number} [options.aperture=0.015] - Camera aperture scale. Bigger values for stronger blur and shallower depth of field.
   * @param {Number} [options.maxBlur=1.0] - The maximum blur strength.
   */
  constructor({
    blendFunction,
    focus = 0.5,
    dof = 0.02,
    aperture = 0.015,
    maxBlur = 1
  } = {}) {
    super("BokehEffect", bokeh_default, {
      blendFunction,
      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["focus", new import_three20.Uniform(focus)],
        ["dof", new import_three20.Uniform(dof)],
        ["aperture", new import_three20.Uniform(aperture)],
        ["maxBlur", new import_three20.Uniform(maxBlur)]
      ])
    });
  }
};

// src/effects/BrightnessContrastEffect.js
var import_three21 = __webpack_require__(39437);

// src/effects/glsl/brightness-contrast.frag
var brightness_contrast_default = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}";

// src/effects/BrightnessContrastEffect.js
var BrightnessContrastEffect = class extends Effect {
  /**
   * Constructs a new brightness/contrast effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {Number} [options.brightness=0.0] - The brightness factor, ranging from -1 to 1, where 0 means no change.
   * @param {Number} [options.contrast=0.0] - The contrast factor, ranging from -1 to 1, where 0 means no change.
   */
  constructor({ blendFunction = BlendFunction.SRC, brightness = 0, contrast = 0 } = {}) {
    super("BrightnessContrastEffect", brightness_contrast_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["brightness", new import_three21.Uniform(brightness)],
        ["contrast", new import_three21.Uniform(contrast)]
      ])
    });
    this.inputColorSpace = import_three21.SRGBColorSpace;
  }
  /**
   * The brightness.
   *
   * @type {Number}
   */
  get brightness() {
    return this.uniforms.get("brightness").value;
  }
  set brightness(value) {
    this.uniforms.get("brightness").value = value;
  }
  /**
   * Returns the brightness.
   *
   * @deprecated Use brightness instead.
   * @return {Number} The brightness.
   */
  getBrightness() {
    return this.brightness;
  }
  /**
   * Sets the brightness.
   *
   * @deprecated Use brightness instead.
   * @param {Number} value - The brightness.
   */
  setBrightness(value) {
    this.brightness = value;
  }
  /**
   * The contrast.
   *
   * @type {Number}
   */
  get contrast() {
    return this.uniforms.get("contrast").value;
  }
  set contrast(value) {
    this.uniforms.get("contrast").value = value;
  }
  /**
   * Returns the contrast.
   *
   * @deprecated Use contrast instead.
   * @return {Number} The contrast.
   */
  getContrast() {
    return this.contrast;
  }
  /**
   * Sets the contrast.
   *
   * @deprecated Use contrast instead.
   * @param {Number} value - The contrast.
   */
  setContrast(value) {
    this.contrast = value;
  }
};

// src/effects/glsl/color-average.frag
var color_average_default = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}";

// src/effects/ColorAverageEffect.js
var ColorAverageEffect = class extends Effect {
  /**
   * Constructs a new color average effect.
   *
   * @param {BlendFunction} [blendFunction] - The blend function of this effect.
   */
  constructor(blendFunction) {
    super("ColorAverageEffect", color_average_default, { blendFunction });
  }
};

// src/effects/ColorDepthEffect.js
var import_three22 = __webpack_require__(39437);

// src/effects/glsl/color-depth.frag
var color_depth_default = "uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}";

// src/effects/ColorDepthEffect.js
var ColorDepthEffect = class extends Effect {
  /**
   * Constructs a new color depth effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
   * @param {Number} [options.bits=16] - The color bit depth.
   */
  constructor({ blendFunction, bits = 16 } = {}) {
    super("ColorDepthEffect", color_depth_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["factor", new import_three22.Uniform(1)]
      ])
    });
    this.bits = 0;
    this.bitDepth = bits;
  }
  /**
   * The virtual amount of color bits.
   *
   * Each color channel effectively uses a fourth of the total amount of bits. Alpha remains unaffected.
   *
   * @type {Number}
   */
  get bitDepth() {
    return this.bits;
  }
  set bitDepth(value) {
    this.bits = value;
    this.uniforms.get("factor").value = Math.pow(2, value / 3);
  }
  /**
   * Returns the current color bit depth.
   *
   * @return {Number} The bit depth.
   */
  getBitDepth() {
    return this.bitDepth;
  }
  /**
   * Sets the virtual amount of color bits.
   *
   * @param {Number} value - The bit depth.
   */
  setBitDepth(value) {
    this.bitDepth = value;
  }
};

// src/effects/ChromaticAberrationEffect.js
var import_three23 = __webpack_require__(39437);

// src/effects/glsl/chromatic-aberration.frag
var chromatic_aberration_default = "#ifdef RADIAL_MODULATION\nuniform float modulationOffset;\n#endif\nvarying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=inputColor.ra;vec2 ba=inputColor.ba;\n#ifdef RADIAL_MODULATION\nconst vec2 center=vec2(0.5);float d=distance(uv,center)*2.0;d=max(d-modulationOffset,0.0);if(vActive>0.0&&d>0.0){ra=texture2D(inputBuffer,mix(uv,vUvR,d)).ra;ba=texture2D(inputBuffer,mix(uv,vUvB,d)).ba;}\n#else\nif(vActive>0.0){ra=texture2D(inputBuffer,vUvR).ra;ba=texture2D(inputBuffer,vUvB).ba;}\n#endif\noutputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}";

// src/effects/glsl/chromatic-aberration.vert
var chromatic_aberration_default2 = "uniform vec2 offset;varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vActive=(shift.x!=0.0||shift.y!=0.0)?1.0:0.0;vUvR=uv+shift;vUvB=uv-shift;}";

// src/effects/ChromaticAberrationEffect.js
var ChromaticAberrationEffect = class extends Effect {
  /**
   * Constructs a new chromatic aberration effect.
   *
   * @param {Object} [options] - The options.
   * @param {Vector2} [options.offset] - The color offset.
   * @param {Boolean} [options.radialModulation=false] - Whether the effect should be modulated with a radial gradient.
   * @param {Number} [options.modulationOffset=0.15] - The modulation offset. Only applies if `radialModulation` is enabled.
   */
  constructor({
    offset = new import_three23.Vector2(1e-3, 5e-4),
    radialModulation = false,
    modulationOffset = 0.15
  } = {}) {
    super("ChromaticAberrationEffect", chromatic_aberration_default, {
      vertexShader: chromatic_aberration_default2,
      attributes: EffectAttribute.CONVOLUTION,
      uniforms: /* @__PURE__ */ new Map([
        ["offset", new import_three23.Uniform(offset)],
        ["modulationOffset", new import_three23.Uniform(modulationOffset)]
      ])
    });
    this.radialModulation = radialModulation;
  }
  /**
   * The color offset.
   *
   * @type {Vector2}
   */
  get offset() {
    return this.uniforms.get("offset").value;
  }
  set offset(value) {
    this.uniforms.get("offset").value = value;
  }
  /**
   * Indicates whether radial modulation is enabled.
   *
   * When enabled, the effect will be weaker in the middle and stronger towards the screen edges.
   *
   * @type {Boolean}
   */
  get radialModulation() {
    return this.defines.has("RADIAL_MODULATION");
  }
  set radialModulation(value) {
    if (value) {
      this.defines.set("RADIAL_MODULATION", "1");
    } else {
      this.defines.delete("RADIAL_MODULATION");
    }
    this.setChanged();
  }
  /**
   * The modulation offset.
   *
   * @type {Number}
   */
  get modulationOffset() {
    return this.uniforms.get("modulationOffset").value;
  }
  set modulationOffset(value) {
    this.uniforms.get("modulationOffset").value = value;
  }
  /**
   * Returns the color offset vector.
   *
   * @deprecated Use offset instead.
   * @return {Vector2} The offset.
   */
  getOffset() {
    return this.offset;
  }
  /**
   * Sets the color offset vector.
   *
   * @deprecated Use offset instead.
   * @param {Vector2} value - The offset.
   */
  setOffset(value) {
    this.offset = value;
  }
};

// src/effects/glsl/depth.frag
var depth_default = "void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){\n#ifdef INVERTED\nvec3 color=vec3(1.0-depth);\n#else\nvec3 color=vec3(depth);\n#endif\noutputColor=vec4(color,inputColor.a);}";

// src/effects/DepthEffect.js
var DepthEffect = class extends Effect {
  /**
   * Constructs a new depth effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {Boolean} [options.inverted=false] - Whether the depth should be inverted.
   */
  constructor({ blendFunction = BlendFunction.SRC, inverted = false } = {}) {
    super("DepthEffect", depth_default, {
      blendFunction,
      attributes: EffectAttribute.DEPTH
    });
    this.inverted = inverted;
  }
  /**
   * Indicates whether depth should be inverted.
   *
   * @type {Boolean}
   */
  get inverted() {
    return this.defines.has("INVERTED");
  }
  set inverted(value) {
    if (this.inverted !== value) {
      if (value) {
        this.defines.set("INVERTED", "1");
      } else {
        this.defines.delete("INVERTED");
      }
      this.setChanged();
    }
  }
  /**
   * Indicates whether the rendered depth is inverted.
   *
   * @deprecated Use inverted instead.
   * @return {Boolean} Whether the rendered depth is inverted.
   */
  isInverted() {
    return this.inverted;
  }
  /**
   * Enables or disables depth inversion.
   *
   * @deprecated Use inverted instead.
   * @param {Boolean} value - Whether depth should be inverted.
   */
  setInverted(value) {
    this.inverted = value;
  }
};

// src/effects/DepthOfFieldEffect.js
var import_three28 = __webpack_require__(39437);

// src/enums/ColorChannel.js
var ColorChannel = {
  RED: 0,
  GREEN: 1,
  BLUE: 2,
  ALPHA: 3
};

// src/enums/MaskFunction.js
var MaskFunction = {
  DISCARD: 0,
  MULTIPLY: 1,
  MULTIPLY_RGB_SET_ALPHA: 2,
  MULTIPLY_RGB: 3
};

// src/materials/BokehMaterial.js
var import_three24 = __webpack_require__(39437);

// src/materials/glsl/convolution.bokeh.frag
var convolution_bokeh_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if PASS == 1\nuniform vec4 kernel64[32];\n#else\nuniform vec4 kernel16[8];\n#endif\nuniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){\n#ifdef FOREGROUND\nvec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;\n#else\nfloat coc=texture2D(cocBuffer,vUv).g*scale;\n#endif\nif(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\n#ifdef FOREGROUND\nvec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);\n#else\nvec2 step=texelSize*coc;\n#endif\n#if PASS == 1\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\n#else\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\n#endif\n}}";

// src/materials/BokehMaterial.js
var BokehMaterial = class extends import_three24.ShaderMaterial {
  /**
   * Constructs a new bokeh material.
   *
   * @param {Boolean} [fill=false] - Enables or disables the bokeh highlight fill mode.
   * @param {Boolean} [foreground=false] - Determines whether this material will be applied to foreground colors.
   */
  constructor(fill = false, foreground = false) {
    super({
      name: "BokehMaterial",
      defines: {
        PASS: fill ? "2" : "1"
      },
      uniforms: {
        inputBuffer: new import_three24.Uniform(null),
        cocBuffer: new import_three24.Uniform(null),
        texelSize: new import_three24.Uniform(new import_three24.Vector2()),
        kernel64: new import_three24.Uniform(null),
        kernel16: new import_three24.Uniform(null),
        scale: new import_three24.Uniform(1)
      },
      blending: import_three24.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_bokeh_default,
      vertexShader: common_default
    });
    if (foreground) {
      this.defines.FOREGROUND = "1";
    }
    this.generateKernel();
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The circle of confusion buffer.
   *
   * @type {Texture}
   */
  set cocBuffer(value) {
    this.uniforms.cocBuffer.value = value;
  }
  /**
   * Sets the circle of confusion buffer.
   *
   * @deprecated Use cocBuffer instead.
   * @param {Texture} value - The buffer.
   */
  setCoCBuffer(value) {
    this.uniforms.cocBuffer.value = value;
  }
  /**
   * The blur scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Returns the blur scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The scale.
   */
  getScale(value) {
    return this.scale;
  }
  /**
   * Sets the blur scale.
   *
   * @deprecated Use scale instead.
   * @param {Number} value - The scale.
   */
  setScale(value) {
    this.scale = value;
  }
  /**
   * Generates the blur kernel.
   *
   * @private
   */
  generateKernel() {
    const GOLDEN_ANGLE = 2.39996323;
    const points64 = new Float64Array(128);
    const points16 = new Float64Array(32);
    let i64 = 0, i16 = 0;
    for (let i = 0, sqrt80 = Math.sqrt(80); i < 80; ++i) {
      const theta = i * GOLDEN_ANGLE;
      const r = Math.sqrt(i) / sqrt80;
      const u = r * Math.cos(theta), v3 = r * Math.sin(theta);
      if (i % 5 === 0) {
        points16[i16++] = u;
        points16[i16++] = v3;
      } else {
        points64[i64++] = u;
        points64[i64++] = v3;
      }
    }
    this.uniforms.kernel64.value = points64;
    this.uniforms.kernel16.value = points16;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/materials/CircleOfConfusionMaterial.js
var import_three25 = __webpack_require__(39437);

// src/utils/orthographicDepthToViewZ.js
function orthographicDepthToViewZ(depth, near, far) {
  return depth * (near - far) - near;
}

// src/utils/viewZToOrthographicDepth.js
function viewZToOrthographicDepth(viewZ, near, far) {
  return Math.min(Math.max((viewZ + near) / (near - far), 0), 1);
}

// src/materials/glsl/circle-of-confusion.frag
var circle_of_confusion_default = "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nfloat depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nfloat depth=texture2D(depthBuffer,uv).r;\n#endif\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;\n#endif\nreturn depth;}void main(){float depth=readDepth(vUv);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}";

// src/materials/CircleOfConfusionMaterial.js
var CircleOfConfusionMaterial = class extends import_three25.ShaderMaterial {
  /**
   * Constructs a new CoC material.
   *
   * @param {Camera} camera - A camera.
   */
  constructor(camera) {
    super({
      name: "CircleOfConfusionMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new import_three25.Uniform(null),
        focusDistance: new import_three25.Uniform(0),
        focusRange: new import_three25.Uniform(0),
        cameraNear: new import_three25.Uniform(0.3),
        cameraFar: new import_three25.Uniform(1e3)
      },
      blending: import_three25.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: circle_of_confusion_default,
      vertexShader: common_default
    });
    this.uniforms.focalLength = this.uniforms.focusRange;
    this.copyCameraSettings(camera);
  }
  /**
   * The current near plane setting.
   *
   * @type {Number}
   * @private
   */
  get near() {
    return this.uniforms.cameraNear.value;
  }
  /**
   * The current far plane setting.
   *
   * @type {Number}
   * @private
   */
  get far() {
    return this.uniforms.cameraFar.value;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = import_three25.BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * The focus distance. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get focusDistance() {
    return this.uniforms.focusDistance.value;
  }
  set focusDistance(value) {
    this.uniforms.focusDistance.value = value;
  }
  /**
   * The focus distance in world units.
   *
   * @type {Number}
   */
  get worldFocusDistance() {
    return -orthographicDepthToViewZ(this.focusDistance, this.near, this.far);
  }
  set worldFocusDistance(value) {
    this.focusDistance = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * Returns the focus distance.
   *
   * @deprecated Use focusDistance instead.
   * @return {Number} The focus distance.
   */
  getFocusDistance(value) {
    this.uniforms.focusDistance.value = value;
  }
  /**
   * Sets the focus distance.
   *
   * @deprecated Use focusDistance instead.
   * @param {Number} value - The focus distance.
   */
  setFocusDistance(value) {
    this.uniforms.focusDistance.value = value;
  }
  /**
   * The focal length.
   *
   * @deprecated Renamed to focusRange.
   * @type {Number}
   */
  get focalLength() {
    return this.focusRange;
  }
  set focalLength(value) {
    this.focusRange = value;
  }
  /**
   * The focus range. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get focusRange() {
    return this.uniforms.focusRange.value;
  }
  set focusRange(value) {
    this.uniforms.focusRange.value = value;
  }
  /**
   * The focus range in world units.
   *
   * @type {Number}
   */
  get worldFocusRange() {
    return -orthographicDepthToViewZ(this.focusRange, this.near, this.far);
  }
  set worldFocusRange(value) {
    this.focusRange = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * Returns the focal length.
   *
   * @deprecated Use focusRange instead.
   * @return {Number} The focal length.
   */
  getFocalLength(value) {
    return this.focusRange;
  }
  /**
   * Sets the focal length.
   *
   * @deprecated Use focusRange instead.
   * @param {Number} value - The focal length.
   */
  setFocalLength(value) {
    this.focusRange = value;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof import_three25.PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
};

// src/materials/MaskMaterial.js
var import_three26 = __webpack_require__(39437);

// src/materials/glsl/mask.frag
var mask_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef MASK_PRECISION_HIGH\nuniform mediump sampler2D maskTexture;\n#else\nuniform lowp sampler2D maskTexture;\n#endif\n#if MASK_FUNCTION != 0\nuniform float strength;\n#endif\nvarying vec2 vUv;void main(){\n#if COLOR_CHANNEL == 0\nfloat mask=texture2D(maskTexture,vUv).r;\n#elif COLOR_CHANNEL == 1\nfloat mask=texture2D(maskTexture,vUv).g;\n#elif COLOR_CHANNEL == 2\nfloat mask=texture2D(maskTexture,vUv).b;\n#else\nfloat mask=texture2D(maskTexture,vUv).a;\n#endif\n#if MASK_FUNCTION == 0\n#ifdef INVERTED\nmask=step(mask,0.0);\n#else\nmask=1.0-step(mask,0.0);\n#endif\n#else\nmask=clamp(mask*strength,0.0,1.0);\n#ifdef INVERTED\nmask=1.0-mask;\n#endif\n#endif\n#if MASK_FUNCTION == 3\nvec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);\n#elif MASK_FUNCTION == 2\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\n#else\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\n#endif\n}";

// src/materials/MaskMaterial.js
var MaskMaterial = class extends import_three26.ShaderMaterial {
  /**
   * Constructs a new mask material.
   *
   * @param {Texture} [maskTexture] - The mask texture.
   */
  constructor(maskTexture = null) {
    super({
      name: "MaskMaterial",
      uniforms: {
        maskTexture: new import_three26.Uniform(maskTexture),
        inputBuffer: new import_three26.Uniform(null),
        strength: new import_three26.Uniform(1)
      },
      blending: import_three26.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: mask_default,
      vertexShader: common_default
    });
    this.colorChannel = ColorChannel.RED;
    this.maskFunction = MaskFunction.DISCARD;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The mask texture.
   *
   * @type {Texture}
   */
  set maskTexture(value) {
    this.uniforms.maskTexture.value = value;
    delete this.defines.MASK_PRECISION_HIGH;
    if (value.type !== import_three26.UnsignedByteType) {
      this.defines.MASK_PRECISION_HIGH = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Sets the mask texture.
   *
   * @deprecated Use maskTexture instead.
   * @param {Texture} value - The texture.
   */
  setMaskTexture(value) {
    this.maskTexture = value;
  }
  /**
   * Sets the color channel to use for masking. Default is `ColorChannel.RED`.
   *
   * @type {ColorChannel}
   */
  set colorChannel(value) {
    this.defines.COLOR_CHANNEL = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the color channel to use for masking. Default is `ColorChannel.RED`.
   *
   * @deprecated Use colorChannel instead.
   * @param {ColorChannel} value - The channel.
   */
  setColorChannel(value) {
    this.colorChannel = value;
  }
  /**
   * The masking technique. Default is `MaskFunction.DISCARD`.
   *
   * @type {MaskFunction}
   */
  set maskFunction(value) {
    this.defines.MASK_FUNCTION = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the masking technique. Default is `MaskFunction.DISCARD`.
   *
   * @deprecated Use maskFunction instead.
   * @param {MaskFunction} value - The function.
   */
  setMaskFunction(value) {
    this.maskFunction = value;
  }
  /**
   * Indicates whether the masking is inverted.
   *
   * @type {Boolean}
   */
  get inverted() {
    return this.defines.INVERTED !== void 0;
  }
  set inverted(value) {
    if (this.inverted && !value) {
      delete this.defines.INVERTED;
    } else if (value) {
      this.defines.INVERTED = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether the masking is inverted.
   *
   * @deprecated Use inverted instead.
   * @return {Boolean} Whether the masking is inverted.
   */
  isInverted() {
    return this.inverted;
  }
  /**
   * Determines whether the masking should be inverted.
   *
   * @deprecated Use inverted instead.
   * @param {Boolean} value - Whether the masking should be inverted.
   */
  setInverted(value) {
    this.inverted = value;
  }
  /**
   * The current mask strength.
   *
   * Individual mask values will be clamped to [0.0, 1.0]. Has no effect when the mask function is set to `DISCARD`.
   *
   * @type {Number}
   */
  get strength() {
    return this.uniforms.strength.value;
  }
  set strength(value) {
    this.uniforms.strength.value = value;
  }
  /**
   * Returns the current mask strength.
   *
   * @deprecated Use strength instead.
   * @return {Number} The mask strength.
   */
  getStrength() {
    return this.strength;
  }
  /**
   * Sets the mask strength.
   *
   * Has no effect when the mask function is set to `DISCARD`.
   *
   * @deprecated Use strength instead.
   * @param {Number} value - The mask strength.
   */
  setStrength(value) {
    this.strength = value;
  }
};

// src/passes/ShaderPass.js
var import_three27 = __webpack_require__(39437);
var ShaderPass = class extends Pass {
  /**
   * Constructs a new shader pass.
   *
   * @param {ShaderMaterial} material - A shader material.
   * @param {String} [input="inputBuffer"] - The name of the input buffer uniform.
   */
  constructor(material, input = "inputBuffer") {
    super("ShaderPass");
    this.fullscreenMaterial = material;
    this.input = input;
  }
  /**
   * Sets the name of the input buffer uniform.
   *
   * @param {String} input - The name of the input buffer uniform.
   * @deprecated Use input instead.
   */
  setInput(input) {
    this.input = input;
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const uniforms = this.fullscreenMaterial.uniforms;
    if (inputBuffer !== null && uniforms !== void 0 && uniforms[this.input] !== void 0) {
      uniforms[this.input].value = inputBuffer.texture;
    }
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== import_three27.UnsignedByteType) {
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};

// src/effects/glsl/depth-of-field.frag
var depth_of_field_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;\n#else\nuniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;\n#endif\nuniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);\n#if MASK_FUNCTION == 1\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);\n#else\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);\n#endif\nvec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}";

// src/effects/DepthOfFieldEffect.js
var DepthOfFieldEffect = class extends Effect {
  /**
   * Constructs a new depth of field effect.
   *
   * @param {Camera} camera - The main camera.
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
   * @param {Number} [options.worldFocusDistance] - The focus distance in world units.
   * @param {Number} [options.worldFocusRange] - The focus distance in world units.
   * @param {Number} [options.focusDistance=0.0] - The normalized focus distance. Range is [0.0, 1.0].
   * @param {Number} [options.focusRange=0.1] - The focus range. Range is [0.0, 1.0].
   * @param {Number} [options.focalLength=0.1] - Deprecated.
   * @param {Number} [options.bokehScale=1.0] - The scale of the bokeh blur.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(camera, {
    blendFunction,
    worldFocusDistance,
    worldFocusRange,
    focusDistance = 0,
    focalLength = 0.1,
    focusRange = focalLength,
    bokehScale = 1,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("DepthOfFieldEffect", depth_of_field_default, {
      blendFunction,
      attributes: EffectAttribute.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["nearColorBuffer", new import_three28.Uniform(null)],
        ["farColorBuffer", new import_three28.Uniform(null)],
        ["nearCoCBuffer", new import_three28.Uniform(null)],
        ["farCoCBuffer", new import_three28.Uniform(null)],
        ["scale", new import_three28.Uniform(1)]
      ])
    });
    this.camera = camera;
    this.renderTarget = new import_three28.WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "DoF.Intermediate";
    this.renderTargetMasked = this.renderTarget.clone();
    this.renderTargetMasked.texture.name = "DoF.Masked.Far";
    this.renderTargetNear = this.renderTarget.clone();
    this.renderTargetNear.texture.name = "DoF.Bokeh.Near";
    this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture;
    this.renderTargetFar = this.renderTarget.clone();
    this.renderTargetFar.texture.name = "DoF.Bokeh.Far";
    this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture;
    this.renderTargetCoC = this.renderTarget.clone();
    this.renderTargetCoC.texture.name = "DoF.CoC";
    this.uniforms.get("farCoCBuffer").value = this.renderTargetCoC.texture;
    this.renderTargetCoCBlurred = this.renderTargetCoC.clone();
    this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred";
    this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture;
    this.cocPass = new ShaderPass(new CircleOfConfusionMaterial(camera));
    const cocMaterial = this.cocMaterial;
    cocMaterial.focusDistance = focusDistance;
    cocMaterial.focusRange = focusRange;
    if (worldFocusDistance !== void 0) {
      cocMaterial.worldFocusDistance = worldFocusDistance;
    }
    if (worldFocusRange !== void 0) {
      cocMaterial.worldFocusRange = worldFocusRange;
    }
    this.blurPass = new KawaseBlurPass({ resolutionScale, resolutionX, resolutionY, kernelSize: KernelSize.MEDIUM });
    this.maskPass = new ShaderPass(new MaskMaterial(this.renderTargetCoC.texture));
    const maskMaterial = this.maskPass.fullscreenMaterial;
    maskMaterial.colorChannel = ColorChannel.GREEN;
    this.maskFunction = MaskFunction.MULTIPLY_RGB;
    this.bokehNearBasePass = new ShaderPass(new BokehMaterial(false, true));
    this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;
    this.bokehNearFillPass = new ShaderPass(new BokehMaterial(true, true));
    this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;
    this.bokehFarBasePass = new ShaderPass(new BokehMaterial(false, false));
    this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;
    this.bokehFarFillPass = new ShaderPass(new BokehMaterial(true, false));
    this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;
    this.target = null;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.bokehScale = bokehScale;
  }
  set mainCamera(value) {
    this.camera = value;
    this.cocMaterial.copyCameraSettings(value);
  }
  /**
   * The circle of confusion texture.
   *
   * @type {Texture}
   */
  get cocTexture() {
    return this.renderTargetCoC.texture;
  }
  /**
   * The mask function. Default is `MULTIPLY_RGB`.
   *
   * @type {MaskFunction}
   */
  get maskFunction() {
    return this.maskPass.fullscreenMaterial.maskFunction;
  }
  set maskFunction(value) {
    if (this.maskFunction !== value) {
      this.defines.set("MASK_FUNCTION", value.toFixed(0));
      this.maskPass.fullscreenMaterial.maskFunction = value;
      this.setChanged();
    }
  }
  /**
   * The circle of confusion material.
   *
   * @type {CircleOfConfusionMaterial}
   */
  get cocMaterial() {
    return this.cocPass.fullscreenMaterial;
  }
  /**
   * The circle of confusion material.
   *
   * @deprecated Use cocMaterial instead.
   * @type {CircleOfConfusionMaterial}
   */
  get circleOfConfusionMaterial() {
    return this.cocMaterial;
  }
  /**
   * Returns the circle of confusion material.
   *
   * @deprecated Use cocMaterial instead.
   * @return {CircleOfConfusionMaterial} The material.
   */
  getCircleOfConfusionMaterial() {
    return this.cocMaterial;
  }
  /**
   * Returns the pass that blurs the foreground CoC buffer to soften edges.
   *
   * @deprecated Use blurPass instead.
   * @return {KawaseBlurPass} The blur pass.
   */
  getBlurPass() {
    return this.blurPass;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * The current bokeh scale.
   *
   * @type {Number}
   */
  get bokehScale() {
    return this.uniforms.get("scale").value;
  }
  set bokehScale(value) {
    this.bokehNearBasePass.fullscreenMaterial.scale = value;
    this.bokehNearFillPass.fullscreenMaterial.scale = value;
    this.bokehFarBasePass.fullscreenMaterial.scale = value;
    this.bokehFarFillPass.fullscreenMaterial.scale = value;
    this.maskPass.fullscreenMaterial.strength = value;
    this.uniforms.get("scale").value = value;
  }
  /**
   * Returns the current bokeh scale.
   *
   * @deprecated Use bokehScale instead.
   * @return {Number} The scale.
   */
  getBokehScale() {
    return this.bokehScale;
  }
  /**
   * Sets the bokeh scale.
   *
   * @deprecated Use bokehScale instead.
   * @param {Number} value - The scale.
   */
  setBokehScale(value) {
    this.bokehScale = value;
  }
  /**
   * Returns the current auto focus target.
   *
   * @deprecated Use target instead.
   * @return {Vector3} The target.
   */
  getTarget() {
    return this.target;
  }
  /**
   * Sets the auto focus target.
   *
   * @deprecated Use target instead.
   * @param {Vector3} value - The target.
   */
  setTarget(value) {
    this.target = value;
  }
  /**
   * Calculates the focus distance from the camera to the given position.
   *
   * @param {Vector3} target - The target.
   * @return {Number} The normalized focus distance.
   */
  calculateFocusDistance(target) {
    const camera = this.camera;
    const distance = camera.position.distanceTo(target);
    return viewZToOrthographicDepth(-distance, camera.near, camera.far);
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = import_three28.BasicDepthPacking) {
    this.cocMaterial.depthBuffer = depthTexture;
    this.cocMaterial.depthPacking = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget = this.renderTarget;
    const renderTargetCoC = this.renderTargetCoC;
    const renderTargetCoCBlurred = this.renderTargetCoCBlurred;
    const renderTargetMasked = this.renderTargetMasked;
    if (this.target !== null) {
      const distance = this.calculateFocusDistance(this.target);
      this.cocMaterial.focusDistance = distance;
    }
    this.cocPass.render(renderer, null, renderTargetCoC);
    this.blurPass.render(renderer, renderTargetCoC, renderTargetCoCBlurred);
    this.maskPass.render(renderer, inputBuffer, renderTargetMasked);
    this.bokehFarBasePass.render(renderer, renderTargetMasked, renderTarget);
    this.bokehFarFillPass.render(renderer, renderTarget, this.renderTargetFar);
    this.bokehNearBasePass.render(renderer, inputBuffer, renderTarget);
    this.bokehNearFillPass.render(renderer, renderTarget, this.renderTargetNear);
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.cocPass.setSize(width, height);
    this.blurPass.setSize(width, height);
    this.maskPass.setSize(width, height);
    this.renderTargetFar.setSize(width, height);
    this.renderTargetCoC.setSize(width, height);
    this.renderTargetMasked.setSize(width, height);
    this.renderTarget.setSize(w, h);
    this.renderTargetNear.setSize(w, h);
    this.renderTargetCoCBlurred.setSize(w, h);
    this.bokehNearBasePass.fullscreenMaterial.setSize(width, height);
    this.bokehNearFillPass.fullscreenMaterial.setSize(width, height);
    this.bokehFarBasePass.fullscreenMaterial.setSize(width, height);
    this.bokehFarFillPass.fullscreenMaterial.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.cocPass.initialize(renderer, alpha, frameBufferType);
    this.maskPass.initialize(renderer, alpha, frameBufferType);
    this.bokehNearBasePass.initialize(renderer, alpha, frameBufferType);
    this.bokehNearFillPass.initialize(renderer, alpha, frameBufferType);
    this.bokehFarBasePass.initialize(renderer, alpha, frameBufferType);
    this.bokehFarFillPass.initialize(renderer, alpha, frameBufferType);
    this.blurPass.initialize(renderer, alpha, import_three28.UnsignedByteType);
    if (renderer.capabilities.logarithmicDepthBuffer) {
      this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = "1";
    }
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      this.renderTargetNear.texture.type = frameBufferType;
      this.renderTargetFar.texture.type = frameBufferType;
      this.renderTargetMasked.texture.type = frameBufferType;
      if (renderer !== null && renderer.outputColorSpace === import_three28.SRGBColorSpace) {
        this.renderTarget.texture.colorSpace = import_three28.SRGBColorSpace;
        this.renderTargetNear.texture.colorSpace = import_three28.SRGBColorSpace;
        this.renderTargetFar.texture.colorSpace = import_three28.SRGBColorSpace;
        this.renderTargetMasked.texture.colorSpace = import_three28.SRGBColorSpace;
      }
    }
  }
};

// src/effects/DotScreenEffect.js
var import_three29 = __webpack_require__(39437);

// src/effects/glsl/dot-screen.frag
var dot_screen_default = "uniform vec2 angle;uniform float scale;float pattern(const in vec2 uv){vec2 point=scale*vec2(dot(angle.yx,vec2(uv.x,-uv.y)),dot(angle,uv));return(sin(point.x)*sin(point.y))*4.0;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(inputColor.rgb*10.0-5.0+pattern(uv*resolution));outputColor=vec4(color,inputColor.a);}";

// src/effects/DotScreenEffect.js
var DotScreenEffect = class extends Effect {
  /**
   * Constructs a new dot screen effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
   * @param {Number} [options.angle=1.57] - The angle of the dot pattern.
   * @param {Number} [options.scale=1.0] - The scale of the dot pattern.
   */
  constructor({ blendFunction, angle = Math.PI * 0.5, scale = 1 } = {}) {
    super("DotScreenEffect", dot_screen_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["angle", new import_three29.Uniform(new import_three29.Vector2())],
        ["scale", new import_three29.Uniform(scale)]
      ])
    });
    this.angle = angle;
  }
  /**
   * The angle.
   *
   * @type {Number}
   */
  get angle() {
    return Math.acos(this.uniforms.get("angle").value.y);
  }
  set angle(value) {
    this.uniforms.get("angle").value.set(Math.sin(value), Math.cos(value));
  }
  /**
   * Returns the pattern angle.
   *
   * @deprecated Use angle instead.
   * @return {Number} The angle in radians.
   */
  getAngle() {
    return this.angle;
  }
  /**
   * Sets the pattern angle.
   *
   * @deprecated Use angle instead.
   * @param {Number} value - The angle in radians.
   */
  setAngle(value) {
    this.angle = value;
  }
  /**
   * The scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.uniforms.get("scale").value;
  }
  set scale(value) {
    this.uniforms.get("scale").value = value;
  }
};

// src/effects/glsl/fxaa.frag
var fxaa_default = "#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))\n#define ONE_OVER_TWELVE 0.08333333333333333\nvarying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;vec4 fxaa(const in vec4 inputColor,const in vec2 uv){float lumaCenter=luminance(inputColor.rgb);float lumaDown=luminance(texture2D(inputBuffer,vUvDown).rgb);float lumaUp=luminance(texture2D(inputBuffer,vUvUp).rgb);float lumaLeft=luminance(texture2D(inputBuffer,vUvLeft).rgb);float lumaRight=luminance(texture2D(inputBuffer,vUvRight).rgb);float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return inputColor;}float lumaDownLeft=luminance(texture2D(inputBuffer,vUvDownLeft).rgb);float lumaUpRight=luminance(texture2D(inputBuffer,vUvUpRight).rgb);float lumaUpLeft=luminance(texture2D(inputBuffer,vUvUpLeft).rgb);float lumaDownRight=luminance(texture2D(inputBuffer,vUvDownRight).rgb);float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=(abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners));float edgeVertical=(abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners));bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal?texelSize.y:texelSize.x;float luma1=isHorizontal?lumaDown:lumaLeft;float luma2=isHorizontal?lumaUp:lumaRight;float gradient1=abs(luma1-lumaCenter);float gradient2=abs(luma2-lumaCenter);bool is1Steepest=gradient1>=gradient2;float gradientScaled=0.25*max(gradient1,gradient2);float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=uv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal?vec2(texelSize.x,0.0):vec2(0.0,texelSize.y);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);float lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<SAMPLES;++i){if(!reached1){lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal?(uv.x-uv1.x):(uv.y-uv1.y);float distance2=isHorizontal?(uv2.x-uv.x):(uv2.y-uv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1?correctVariation1:correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation?pixelOffset:0.0;float lumaAverage=ONE_OVER_TWELVE*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=uv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture2D(inputBuffer,finalUv);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=fxaa(inputColor,uv);}";

// src/effects/glsl/fxaa.vert
var fxaa_default2 = "varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;void mainSupport(const in vec2 uv){vUvDown=uv+vec2(0.0,-1.0)*texelSize;vUvUp=uv+vec2(0.0,1.0)*texelSize;vUvRight=uv+vec2(1.0,0.0)*texelSize;vUvLeft=uv+vec2(-1.0,0.0)*texelSize;vUvDownLeft=uv+vec2(-1.0,-1.0)*texelSize;vUvUpRight=uv+vec2(1.0,1.0)*texelSize;vUvUpLeft=uv+vec2(-1.0,1.0)*texelSize;vUvDownRight=uv+vec2(1.0,-1.0)*texelSize;}";

// src/effects/FXAAEffect.js
var FXAAEffect = class extends Effect {
  /**
   * Constructs a new FXAA effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   */
  constructor({ blendFunction = BlendFunction.SRC } = {}) {
    super("FXAAEffect", fxaa_default, {
      vertexShader: fxaa_default2,
      blendFunction,
      defines: /* @__PURE__ */ new Map([
        ["EDGE_THRESHOLD_MIN", "0.0312"],
        ["EDGE_THRESHOLD_MAX", "0.125"],
        ["SUBPIXEL_QUALITY", "0.75"],
        ["SAMPLES", "12"]
      ])
    });
  }
  /**
   * The minimum edge detection threshold. Range is [0.0, 1.0].
   *
   * @type {Number}
   */
  get minEdgeThreshold() {
    return Number(this.defines.get("EDGE_THRESHOLD_MIN"));
  }
  set minEdgeThreshold(value) {
    this.defines.set("EDGE_THRESHOLD_MIN", value.toFixed(12));
    this.setChanged();
  }
  /**
   * The maximum edge detection threshold. Range is [0.0, 1.0].
   *
   * @type {Number}
   */
  get maxEdgeThreshold() {
    return Number(this.defines.get("EDGE_THRESHOLD_MAX"));
  }
  set maxEdgeThreshold(value) {
    this.defines.set("EDGE_THRESHOLD_MAX", value.toFixed(12));
    this.setChanged();
  }
  /**
   * The subpixel blend quality. Range is [0.0, 1.0].
   *
   * @type {Number}
   */
  get subpixelQuality() {
    return Number(this.defines.get("SUBPIXEL_QUALITY"));
  }
  set subpixelQuality(value) {
    this.defines.set("SUBPIXEL_QUALITY", value.toFixed(12));
    this.setChanged();
  }
  /**
   * The maximum amount of edge detection samples.
   *
   * @type {Number}
   */
  get samples() {
    return Number(this.defines.get("SAMPLES"));
  }
  set samples(value) {
    this.defines.set("SAMPLES", value.toFixed(0));
    this.setChanged();
  }
};

// src/effects/GammaCorrectionEffect.js
var import_three30 = __webpack_require__(39437);

// src/effects/glsl/gamma-correction.frag
var gamma_correction_default = "uniform float gamma;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=LinearToGamma(max(inputColor,0.0),gamma);}";

// src/effects/GammaCorrectionEffect.js
var GammaCorrectionEffect = class extends Effect {
  /**
   * Constructs a new gamma correction effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {Number} [options.gamma=2.0] - The gamma factor.
   */
  constructor({ blendFunction = BlendFunction.SRC, gamma = 2 } = {}) {
    super("GammaCorrectionEffect", gamma_correction_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["gamma", new import_three30.Uniform(gamma)]
      ])
    });
  }
};

// src/effects/GlitchEffect.js
var import_three32 = __webpack_require__(39437);

// src/enums/GlitchMode.js
var GlitchMode = {
  DISABLED: 0,
  SPORADIC: 1,
  CONSTANT_MILD: 2,
  CONSTANT_WILD: 3
};

// src/textures/NoiseTexture.js
var import_three31 = __webpack_require__(39437);
function getNoise(size, format, type) {
  const channels = /* @__PURE__ */ new Map([
    [import_three31.LuminanceFormat, 1],
    [import_three31.RedFormat, 1],
    [import_three31.RGFormat, 2],
    [import_three31.RGBAFormat, 4]
  ]);
  let data;
  if (!channels.has(format)) {
    console.error("Invalid noise texture format");
  }
  if (type === import_three31.UnsignedByteType) {
    data = new Uint8Array(size * channels.get(format));
    for (let i = 0, l = data.length; i < l; ++i) {
      data[i] = Math.random() * 255 + 0.5;
    }
  } else {
    data = new Float32Array(size * channels.get(format));
    for (let i = 0, l = data.length; i < l; ++i) {
      data[i] = Math.random();
    }
  }
  return data;
}
var NoiseTexture = class extends import_three31.DataTexture {
  /**
   * Constructs a new noise texture.
   *
   * The texture format can be either `LuminanceFormat` or `RGBAFormat`. Additionally, the formats `RedFormat` and
   * `RGFormat` can be used in a WebGL 2 context.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   * @param {Number} [format=LuminanceFormat] - The texture format.
   * @param {Number} [type=UnsignedByteType] - The texture type.
   */
  constructor(width, height, format = import_three31.LuminanceFormat, type = import_three31.UnsignedByteType) {
    super(getNoise(width * height, format, type), width, height, format, type);
    this.needsUpdate = true;
  }
};

// src/effects/glsl/glitch.frag
var glitch_default = "uniform lowp sampler2D perturbationMap;uniform bool active;uniform float columns;uniform float random;uniform vec2 seeds;uniform vec2 distortion;void mainUv(inout vec2 uv){if(active){if(uv.y<distortion.x+columns&&uv.y>distortion.x-columns*random){float sx=clamp(ceil(seeds.x),0.0,1.0);uv.y=sx*(1.0-(uv.y+distortion.y))+(1.0-sx)*distortion.y;}if(uv.x<distortion.y+columns&&uv.x>distortion.y-columns*random){float sy=clamp(ceil(seeds.y),0.0,1.0);uv.x=sy*distortion.x+(1.0-sy)*(1.0-(uv.x+distortion.x));}vec2 normal=texture2D(perturbationMap,uv*random*random).rg;uv+=normal*seeds*(random*0.2);}}";

// src/effects/GlitchEffect.js
var textureTag = "Glitch.Generated";
function randomFloat(low, high) {
  return low + Math.random() * (high - low);
}
var GlitchEffect = class extends Effect {
  /**
   * Constructs a new glitch effect.
   *
   * TODO Change ratio to 0.15.
   * @param {Object} [options] - The options.
   * @param {Vector2} [options.chromaticAberrationOffset] - A chromatic aberration offset. If provided, the glitch effect will influence this offset.
   * @param {Vector2} [options.delay] - The minimum and maximum delay between glitch activations in seconds.
   * @param {Vector2} [options.duration] - The minimum and maximum duration of a glitch in seconds.
   * @param {Vector2} [options.strength] - The strength of weak and strong glitches.
   * @param {Texture} [options.perturbationMap] - A perturbation map. If none is provided, a noise texture will be created.
   * @param {Number} [options.dtSize=64] - The size of the generated noise map. Will be ignored if a perturbation map is provided.
   * @param {Number} [options.columns=0.05] - The scale of the blocky glitch columns.
   * @param {Number} [options.ratio=0.85] - The threshold for strong glitches.
   */
  constructor({
    chromaticAberrationOffset = null,
    delay = new import_three32.Vector2(1.5, 3.5),
    duration = new import_three32.Vector2(0.6, 1),
    strength = new import_three32.Vector2(0.3, 1),
    columns = 0.05,
    ratio = 0.85,
    perturbationMap = null,
    dtSize = 64
  } = {}) {
    super("GlitchEffect", glitch_default, {
      uniforms: /* @__PURE__ */ new Map([
        ["perturbationMap", new import_three32.Uniform(null)],
        ["columns", new import_three32.Uniform(columns)],
        ["active", new import_three32.Uniform(false)],
        ["random", new import_three32.Uniform(1)],
        ["seeds", new import_three32.Uniform(new import_three32.Vector2())],
        ["distortion", new import_three32.Uniform(new import_three32.Vector2())]
      ])
    });
    if (perturbationMap === null) {
      const map = new NoiseTexture(dtSize, dtSize, import_three32.RGBAFormat);
      map.name = textureTag;
      this.perturbationMap = map;
    } else {
      this.perturbationMap = perturbationMap;
    }
    this.time = 0;
    this.distortion = this.uniforms.get("distortion").value;
    this.delay = delay;
    this.duration = duration;
    this.breakPoint = new import_three32.Vector2(
      randomFloat(this.delay.x, this.delay.y),
      randomFloat(this.duration.x, this.duration.y)
    );
    this.strength = strength;
    this.mode = GlitchMode.SPORADIC;
    this.ratio = ratio;
    this.chromaticAberrationOffset = chromaticAberrationOffset;
  }
  /**
   * Random number seeds.
   *
   * @type {Vector2}
   * @private
   */
  get seeds() {
    return this.uniforms.get("seeds").value;
  }
  /**
   * Indicates whether the glitch effect is currently active.
   *
   * @type {Boolean}
   */
  get active() {
    return this.uniforms.get("active").value;
  }
  /**
   * Indicates whether the glitch effect is currently active.
   *
   * @deprecated Use active instead.
   * @return {Boolean} Whether the glitch effect is active.
   */
  isActive() {
    return this.active;
  }
  /**
   * The minimum delay between glitch activations.
   *
   * @type {Number}
   */
  get minDelay() {
    return this.delay.x;
  }
  set minDelay(value) {
    this.delay.x = value;
  }
  /**
   * Returns the minimum delay between glitch activations.
   *
   * @deprecated Use minDelay instead.
   * @return {Number} The minimum delay in seconds.
   */
  getMinDelay() {
    return this.delay.x;
  }
  /**
   * Sets the minimum delay between glitch activations.
   *
   * @deprecated Use minDelay instead.
   * @param {Number} value - The minimum delay in seconds.
   */
  setMinDelay(value) {
    this.delay.x = value;
  }
  /**
   * The maximum delay between glitch activations.
   *
   * @type {Number}
   */
  get maxDelay() {
    return this.delay.y;
  }
  set maxDelay(value) {
    this.delay.y = value;
  }
  /**
   * Returns the maximum delay between glitch activations.
   *
   * @deprecated Use maxDelay instead.
   * @return {Number} The maximum delay in seconds.
   */
  getMaxDelay() {
    return this.delay.y;
  }
  /**
   * Sets the maximum delay between glitch activations.
   *
   * @deprecated Use maxDelay instead.
   * @param {Number} value - The maximum delay in seconds.
   */
  setMaxDelay(value) {
    this.delay.y = value;
  }
  /**
   * The minimum duration of sporadic glitches.
   *
   * @type {Number}
   */
  get minDuration() {
    return this.duration.x;
  }
  set minDuration(value) {
    this.duration.x = value;
  }
  /**
   * Returns the minimum duration of sporadic glitches.
   *
   * @deprecated Use minDuration instead.
   * @return {Number} The minimum duration in seconds.
   */
  getMinDuration() {
    return this.duration.x;
  }
  /**
   * Sets the minimum duration of sporadic glitches.
   *
   * @deprecated Use minDuration instead.
   * @param {Number} value - The minimum duration in seconds.
   */
  setMinDuration(value) {
    this.duration.x = value;
  }
  /**
   * The maximum duration of sporadic glitches.
   *
   * @type {Number}
   */
  get maxDuration() {
    return this.duration.y;
  }
  set maxDuration(value) {
    this.duration.y = value;
  }
  /**
   * Returns the maximum duration of sporadic glitches.
   *
   * @deprecated Use maxDuration instead.
   * @return {Number} The maximum duration in seconds.
   */
  getMaxDuration() {
    return this.duration.y;
  }
  /**
   * Sets the maximum duration of sporadic glitches.
   *
   * @deprecated Use maxDuration instead.
   * @param {Number} value - The maximum duration in seconds.
   */
  setMaxDuration(value) {
    this.duration.y = value;
  }
  /**
   * The strength of weak glitches.
   *
   * @type {Number}
   */
  get minStrength() {
    return this.strength.x;
  }
  set minStrength(value) {
    this.strength.x = value;
  }
  /**
   * Returns the strength of weak glitches.
   *
   * @deprecated Use minStrength instead.
   * @return {Number} The strength.
   */
  getMinStrength() {
    return this.strength.x;
  }
  /**
   * Sets the strength of weak glitches.
   *
   * @deprecated Use minStrength instead.
   * @param {Number} value - The strength.
   */
  setMinStrength(value) {
    this.strength.x = value;
  }
  /**
   * The strength of strong glitches.
   *
   * @type {Number}
   */
  get maxStrength() {
    return this.strength.y;
  }
  set maxStrength(value) {
    this.strength.y = value;
  }
  /**
   * Returns the strength of strong glitches.
   *
   * @deprecated Use maxStrength instead.
   * @return {Number} The strength.
   */
  getMaxStrength() {
    return this.strength.y;
  }
  /**
   * Sets the strength of strong glitches.
   *
   * @deprecated Use maxStrength instead.
   * @param {Number} value - The strength.
   */
  setMaxStrength(value) {
    this.strength.y = value;
  }
  /**
   * Returns the current glitch mode.
   *
   * @deprecated Use mode instead.
   * @return {GlitchMode} The mode.
   */
  getMode() {
    return this.mode;
  }
  /**
   * Sets the current glitch mode.
   *
   * @deprecated Use mode instead.
   * @param {GlitchMode} value - The mode.
   */
  setMode(value) {
    this.mode = value;
  }
  /**
   * Returns the glitch ratio.
   *
   * @deprecated Use ratio instead.
   * @return {Number} The ratio.
   */
  getGlitchRatio() {
    return 1 - this.ratio;
  }
  /**
   * Sets the ratio of weak (0.0) and strong (1.0) glitches.
   *
   * @deprecated Use ratio instead.
   * @param {Number} value - The ratio. Range is [0.0, 1.0].
   */
  setGlitchRatio(value) {
    this.ratio = Math.min(Math.max(1 - value, 0), 1);
  }
  /**
   * The glitch column size.
   *
   * @type {Number}
   */
  get columns() {
    return this.uniforms.get("columns").value;
  }
  set columns(value) {
    this.uniforms.get("columns").value = value;
  }
  /**
   * Returns the glitch column size.
   *
   * @deprecated Use columns instead.
   * @return {Number} The glitch column size.
   */
  getGlitchColumns() {
    return this.columns;
  }
  /**
   * Sets the glitch column size.
   *
   * @deprecated Use columns instead.
   * @param {Number} value - The glitch column size.
   */
  setGlitchColumns(value) {
    this.columns = value;
  }
  /**
   * Returns the chromatic aberration offset.
   *
   * @deprecated Use chromaticAberrationOffset instead.
   * @return {Vector2} The offset.
   */
  getChromaticAberrationOffset() {
    return this.chromaticAberrationOffset;
  }
  /**
   * Sets the chromatic aberration offset.
   *
   * @deprecated Use chromaticAberrationOffset instead.
   * @param {Vector2} value - The offset.
   */
  setChromaticAberrationOffset(value) {
    this.chromaticAberrationOffset = value;
  }
  /**
   * The perturbation map.
   *
   * @type {Texture}
   */
  get perturbationMap() {
    return this.uniforms.get("perturbationMap").value;
  }
  set perturbationMap(value) {
    const currentMap = this.perturbationMap;
    if (currentMap !== null && currentMap.name === textureTag) {
      currentMap.dispose();
    }
    value.minFilter = value.magFilter = import_three32.NearestFilter;
    value.wrapS = value.wrapT = import_three32.RepeatWrapping;
    value.generateMipmaps = false;
    this.uniforms.get("perturbationMap").value = value;
  }
  /**
   * Returns the current perturbation map.
   *
   * @deprecated Use perturbationMap instead.
   * @return {Texture} The current perturbation map.
   */
  getPerturbationMap() {
    return this.perturbationMap;
  }
  /**
   * Replaces the current perturbation map with the given one.
   *
   * The current map will be disposed if it was generated by this effect.
   *
   * @deprecated Use perturbationMap instead.
   * @param {Texture} value - The new perturbation map.
   */
  setPerturbationMap(value) {
    this.perturbationMap = value;
  }
  /**
   * Generates a perturbation map.
   *
   * @deprecated Use NoiseTexture instead.
   * @param {Number} [value=64] - The texture size.
   * @return {DataTexture} The perturbation map.
   */
  generatePerturbationMap(value = 64) {
    const map = new NoiseTexture(value, value, import_three32.RGBAFormat);
    map.name = textureTag;
    return map;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const mode = this.mode;
    const breakPoint = this.breakPoint;
    const offset = this.chromaticAberrationOffset;
    const s = this.strength;
    let time = this.time;
    let active = false;
    let r = 0, a = 0;
    let trigger;
    if (mode !== GlitchMode.DISABLED) {
      if (mode === GlitchMode.SPORADIC) {
        time += deltaTime;
        trigger = time > breakPoint.x;
        if (time >= breakPoint.x + breakPoint.y) {
          breakPoint.set(
            randomFloat(this.delay.x, this.delay.y),
            randomFloat(this.duration.x, this.duration.y)
          );
          time = 0;
        }
      }
      r = Math.random();
      this.uniforms.get("random").value = r;
      if (trigger && r > this.ratio || mode === GlitchMode.CONSTANT_WILD) {
        active = true;
        r *= s.y * 0.03;
        a = randomFloat(-Math.PI, Math.PI);
        this.seeds.set(randomFloat(-s.y, s.y), randomFloat(-s.y, s.y));
        this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));
      } else if (trigger || mode === GlitchMode.CONSTANT_MILD) {
        active = true;
        r *= s.x * 0.03;
        a = randomFloat(-Math.PI, Math.PI);
        this.seeds.set(randomFloat(-s.x, s.x), randomFloat(-s.x, s.x));
        this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));
      }
      this.time = time;
    }
    if (offset !== null) {
      if (active) {
        offset.set(Math.cos(a), Math.sin(a)).multiplyScalar(r);
      } else {
        offset.set(0, 0);
      }
    }
    this.uniforms.get("active").value = active;
  }
  /**
   * Deletes generated resources.
   */
  dispose() {
    const map = this.perturbationMap;
    if (map !== null && map.name === textureTag) {
      map.dispose();
    }
  }
};

// src/effects/GodRaysEffect.js
var import_three35 = __webpack_require__(39437);

// src/materials/DepthMaskMaterial.js
var import_three33 = __webpack_require__(39437);

// src/enums/DepthTestStrategy.js
var DepthTestStrategy = {
  DEFAULT: 0,
  KEEP_MAX_DEPTH: 1,
  DISCARD_MAX_DEPTH: 2
};

// src/materials/glsl/depth-mask.frag
var depth_mask_default = "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;\n#else\nuniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;\n#endif\nuniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}varying vec2 vUv;void main(){vec2 depth;\n#if DEPTH_PACKING_0 == 3201\ndepth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));\n#else\ndepth.x=texture2D(depthBuffer0,vUv).r;\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth.x*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.x=a+b/d;\n#endif\n#endif\n#if DEPTH_PACKING_1 == 3201\ndepth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));\n#else\ndepth.y=texture2D(depthBuffer1,vUv).r;\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth.y*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.y=a+b/d;\n#endif\n#endif\nbool isMaxDepth=(depth.x==1.0);\n#ifdef PERSPECTIVE_CAMERA\ndepth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);\n#endif\n#if DEPTH_TEST_STRATEGY == 0\nbool keep=depthTest(depth.x,depth.y);\n#elif DEPTH_TEST_STRATEGY == 1\nbool keep=isMaxDepth||depthTest(depth.x,depth.y);\n#else\nbool keep=!isMaxDepth&&depthTest(depth.x,depth.y);\n#endif\nif(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}";

// src/materials/DepthMaskMaterial.js
var DepthMaskMaterial = class extends import_three33.ShaderMaterial {
  /**
   * Constructs a new depth mask material.
   */
  constructor() {
    super({
      name: "DepthMaskMaterial",
      defines: {
        DEPTH_EPSILON: "0.0001",
        DEPTH_PACKING_0: "0",
        DEPTH_PACKING_1: "0",
        DEPTH_TEST_STRATEGY: DepthTestStrategy.KEEP_MAX_DEPTH
      },
      uniforms: {
        inputBuffer: new import_three33.Uniform(null),
        depthBuffer0: new import_three33.Uniform(null),
        depthBuffer1: new import_three33.Uniform(null),
        cameraNearFar: new import_three33.Uniform(new import_three33.Vector2(1, 1))
      },
      blending: import_three33.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_mask_default,
      vertexShader: common_default
    });
    this.depthMode = import_three33.LessDepth;
  }
  /**
   * The primary depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer0(value) {
    this.uniforms.depthBuffer0.value = value;
  }
  /**
   * The primary depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking0(value) {
    this.defines.DEPTH_PACKING_0 = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the base depth buffer.
   *
   * @deprecated Use depthBuffer0 and depthPacking0 instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer0(buffer, depthPacking = import_three33.BasicDepthPacking) {
    this.depthBuffer0 = buffer;
    this.depthPacking0 = depthPacking;
  }
  /**
   * The secondary depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer1(value) {
    this.uniforms.depthBuffer1.value = value;
  }
  /**
   * The secondary depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking1(value) {
    this.defines.DEPTH_PACKING_1 = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer that will be compared with the base depth buffer.
   *
   * @deprecated Use depthBuffer1 and depthPacking1 instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer1(buffer, depthPacking = import_three33.BasicDepthPacking) {
    this.depthBuffer1 = buffer;
    this.depthPacking1 = depthPacking;
  }
  /**
   * The strategy for handling maximum depth.
   *
   * @type {DepthTestStrategy}
   */
  get maxDepthStrategy() {
    return Number(this.defines.DEPTH_TEST_STRATEGY);
  }
  set maxDepthStrategy(value) {
    this.defines.DEPTH_TEST_STRATEGY = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Indicates whether maximum depth values should be preserved.
   *
   * @type {Boolean}
   * @deprecated Use maxDepthStrategy instead.
   */
  get keepFar() {
    return this.maxDepthStrategy;
  }
  set keepFar(value) {
    this.maxDepthStrategy = value ? DepthTestStrategy.KEEP_MAX_DEPTH : DepthTestStrategy.DISCARD_MAX_DEPTH;
  }
  /**
   * Returns the strategy for dealing with maximum depth values.
   *
   * @deprecated Use maxDepthStrategy instead.
   * @return {DepthTestStrategy} The strategy.
   */
  getMaxDepthStrategy() {
    return this.maxDepthStrategy;
  }
  /**
   * Sets the strategy for dealing with maximum depth values.
   *
   * @deprecated Use maxDepthStrategy instead.
   * @param {DepthTestStrategy} value - The strategy.
   */
  setMaxDepthStrategy(value) {
    this.maxDepthStrategy = value;
  }
  /**
   * A small error threshold that is used for `EqualDepth` and `NotEqualDepth` tests. Default is `1e-4`.
   *
   * @type {Number}
   */
  get epsilon() {
    return Number(this.defines.DEPTH_EPSILON);
  }
  set epsilon(value) {
    this.defines.DEPTH_EPSILON = value.toFixed(16);
    this.needsUpdate = true;
  }
  /**
   * Returns the current error threshold for depth comparisons.
   *
   * @deprecated Use epsilon instead.
   * @return {Number} The error threshold.
   */
  getEpsilon() {
    return this.epsilon;
  }
  /**
   * Sets the depth comparison error threshold.
   *
   * @deprecated Use epsilon instead.
   * @param {Number} value - The new error threshold.
   */
  setEpsilon(value) {
    this.epsilon = value;
  }
  /**
   * The depth mode.
   *
   * @see https://threejs.org/docs/#api/en/constants/Materials
   * @type {DepthModes}
   */
  get depthMode() {
    return Number(this.defines.DEPTH_MODE);
  }
  set depthMode(value) {
    let depthTest;
    switch (value) {
      case import_three33.NeverDepth:
        depthTest = "false";
        break;
      case import_three33.AlwaysDepth:
        depthTest = "true";
        break;
      case import_three33.EqualDepth:
        depthTest = "abs(d1 - d0) <= DEPTH_EPSILON";
        break;
      case import_three33.NotEqualDepth:
        depthTest = "abs(d1 - d0) > DEPTH_EPSILON";
        break;
      case import_three33.LessDepth:
        depthTest = "d0 > d1";
        break;
      case import_three33.LessEqualDepth:
        depthTest = "d0 >= d1";
        break;
      case import_three33.GreaterEqualDepth:
        depthTest = "d0 <= d1";
        break;
      case import_three33.GreaterDepth:
      default:
        depthTest = "d0 < d1";
        break;
    }
    this.defines.DEPTH_MODE = value.toFixed(0);
    this.defines["depthTest(d0, d1)"] = depthTest;
    this.needsUpdate = true;
  }
  /**
   * Returns the current depth mode.
   *
   * @deprecated Use depthMode instead.
   * @return {DepthModes} The depth mode. Default is `LessDepth`.
   */
  getDepthMode() {
    return this.depthMode;
  }
  /**
   * Sets the depth mode.
   *
   * @deprecated Use depthMode instead.
   * @param {DepthModes} mode - The depth mode.
   */
  setDepthMode(mode) {
    this.depthMode = mode;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);
      if (camera instanceof import_three33.PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
};

// src/materials/GodRaysMaterial.js
var import_three34 = __webpack_require__(39437);

// src/materials/glsl/convolution.god-rays.frag
var convolution_god_rays_default = "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform vec2 lightPosition;uniform float exposure;uniform float decay;uniform float density;uniform float weight;uniform float clampMax;varying vec2 vUv;void main(){vec2 coord=vUv;vec2 delta=lightPosition-coord;delta*=1.0/SAMPLES_FLOAT*density;float illuminationDecay=1.0;vec4 color=vec4(0.0);for(int i=0;i<SAMPLES_INT;++i){coord+=delta;vec4 texel=texture2D(inputBuffer,coord);texel*=illuminationDecay*weight;color+=texel;illuminationDecay*=decay;}gl_FragColor=clamp(color*exposure,0.0,clampMax);\n#include <dithering_fragment>\n}";

// src/materials/GodRaysMaterial.js
var GodRaysMaterial = class extends import_three34.ShaderMaterial {
  /**
   * Constructs a new god rays material.
   *
   * TODO Remove lightPosition param.
   * @param {Vector2} lightPosition - Deprecated.
   */
  constructor(lightPosition) {
    super({
      name: "GodRaysMaterial",
      defines: {
        SAMPLES_INT: "60",
        SAMPLES_FLOAT: "60.0"
      },
      uniforms: {
        inputBuffer: new import_three34.Uniform(null),
        lightPosition: new import_three34.Uniform(lightPosition),
        density: new import_three34.Uniform(1),
        decay: new import_three34.Uniform(1),
        weight: new import_three34.Uniform(1),
        exposure: new import_three34.Uniform(1),
        clampMax: new import_three34.Uniform(1)
      },
      blending: import_three34.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_god_rays_default,
      vertexShader: common_default
    });
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The screen space position of the light source.
   *
   * @type {Vector2}
   */
  get lightPosition() {
    return this.uniforms.lightPosition.value;
  }
  /**
   * Returns the screen space position of the light source.
   *
   * @deprecated Use lightPosition instead.
   * @return {Vector2} The position.
   */
  getLightPosition() {
    return this.uniforms.lightPosition.value;
  }
  /**
   * Sets the screen space position of the light source.
   *
   * @deprecated Use lightPosition instead.
   * @param {Vector2} value - The position.
   */
  setLightPosition(value) {
    this.uniforms.lightPosition.value = value;
  }
  /**
   * The density.
   *
   * @type {Number}
   */
  get density() {
    return this.uniforms.density.value;
  }
  set density(value) {
    this.uniforms.density.value = value;
  }
  /**
   * Returns the density.
   *
   * @deprecated Use density instead.
   * @return {Number} The density.
   */
  getDensity() {
    return this.uniforms.density.value;
  }
  /**
   * Sets the density.
   *
   * @deprecated Use density instead.
   * @param {Number} value - The density.
   */
  setDensity(value) {
    this.uniforms.density.value = value;
  }
  /**
   * The decay.
   *
   * @type {Number}
   */
  get decay() {
    return this.uniforms.decay.value;
  }
  set decay(value) {
    this.uniforms.decay.value = value;
  }
  /**
   * Returns the decay.
   *
   * @deprecated Use decay instead.
   * @return {Number} The decay.
   */
  getDecay() {
    return this.uniforms.decay.value;
  }
  /**
   * Sets the decay.
   *
   * @deprecated Use decay instead.
   * @param {Number} value - The decay.
   */
  setDecay(value) {
    this.uniforms.decay.value = value;
  }
  /**
   * The weight.
   *
   * @type {Number}
   */
  get weight() {
    return this.uniforms.weight.value;
  }
  set weight(value) {
    this.uniforms.weight.value = value;
  }
  /**
   * Returns the weight.
   *
   * @deprecated Use weight instead.
   * @return {Number} The weight.
   */
  getWeight() {
    return this.uniforms.weight.value;
  }
  /**
   * Sets the weight.
   *
   * @deprecated Use weight instead.
   * @param {Number} value - The weight.
   */
  setWeight(value) {
    this.uniforms.weight.value = value;
  }
  /**
   * The exposure.
   *
   * @type {Number}
   */
  get exposure() {
    return this.uniforms.exposure.value;
  }
  set exposure(value) {
    this.uniforms.exposure.value = value;
  }
  /**
   * Returns the exposure.
   *
   * @deprecated Use exposure instead.
   * @return {Number} The exposure.
   */
  getExposure() {
    return this.uniforms.exposure.value;
  }
  /**
   * Sets the exposure.
   *
   * @deprecated Use exposure instead.
   * @param {Number} value - The exposure.
   */
  setExposure(value) {
    this.uniforms.exposure.value = value;
  }
  /**
   * The maximum light intensity.
   *
   * @type {Number}
   */
  get maxIntensity() {
    return this.uniforms.clampMax.value;
  }
  set maxIntensity(value) {
    this.uniforms.clampMax.value = value;
  }
  /**
   * Returns the maximum light intensity.
   *
   * @deprecated Use maxIntensity instead.
   * @return {Number} The maximum light intensity.
   */
  getMaxIntensity() {
    return this.uniforms.clampMax.value;
  }
  /**
   * Sets the maximum light intensity.
   *
   * @deprecated Use maxIntensity instead.
   * @param {Number} value - The maximum light intensity.
   */
  setMaxIntensity(value) {
    this.uniforms.clampMax.value = value;
  }
  /**
   * The amount of samples per pixel.
   *
   * @type {Number}
   */
  get samples() {
    return Number(this.defines.SAMPLES_INT);
  }
  set samples(value) {
    const s = Math.floor(value);
    this.defines.SAMPLES_INT = s.toFixed(0);
    this.defines.SAMPLES_FLOAT = s.toFixed(1);
    this.needsUpdate = true;
  }
  /**
   * Returns the amount of samples per pixel.
   *
   * @deprecated Use samples instead.
   * @return {Number} The sample count.
   */
  getSamples() {
    return this.samples;
  }
  /**
   * Sets the amount of samples per pixel.
   *
   * @deprecated Use samples instead.
   * @param {Number} value - The sample count.
   */
  setSamples(value) {
    this.samples = value;
  }
};

// src/passes/RenderPass.js
var RenderPass = class extends Pass {
  /**
   * Constructs a new render pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Material} [overrideMaterial=null] - An override material.
   */
  constructor(scene, camera, overrideMaterial = null) {
    super("RenderPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass();
    this.overrideMaterialManager = overrideMaterial === null ? null : new OverrideMaterialManager(overrideMaterial);
    this.ignoreBackground = false;
    this.skipShadowMapUpdate = false;
    this.selection = null;
  }
  set mainScene(value) {
    this.scene = value;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  get renderToScreen() {
    return super.renderToScreen;
  }
  set renderToScreen(value) {
    super.renderToScreen = value;
    this.clearPass.renderToScreen = value;
  }
  /**
   * The current override material.
   *
   * @type {Material}
   */
  get overrideMaterial() {
    const manager = this.overrideMaterialManager;
    return manager !== null ? manager.material : null;
  }
  set overrideMaterial(value) {
    const manager = this.overrideMaterialManager;
    if (value !== null) {
      if (manager !== null) {
        manager.setMaterial(value);
      } else {
        this.overrideMaterialManager = new OverrideMaterialManager(value);
      }
    } else if (manager !== null) {
      manager.dispose();
      this.overrideMaterialManager = null;
    }
  }
  /**
   * Returns the current override material.
   *
   * @deprecated Use overrideMaterial instead.
   * @return {Material} The material.
   */
  getOverrideMaterial() {
    return this.overrideMaterial;
  }
  /**
   * Sets the override material.
   *
   * @deprecated Use overrideMaterial instead.
   * @return {Material} value - The material.
   */
  setOverrideMaterial(value) {
    this.overrideMaterial = value;
  }
  /**
   * Indicates whether the target buffer should be cleared before rendering.
   *
   * @type {Boolean}
   * @deprecated Use clearPass.enabled instead.
   */
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  /**
   * Returns the selection. Default is `null` (no restriction).
   *
   * @deprecated Use selection instead.
   * @return {Selection} The selection.
   */
  getSelection() {
    return this.selection;
  }
  /**
   * Sets the selection. Set to `null` to disable.
   *
   * @deprecated Use selection instead.
   * @param {Selection} value - The selection.
   */
  setSelection(value) {
    this.selection = value;
  }
  /**
   * Indicates whether the scene background is disabled.
   *
   * @deprecated Use ignoreBackground instead.
   * @return {Boolean} Whether the scene background is disabled.
   */
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  /**
   * Enables or disables the scene background.
   *
   * @deprecated Use ignoreBackground instead.
   * @param {Boolean} value - Whether the scene background should be disabled.
   */
  setBackgroundDisabled(value) {
    this.ignoreBackground = value;
  }
  /**
   * Indicates whether the shadow map auto update is disabled.
   *
   * @deprecated Use skipShadowMapUpdate instead.
   * @return {Boolean} Whether the shadow map update is disabled.
   */
  isShadowMapDisabled() {
    return this.skipShadowMapUpdate;
  }
  /**
   * Enables or disables the shadow map auto update.
   *
   * @deprecated Use skipShadowMapUpdate instead.
   * @param {Boolean} value - Whether the shadow map auto update should be disabled.
   */
  setShadowMapDisabled(value) {
    this.skipShadowMapUpdate = value;
  }
  /**
   * Returns the clear pass.
   *
   * @deprecated Use clearPass.enabled instead.
   * @return {ClearPass} The clear pass.
   */
  getClearPass() {
    return this.clearPass;
  }
  /**
   * Renders the scene.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const selection = this.selection;
    const mask = camera.layers.mask;
    const background = scene.background;
    const shadowMapAutoUpdate = renderer.shadowMap.autoUpdate;
    const renderTarget = this.renderToScreen ? null : inputBuffer;
    if (selection !== null) {
      camera.layers.set(selection.getLayer());
    }
    if (this.skipShadowMapUpdate) {
      renderer.shadowMap.autoUpdate = false;
    }
    if (this.ignoreBackground || this.clearPass.overrideClearColor !== null) {
      scene.background = null;
    }
    if (this.clearPass.enabled) {
      this.clearPass.render(renderer, inputBuffer);
    }
    renderer.setRenderTarget(renderTarget);
    if (this.overrideMaterialManager !== null) {
      this.overrideMaterialManager.render(renderer, scene, camera);
    } else {
      renderer.render(scene, camera);
    }
    camera.layers.mask = mask;
    scene.background = background;
    renderer.shadowMap.autoUpdate = shadowMapAutoUpdate;
  }
};

// src/effects/glsl/god-rays.frag
var god_rays_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv);}";

// src/effects/GodRaysEffect.js
var v = /* @__PURE__ */ new import_three35.Vector3();
var m = /* @__PURE__ */ new import_three35.Matrix4();
var GodRaysEffect = class extends Effect {
  /**
   * Constructs a new god rays effect.
   *
   * @param {Camera} [camera] - The main camera.
   * @param {Mesh|Points} [lightSource] - The light source. Must not write depth and has to be flagged as transparent.
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.
   * @param {Number} [options.samples=60.0] - The number of samples per pixel.
   * @param {Number} [options.density=0.96] - The density of the light rays.
   * @param {Number} [options.decay=0.9] - An illumination decay factor.
   * @param {Number} [options.weight=0.4] - A light ray weight factor.
   * @param {Number} [options.exposure=0.6] - A constant attenuation coefficient.
   * @param {Number} [options.clampMax=1.0] - An upper bound for the saturation of the overall effect.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   * @param {KernelSize} [options.kernelSize=KernelSize.SMALL] - The blur kernel size. Has no effect if blur is disabled.
   * @param {Boolean} [options.blur=true] - Whether the god rays should be blurred to reduce artifacts.
   */
  constructor(camera, lightSource, {
    blendFunction = BlendFunction.SCREEN,
    samples = 60,
    density = 0.96,
    decay = 0.9,
    weight = 0.4,
    exposure = 0.6,
    clampMax = 1,
    blur = true,
    kernelSize = KernelSize.SMALL,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("GodRaysEffect", god_rays_default, {
      blendFunction,
      attributes: EffectAttribute.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["map", new import_three35.Uniform(null)]
      ])
    });
    this.camera = camera;
    this._lightSource = lightSource;
    this.lightSource = lightSource;
    this.lightScene = new import_three35.Scene();
    this.screenPosition = new import_three35.Vector2();
    this.renderTargetA = new import_three35.WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetA.texture.name = "GodRays.Target.A";
    this.renderTargetB = this.renderTargetA.clone();
    this.renderTargetB.texture.name = "GodRays.Target.B";
    this.uniforms.get("map").value = this.renderTargetB.texture;
    this.renderTargetLight = new import_three35.WebGLRenderTarget(1, 1);
    this.renderTargetLight.texture.name = "GodRays.Light";
    this.renderTargetLight.depthTexture = new import_three35.DepthTexture();
    this.renderPassLight = new RenderPass(this.lightScene, camera);
    this.renderPassLight.clearPass.overrideClearColor = new import_three35.Color(0);
    this.clearPass = new ClearPass(true, false, false);
    this.clearPass.overrideClearColor = new import_three35.Color(0);
    this.blurPass = new KawaseBlurPass({ kernelSize });
    this.blurPass.enabled = blur;
    this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());
    const depthMaskMaterial = this.depthMaskMaterial;
    depthMaskMaterial.depthBuffer1 = this.renderTargetLight.depthTexture;
    depthMaskMaterial.copyCameraSettings(camera);
    this.godRaysPass = new ShaderPass(new GodRaysMaterial(this.screenPosition));
    const godRaysMaterial = this.godRaysMaterial;
    godRaysMaterial.density = density;
    godRaysMaterial.decay = decay;
    godRaysMaterial.weight = weight;
    godRaysMaterial.exposure = exposure;
    godRaysMaterial.maxIntensity = clampMax;
    godRaysMaterial.samples = samples;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  set mainCamera(value) {
    this.camera = value;
    this.renderPassLight.mainCamera = value;
    this.depthMaskMaterial.copyCameraSettings(value);
  }
  /**
   * Sets the light source.
   *
   * @type {Mesh|Points}
   */
  get lightSource() {
    return this._lightSource;
  }
  set lightSource(value) {
    this._lightSource = value;
    if (value !== null) {
      value.material.depthWrite = false;
      value.material.transparent = true;
    }
  }
  /**
   * Returns the blur pass that reduces aliasing artifacts and makes the light softer.
   *
   * @deprecated Use blurPass instead.
   * @return {KawaseBlurPass} The blur pass.
   */
  getBlurPass() {
    return this.blurPass;
  }
  /**
   * A texture that contains the intermediate result of this effect.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTargetB.texture;
  }
  /**
   * Returns the god rays texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.texture;
  }
  /**
   * The depth mask material.
   *
   * @type {DepthMaskMaterial}
   * @private
   */
  get depthMaskMaterial() {
    return this.depthMaskPass.fullscreenMaterial;
  }
  /**
   * The internal god rays material.
   *
   * @type {GodRaysMaterial}
   */
  get godRaysMaterial() {
    return this.godRaysPass.fullscreenMaterial;
  }
  /**
   * Returns the god rays material.
   *
   * @deprecated Use godRaysMaterial instead.
   * @return {GodRaysMaterial} The material.
   */
  getGodRaysMaterial() {
    return this.godRaysMaterial;
  }
  /**
   * Returns the resolution of this effect.
   *
   * @deprecated Use resolution instead.
   * @return {GodRaysMaterial} The material.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.width instead.
   */
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.height instead.
   */
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get dithering() {
    return this.godRaysMaterial.dithering;
  }
  set dithering(value) {
    const material = this.godRaysMaterial;
    material.dithering = value;
    material.needsUpdate = true;
  }
  /**
   * Indicates whether the god rays should be blurred to reduce artifacts.
   *
   * @type {Boolean}
   * @deprecated Use blurPass.enabled instead.
   */
  get blur() {
    return this.blurPass.enabled;
  }
  set blur(value) {
    this.blurPass.enabled = value;
  }
  /**
   * The blur kernel size.
   *
   * @type {KernelSize}
   * @deprecated Use blurPass.kernelSize instead.
   */
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(value) {
    this.blurPass.kernelSize = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * The number of samples per pixel.
   *
   * @type {Number}
   * @deprecated Use godRaysMaterial.samples instead.
   */
  get samples() {
    return this.godRaysMaterial.samples;
  }
  /**
   * A higher sample count improves quality at the cost of performance.
   *
   * @type {Number}
   * @deprecated Use godRaysMaterial.samples instead.
   */
  set samples(value) {
    this.godRaysMaterial.samples = value;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {Number} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = import_three35.BasicDepthPacking) {
    this.depthMaskPass.fullscreenMaterial.depthBuffer0 = depthTexture;
    this.depthMaskPass.fullscreenMaterial.depthPacking0 = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const lightSource = this.lightSource;
    const parent = lightSource.parent;
    const matrixAutoUpdate = lightSource.matrixAutoUpdate;
    const renderTargetA = this.renderTargetA;
    const renderTargetLight = this.renderTargetLight;
    lightSource.material.depthWrite = true;
    lightSource.matrixAutoUpdate = false;
    lightSource.updateWorldMatrix(true, false);
    if (parent !== null) {
      if (!matrixAutoUpdate) {
        m.copy(lightSource.matrix);
      }
      lightSource.matrix.copy(lightSource.matrixWorld);
    }
    this.lightScene.add(lightSource);
    this.renderPassLight.render(renderer, renderTargetLight);
    this.clearPass.render(renderer, renderTargetA);
    this.depthMaskPass.render(renderer, renderTargetLight, renderTargetA);
    lightSource.material.depthWrite = false;
    lightSource.matrixAutoUpdate = matrixAutoUpdate;
    if (parent !== null) {
      if (!matrixAutoUpdate) {
        lightSource.matrix.copy(m);
      }
      parent.add(lightSource);
    }
    v.setFromMatrixPosition(lightSource.matrixWorld).project(this.camera);
    this.screenPosition.set(
      Math.min(Math.max((v.x + 1) * 0.5, -1), 2),
      Math.min(Math.max((v.y + 1) * 0.5, -1), 2)
    );
    if (this.blurPass.enabled) {
      this.blurPass.render(renderer, renderTargetA, renderTargetA);
    }
    this.godRaysPass.render(renderer, renderTargetA, this.renderTargetB);
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.renderTargetA.setSize(w, h);
    this.renderTargetB.setSize(w, h);
    this.renderTargetLight.setSize(w, h);
    this.blurPass.resolution.copy(resolution);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.blurPass.initialize(renderer, alpha, frameBufferType);
    this.renderPassLight.initialize(renderer, alpha, frameBufferType);
    this.depthMaskPass.initialize(renderer, alpha, frameBufferType);
    this.godRaysPass.initialize(renderer, alpha, frameBufferType);
    if (frameBufferType !== void 0) {
      this.renderTargetA.texture.type = frameBufferType;
      this.renderTargetB.texture.type = frameBufferType;
      this.renderTargetLight.texture.type = frameBufferType;
      if (renderer !== null && renderer.outputColorSpace === import_three35.SRGBColorSpace) {
        this.renderTargetA.texture.colorSpace = import_three35.SRGBColorSpace;
        this.renderTargetB.texture.colorSpace = import_three35.SRGBColorSpace;
        this.renderTargetLight.texture.colorSpace = import_three35.SRGBColorSpace;
      }
    }
  }
};

// src/effects/GridEffect.js
var import_three36 = __webpack_require__(39437);

// src/effects/glsl/grid.frag
var grid_default = "uniform vec2 scale;uniform float lineWidth;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float grid=0.5-max(abs(mod(uv.x*scale.x,1.0)-0.5),abs(mod(uv.y*scale.y,1.0)-0.5));outputColor=vec4(vec3(smoothstep(0.0,lineWidth,grid)),inputColor.a);}";

// src/effects/GridEffect.js
var GridEffect = class extends Effect {
  /**
   * Constructs a new grid effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.OVERLAY] - The blend function of this effect.
   * @param {Number} [options.scale=1.0] - The scale of the grid pattern.
   * @param {Number} [options.lineWidth=0.0] - The line width of the grid pattern.
   */
  constructor({ blendFunction = BlendFunction.OVERLAY, scale = 1, lineWidth = 0 } = {}) {
    super("GridEffect", grid_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["scale", new import_three36.Uniform(new import_three36.Vector2())],
        ["lineWidth", new import_three36.Uniform(lineWidth)]
      ])
    });
    this.resolution = new import_three36.Vector2();
    this.s = 0;
    this.scale = scale;
    this.l = 0;
    this.lineWidth = lineWidth;
  }
  /**
   * The scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.s;
  }
  set scale(value) {
    this.s = Math.max(value, 1e-6);
    this.setSize(this.resolution.width, this.resolution.height);
  }
  /**
   * Returns the current grid scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The grid scale.
   */
  getScale() {
    return this.scale;
  }
  /**
   * Sets the grid scale.
   *
   * @deprecated Use scale instead.
   * @param {Number} value - The new grid scale.
   */
  setScale(value) {
    this.scale = value;
  }
  /**
   * The line width.
   *
   * @type {Number}
   */
  get lineWidth() {
    return this.l;
  }
  set lineWidth(value) {
    this.l = value;
    this.setSize(this.resolution.width, this.resolution.height);
  }
  /**
   * Returns the current grid line width.
   *
   * @deprecated Use lineWidth instead.
   * @return {Number} The grid line width.
   */
  getLineWidth() {
    return this.lineWidth;
  }
  /**
   * Sets the grid line width.
   *
   * @deprecated Use lineWidth instead.
   * @param {Number} value - The new grid line width.
   */
  setLineWidth(value) {
    this.lineWidth = value;
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.resolution.set(width, height);
    const aspect = width / height;
    const scale = this.scale * (height * 0.125);
    this.uniforms.get("scale").value.set(aspect * scale, scale);
    this.uniforms.get("lineWidth").value = scale / height + this.lineWidth;
  }
};

// src/effects/HueSaturationEffect.js
var import_three37 = __webpack_require__(39437);

// src/effects/glsl/hue-saturation.frag
var hue_saturation_default = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}";

// src/effects/HueSaturationEffect.js
var HueSaturationEffect = class extends Effect {
  /**
   * Constructs a new hue/saturation effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {Number} [options.hue=0.0] - The hue in radians.
   * @param {Number} [options.saturation=0.0] - The saturation factor, ranging from -1 to 1, where 0 means no change.
   */
  constructor({ blendFunction = BlendFunction.SRC, hue = 0, saturation = 0 } = {}) {
    super("HueSaturationEffect", hue_saturation_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["hue", new import_three37.Uniform(new import_three37.Vector3())],
        ["saturation", new import_three37.Uniform(saturation)]
      ])
    });
    this.hue = hue;
  }
  /**
   * The saturation.
   *
   * @type {Number}
   */
  get saturation() {
    return this.uniforms.get("saturation").value;
  }
  set saturation(value) {
    this.uniforms.get("saturation").value = value;
  }
  /**
   * Returns the saturation.
   *
   * @deprecated Use saturation instead.
   * @return {Number} The saturation.
   */
  getSaturation() {
    return this.saturation;
  }
  /**
   * Sets the saturation.
   *
   * @deprecated Use saturation instead.
   * @param {Number} value - The saturation.
   */
  setSaturation(value) {
    this.saturation = value;
  }
  /**
   * The hue.
   *
   * @type {Number}
   */
  get hue() {
    const hue = this.uniforms.get("hue").value;
    return Math.acos((hue.x * 3 - 1) / 2);
  }
  set hue(value) {
    const s = Math.sin(value), c2 = Math.cos(value);
    this.uniforms.get("hue").value.set(
      (2 * c2 + 1) / 3,
      (-Math.sqrt(3) * s - c2 + 1) / 3,
      (Math.sqrt(3) * s - c2 + 1) / 3
    );
  }
  /**
   * Returns the hue.
   *
   * @deprecated Use hue instead.
   * @return {Number} The hue in radians.
   */
  getHue() {
    return this.hue;
  }
  /**
   * Sets the hue.
   *
   * @deprecated Use hue instead.
   * @param {Number} value - The hue in radians.
   */
  setHue(value) {
    this.hue = value;
  }
};

// src/effects/LensDistortionEffect.js
var import_three38 = __webpack_require__(39437);

// src/effects/glsl/lens-distortion.frag
var lens_distortion_default = "uniform vec2 distortion;uniform vec2 principalPoint;uniform vec2 focalLength;uniform float skew;float mask(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void mainUv(inout vec2 uv){vec2 xn=2.0*(uv.st-0.5);vec3 xDistorted=vec3((1.0+distortion*dot(xn,xn))*xn,1.0);mat3 kk=mat3(vec3(focalLength.x,0.0,0.0),vec3(skew*focalLength.x,focalLength.y,0.0),vec3(principalPoint.x,principalPoint.y,1.0));uv=(kk*xDistorted).xy*0.5+0.5;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=mask(uv)*inputColor;}";

// src/effects/LensDistortionEffect.js
var LensDistortionEffect = class extends Effect {
  /**
   * Constructs a new lens distortion effect.
   *
   * @param {Object} [options] - The options.
   * @param {Vector2} [options.distortion] - The distortion value.
   * @param {Vector2} [options.principalPoint] - The center point.
   * @param {Vector2} [options.focalLength] - The focal length.
   * @param {Number} [options.skew=0] - The skew value.
   */
  constructor({
    distortion = new import_three38.Vector2(0, 0),
    principalPoint = new import_three38.Vector2(0, 0),
    focalLength = new import_three38.Vector2(1, 1),
    skew = 0
  } = {}) {
    super("LensDistortionEffect", lens_distortion_default, {
      uniforms: /* @__PURE__ */ new Map([
        ["distortion", new import_three38.Uniform(distortion)],
        ["principalPoint", new import_three38.Uniform(principalPoint)],
        ["focalLength", new import_three38.Uniform(focalLength)],
        ["skew", new import_three38.Uniform(skew)]
      ])
    });
  }
  /**
   * The radial distortion coefficients. Default is (0, 0).
   *
   * @type {Vector2}
   */
  get distortion() {
    return this.uniforms.get("distortion").value;
  }
  set distortion(value) {
    this.uniforms.get("distortion").value = value;
  }
  /**
   * The principal point. Default is (0, 0).
   *
   * @type {Vector2}
   */
  get principalPoint() {
    return this.uniforms.get("principalPoint").value;
  }
  set principalPoint(value) {
    this.uniforms.get("principalPoint").value = value;
  }
  /**
   * The focal length. Default is (1, 1).
   *
   * @type {Vector2}
   */
  get focalLength() {
    return this.uniforms.get("focalLength").value;
  }
  set focalLength(value) {
    this.uniforms.get("focalLength").value = value;
  }
  /**
   * The skew factor in radians.
   *
   * @type {Number}
   */
  get skew() {
    return this.uniforms.get("skew").value;
  }
  set skew(value) {
    this.uniforms.get("skew").value = value;
  }
};

// src/effects/LUT1DEffect.js
var import_three39 = __webpack_require__(39437);

// src/effects/glsl/lut-1d.frag
var lut_1d_default = "#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D lut;\n#else\nuniform mediump sampler2D lut;\n#endif\n#else\nuniform lowp sampler2D lut;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(texture2D(lut,vec2(inputColor.r,0.5)).r,texture2D(lut,vec2(inputColor.g,0.5)).r,texture2D(lut,vec2(inputColor.b,0.5)).r,inputColor.a);}";

// src/effects/LUT1DEffect.js
var LUT1DEffect = class extends Effect {
  /**
   * Constructs a new color grading effect.
   *
   * @param {Texture} lut - The lookup texture.
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   */
  constructor(lut, { blendFunction = BlendFunction.SRC } = {}) {
    super("LUT1DEffect", lut_1d_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([["lut", new import_three39.Uniform(null)]])
    });
    this.lut = lut;
  }
  /**
   * The LUT.
   *
   * @type {Texture}
   */
  get lut() {
    return this.uniforms.get("lut").value;
  }
  set lut(value) {
    this.uniforms.get("lut").value = value;
    if (value !== null && (value.type === import_three39.FloatType || value.type === import_three39.HalfFloatType)) {
      this.defines.set("LUT_PRECISION_HIGH", "1");
    }
  }
};

// src/effects/LUT3DEffect.js
var import_three41 = __webpack_require__(39437);

// src/textures/lut/LookupTexture.js
var import_three40 = __webpack_require__(39437);

// src/enums/LUTOperation.js
var LUTOperation = {
  SCALE_UP: "lut.scaleup"
};

// src/textures/RawImageData.js
function createCanvas(width, height, data) {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  canvas.width = width;
  canvas.height = height;
  if (data instanceof Image) {
    context.drawImage(data, 0, 0);
  } else {
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
  }
  return canvas;
}
var RawImageData = class _RawImageData {
  /**
   * Constructs a new image data container.
   *
   * @param {Number} [width=0] - The width of the image.
   * @param {Number} [height=0] - The height of the image.
   * @param {Uint8ClampedArray} [data=null] - The image data.
   */
  constructor(width = 0, height = 0, data = null) {
    this.width = width;
    this.height = height;
    this.data = data;
  }
  /**
   * Creates a canvas from this image data.
   *
   * @return {Canvas} The canvas, or null if it couldn't be created.
   */
  toCanvas() {
    return typeof document === "undefined" ? null : createCanvas(this.width, this.height, this.data);
  }
  /**
   * Creates a new image data container.
   *
   * @param {ImageData|Image} image - An image or plain image data.
   * @return {RawImageData} The image data.
   */
  static from(image) {
    const { width, height } = image;
    let data;
    if (image instanceof Image) {
      const canvas = createCanvas(width, height, image);
      if (canvas !== null) {
        const context = canvas.getContext("2d");
        data = context.getImageData(0, 0, width, height).data;
      }
    } else {
      data = image.data;
    }
    return new _RawImageData(width, height, data);
  }
};

// tmp/lut/worker.txt
var worker_default = '"use strict";(()=>{var O={SCALE_UP:"lut.scaleup"};var _=[new Float32Array(3),new Float32Array(3)],n=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],Z=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function d(a,t,r,m){let i=r[0]-t[0],e=r[1]-t[1],y=r[2]-t[2],h=a[0]-t[0],A=a[1]-t[1],w=a[2]-t[2],c=e*w-y*A,l=y*h-i*w,x=i*A-e*h,u=Math.sqrt(c*c+l*l+x*x),b=u*.5,s=c/u,F=l/u,f=x/u,p=-(a[0]*s+a[1]*F+a[2]*f),M=m[0]*s+m[1]*F+m[2]*f;return Math.abs(M+p)*b/3}function V(a,t,r,m,i,e){let y=(r+m*t+i*t*t)*4;e[0]=a[y+0],e[1]=a[y+1],e[2]=a[y+2]}function k(a,t,r,m,i,e){let y=r*(t-1),h=m*(t-1),A=i*(t-1),w=Math.floor(y),c=Math.floor(h),l=Math.floor(A),x=Math.ceil(y),u=Math.ceil(h),b=Math.ceil(A),s=y-w,F=h-c,f=A-l;if(w===y&&c===h&&l===A)V(a,t,y,h,A,e);else{let p;s>=F&&F>=f?p=Z[0]:s>=f&&f>=F?p=Z[1]:f>=s&&s>=F?p=Z[2]:F>=s&&s>=f?p=Z[3]:F>=f&&f>=s?p=Z[4]:f>=F&&F>=s&&(p=Z[5]);let[M,g,X,Y]=p,P=_[0];P[0]=s,P[1]=F,P[2]=f;let o=_[1],L=x-w,S=u-c,U=b-l;o[0]=L*M[0]+w,o[1]=S*M[1]+c,o[2]=U*M[2]+l,V(a,t,o[0],o[1],o[2],n[0]),o[0]=L*g[0]+w,o[1]=S*g[1]+c,o[2]=U*g[2]+l,V(a,t,o[0],o[1],o[2],n[1]),o[0]=L*X[0]+w,o[1]=S*X[1]+c,o[2]=U*X[2]+l,V(a,t,o[0],o[1],o[2],n[2]),o[0]=L*Y[0]+w,o[1]=S*Y[1]+c,o[2]=U*Y[2]+l,V(a,t,o[0],o[1],o[2],n[3]);let T=d(g,X,Y,P)*6,q=d(M,X,Y,P)*6,C=d(M,g,Y,P)*6,E=d(M,g,X,P)*6;n[0][0]*=T,n[0][1]*=T,n[0][2]*=T,n[1][0]*=q,n[1][1]*=q,n[1][2]*=q,n[2][0]*=C,n[2][1]*=C,n[2][2]*=C,n[3][0]*=E,n[3][1]*=E,n[3][2]*=E,e[0]=n[0][0]+n[1][0]+n[2][0]+n[3][0],e[1]=n[0][1]+n[1][1]+n[2][1]+n[3][1],e[2]=n[0][2]+n[1][2]+n[2][2]+n[3][2]}}var v=class{static expand(t,r){let m=Math.cbrt(t.length/4),i=new Float32Array(3),e=new t.constructor(r**3*4),y=t instanceof Uint8Array?255:1,h=r**2,A=1/(r-1);for(let w=0;w<r;++w)for(let c=0;c<r;++c)for(let l=0;l<r;++l){let x=l*A,u=c*A,b=w*A,s=Math.round(l+c*r+w*h)*4;k(t,m,x,u,b,i),e[s+0]=i[0],e[s+1]=i[1],e[s+2]=i[2],e[s+3]=y}return e}};self.addEventListener("message",a=>{let t=a.data,r=t.data;switch(t.operation){case O.SCALE_UP:r=v.expand(r,t.size);break}postMessage(r,[r.buffer]),close()});})();\n';

// src/textures/lut/LookupTexture.js
var c = /* @__PURE__ */ new import_three40.Color();
var LookupTexture = class _LookupTexture extends import_three40.Data3DTexture {
  /**
   * Constructs a cubic 3D lookup texture.
   *
   * @param {TypedArray} data - The pixel data. The default format is RGBA.
   * @param {Number} size - The sidelength.
   */
  constructor(data, size) {
    super(data, size, size, size);
    this.type = import_three40.FloatType;
    this.format = import_three40.RGBAFormat;
    this.minFilter = import_three40.LinearFilter;
    this.magFilter = import_three40.LinearFilter;
    this.wrapS = import_three40.ClampToEdgeWrapping;
    this.wrapT = import_three40.ClampToEdgeWrapping;
    this.wrapR = import_three40.ClampToEdgeWrapping;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
    this.colorSpace = import_three40.LinearSRGBColorSpace;
    this.domainMin = new import_three40.Vector3(0, 0, 0);
    this.domainMax = new import_three40.Vector3(1, 1, 1);
  }
  /**
   * Indicates that this is an instance of LookupTexture3D.
   *
   * @type {Boolean}
   * @deprecated
   */
  get isLookupTexture3D() {
    return true;
  }
  /**
   * Scales this LUT up to a given target size using tetrahedral interpolation.
   *
   * @param {Number} size - The target sidelength.
   * @param {Boolean} [transferData=true] - Extra fast mode. Set to false to keep the original data intact.
   * @return {Promise<LookupTexture>} A promise that resolves with a new LUT upon completion.
   */
  scaleUp(size, transferData = true) {
    const image = this.image;
    let promise;
    if (size <= image.width) {
      promise = Promise.reject(new Error("The target size must be greater than the current size"));
    } else {
      promise = new Promise((resolve, reject) => {
        const workerURL = URL.createObjectURL(new Blob([worker_default], {
          type: "text/javascript"
        }));
        const worker = new Worker(workerURL);
        worker.addEventListener("error", (event) => reject(event.error));
        worker.addEventListener("message", (event) => {
          const lut = new _LookupTexture(event.data, size);
          this.colorSpace = lut.colorSpace;
          lut.type = this.type;
          lut.name = this.name;
          URL.revokeObjectURL(workerURL);
          resolve(lut);
        });
        const transferList = transferData ? [image.data.buffer] : [];
        worker.postMessage({
          operation: LUTOperation.SCALE_UP,
          data: image.data,
          size
        }, transferList);
      });
    }
    return promise;
  }
  /**
   * Applies the given LUT to this one.
   *
   * @param {LookupTexture} lut - A LUT. Must have the same dimensions, type and format as this LUT.
   * @return {LookupTexture} This texture.
   */
  applyLUT(lut) {
    const img0 = this.image;
    const img1 = lut.image;
    const size0 = Math.min(img0.width, img0.height, img0.depth);
    const size1 = Math.min(img1.width, img1.height, img1.depth);
    if (size0 !== size1) {
      console.error("Size mismatch");
    } else if (lut.type !== import_three40.FloatType || this.type !== import_three40.FloatType) {
      console.error("Both LUTs must be FloatType textures");
    } else if (lut.format !== import_three40.RGBAFormat || this.format !== import_three40.RGBAFormat) {
      console.error("Both LUTs must be RGBA textures");
    } else {
      const data0 = img0.data;
      const data1 = img1.data;
      const size = size0;
      const sizeSq = size ** 2;
      const s = size - 1;
      for (let i = 0, l = size ** 3; i < l; ++i) {
        const i4 = i * 4;
        const r = data0[i4 + 0] * s;
        const g = data0[i4 + 1] * s;
        const b = data0[i4 + 2] * s;
        const iRGB = Math.round(r + g * size + b * sizeSq) * 4;
        data0[i4 + 0] = data1[iRGB + 0];
        data0[i4 + 1] = data1[iRGB + 1];
        data0[i4 + 2] = data1[iRGB + 2];
      }
      this.needsUpdate = true;
    }
    return this;
  }
  /**
   * Converts the LUT data into unsigned byte data.
   *
   * This is a lossy operation which should only be performed after all other transformations have been applied.
   *
   * @return {LookupTexture} This texture.
   */
  convertToUint8() {
    if (this.type === import_three40.FloatType) {
      const floatData = this.image.data;
      const uint8Data = new Uint8Array(floatData.length);
      for (let i = 0, l = floatData.length; i < l; ++i) {
        uint8Data[i] = floatData[i] * 255 + 0.5;
      }
      this.image.data = uint8Data;
      this.type = import_three40.UnsignedByteType;
      this.needsUpdate = true;
    }
    return this;
  }
  /**
   * Converts the LUT data into float data.
   *
   * @return {LookupTexture} This texture.
   */
  convertToFloat() {
    if (this.type === import_three40.UnsignedByteType) {
      const uint8Data = this.image.data;
      const floatData = new Float32Array(uint8Data.length);
      for (let i = 0, l = uint8Data.length; i < l; ++i) {
        floatData[i] = uint8Data[i] / 255;
      }
      this.image.data = floatData;
      this.type = import_three40.FloatType;
      this.needsUpdate = true;
    }
    return this;
  }
  /**
   * Converts this LUT into RGBA data.
   *
   * @deprecated LUTs are RGBA by default since three r137.
   * @return {LookupTexture} This texture.
   */
  convertToRGBA() {
    console.warn("LookupTexture", "convertToRGBA() is deprecated, LUTs are now RGBA by default");
    return this;
  }
  /**
   * Converts the output of this LUT into sRGB color space.
   *
   * @return {LookupTexture} This texture.
   */
  convertLinearToSRGB() {
    const data = this.image.data;
    if (this.type === import_three40.FloatType) {
      for (let i = 0, l = data.length; i < l; i += 4) {
        c.fromArray(data, i).convertLinearToSRGB().toArray(data, i);
      }
      this.colorSpace = import_three40.SRGBColorSpace;
      this.needsUpdate = true;
    } else {
      console.error("Color space conversion requires FloatType data");
    }
    return this;
  }
  /**
   * Converts the output of this LUT into linear color space.
   *
   * @return {LookupTexture} This texture.
   */
  convertSRGBToLinear() {
    const data = this.image.data;
    if (this.type === import_three40.FloatType) {
      for (let i = 0, l = data.length; i < l; i += 4) {
        c.fromArray(data, i).convertSRGBToLinear().toArray(data, i);
      }
      this.colorSpace = import_three40.LinearSRGBColorSpace;
      this.needsUpdate = true;
    } else {
      console.error("Color space conversion requires FloatType data");
    }
    return this;
  }
  /**
   * Converts this LUT into a 2D data texture.
   *
   * Please note that custom input domains are not carried over to 2D textures.
   *
   * @return {DataTexture} The texture.
   */
  toDataTexture() {
    const width = this.image.width;
    const height = this.image.height * this.image.depth;
    const texture = new import_three40.DataTexture(this.image.data, width, height);
    texture.name = this.name;
    texture.type = this.type;
    texture.format = this.format;
    texture.minFilter = import_three40.LinearFilter;
    texture.magFilter = import_three40.LinearFilter;
    texture.wrapS = this.wrapS;
    texture.wrapT = this.wrapT;
    texture.generateMipmaps = false;
    texture.needsUpdate = true;
    this.colorSpace = texture.colorSpace;
    return texture;
  }
  /**
   * Creates a new 3D LUT by copying a given LUT.
   *
   * Common image-based textures will be converted into 3D data textures.
   *
   * @param {Texture} texture - The LUT. Assumed to be cubic.
   * @return {LookupTexture} A new 3D LUT.
   */
  static from(texture) {
    const image = texture.image;
    const { width, height } = image;
    const size = Math.min(width, height);
    let data;
    if (image instanceof Image) {
      const rawImageData = RawImageData.from(image);
      const src = rawImageData.data;
      if (width > height) {
        data = new Uint8Array(src.length);
        for (let z = 0; z < size; ++z) {
          for (let y = 0; y < size; ++y) {
            for (let x = 0; x < size; ++x) {
              const i4 = (x + z * size + y * size * size) * 4;
              const j4 = (x + y * size + z * size * size) * 4;
              data[j4 + 0] = src[i4 + 0];
              data[j4 + 1] = src[i4 + 1];
              data[j4 + 2] = src[i4 + 2];
              data[j4 + 3] = src[i4 + 3];
            }
          }
        }
      } else {
        data = new Uint8Array(src.buffer);
      }
    } else {
      data = image.data.slice();
    }
    const lut = new _LookupTexture(data, size);
    lut.type = texture.type;
    lut.name = texture.name;
    texture.colorSpace = lut.colorSpace;
    return lut;
  }
  /**
   * Creates a neutral 3D LUT.
   *
   * @param {Number} size - The sidelength.
   * @return {LookupTexture} A neutral 3D LUT.
   */
  static createNeutral(size) {
    const data = new Float32Array(size ** 3 * 4);
    const sizeSq = size ** 2;
    const s = 1 / (size - 1);
    for (let r = 0; r < size; ++r) {
      for (let g = 0; g < size; ++g) {
        for (let b = 0; b < size; ++b) {
          const i4 = (r + g * size + b * sizeSq) * 4;
          data[i4 + 0] = r * s;
          data[i4 + 1] = g * s;
          data[i4 + 2] = b * s;
          data[i4 + 3] = 1;
        }
      }
    }
    const lut = new _LookupTexture(data, size);
    lut.name = "neutral";
    return lut;
  }
};

// src/effects/glsl/lut-3d.frag
var lut_3d_default = "uniform vec3 scale;uniform vec3 offset;\n#ifdef CUSTOM_INPUT_DOMAIN\nuniform vec3 domainMin;uniform vec3 domainMax;\n#endif\n#ifdef LUT_3D\n#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler3D lut;\n#else\nuniform mediump sampler3D lut;\n#endif\n#else\nuniform lowp sampler3D lut;\n#endif\nvec4 applyLUT(const in vec3 rgb){\n#ifdef TETRAHEDRAL_INTERPOLATION\nvec3 p=floor(rgb);vec3 f=rgb-p;vec3 v1=(p+0.5)*LUT_TEXEL_WIDTH;vec3 v4=(p+1.5)*LUT_TEXEL_WIDTH;vec3 v2,v3;vec3 frac;if(f.r>=f.g){if(f.g>f.b){frac=f.rgb;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else if(f.r>=f.b){frac=f.rbg;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v1.y,v4.z);}else{frac=f.brg;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v4.x,v1.y,v4.z);}}else{if(f.b>f.g){frac=f.bgr;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v1.x,v4.y,v4.z);}else if(f.r>=f.b){frac=f.grb;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else{frac=f.gbr;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v1.x,v4.y,v4.z);}}vec4 n1=texture(lut,v1);vec4 n2=texture(lut,v2);vec4 n3=texture(lut,v3);vec4 n4=texture(lut,v4);vec4 weights=vec4(1.0-frac.x,frac.x-frac.y,frac.y-frac.z,frac.z);vec4 result=weights*mat4(vec4(n1.r,n2.r,n3.r,n4.r),vec4(n1.g,n2.g,n3.g,n4.g),vec4(n1.b,n2.b,n3.b,n4.b),vec4(1.0));return vec4(result.rgb,1.0);\n#else\nreturn texture(lut,rgb);\n#endif\n}\n#else\n#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D lut;\n#else\nuniform mediump sampler2D lut;\n#endif\n#else\nuniform lowp sampler2D lut;\n#endif\nvec4 applyLUT(const in vec3 rgb){float slice=rgb.b*LUT_SIZE;float slice0=floor(slice);float interp=slice-slice0;float centeredInterp=interp-0.5;float slice1=slice0+sign(centeredInterp);\n#ifdef LUT_STRIP_HORIZONTAL\nfloat xOffset=clamp(rgb.r*LUT_TEXEL_HEIGHT,LUT_TEXEL_WIDTH*0.5,LUT_TEXEL_HEIGHT-LUT_TEXEL_WIDTH*0.5);vec2 uv0=vec2(slice0*LUT_TEXEL_HEIGHT+xOffset,rgb.g);vec2 uv1=vec2(slice1*LUT_TEXEL_HEIGHT+xOffset,rgb.g);\n#else\nfloat yOffset=clamp(rgb.g*LUT_TEXEL_WIDTH,LUT_TEXEL_HEIGHT*0.5,LUT_TEXEL_WIDTH-LUT_TEXEL_HEIGHT*0.5);vec2 uv0=vec2(rgb.r,slice0*LUT_TEXEL_WIDTH+yOffset);vec2 uv1=vec2(rgb.r,slice1*LUT_TEXEL_WIDTH+yOffset);\n#endif\nvec4 sample0=texture2D(lut,uv0);vec4 sample1=texture2D(lut,uv1);return mix(sample0,sample1,abs(centeredInterp));}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 c=inputColor.rgb;\n#ifdef CUSTOM_INPUT_DOMAIN\nif(c.r>=domainMin.r&&c.g>=domainMin.g&&c.b>=domainMin.b&&c.r<=domainMax.r&&c.g<=domainMax.g&&c.b<=domainMax.b){c=applyLUT(scale*c+offset).rgb;}else{c=inputColor.rgb;}\n#else\n#if !defined(LUT_3D) || defined(TETRAHEDRAL_INTERPOLATION)\nc=clamp(c,0.0,1.0);\n#endif\nc=applyLUT(scale*c+offset).rgb;\n#endif\noutputColor=vec4(c,inputColor.a);}";

// src/effects/LUT3DEffect.js
var LUT3DEffect = class extends Effect {
  /**
   * Constructs a new color grading effect.
   *
   * @param {Texture} lut - The lookup texture.
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {Boolean} [options.tetrahedralInterpolation=false] - Enables or disables tetrahedral interpolation.
   * @param {ColorSpace} [options.inputColorSpace=SRGBColorSpace] - The input color space.
   */
  constructor(lut, {
    blendFunction = BlendFunction.SRC,
    tetrahedralInterpolation = false,
    inputColorSpace = import_three41.SRGBColorSpace
  } = {}) {
    super("LUT3DEffect", lut_3d_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["lut", new import_three41.Uniform(null)],
        ["scale", new import_three41.Uniform(new import_three41.Vector3())],
        ["offset", new import_three41.Uniform(new import_three41.Vector3())],
        ["domainMin", new import_three41.Uniform(null)],
        ["domainMax", new import_three41.Uniform(null)]
      ])
    });
    this.tetrahedralInterpolation = tetrahedralInterpolation;
    this.inputColorSpace = inputColorSpace;
    this.lut = lut;
  }
  /**
   * The LUT.
   *
   * @type {Texture}
   */
  get lut() {
    return this.uniforms.get("lut").value;
  }
  set lut(value) {
    const defines = this.defines;
    const uniforms = this.uniforms;
    if (this.lut !== value) {
      uniforms.get("lut").value = value;
      if (value !== null) {
        const image = value.image;
        const tetrahedralInterpolation = this.tetrahedralInterpolation;
        defines.clear();
        defines.set("LUT_SIZE", Math.min(image.width, image.height).toFixed(16));
        defines.set("LUT_TEXEL_WIDTH", (1 / image.width).toFixed(16));
        defines.set("LUT_TEXEL_HEIGHT", (1 / image.height).toFixed(16));
        uniforms.get("domainMin").value = null;
        uniforms.get("domainMax").value = null;
        if (value.type === import_three41.FloatType || value.type === import_three41.HalfFloatType) {
          defines.set("LUT_PRECISION_HIGH", "1");
        }
        if (image.width > image.height) {
          defines.set("LUT_STRIP_HORIZONTAL", "1");
        } else if (value instanceof import_three41.Data3DTexture) {
          defines.set("LUT_3D", "1");
        }
        if (value instanceof LookupTexture) {
          const min = value.domainMin;
          const max = value.domainMax;
          if (min.x !== 0 || min.y !== 0 || min.z !== 0 || max.x !== 1 || max.y !== 1 || max.z !== 1) {
            defines.set("CUSTOM_INPUT_DOMAIN", "1");
            uniforms.get("domainMin").value = min.clone();
            uniforms.get("domainMax").value = max.clone();
          }
        }
        this.tetrahedralInterpolation = tetrahedralInterpolation;
      }
    }
  }
  /**
   * Returns the current LUT.
   *
   * @deprecated Use lut instead.
   * @return {Texture} The LUT.
   */
  getLUT() {
    return this.lut;
  }
  /**
   * Sets the LUT.
   *
   * @deprecated Use lut instead.
   * @param {Texture} value - The LUT.
   */
  setLUT(value) {
    this.lut = value;
  }
  /**
   * Updates the scale and offset for the LUT sampling coordinates.
   *
   * @private
   */
  updateScaleOffset() {
    const lut = this.lut;
    if (lut !== null) {
      const size = Math.min(lut.image.width, lut.image.height);
      const scale = this.uniforms.get("scale").value;
      const offset = this.uniforms.get("offset").value;
      if (this.tetrahedralInterpolation && lut instanceof import_three41.Data3DTexture) {
        if (this.defines.has("CUSTOM_INPUT_DOMAIN")) {
          const domainScale = lut.domainMax.clone().sub(lut.domainMin);
          scale.setScalar(size - 1).divide(domainScale);
          offset.copy(lut.domainMin).negate().multiply(scale);
        } else {
          scale.setScalar(size - 1);
          offset.setScalar(0);
        }
      } else {
        if (this.defines.has("CUSTOM_INPUT_DOMAIN")) {
          const domainScale = lut.domainMax.clone().sub(lut.domainMin).multiplyScalar(size);
          scale.setScalar(size - 1).divide(domainScale);
          offset.copy(lut.domainMin).negate().multiply(scale).addScalar(1 / (2 * size));
        } else {
          scale.setScalar((size - 1) / size);
          offset.setScalar(1 / (2 * size));
        }
      }
    }
  }
  /**
   * Configures parameters for tetrahedral interpolation.
   *
   * @private
   */
  configureTetrahedralInterpolation() {
    const lut = this.lut;
    if (lut !== null) {
      lut.minFilter = import_three41.LinearFilter;
      lut.magFilter = import_three41.LinearFilter;
      if (this.tetrahedralInterpolation) {
        if (lut instanceof import_three41.Data3DTexture) {
          lut.minFilter = import_three41.NearestFilter;
          lut.magFilter = import_three41.NearestFilter;
        } else {
          console.warn("Tetrahedral interpolation requires a 3D texture");
        }
      }
      if (lut.source === void 0) {
        lut.needsUpdate = true;
      }
    }
  }
  /**
   * Indicates whether tetrahedral interpolation is enabled. Requires a 3D LUT, disabled by default.
   *
   * Tetrahedral interpolation produces highly accurate results but is slower than hardware interpolation.
   *
   * @type {Boolean}
   */
  get tetrahedralInterpolation() {
    return this.defines.has("TETRAHEDRAL_INTERPOLATION");
  }
  set tetrahedralInterpolation(value) {
    if (value) {
      this.defines.set("TETRAHEDRAL_INTERPOLATION", "1");
    } else {
      this.defines.delete("TETRAHEDRAL_INTERPOLATION");
    }
    this.configureTetrahedralInterpolation();
    this.updateScaleOffset();
    this.setChanged();
  }
  /**
   * Enables or disables tetrahedral interpolation.
   *
   * @deprecated Use tetrahedralInterpolation instead.
   * @param {Boolean} value - Whether tetrahedral interpolation should be enabled.
   */
  setTetrahedralInterpolationEnabled(value) {
    this.tetrahedralInterpolation = value;
  }
};

// src/enums/DepthCopyMode.js
var DepthCopyMode = {
  FULL: 0,
  SINGLE: 1
};

// src/enums/EdgeDetectionMode.js
var EdgeDetectionMode = {
  DEPTH: 0,
  LUMA: 1,
  COLOR: 2
};

// src/enums/PredicationMode.js
var PredicationMode = {
  DISABLED: 0,
  DEPTH: 1,
  CUSTOM: 2
};

// src/enums/SMAAPreset.js
var SMAAPreset = {
  LOW: 0,
  MEDIUM: 1,
  HIGH: 2,
  ULTRA: 3
};

// src/enums/ToneMappingMode.js
var ToneMappingMode = {
  LINEAR: 0,
  REINHARD: 1,
  REINHARD2: 2,
  REINHARD2_ADAPTIVE: 3,
  UNCHARTED2: 4,
  OPTIMIZED_CINEON: 5,
  ACES_FILMIC: 6,
  AGX: 7,
  NEUTRAL: 8
};

// src/enums/VignetteTechnique.js
var VignetteTechnique = {
  DEFAULT: 0,
  ESKIL: 1
};

// src/enums/WebGLExtension.js
var WebGLExtension = {
  DERIVATIVES: "derivatives",
  FRAG_DEPTH: "fragDepth",
  DRAW_BUFFERS: "drawBuffers",
  SHADER_TEXTURE_LOD: "shaderTextureLOD"
};

// src/effects/glsl/noise.frag
var noise_default = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*(1.0+time)));\n#ifdef PREMULTIPLY\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\n#else\noutputColor=vec4(noise,inputColor.a);\n#endif\n}";

// src/effects/NoiseEffect.js
var NoiseEffect = class extends Effect {
  /**
   * Constructs a new noise effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.
   * @param {Boolean} [options.premultiply=false] - Whether the noise should be multiplied with the input colors prior to blending.
   */
  constructor({ blendFunction = BlendFunction.SCREEN, premultiply = false } = {}) {
    super("NoiseEffect", noise_default, { blendFunction });
    this.premultiply = premultiply;
  }
  /**
   * Indicates whether noise will be multiplied with the input colors prior to blending.
   *
   * @type {Boolean}
   */
  get premultiply() {
    return this.defines.has("PREMULTIPLY");
  }
  set premultiply(value) {
    if (this.premultiply !== value) {
      if (value) {
        this.defines.set("PREMULTIPLY", "1");
      } else {
        this.defines.delete("PREMULTIPLY");
      }
      this.setChanged();
    }
  }
  /**
   * Indicates whether noise will be multiplied with the input colors prior to blending.
   *
   * @deprecated Use premultiply instead.
   * @return {Boolean} Whether noise is premultiplied.
   */
  isPremultiplied() {
    return this.premultiply;
  }
  /**
   * Controls whether noise should be multiplied with the input colors prior to blending.
   *
   * @deprecated Use premultiply instead.
   * @param {Boolean} value - Whether noise should be premultiplied.
   */
  setPremultiplied(value) {
    this.premultiply = value;
  }
};

// src/effects/OutlineEffect.js
var import_three45 = __webpack_require__(39437);

// src/materials/DepthComparisonMaterial.js
var import_three42 = __webpack_require__(39437);

// src/materials/glsl/depth-comparison.frag
var depth_comparison_default = "#include <packing>\n#include <clipping_planes_pars_fragment>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float cameraNear;uniform float cameraFar;centroid varying float vViewZ;centroid varying vec4 vProjTexCoord;void main(){\n#include <clipping_planes_fragment>\nvec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);\n#if DEPTH_PACKING == 3201\nfloat fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));\n#else\nfloat fragCoordZ=texture2D(depthBuffer,projTexCoord).r;\n#endif\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#else\nfloat viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#endif\nfloat depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}";

// src/materials/glsl/depth-comparison.vert
var depth_comparison_default2 = "#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\nvViewZ=mvPosition.z;vProjTexCoord=gl_Position;\n#include <clipping_planes_vertex>\n}";

// src/materials/DepthComparisonMaterial.js
var DepthComparisonMaterial = class extends import_three42.ShaderMaterial {
  /**
   * Constructs a new depth comparison material.
   *
   * @param {Texture} [depthTexture=null] - A depth texture.
   * @param {PerspectiveCamera} [camera] - A camera.
   */
  constructor(depthTexture = null, camera) {
    super({
      name: "DepthComparisonMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new import_three42.Uniform(null),
        cameraNear: new import_three42.Uniform(0.3),
        cameraFar: new import_three42.Uniform(1e3)
      },
      blending: import_three42.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_comparison_default,
      vertexShader: depth_comparison_default2
    });
    this.depthBuffer = depthTexture;
    this.depthPacking = import_three42.RGBADepthPacking;
    this.copyCameraSettings(camera);
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=RGBADepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = import_three42.RGBADepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof import_three42.PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
};

// src/materials/OutlineMaterial.js
var import_three43 = __webpack_require__(39437);

// src/materials/glsl/outline.frag
var outline_default = "uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}";

// src/materials/glsl/outline.vert
var outline_default2 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/OutlineMaterial.js
var OutlineMaterial = class extends import_three43.ShaderMaterial {
  /**
   * Constructs a new outline material.
   *
   * TODO Remove texelSize param.
   * @param {Vector2} [texelSize] - The screen texel size.
   */
  constructor(texelSize = new import_three43.Vector2()) {
    super({
      name: "OutlineMaterial",
      uniforms: {
        inputBuffer: new import_three43.Uniform(null),
        texelSize: new import_three43.Uniform(new import_three43.Vector2())
      },
      blending: import_three43.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: outline_default,
      vertexShader: outline_default2
    });
    this.uniforms.texelSize.value.set(texelSize.x, texelSize.y);
    this.uniforms.maskTexture = this.uniforms.inputBuffer;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/passes/DepthPass.js
var import_three44 = __webpack_require__(39437);
var DepthPass = class extends Pass {
  /**
   * Constructs a new depth pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Object} [options] - The options.
   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(scene, camera, {
    renderTarget,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("DepthPass");
    this.needsSwap = false;
    this.renderPass = new RenderPass(scene, camera, new import_three44.MeshDepthMaterial({
      depthPacking: import_three44.RGBADepthPacking
    }));
    const renderPass = this.renderPass;
    renderPass.skipShadowMapUpdate = true;
    renderPass.ignoreBackground = true;
    const clearPass = renderPass.clearPass;
    clearPass.overrideClearColor = new import_three44.Color(16777215);
    clearPass.overrideClearAlpha = 1;
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new import_three44.WebGLRenderTarget(1, 1, {
        minFilter: import_three44.NearestFilter,
        magFilter: import_three44.NearestFilter
      });
      this.renderTarget.texture.name = "DepthPass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  set mainScene(value) {
    this.renderPass.mainScene = value;
  }
  set mainCamera(value) {
    this.renderPass.mainCamera = value;
  }
  /**
   * The depth texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the depth texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Renders the scene depth.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const renderTarget = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(renderer, renderTarget);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
};

// src/effects/glsl/outline.frag
var outline_default3 = "uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;\n#ifdef USE_PATTERN\nuniform lowp sampler2D patternTexture;varying vec2 vUvPattern;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;\n#ifndef X_RAY\nedge.y=0.0;\n#endif\nedge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;\n#ifdef USE_PATTERN\nvec4 patternColor=texture2D(patternTexture,vUvPattern);\n#ifdef X_RAY\nfloat hiddenFactor=0.5;\n#else\nfloat hiddenFactor=0.0;\n#endif\nvisibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;\n#endif\nfloat alpha=max(max(edge.x,edge.y),visibilityFactor);\n#ifdef ALPHA\noutputColor=vec4(color,alpha);\n#else\noutputColor=vec4(color,max(alpha,inputColor.a));\n#endif\n}";

// src/effects/glsl/outline.vert
var outline_default4 = "uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}";

// src/effects/OutlineEffect.js
var OutlineEffect = class extends Effect {
  /**
   * Constructs a new outline effect.
   *
   * @param {Scene} scene - The main scene.
   * @param {Camera} camera - The main camera.
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function. Use `BlendFunction.ALPHA` for dark outlines.
   * @param {Texture} [options.patternTexture=null] - A pattern texture.
   * @param {Number} [options.patternScale=1.0] - The pattern scale.
   * @param {Number} [options.edgeStrength=1.0] - The edge strength.
   * @param {Number} [options.pulseSpeed=0.0] - The pulse speed. A value of zero disables the pulse effect.
   * @param {Number} [options.visibleEdgeColor=0xffffff] - The color of visible edges.
   * @param {Number} [options.hiddenEdgeColor=0x22090a] - The color of hidden edges.
   * @param {KernelSize} [options.kernelSize=KernelSize.VERY_SMALL] - The blur kernel size.
   * @param {Boolean} [options.blur=false] - Whether the outline should be blurred.
   * @param {Boolean} [options.xRay=true] - Whether occluded parts of selected objects should be visible.
   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(scene, camera, {
    blendFunction = BlendFunction.SCREEN,
    patternTexture = null,
    patternScale = 1,
    edgeStrength = 1,
    pulseSpeed = 0,
    visibleEdgeColor = 16777215,
    hiddenEdgeColor = 2230538,
    kernelSize = KernelSize.VERY_SMALL,
    blur = false,
    xRay = true,
    multisampling = 0,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("OutlineEffect", outline_default3, {
      uniforms: /* @__PURE__ */ new Map([
        ["maskTexture", new import_three45.Uniform(null)],
        ["edgeTexture", new import_three45.Uniform(null)],
        ["edgeStrength", new import_three45.Uniform(edgeStrength)],
        ["visibleEdgeColor", new import_three45.Uniform(new import_three45.Color(visibleEdgeColor))],
        ["hiddenEdgeColor", new import_three45.Uniform(new import_three45.Color(hiddenEdgeColor))],
        ["pulse", new import_three45.Uniform(1)],
        ["patternScale", new import_three45.Uniform(patternScale)],
        ["patternTexture", new import_three45.Uniform(null)]
      ])
    });
    this.blendMode.addEventListener("change", (event) => {
      if (this.blendMode.blendFunction === BlendFunction.ALPHA) {
        this.defines.set("ALPHA", "1");
      } else {
        this.defines.delete("ALPHA");
      }
      this.setChanged();
    });
    this.blendMode.blendFunction = blendFunction;
    this.patternTexture = patternTexture;
    this.xRay = xRay;
    this.scene = scene;
    this.camera = camera;
    this.renderTargetMask = new import_three45.WebGLRenderTarget(1, 1);
    this.renderTargetMask.samples = multisampling;
    this.renderTargetMask.texture.name = "Outline.Mask";
    this.uniforms.get("maskTexture").value = this.renderTargetMask.texture;
    this.renderTargetOutline = new import_three45.WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetOutline.texture.name = "Outline.Edges";
    this.uniforms.get("edgeTexture").value = this.renderTargetOutline.texture;
    this.clearPass = new ClearPass();
    this.clearPass.overrideClearColor = new import_three45.Color(0);
    this.clearPass.overrideClearAlpha = 1;
    this.depthPass = new DepthPass(scene, camera);
    this.maskPass = new RenderPass(scene, camera, new DepthComparisonMaterial(this.depthPass.texture, camera));
    const clearPass = this.maskPass.clearPass;
    clearPass.overrideClearColor = new import_three45.Color(16777215);
    clearPass.overrideClearAlpha = 1;
    this.blurPass = new KawaseBlurPass({ resolutionScale, resolutionX, resolutionY, kernelSize });
    this.blurPass.enabled = blur;
    const resolution = this.blurPass.resolution;
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.outlinePass = new ShaderPass(new OutlineMaterial());
    const outlineMaterial = this.outlinePass.fullscreenMaterial;
    outlineMaterial.inputBuffer = this.renderTargetMask.texture;
    this.time = 0;
    this.forceUpdate = true;
    this.selection = new Selection();
    this.selection.layer = 10;
    this.pulseSpeed = pulseSpeed;
  }
  set mainScene(value) {
    this.scene = value;
    this.depthPass.mainScene = value;
    this.maskPass.mainScene = value;
  }
  set mainCamera(value) {
    this.camera = value;
    this.depthPass.mainCamera = value;
    this.maskPass.mainCamera = value;
    this.maskPass.overrideMaterial.copyCameraSettings(value);
  }
  /**
   * The resolution of this effect.
   *
   * @type {Resolution}
   */
  get resolution() {
    return this.blurPass.resolution;
  }
  /**
   * Returns the resolution.
   *
   * @return {Resizer} The resolution.
   */
  getResolution() {
    return this.blurPass.getResolution();
  }
  /**
   * The amount of MSAA samples.
   *
   * Requires WebGL 2. Set to zero to disable multisampling.
   *
   * @experimental Requires three >= r138.
   * @type {Number}
   */
  get multisampling() {
    return this.renderTargetMask.samples;
  }
  set multisampling(value) {
    this.renderTargetMask.samples = value;
    this.renderTargetMask.dispose();
  }
  /**
   * The pattern scale.
   *
   * @type {Number}
   */
  get patternScale() {
    return this.uniforms.get("patternScale").value;
  }
  set patternScale(value) {
    this.uniforms.get("patternScale").value = value;
  }
  /**
   * The edge strength.
   *
   * @type {Number}
   */
  get edgeStrength() {
    return this.uniforms.get("edgeStrength").value;
  }
  set edgeStrength(value) {
    this.uniforms.get("edgeStrength").value = value;
  }
  /**
   * The visible edge color.
   *
   * @type {Color}
   */
  get visibleEdgeColor() {
    return this.uniforms.get("visibleEdgeColor").value;
  }
  set visibleEdgeColor(value) {
    this.uniforms.get("visibleEdgeColor").value = value;
  }
  /**
   * The hidden edge color.
   *
   * @type {Color}
   */
  get hiddenEdgeColor() {
    return this.uniforms.get("hiddenEdgeColor").value;
  }
  set hiddenEdgeColor(value) {
    this.uniforms.get("hiddenEdgeColor").value = value;
  }
  /**
   * Returns the blur pass.
   *
   * @deprecated Use blurPass instead.
   * @return {KawaseBlurPass} The blur pass.
   */
  getBlurPass() {
    return this.blurPass;
  }
  /**
   * Returns the selection.
   *
   * @deprecated Use selection instead.
   * @return {Selection} The selection.
   */
  getSelection() {
    return this.selection;
  }
  /**
   * Returns the pulse speed.
   *
   * @deprecated Use pulseSpeed instead.
   * @return {Number} The speed.
   */
  getPulseSpeed() {
    return this.pulseSpeed;
  }
  /**
   * Sets the pulse speed. Set to zero to disable.
   *
   * @deprecated Use pulseSpeed instead.
   * @param {Number} value - The speed.
   */
  setPulseSpeed(value) {
    this.pulseSpeed = value;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.width instead.
   */
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.height instead.
   */
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * The selection layer.
   *
   * @type {Number}
   * @deprecated Use selection.layer instead.
   */
  get selectionLayer() {
    return this.selection.layer;
  }
  set selectionLayer(value) {
    this.selection.layer = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(value) {
    this.blurPass.dithering = value;
  }
  /**
   * The blur kernel size.
   *
   * @type {KernelSize}
   * @deprecated Use blurPass.kernelSize instead.
   */
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(value) {
    this.blurPass.kernelSize = value;
  }
  /**
   * Indicates whether the outlines should be blurred.
   *
   * @type {Boolean}
   * @deprecated Use blurPass.enabled instead.
   */
  get blur() {
    return this.blurPass.enabled;
  }
  set blur(value) {
    this.blurPass.enabled = value;
  }
  /**
   * Indicates whether X-ray mode is enabled.
   *
   * @type {Boolean}
   */
  get xRay() {
    return this.defines.has("X_RAY");
  }
  set xRay(value) {
    if (this.xRay !== value) {
      if (value) {
        this.defines.set("X_RAY", "1");
      } else {
        this.defines.delete("X_RAY");
      }
      this.setChanged();
    }
  }
  /**
   * Indicates whether X-ray mode is enabled.
   *
   * @deprecated Use xRay instead.
   * @return {Boolean} Whether X-ray mode is enabled.
   */
  isXRayEnabled() {
    return this.xRay;
  }
  /**
   * Enables or disables X-ray outlines.
   *
   * @deprecated Use xRay instead.
   * @param {Boolean} value - Whether X-ray should be enabled.
   */
  setXRayEnabled(value) {
    this.xRay = value;
  }
  /**
   * The pattern texture. Set to `null` to disable.
   *
   * @type {Texture}
   */
  get patternTexture() {
    return this.uniforms.get("patternTexture").value;
  }
  set patternTexture(value) {
    if (value !== null) {
      value.wrapS = value.wrapT = import_three45.RepeatWrapping;
      this.defines.set("USE_PATTERN", "1");
      this.setVertexShader(outline_default4);
    } else {
      this.defines.delete("USE_PATTERN");
      this.setVertexShader(null);
    }
    this.uniforms.get("patternTexture").value = value;
    this.setChanged();
  }
  /**
   * Sets the pattern texture.
   *
   * @deprecated Use patternTexture instead.
   * @param {Texture} value - The new texture.
   */
  setPatternTexture(value) {
    this.patternTexture = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Clears the current selection and selects a list of objects.
   *
   * @param {Object3D[]} objects - The objects that should be outlined. This array will be copied.
   * @return {OutlinePass} This pass.
   * @deprecated Use selection.set() instead.
   */
  setSelection(objects) {
    this.selection.set(objects);
    return this;
  }
  /**
   * Clears the list of selected objects.
   *
   * @return {OutlinePass} This pass.
   * @deprecated Use selection.clear() instead.
   */
  clearSelection() {
    this.selection.clear();
    return this;
  }
  /**
   * Selects an object.
   *
   * @param {Object3D} object - The object that should be outlined.
   * @return {OutlinePass} This pass.
   * @deprecated Use selection.add() instead.
   */
  selectObject(object) {
    this.selection.add(object);
    return this;
  }
  /**
   * Deselects an object.
   *
   * @param {Object3D} object - The object that should no longer be outlined.
   * @return {OutlinePass} This pass.
   * @deprecated Use selection.delete() instead.
   */
  deselectObject(object) {
    this.selection.delete(object);
    return this;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const scene = this.scene;
    const camera = this.camera;
    const selection = this.selection;
    const uniforms = this.uniforms;
    const pulse = uniforms.get("pulse");
    const background = scene.background;
    const mask = camera.layers.mask;
    if (this.forceUpdate || selection.size > 0) {
      scene.background = null;
      pulse.value = 1;
      if (this.pulseSpeed > 0) {
        pulse.value = Math.cos(this.time * this.pulseSpeed * 10) * 0.375 + 0.625;
      }
      this.time += deltaTime;
      selection.setVisible(false);
      this.depthPass.render(renderer);
      selection.setVisible(true);
      camera.layers.set(selection.layer);
      this.maskPass.render(renderer, this.renderTargetMask);
      camera.layers.mask = mask;
      scene.background = background;
      this.outlinePass.render(renderer, null, this.renderTargetOutline);
      if (this.blurPass.enabled) {
        this.blurPass.render(renderer, this.renderTargetOutline, this.renderTargetOutline);
      }
    }
    this.forceUpdate = selection.size > 0;
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.blurPass.setSize(width, height);
    this.renderTargetMask.setSize(width, height);
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.depthPass.setSize(w, h);
    this.renderTargetOutline.setSize(w, h);
    this.outlinePass.fullscreenMaterial.setSize(w, h);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.blurPass.initialize(renderer, alpha, import_three45.UnsignedByteType);
    if (frameBufferType !== void 0) {
      this.depthPass.initialize(renderer, alpha, frameBufferType);
      this.maskPass.initialize(renderer, alpha, frameBufferType);
      this.outlinePass.initialize(renderer, alpha, frameBufferType);
    }
  }
};

// src/effects/PixelationEffect.js
var import_three46 = __webpack_require__(39437);

// src/effects/glsl/pixelation.frag
var pixelation_default = "uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}";

// src/effects/PixelationEffect.js
var PixelationEffect = class extends Effect {
  /**
   * Constructs a new pixelation effect.
   *
   * @param {Object} [granularity=30.0] - The pixel granularity.
   */
  constructor(granularity = 30) {
    super("PixelationEffect", pixelation_default, {
      uniforms: /* @__PURE__ */ new Map([
        ["active", new import_three46.Uniform(false)],
        ["d", new import_three46.Uniform(new import_three46.Vector4())]
      ])
    });
    this.resolution = new import_three46.Vector2();
    this._granularity = 0;
    this.granularity = granularity;
  }
  /**
   * The pixel granularity.
   *
   * A higher value yields coarser visuals.
   *
   * @type {Number}
   */
  get granularity() {
    return this._granularity;
  }
  set granularity(value) {
    let d = Math.floor(value);
    if (d % 2 > 0) {
      d += 1;
    }
    this._granularity = d;
    this.uniforms.get("active").value = d > 0;
    this.setSize(this.resolution.width, this.resolution.height);
  }
  /**
   * Returns the pixel granularity.
   *
   * @deprecated Use granularity instead.
   * @return {Number} The granularity.
   */
  getGranularity() {
    return this.granularity;
  }
  /**
   * Sets the pixel granularity.
   *
   * @deprecated Use granularity instead.
   * @param {Number} value - The new granularity.
   */
  setGranularity(value) {
    this.granularity = value;
  }
  /**
   * Updates the granularity.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.set(width, height);
    const d = this.granularity;
    const x = d / resolution.x;
    const y = d / resolution.y;
    this.uniforms.get("d").value.set(x, y, 1 / x, 1 / y);
  }
};

// src/effects/RealisticBokehEffect.js
var import_three47 = __webpack_require__(39437);

// src/effects/glsl/realistic-bokeh.frag
var realistic_bokeh_default = "uniform float focus;uniform float focalLength;uniform float fStop;uniform float maxBlur;uniform float luminanceThreshold;uniform float luminanceGain;uniform float bias;uniform float fringe;\n#ifdef MANUAL_DOF\nuniform vec4 dof;\n#endif\n#ifdef PENTAGON\nfloat pentagon(const in vec2 coords){const vec4 HS0=vec4(1.0,0.0,0.0,1.0);const vec4 HS1=vec4(0.309016994,0.951056516,0.0,1.0);const vec4 HS2=vec4(-0.809016994,0.587785252,0.0,1.0);const vec4 HS3=vec4(-0.809016994,-0.587785252,0.0,1.0);const vec4 HS4=vec4(0.309016994,-0.951056516,0.0,1.0);const vec4 HS5=vec4(0.0,0.0,1.0,1.0);const vec4 ONE=vec4(1.0);const float P_FEATHER=0.4;const float N_FEATHER=-P_FEATHER;float inOrOut=-4.0;vec4 P=vec4(coords,vec2(RINGS_FLOAT-1.3));vec4 dist=vec4(dot(P,HS0),dot(P,HS1),dot(P,HS2),dot(P,HS3));dist=smoothstep(N_FEATHER,P_FEATHER,dist);inOrOut+=dot(dist,ONE);dist.x=dot(P,HS4);dist.y=HS5.w-abs(P.z);dist=smoothstep(N_FEATHER,P_FEATHER,dist);inOrOut+=dist.x;return clamp(inOrOut,0.0,1.0);}\n#endif\nvec3 processTexel(const in vec2 coords,const in float blur){vec2 scale=texelSize*fringe*blur;vec3 c=vec3(texture2D(inputBuffer,coords+vec2(0.0,1.0)*scale).r,texture2D(inputBuffer,coords+vec2(-0.866,-0.5)*scale).g,texture2D(inputBuffer,coords+vec2(0.866,-0.5)*scale).b);float luminance=linearToRelativeLuminance(c);float threshold=max((luminance-luminanceThreshold)*luminanceGain,0.0);return c+mix(vec3(0.0),c,threshold*blur);}float gather(const in float i,const in float j,const in float ringSamples,const in vec2 uv,const in vec2 blurFactor,const in float blur,inout vec3 color){float step=PI2/ringSamples;vec2 wh=vec2(cos(j*step)*i,sin(j*step)*i);\n#ifdef PENTAGON\nfloat p=pentagon(wh);\n#else\nfloat p=1.0;\n#endif\ncolor+=processTexel(wh*blurFactor+uv,blur)*mix(1.0,i/RINGS_FLOAT,bias)*p;return mix(1.0,i/RINGS_FLOAT,bias)*p;}void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\n#ifdef MANUAL_DOF\nfloat focalPlane=linearDepth-focus;float farDoF=(focalPlane-dof.z)/dof.w;float nearDoF=(-focalPlane-dof.x)/dof.y;float blur=(focalPlane>0.0)?farDoF:nearDoF;\n#else\nconst float CIRCLE_OF_CONFUSION=0.03;float focalPlaneMM=focus*1000.0;float depthMM=linearDepth*1000.0;float focalPlane=(depthMM*focalLength)/(depthMM-focalLength);float farDoF=(focalPlaneMM*focalLength)/(focalPlaneMM-focalLength);float nearDoF=(focalPlaneMM-focalLength)/(focalPlaneMM*fStop*CIRCLE_OF_CONFUSION);float blur=abs(focalPlane-farDoF)*nearDoF;\n#endif\nconst int MAX_RING_SAMPLES=RINGS_INT*SAMPLES_INT;blur=clamp(blur,0.0,1.0);vec3 color=inputColor.rgb;if(blur>=0.05){vec2 blurFactor=blur*maxBlur*texelSize;float s=1.0;int ringSamples;for(int i=1;i<=RINGS_INT;i++){ringSamples=i*SAMPLES_INT;for(int j=0;j<MAX_RING_SAMPLES;j++){if(j>=ringSamples){break;}s+=gather(float(i),float(j),float(ringSamples),uv,blurFactor,blur,color);}}color/=s;}\n#ifdef SHOW_FOCUS\nfloat edge=0.002*linearDepth;float m=clamp(smoothstep(0.0,edge,blur),0.0,1.0);float e=clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);color=mix(color,vec3(1.0,0.5,0.0),(1.0-m)*0.6);color=mix(color,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\n#endif\noutputColor=vec4(color,inputColor.a);}";

// src/effects/RealisticBokehEffect.js
var RealisticBokehEffect = class extends Effect {
  /**
   * Constructs a new bokeh effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
   * @param {Number} [options.focus=1.0] - The focus distance in world units.
   * @param {Number} [options.focalLength=24.0] - The focal length of the main camera.
   * @param {Number} [options.fStop=0.9] - The ratio of the lens focal length to the diameter of the entrance pupil (aperture).
   * @param {Number} [options.luminanceThreshold=0.5] - A luminance threshold.
   * @param {Number} [options.luminanceGain=2.0] - A luminance gain factor.
   * @param {Number} [options.bias=0.5] - A blur bias.
   * @param {Number} [options.fringe=0.7] - A blur offset.
   * @param {Number} [options.maxBlur=1.0] - The maximum blur strength.
   * @param {Boolean} [options.rings=3] - The number of blur iterations.
   * @param {Boolean} [options.samples=2] - The amount of samples taken per ring.
   * @param {Boolean} [options.showFocus=false] - Whether the focal point should be highlighted. Useful for debugging.
   * @param {Boolean} [options.manualDoF=false] - Enables manual control over the depth of field.
   * @param {Boolean} [options.pentagon=false] - Enables pentagonal blur shapes. Requires a high number of rings and samples.
   */
  constructor({
    blendFunction,
    focus = 1,
    focalLength = 24,
    fStop = 0.9,
    luminanceThreshold = 0.5,
    luminanceGain = 2,
    bias = 0.5,
    fringe = 0.7,
    maxBlur = 1,
    rings = 3,
    samples = 2,
    showFocus = false,
    manualDoF = false,
    pentagon = false
  } = {}) {
    super("RealisticBokehEffect", realistic_bokeh_default, {
      blendFunction,
      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["focus", new import_three47.Uniform(focus)],
        ["focalLength", new import_three47.Uniform(focalLength)],
        ["fStop", new import_three47.Uniform(fStop)],
        ["luminanceThreshold", new import_three47.Uniform(luminanceThreshold)],
        ["luminanceGain", new import_three47.Uniform(luminanceGain)],
        ["bias", new import_three47.Uniform(bias)],
        ["fringe", new import_three47.Uniform(fringe)],
        ["maxBlur", new import_three47.Uniform(maxBlur)],
        ["dof", new import_three47.Uniform(null)]
      ])
    });
    this.rings = rings;
    this.samples = samples;
    this.showFocus = showFocus;
    this.manualDoF = manualDoF;
    this.pentagon = pentagon;
  }
  /**
   * The amount of blur iterations.
   *
   * @type {Number}
   */
  get rings() {
    return Number.parseInt(this.defines.get("RINGS_INT"));
  }
  set rings(value) {
    const r = Math.floor(value);
    this.defines.set("RINGS_INT", r.toFixed(0));
    this.defines.set("RINGS_FLOAT", r.toFixed(1));
    this.setChanged();
  }
  /**
   * The amount of blur samples per ring.
   *
   * @type {Number}
   */
  get samples() {
    return Number.parseInt(this.defines.get("SAMPLES_INT"));
  }
  set samples(value) {
    const s = Math.floor(value);
    this.defines.set("SAMPLES_INT", s.toFixed(0));
    this.defines.set("SAMPLES_FLOAT", s.toFixed(1));
    this.setChanged();
  }
  /**
   * Indicates whether the focal point will be highlighted.
   *
   * @type {Boolean}
   */
  get showFocus() {
    return this.defines.has("SHOW_FOCUS");
  }
  set showFocus(value) {
    if (this.showFocus !== value) {
      if (value) {
        this.defines.set("SHOW_FOCUS", "1");
      } else {
        this.defines.delete("SHOW_FOCUS");
      }
      this.setChanged();
    }
  }
  /**
   * Indicates whether the Depth of Field should be calculated manually.
   *
   * If enabled, the Depth of Field can be adjusted via the `dof` uniform.
   *
   * @type {Boolean}
   */
  get manualDoF() {
    return this.defines.has("MANUAL_DOF");
  }
  set manualDoF(value) {
    if (this.manualDoF !== value) {
      if (value) {
        this.defines.set("MANUAL_DOF", "1");
        this.uniforms.get("dof").value = new import_three47.Vector4(0.2, 1, 0.2, 2);
      } else {
        this.defines.delete("MANUAL_DOF");
        this.uniforms.get("dof").value = null;
      }
      this.setChanged();
    }
  }
  /**
   * Indicates whether the blur shape should be pentagonal.
   *
   * @type {Boolean}
   */
  get pentagon() {
    return this.defines.has("PENTAGON");
  }
  set pentagon(value) {
    if (this.pentagon !== value) {
      if (value) {
        this.defines.set("PENTAGON", "1");
      } else {
        this.defines.delete("PENTAGON");
      }
      this.setChanged();
    }
  }
};

// src/effects/ScanlineEffect.js
var import_three48 = __webpack_require__(39437);

// src/effects/glsl/scanlines.frag
var scanlines_default = "uniform float count;\n#ifdef SCROLL\nuniform float scrollSpeed;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float y=uv.y;\n#ifdef SCROLL\ny+=time*scrollSpeed;\n#endif\nvec2 sl=vec2(sin(y*count),cos(y*count));outputColor=vec4(sl.xyx,inputColor.a);}";

// src/effects/ScanlineEffect.js
var ScanlineEffect = class extends Effect {
  /**
   * Constructs a new scanline effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.OVERLAY] - The blend function of this effect.
   * @param {Number} [options.density=1.25] - The scanline density.
   * @param {Number} [options.scrollSpeed=0.0] - The scanline scroll speed.
   */
  constructor({ blendFunction = BlendFunction.OVERLAY, density = 1.25, scrollSpeed = 0 } = {}) {
    super("ScanlineEffect", scanlines_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["count", new import_three48.Uniform(0)],
        ["scrollSpeed", new import_three48.Uniform(0)]
      ])
    });
    this.resolution = new import_three48.Vector2();
    this.d = density;
    this.scrollSpeed = scrollSpeed;
  }
  /**
   * The scanline density.
   *
   * @type {Number}
   */
  get density() {
    return this.d;
  }
  set density(value) {
    this.d = value;
    this.setSize(this.resolution.width, this.resolution.height);
  }
  /**
   * Returns the current scanline density.
   *
   * @deprecated Use density instead.
   * @return {Number} The scanline density.
   */
  getDensity() {
    return this.density;
  }
  /**
   * Sets the scanline density.
   *
   * @deprecated Use density instead.
   * @param {Number} value - The new scanline density.
   */
  setDensity(value) {
    this.density = value;
  }
  /**
   * The scanline scroll speed. Default is 0 (disabled).
   *
   * @type {Number}
   */
  get scrollSpeed() {
    return this.uniforms.get("scrollSpeed").value;
  }
  set scrollSpeed(value) {
    this.uniforms.get("scrollSpeed").value = value;
    if (value === 0) {
      if (this.defines.delete("SCROLL")) {
        this.setChanged();
      }
    } else if (!this.defines.has("SCROLL")) {
      this.defines.set("SCROLL", "1");
      this.setChanged();
    }
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.resolution.set(width, height);
    this.uniforms.get("count").value = Math.round(height * this.density);
  }
};

// src/effects/ShockWaveEffect.js
var import_three49 = __webpack_require__(39437);

// src/effects/glsl/shock-wave.frag
var shock_wave_default = "uniform bool active;uniform vec2 center;uniform float waveSize;uniform float radius;uniform float maxRadius;uniform float amplitude;varying float vSize;void mainUv(inout vec2 uv){if(active){vec2 aspectCorrection=vec2(aspect,1.0);vec2 difference=uv*aspectCorrection-center*aspectCorrection;float distance=sqrt(dot(difference,difference))*vSize;if(distance>radius){if(distance<radius+waveSize){float angle=(distance-radius)*PI2/waveSize;float cosSin=(1.0-cos(angle))*0.5;float extent=maxRadius+waveSize;float decay=max(extent-distance*distance,0.0)/extent;uv-=((cosSin*amplitude*difference)/distance)*decay;}}}}";

// src/effects/glsl/shock-wave.vert
var shock_wave_default2 = "uniform float size;uniform float cameraDistance;varying float vSize;void mainSupport(){vSize=(0.1*cameraDistance)/size;}";

// src/effects/ShockWaveEffect.js
var HALF_PI = Math.PI * 0.5;
var v2 = /* @__PURE__ */ new import_three49.Vector3();
var ab = /* @__PURE__ */ new import_three49.Vector3();
var ShockWaveEffect = class extends Effect {
  /**
   * Constructs a new shock wave effect.
   *
   * @param {Camera} camera - The main camera.
   * @param {Vector3} [position] - The world position of the shock wave.
   * @param {Object} [options] - The options.
   * @param {Number} [options.speed=2.0] - The animation speed.
   * @param {Number} [options.maxRadius=1.0] - The extent of the shock wave.
   * @param {Number} [options.waveSize=0.2] - The wave size.
   * @param {Number} [options.amplitude=0.05] - The distortion amplitude.
   */
  constructor(camera, position = new import_three49.Vector3(), {
    speed = 2,
    maxRadius = 1,
    waveSize = 0.2,
    amplitude = 0.05
  } = {}) {
    super("ShockWaveEffect", shock_wave_default, {
      vertexShader: shock_wave_default2,
      uniforms: /* @__PURE__ */ new Map([
        ["active", new import_three49.Uniform(false)],
        ["center", new import_three49.Uniform(new import_three49.Vector2(0.5, 0.5))],
        ["cameraDistance", new import_three49.Uniform(1)],
        ["size", new import_three49.Uniform(1)],
        ["radius", new import_three49.Uniform(-waveSize)],
        ["maxRadius", new import_three49.Uniform(maxRadius)],
        ["waveSize", new import_three49.Uniform(waveSize)],
        ["amplitude", new import_three49.Uniform(amplitude)]
      ])
    });
    this.position = position;
    this.speed = speed;
    this.camera = camera;
    this.screenPosition = this.uniforms.get("center").value;
    this.time = 0;
    this.active = false;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  /**
   * The amplitude.
   *
   * @type {Number}
   */
  get amplitude() {
    return this.uniforms.get("amplitude").value;
  }
  set amplitude(value) {
    this.uniforms.get("amplitude").value = value;
  }
  /**
   * The wave size.
   *
   * @type {Number}
   */
  get waveSize() {
    return this.uniforms.get("waveSize").value;
  }
  set waveSize(value) {
    this.uniforms.get("waveSize").value = value;
  }
  /**
   * The maximum radius.
   *
   * @type {Number}
   */
  get maxRadius() {
    return this.uniforms.get("maxRadius").value;
  }
  set maxRadius(value) {
    this.uniforms.get("maxRadius").value = value;
  }
  /**
   * The position of the shock wave.
   *
   * @type {Vector3}
   * @deprecated Use position instead.
   */
  get epicenter() {
    return this.position;
  }
  set epicenter(value) {
    this.position = value;
  }
  /**
   * Returns the position of the shock wave.
   *
   * @deprecated Use position instead.
   * @return {Vector3} The position.
   */
  getPosition() {
    return this.position;
  }
  /**
   * Sets the position of the shock wave.
   *
   * @deprecated Use position instead.
   * @param {Vector3} value - The position.
   */
  setPosition(value) {
    this.position = value;
  }
  /**
   * Returns the speed of the shock wave.
   *
   * @deprecated Use speed instead.
   * @return {Number} The speed.
   */
  getSpeed() {
    return this.speed;
  }
  /**
   * Sets the speed of the shock wave.
   *
   * @deprecated Use speed instead.
   * @param {Number} value - The speed.
   */
  setSpeed(value) {
    this.speed = value;
  }
  /**
   * Emits the shock wave.
   */
  explode() {
    this.time = 0;
    this.active = true;
    this.uniforms.get("active").value = true;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [delta] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, delta) {
    const position = this.position;
    const camera = this.camera;
    const uniforms = this.uniforms;
    const uActive = uniforms.get("active");
    if (this.active) {
      const waveSize = uniforms.get("waveSize").value;
      camera.getWorldDirection(v2);
      ab.copy(camera.position).sub(position);
      uActive.value = v2.angleTo(ab) > HALF_PI;
      if (uActive.value) {
        uniforms.get("cameraDistance").value = camera.position.distanceTo(position);
        v2.copy(position).project(camera);
        this.screenPosition.set((v2.x + 1) * 0.5, (v2.y + 1) * 0.5);
      }
      this.time += delta * this.speed;
      const radius = this.time - waveSize;
      uniforms.get("radius").value = radius;
      if (radius >= (uniforms.get("maxRadius").value + waveSize) * 2) {
        this.active = false;
        uActive.value = false;
      }
    }
  }
};

// src/effects/SelectiveBloomEffect.js
var import_three50 = __webpack_require__(39437);
var SelectiveBloomEffect = class extends BloomEffect {
  /**
   * Constructs a new selective bloom effect.
   *
   * @param {Scene} scene - The main scene.
   * @param {Camera} camera - The main camera.
   * @param {Object} [options] - The options. See {@link BloomEffect} for details.
   */
  constructor(scene, camera, options) {
    super(options);
    this.setAttributes(this.getAttributes() | EffectAttribute.DEPTH);
    this.camera = camera;
    this.depthPass = new DepthPass(scene, camera);
    this.clearPass = new ClearPass(true, false, false);
    this.clearPass.overrideClearColor = new import_three50.Color(0);
    this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());
    const depthMaskMaterial = this.depthMaskMaterial;
    depthMaskMaterial.copyCameraSettings(camera);
    depthMaskMaterial.depthBuffer1 = this.depthPass.texture;
    depthMaskMaterial.depthPacking1 = import_three50.RGBADepthPacking;
    depthMaskMaterial.depthMode = import_three50.EqualDepth;
    this.renderTargetMasked = new import_three50.WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetMasked.texture.name = "Bloom.Masked";
    this.selection = new Selection();
    this.selection.layer = 11;
    this._inverted = false;
    this._ignoreBackground = false;
  }
  set mainScene(value) {
    this.depthPass.mainScene = value;
  }
  set mainCamera(value) {
    this.camera = value;
    this.depthPass.mainCamera = value;
    this.depthMaskMaterial.copyCameraSettings(value);
  }
  /**
   * Returns the selection.
   *
   * @deprecated Use selection instead.
   * @return {Selection} The selection.
   */
  getSelection() {
    return this.selection;
  }
  /**
   * The depth mask material.
   *
   * @type {DepthMaskMaterial}
   * @private
   */
  get depthMaskMaterial() {
    return this.depthMaskPass.fullscreenMaterial;
  }
  /**
   * Indicates whether the selection should be considered inverted.
   *
   * @type {Boolean}
   */
  get inverted() {
    return this._inverted;
  }
  set inverted(value) {
    this._inverted = value;
    this.depthMaskMaterial.depthMode = value ? import_three50.NotEqualDepth : import_three50.EqualDepth;
  }
  /**
   * Indicates whether the mask is inverted.
   *
   * @deprecated Use inverted instead.
   * @return {Boolean} Whether the mask is inverted.
   */
  isInverted() {
    return this.inverted;
  }
  /**
   * Enables or disable mask inversion.
   *
   * @deprecated Use inverted instead.
   * @param {Boolean} value - Whether the mask should be inverted.
   */
  setInverted(value) {
    this.inverted = value;
  }
  /**
   * Indicates whether the background colors will be ignored.
   *
   * @type {Boolean}
   */
  get ignoreBackground() {
    return this._ignoreBackground;
  }
  set ignoreBackground(value) {
    this._ignoreBackground = value;
    this.depthMaskMaterial.maxDepthStrategy = value ? DepthTestStrategy.DISCARD_MAX_DEPTH : DepthTestStrategy.KEEP_MAX_DEPTH;
  }
  /**
   * Indicates whether the background is disabled.
   *
   * @deprecated Use ignoreBackground instead.
   * @return {Boolean} Whether the background is disabled.
   */
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  /**
   * Enables or disables the background.
   *
   * @deprecated Use ignoreBackground instead.
   * @param {Boolean} value - Whether the background should be disabled.
   */
  setBackgroundDisabled(value) {
    this.ignoreBackground = value;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = import_three50.BasicDepthPacking) {
    this.depthMaskMaterial.depthBuffer0 = depthTexture;
    this.depthMaskMaterial.depthPacking0 = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const camera = this.camera;
    const selection = this.selection;
    const inverted = this.inverted;
    let renderTarget = inputBuffer;
    if (this.ignoreBackground || !inverted || selection.size > 0) {
      const mask = camera.layers.mask;
      camera.layers.set(selection.layer);
      this.depthPass.render(renderer);
      camera.layers.mask = mask;
      renderTarget = this.renderTargetMasked;
      this.clearPass.render(renderer, renderTarget);
      this.depthMaskPass.render(renderer, inputBuffer, renderTarget);
    }
    super.update(renderer, renderTarget, deltaTime);
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    super.setSize(width, height);
    this.renderTargetMasked.setSize(width, height);
    this.depthPass.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    super.initialize(renderer, alpha, frameBufferType);
    this.clearPass.initialize(renderer, alpha, frameBufferType);
    this.depthPass.initialize(renderer, alpha, frameBufferType);
    this.depthMaskPass.initialize(renderer, alpha, frameBufferType);
    if (renderer !== null && renderer.capabilities.logarithmicDepthBuffer) {
      this.depthMaskPass.fullscreenMaterial.defines.LOG_DEPTH = "1";
    }
    if (frameBufferType !== void 0) {
      this.renderTargetMasked.texture.type = frameBufferType;
      if (renderer !== null && renderer.outputColorSpace === import_three50.SRGBColorSpace) {
        this.renderTargetMasked.texture.colorSpace = import_three50.SRGBColorSpace;
      }
    }
  }
};

// src/effects/SepiaEffect.js
var import_three51 = __webpack_require__(39437);

// src/effects/glsl/sepia.frag
var sepia_default = "uniform vec3 weightsR;uniform vec3 weightsG;uniform vec3 weightsB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,weightsR),dot(inputColor.rgb,weightsG),dot(inputColor.rgb,weightsB));outputColor=vec4(color,inputColor.a);}";

// src/effects/SepiaEffect.js
var SepiaEffect = class extends Effect {
  /**
   * Constructs a new sepia effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
   * @param {Number} [options.intensity=1.0] - The intensity of the effect.
   */
  constructor({ blendFunction, intensity = 1 } = {}) {
    super("SepiaEffect", sepia_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["weightsR", new import_three51.Uniform(new import_three51.Vector3(0.393, 0.769, 0.189))],
        ["weightsG", new import_three51.Uniform(new import_three51.Vector3(0.349, 0.686, 0.168))],
        ["weightsB", new import_three51.Uniform(new import_three51.Vector3(0.272, 0.534, 0.131))]
      ])
    });
  }
  /**
   * The intensity.
   *
   * @deprecated Use blendMode.opacity instead.
   * @type {Number}
   */
  get intensity() {
    return this.blendMode.opacity.value;
  }
  set intensity(value) {
    this.blendMode.opacity.value = value;
  }
  /**
   * Returns the current sepia intensity.
   *
   * @deprecated Use blendMode.opacity instead.
   * @return {Number} The intensity.
   */
  getIntensity() {
    return this.intensity;
  }
  /**
   * Sets the sepia intensity.
   *
   * @deprecated Use blendMode.opacity instead.
   * @param {Number} value - The intensity.
   */
  setIntensity(value) {
    this.intensity = value;
  }
  /**
   * The weights for the red channel. Default is `(0.393, 0.769, 0.189)`.
   *
   * @type {Vector3}
   */
  get weightsR() {
    return this.uniforms.get("weightsR").value;
  }
  /**
   * The weights for the green channel. Default is `(0.349, 0.686, 0.168)`.
   *
   * @type {Vector3}
   */
  get weightsG() {
    return this.uniforms.get("weightsG").value;
  }
  /**
   * The weights for the blue channel. Default is `(0.272, 0.534, 0.131)`.
   *
   * @type {Vector3}
   */
  get weightsB() {
    return this.uniforms.get("weightsB").value;
  }
};

// src/effects/SMAAEffect.js
var import_three54 = __webpack_require__(39437);

// src/materials/EdgeDetectionMaterial.js
var import_three52 = __webpack_require__(39437);

// src/materials/glsl/edge-detection.frag
var edge_detection_default = "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}";

// src/materials/glsl/edge-detection.vert
var edge_detection_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/EdgeDetectionMaterial.js
var EdgeDetectionMaterial = class extends import_three52.ShaderMaterial {
  /**
   * Constructs a new edge detection material.
   *
   * TODO Remove parameters.
   * @param {Vector2} [texelSize] - The screen texel size.
   * @param {EdgeDetectionMode} [mode=EdgeDetectionMode.COLOR] - The edge detection mode.
   */
  constructor(texelSize = new import_three52.Vector2(), mode = EdgeDetectionMode.COLOR) {
    super({
      name: "EdgeDetectionMaterial",
      defines: {
        THREE_REVISION: import_three52.REVISION.replace(/\D+/g, ""),
        LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
        EDGE_THRESHOLD: "0.1",
        DEPTH_THRESHOLD: "0.01",
        PREDICATION_MODE: "0",
        PREDICATION_THRESHOLD: "0.01",
        PREDICATION_SCALE: "2.0",
        PREDICATION_STRENGTH: "1.0",
        DEPTH_PACKING: "0"
      },
      uniforms: {
        inputBuffer: new import_three52.Uniform(null),
        depthBuffer: new import_three52.Uniform(null),
        predicationBuffer: new import_three52.Uniform(null),
        texelSize: new import_three52.Uniform(texelSize)
      },
      blending: import_three52.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: edge_detection_default,
      vertexShader: edge_detection_default2
    });
    this.edgeDetectionMode = mode;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = import_three52.BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * The edge detection mode.
   *
   * @type {EdgeDetectionMode}
   */
  get edgeDetectionMode() {
    return Number(this.defines.EDGE_DETECTION_MODE);
  }
  set edgeDetectionMode(value) {
    this.defines.EDGE_DETECTION_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the edge detection mode.
   *
   * @deprecated Use edgeDetectionMode instead.
   * @return {EdgeDetectionMode} The mode.
   */
  getEdgeDetectionMode() {
    return this.edgeDetectionMode;
  }
  /**
   * Sets the edge detection mode.
   *
   * @deprecated Use edgeDetectionMode instead.
   * @param {EdgeDetectionMode} value - The edge detection mode.
   */
  setEdgeDetectionMode(value) {
    this.edgeDetectionMode = value;
  }
  /**
   * The local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH. Default is 2.0.
   *
   * If a neighbor edge has _factor_ times bigger contrast than the current edge, the edge will be discarded.
   *
   * This allows to eliminate spurious crossing edges and is based on the fact that if there is too much contrast in a
   * direction, the perceptual contrast in the other neighbors will be hidden.
   *
   * @type {Number}
   */
  get localContrastAdaptationFactor() {
    return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
  }
  set localContrastAdaptationFactor(value) {
    this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the local contrast adaptation factor.
   *
   * @deprecated Use localContrastAdaptationFactor instead.
   * @return {Number} The factor.
   */
  getLocalContrastAdaptationFactor() {
    return this.localContrastAdaptationFactor;
  }
  /**
   * Sets the local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH.
   *
   * @deprecated Use localContrastAdaptationFactor instead.
   * @param {Number} value - The local contrast adaptation factor. Default is 2.0.
   */
  setLocalContrastAdaptationFactor(value) {
    this.localContrastAdaptationFactor = value;
  }
  /**
   * The edge detection threshold. Range: [0.0, 0.5].
   *
   * A lower value results in more edges being detected at the expense of performance.
   *
   * For luma- and chroma-based edge detection, 0.1 is a reasonable value and allows to catch most visible edges. 0.05
   * is a rather overkill value that allows to catch 'em all. Darker scenes may require an even lower threshold.
   *
   * If depth-based edge detection is used, the threshold will depend on the scene depth.
   *
   * @type {Number}
   */
  get edgeDetectionThreshold() {
    return Number(this.defines.EDGE_THRESHOLD);
  }
  set edgeDetectionThreshold(value) {
    this.defines.EDGE_THRESHOLD = value.toFixed("6");
    this.defines.DEPTH_THRESHOLD = (value * 0.1).toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the edge detection threshold.
   *
   * @deprecated Use edgeDetectionThreshold instead.
   * @return {Number} The threshold.
   */
  getEdgeDetectionThreshold() {
    return this.edgeDetectionThreshold;
  }
  /**
   * Sets the edge detection threshold.
   *
   * @deprecated Use edgeDetectionThreshold instead.
   * @param {Number} value - The edge detection threshold. Range: [0.0, 0.5].
   */
  setEdgeDetectionThreshold(value) {
    this.edgeDetectionThreshold = value;
  }
  /**
   * The predication mode.
   *
   * Predicated thresholding allows to better preserve texture details and to improve edge detection using an additional
   * buffer such as a light accumulation or depth buffer.
   *
   * @type {PredicationMode}
   */
  get predicationMode() {
    return Number(this.defines.PREDICATION_MODE);
  }
  set predicationMode(value) {
    this.defines.PREDICATION_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the predication mode.
   *
   * @deprecated Use predicationMode instead.
   * @return {PredicationMode} The mode.
   */
  getPredicationMode() {
    return this.predicationMode;
  }
  /**
   * Sets the predication mode.
   *
   * @deprecated Use predicationMode instead.
   * @param {PredicationMode} value - The predication mode.
   */
  setPredicationMode(value) {
    this.predicationMode = value;
  }
  /**
   * The predication buffer.
   *
   * @type {Texture}
   */
  set predicationBuffer(value) {
    this.uniforms.predicationBuffer.value = value;
  }
  /**
   * Sets a custom predication buffer.
   *
   * @deprecated Use predicationBuffer instead.
   * @param {Texture} value - The predication buffer.
   */
  setPredicationBuffer(value) {
    this.uniforms.predicationBuffer.value = value;
  }
  /**
   * The predication threshold.
   *
   * @type {Number}
   */
  get predicationThreshold() {
    return Number(this.defines.PREDICATION_THRESHOLD);
  }
  set predicationThreshold(value) {
    this.defines.PREDICATION_THRESHOLD = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication threshold.
   *
   * @deprecated Use predicationThreshold instead.
   * @return {Number} The threshold.
   */
  getPredicationThreshold() {
    return this.predicationThreshold;
  }
  /**
   * Sets the predication threshold.
   *
   * @deprecated Use predicationThreshold instead.
   * @param {Number} value - The threshold.
   */
  setPredicationThreshold(value) {
    this.predicationThreshold = value;
  }
  /**
   * The predication scale. Range: [1.0, 5.0].
   *
   * Determines how much the edge detection threshold should be scaled when using predication.
   *
   * @type {Boolean|Texture|Number}
   */
  get predicationScale() {
    return Number(this.defines.PREDICATION_SCALE);
  }
  set predicationScale(value) {
    this.defines.PREDICATION_SCALE = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication scale.
   *
   * @deprecated Use predicationScale instead.
   * @return {Number} The scale.
   */
  getPredicationScale() {
    return this.predicationScale;
  }
  /**
   * Sets the predication scale.
   *
   * @deprecated Use predicationScale instead.
   * @param {Number} value - The scale. Range: [1.0, 5.0].
   */
  setPredicationScale(value) {
    this.predicationScale = value;
  }
  /**
   * The predication strength. Range: [0.0, 1.0].
   *
   * Determines how much the edge detection threshold should be decreased locally when using predication.
   *
   * @type {Number}
   */
  get predicationStrength() {
    return Number(this.defines.PREDICATION_STRENGTH);
  }
  set predicationStrength(value) {
    this.defines.PREDICATION_STRENGTH = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication strength.
   *
   * @deprecated Use predicationStrength instead.
   * @return {Number} The strength.
   */
  getPredicationStrength() {
    return this.predicationStrength;
  }
  /**
   * Sets the predication strength.
   *
   * @deprecated Use predicationStrength instead.
   * @param {Number} value - The strength. Range: [0.0, 1.0].
   */
  setPredicationStrength(value) {
    this.predicationStrength = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/materials/SMAAWeightsMaterial.js
var import_three53 = __webpack_require__(39437);

// src/materials/glsl/smaa-weights.frag
var smaa_weights_default = "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}";

// src/materials/glsl/smaa-weights.vert
var smaa_weights_default2 = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/SMAAWeightsMaterial.js
var SMAAWeightsMaterial = class extends import_three53.ShaderMaterial {
  /**
   * Constructs a new SMAA weights material.
   *
   * @param {Vector2} [texelSize] - The absolute screen texel size.
   * @param {Vector2} [resolution] - The resolution.
   */
  constructor(texelSize = new import_three53.Vector2(), resolution = new import_three53.Vector2()) {
    super({
      name: "SMAAWeightsMaterial",
      defines: {
        // Configurable settings:
        MAX_SEARCH_STEPS_INT: "16",
        MAX_SEARCH_STEPS_FLOAT: "16.0",
        MAX_SEARCH_STEPS_DIAG_INT: "8",
        MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
        CORNER_ROUNDING: "25",
        CORNER_ROUNDING_NORM: "0.25",
        // Non-configurable settings:
        AREATEX_MAX_DISTANCE: "16.0",
        AREATEX_MAX_DISTANCE_DIAG: "20.0",
        AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
        AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
        SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
        SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
      },
      uniforms: {
        inputBuffer: new import_three53.Uniform(null),
        searchTexture: new import_three53.Uniform(null),
        areaTexture: new import_three53.Uniform(null),
        resolution: new import_three53.Uniform(resolution),
        texelSize: new import_three53.Uniform(texelSize)
      },
      blending: import_three53.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: smaa_weights_default,
      vertexShader: smaa_weights_default2
    });
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The search lookup texture.
   *
   * @type {Texture}
   */
  get searchTexture() {
    return this.uniforms.searchTexture.value;
  }
  set searchTexture(value) {
    this.uniforms.searchTexture.value = value;
  }
  /**
   * The area lookup texture.
   *
   * @type {Texture}
   */
  get areaTexture() {
    return this.uniforms.areaTexture.value;
  }
  set areaTexture(value) {
    this.uniforms.areaTexture.value = value;
  }
  /**
   * Sets the search and area lookup textures.
   *
   * @deprecated Use searchTexture and areaTexture instead.
   * @param {Texture} search - The search lookup texture.
   * @param {Texture} area - The area lookup texture.
   */
  setLookupTextures(search, area2) {
    this.searchTexture = search;
    this.areaTexture = area2;
  }
  /**
   * The maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.
   * Range: [0, 112].
   *
   * In number of pixels, it's actually the double. So the maximum line length perfectly handled by, for example 16, is
   * 64 (perfectly means that longer lines won't look as good, but are still antialiased).
   *
   * @type {Number}
   */
  get orthogonalSearchSteps() {
    return Number(this.defines.MAX_SEARCH_STEPS_INT);
  }
  set orthogonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 112);
    this.defines.MAX_SEARCH_STEPS_INT = s.toFixed("0");
    this.defines.MAX_SEARCH_STEPS_FLOAT = s.toFixed("1");
    this.needsUpdate = true;
  }
  /**
   * Sets the maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.
   *
   * @deprecated Use orthogonalSearchSteps instead.
   * @param {Number} value - The search steps. Range: [0, 112].
   */
  setOrthogonalSearchSteps(value) {
    this.orthogonalSearchSteps = value;
  }
  /**
   * The maximum steps performed in the diagonal pattern searches, at each side of the pixel. This search
   * jumps one pixel at a time. Range: [0, 20].
   *
   * On high-end machines this search is cheap (between 0.8x and 0.9x slower for 16 steps), but it can have a
   * significant impact on older machines.
   *
   * @type {Number}
   */
  get diagonalSearchSteps() {
    return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);
  }
  set diagonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 20);
    this.defines.MAX_SEARCH_STEPS_DIAG_INT = s.toFixed("0");
    this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = s.toFixed("1");
    this.needsUpdate = true;
  }
  /**
   * Specifies the maximum steps performed in the diagonal pattern searches, at each side of the pixel.
   *
   * @deprecated Use diagonalSearchSteps instead.
   * @param {Number} value - The search steps. Range: [0, 20].
   */
  setDiagonalSearchSteps(value) {
    this.diagonalSearchSteps = value;
  }
  /**
   * Indicates whether diagonal pattern detection is enabled.
   *
   * @type {Boolean}
   */
  get diagonalDetection() {
    return this.defines.DISABLE_DIAG_DETECTION === void 0;
  }
  set diagonalDetection(value) {
    if (value) {
      delete this.defines.DISABLE_DIAG_DETECTION;
    } else {
      this.defines.DISABLE_DIAG_DETECTION = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether diagonal pattern detection is enabled.
   *
   * @deprecated Use diagonalDetection instead.
   * @return {Boolean} Whether diagonal pattern detection is enabled.
   */
  isDiagonalDetectionEnabled() {
    return this.diagonalDetection;
  }
  /**
   * Enables or disables diagonal pattern detection.
   *
   * @deprecated Use diagonalDetection instead.
   * @param {Boolean} value - Whether diagonal pattern detection should be enabled.
   */
  setDiagonalDetectionEnabled(value) {
    this.diagonalDetection = value;
  }
  /**
   * Specifies how much sharp corners will be rounded. Range: [0, 100].
   *
   * @type {Number}
   */
  get cornerRounding() {
    return Number(this.defines.CORNER_ROUNDING);
  }
  set cornerRounding(value) {
    const r = Math.min(Math.max(value, 0), 100);
    this.defines.CORNER_ROUNDING = r.toFixed("4");
    this.defines.CORNER_ROUNDING_NORM = (r / 100).toFixed("4");
    this.needsUpdate = true;
  }
  /**
   * Specifies how much sharp corners will be rounded.
   *
   * @deprecated Use cornerRounding instead.
   * @param {Number} value - The corner rounding amount. Range: [0, 100].
   */
  setCornerRounding(value) {
    this.cornerRounding = value;
  }
  /**
   * Indicates whether corner detection is enabled.
   *
   * @type {Number}
   */
  get cornerDetection() {
    return this.defines.DISABLE_CORNER_DETECTION === void 0;
  }
  set cornerDetection(value) {
    if (value) {
      delete this.defines.DISABLE_CORNER_DETECTION;
    } else {
      this.defines.DISABLE_CORNER_DETECTION = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether corner rounding is enabled.
   *
   * @deprecated Use cornerDetection instead.
   * @return {Boolean} Whether corner rounding is enabled.
   */
  isCornerRoundingEnabled() {
    return this.cornerDetection;
  }
  /**
   * Enables or disables corner rounding.
   *
   * @deprecated Use cornerDetection instead.
   * @param {Boolean} value - Whether corner rounding should be enabled.
   */
  setCornerRoundingEnabled(value) {
    this.cornerDetection = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    uniforms.texelSize.value.set(1 / width, 1 / height);
    uniforms.resolution.value.set(width, height);
  }
};

// src/textures/smaa/searchImageDataURL.js
var searchImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC";

// src/textures/smaa/areaImageDataURL.js
var areaImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC";

// src/effects/glsl/smaa.frag
var smaa_default = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}";

// src/effects/glsl/smaa.vert
var smaa_default2 = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}";

// src/effects/SMAAEffect.js
var SMAAEffect = class extends Effect {
  /**
   * Constructs a new SMAA effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {SMAAPreset} [options.preset=SMAAPreset.MEDIUM] - The quality preset.
   * @param {EdgeDetectionMode} [options.edgeDetectionMode=EdgeDetectionMode.COLOR] - The edge detection mode.
   * @param {PredicationMode} [options.predicationMode=PredicationMode.DISABLED] - The predication mode.
   */
  constructor({
    blendFunction = BlendFunction.SRC,
    preset = SMAAPreset.MEDIUM,
    edgeDetectionMode = EdgeDetectionMode.COLOR,
    predicationMode = PredicationMode.DISABLED
  } = {}) {
    super("SMAAEffect", smaa_default, {
      vertexShader: smaa_default2,
      blendFunction,
      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["weightMap", new import_three54.Uniform(null)]
      ])
    });
    let searchImage, areaImage;
    if (arguments.length > 1) {
      searchImage = arguments[0];
      areaImage = arguments[1];
      if (arguments.length > 2) {
        preset = arguments[2];
      }
      if (arguments.length > 3) {
        edgeDetectionMode = arguments[3];
      }
    }
    this.renderTargetEdges = new import_three54.WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetEdges.texture.name = "SMAA.Edges";
    this.renderTargetWeights = this.renderTargetEdges.clone();
    this.renderTargetWeights.texture.name = "SMAA.Weights";
    this.uniforms.get("weightMap").value = this.renderTargetWeights.texture;
    this.clearPass = new ClearPass(true, false, false);
    this.clearPass.overrideClearColor = new import_three54.Color(0);
    this.clearPass.overrideClearAlpha = 1;
    this.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial());
    this.edgeDetectionMaterial.edgeDetectionMode = edgeDetectionMode;
    this.edgeDetectionMaterial.predicationMode = predicationMode;
    this.weightsPass = new ShaderPass(new SMAAWeightsMaterial());
    const loadingManager = new import_three54.LoadingManager();
    loadingManager.onLoad = () => {
      const searchTexture = new import_three54.Texture(searchImage);
      searchTexture.name = "SMAA.Search";
      searchTexture.magFilter = import_three54.NearestFilter;
      searchTexture.minFilter = import_three54.NearestFilter;
      searchTexture.generateMipmaps = false;
      searchTexture.needsUpdate = true;
      searchTexture.flipY = true;
      this.weightsMaterial.searchTexture = searchTexture;
      const areaTexture = new import_three54.Texture(areaImage);
      areaTexture.name = "SMAA.Area";
      areaTexture.magFilter = import_three54.LinearFilter;
      areaTexture.minFilter = import_three54.LinearFilter;
      areaTexture.generateMipmaps = false;
      areaTexture.needsUpdate = true;
      areaTexture.flipY = false;
      this.weightsMaterial.areaTexture = areaTexture;
      this.dispatchEvent({ type: "load" });
    };
    loadingManager.itemStart("search");
    loadingManager.itemStart("area");
    if (searchImage !== void 0 && areaImage !== void 0) {
      loadingManager.itemEnd("search");
      loadingManager.itemEnd("area");
    } else if (typeof Image !== "undefined") {
      searchImage = new Image();
      areaImage = new Image();
      searchImage.addEventListener("load", () => loadingManager.itemEnd("search"));
      areaImage.addEventListener("load", () => loadingManager.itemEnd("area"));
      searchImage.src = searchImageDataURL_default;
      areaImage.src = areaImageDataURL_default;
    }
    this.applyPreset(preset);
  }
  /**
   * The edges texture.
   *
   * @type {Texture}
   */
  get edgesTexture() {
    return this.renderTargetEdges.texture;
  }
  /**
   * Returns the edges texture.
   *
   * @deprecated Use edgesTexture instead.
   * @return {Texture} The texture.
   */
  getEdgesTexture() {
    return this.edgesTexture;
  }
  /**
   * The edge weights texture.
   *
   * @type {Texture}
   */
  get weightsTexture() {
    return this.renderTargetWeights.texture;
  }
  /**
   * Returns the edge weights texture.
   *
   * @deprecated Use weightsTexture instead.
   * @return {Texture} The texture.
   */
  getWeightsTexture() {
    return this.weightsTexture;
  }
  /**
   * The edge detection material.
   *
   * @type {EdgeDetectionMaterial}
   */
  get edgeDetectionMaterial() {
    return this.edgeDetectionPass.fullscreenMaterial;
  }
  /**
   * The edge detection material.
   *
   * @type {EdgeDetectionMaterial}
   * @deprecated Use edgeDetectionMaterial instead.
   */
  get colorEdgesMaterial() {
    return this.edgeDetectionMaterial;
  }
  /**
   * Returns the edge detection material.
   *
   * @deprecated Use edgeDetectionMaterial instead.
   * @return {EdgeDetectionMaterial} The material.
   */
  getEdgeDetectionMaterial() {
    return this.edgeDetectionMaterial;
  }
  /**
   * The edge weights material.
   *
   * @type {SMAAWeightsMaterial}
   */
  get weightsMaterial() {
    return this.weightsPass.fullscreenMaterial;
  }
  /**
   * Returns the edge weights material.
   *
   * @deprecated Use weightsMaterial instead.
   * @return {SMAAWeightsMaterial} The material.
   */
  getWeightsMaterial() {
    return this.weightsMaterial;
  }
  /**
   * Sets the edge detection sensitivity.
   *
   * See {@link EdgeDetectionMaterial#setEdgeDetectionThreshold} for more details.
   *
   * @deprecated Use edgeDetectionMaterial instead.
   * @param {Number} threshold - The edge detection sensitivity. Range: [0.05, 0.5].
   */
  setEdgeDetectionThreshold(threshold) {
    this.edgeDetectionMaterial.edgeDetectionThreshold = threshold;
  }
  /**
   * Sets the maximum amount of horizontal/vertical search steps.
   *
   * See {@link SMAAWeightsMaterial#setOrthogonalSearchSteps} for more details.
   *
   * @deprecated Use weightsMaterial instead.
   * @param {Number} steps - The search steps. Range: [0, 112].
   */
  setOrthogonalSearchSteps(steps) {
    this.weightsMaterial.orthogonalSearchSteps = steps;
  }
  /**
   * Applies the given quality preset.
   *
   * @param {SMAAPreset} preset - The preset.
   */
  applyPreset(preset) {
    const edgeDetectionMaterial = this.edgeDetectionMaterial;
    const weightsMaterial = this.weightsMaterial;
    switch (preset) {
      case SMAAPreset.LOW:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.15;
        weightsMaterial.orthogonalSearchSteps = 4;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case SMAAPreset.MEDIUM:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;
        weightsMaterial.orthogonalSearchSteps = 8;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case SMAAPreset.HIGH:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;
        weightsMaterial.orthogonalSearchSteps = 16;
        weightsMaterial.diagonalSearchSteps = 8;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
      case SMAAPreset.ULTRA:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.05;
        weightsMaterial.orthogonalSearchSteps = 32;
        weightsMaterial.diagonalSearchSteps = 16;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
    }
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = import_three54.BasicDepthPacking) {
    this.edgeDetectionMaterial.depthBuffer = depthTexture;
    this.edgeDetectionMaterial.depthPacking = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    this.clearPass.render(renderer, this.renderTargetEdges);
    this.edgeDetectionPass.render(renderer, inputBuffer, this.renderTargetEdges);
    this.weightsPass.render(renderer, this.renderTargetEdges, this.renderTargetWeights);
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.edgeDetectionMaterial.setSize(width, height);
    this.weightsMaterial.setSize(width, height);
    this.renderTargetEdges.setSize(width, height);
    this.renderTargetWeights.setSize(width, height);
  }
  /**
   * Deletes internal render targets and textures.
   */
  dispose() {
    const { searchTexture, areaTexture } = this.weightsMaterial;
    if (searchTexture !== null && areaTexture !== null) {
      searchTexture.dispose();
      areaTexture.dispose();
    }
    super.dispose();
  }
  /**
   * The SMAA search image, encoded as a base64 data URL.
   *
   * @type {String}
   * @deprecated
   */
  static get searchImageDataURL() {
    return searchImageDataURL_default;
  }
  /**
   * The SMAA area image, encoded as a base64 data URL.
   *
   * @type {String}
   * @deprecated
   */
  static get areaImageDataURL() {
    return areaImageDataURL_default;
  }
};

// src/effects/SSAOEffect.js
var import_three58 = __webpack_require__(39437);

// src/materials/SSAOMaterial.js
var import_three55 = __webpack_require__(39437);

// src/materials/glsl/ssao.frag
var ssao_default = "#include <common>\n#include <packing>\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\nuniform lowp sampler2D normalBuffer;\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nuniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearSampleDepth=sampleDepth;\n#endif\nfloat proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){\n#ifdef NORMAL_DEPTH\nvec4 normalDepth=texture2D(normalDepthBuffer,vUv);\n#else\nvec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));\n#endif\nfloat ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearDepth=depth;\n#endif\nif(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);\n#ifdef LEGACY_INTENSITY\nao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);\n#endif\n}gl_FragColor.r=ao;}";

// src/materials/glsl/ssao.vert
var ssao_default2 = "uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/SSAOMaterial.js
var SSAOMaterial = class extends import_three55.ShaderMaterial {
  /**
   * Constructs a new SSAO material.
   *
   * @param {Camera} camera - A camera.
   */
  constructor(camera) {
    super({
      name: "SSAOMaterial",
      defines: {
        SAMPLES_INT: "0",
        INV_SAMPLES_FLOAT: "0.0",
        SPIRAL_TURNS: "0.0",
        RADIUS: "1.0",
        RADIUS_SQ: "1.0",
        DISTANCE_SCALING: "1",
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new import_three55.Uniform(null),
        normalBuffer: new import_three55.Uniform(null),
        normalDepthBuffer: new import_three55.Uniform(null),
        noiseTexture: new import_three55.Uniform(null),
        inverseProjectionMatrix: new import_three55.Uniform(new import_three55.Matrix4()),
        projectionMatrix: new import_three55.Uniform(new import_three55.Matrix4()),
        texelSize: new import_three55.Uniform(new import_three55.Vector2()),
        cameraNearFar: new import_three55.Uniform(new import_three55.Vector2()),
        distanceCutoff: new import_three55.Uniform(new import_three55.Vector2()),
        proximityCutoff: new import_three55.Uniform(new import_three55.Vector2()),
        noiseScale: new import_three55.Uniform(new import_three55.Vector2()),
        minRadiusScale: new import_three55.Uniform(0.33),
        intensity: new import_three55.Uniform(1),
        fade: new import_three55.Uniform(0.01),
        bias: new import_three55.Uniform(0)
      },
      blending: import_three55.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: ssao_default,
      vertexShader: ssao_default2
    });
    this.copyCameraSettings(camera);
    this.resolution = new import_three55.Vector2();
    this.r = 1;
  }
  /**
   * The current near plane setting.
   *
   * @type {Number}
   * @private
   */
  get near() {
    return this.uniforms.cameraNearFar.value.x;
  }
  /**
   * The current far plane setting.
   *
   * @type {Number}
   * @private
   */
  get far() {
    return this.uniforms.cameraNearFar.value.y;
  }
  /**
   * A combined normal-depth buffer.
   *
   * @type {Texture}
   */
  set normalDepthBuffer(value) {
    this.uniforms.normalDepthBuffer.value = value;
    if (value !== null) {
      this.defines.NORMAL_DEPTH = "1";
    } else {
      delete this.defines.NORMAL_DEPTH;
    }
    this.needsUpdate = true;
  }
  /**
   * Sets the combined normal-depth buffer.
   *
   * @deprecated Use normalDepthBuffer instead.
   * @param {Number} value - The buffer.
   */
  setNormalDepthBuffer(value) {
    this.normalDepthBuffer = value;
  }
  /**
   * The normal buffer.
   *
   * @type {Texture}
   */
  set normalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
  }
  /**
   * Sets the normal buffer.
   *
   * @deprecated Use normalBuffer instead.
   * @param {Number} value - The buffer.
   */
  setNormalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = import_three55.BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * The noise texture.
   *
   * @type {Texture}
   */
  set noiseTexture(value) {
    this.uniforms.noiseTexture.value = value;
  }
  /**
   * Sets the noise texture.
   *
   * @deprecated Use noiseTexture instead.
   * @param {Number} value - The texture.
   */
  setNoiseTexture(value) {
    this.uniforms.noiseTexture.value = value;
  }
  /**
   * The sample count.
   *
   * @type {Number}
   */
  get samples() {
    return Number(this.defines.SAMPLES_INT);
  }
  set samples(value) {
    this.defines.SAMPLES_INT = value.toFixed(0);
    this.defines.INV_SAMPLES_FLOAT = (1 / value).toFixed(9);
    this.needsUpdate = true;
  }
  /**
   * Returns the amount of occlusion samples per pixel.
   *
   * @deprecated Use samples instead.
   * @return {Number} The sample count.
   */
  getSamples() {
    return this.samples;
  }
  /**
   * Sets the amount of occlusion samples per pixel.
   *
   * @deprecated Use samples instead.
   * @param {Number} value - The sample count.
   */
  setSamples(value) {
    this.samples = value;
  }
  /**
   * The sampling spiral ring count.
   *
   * @type {Number}
   */
  get rings() {
    return Number(this.defines.SPIRAL_TURNS);
  }
  set rings(value) {
    this.defines.SPIRAL_TURNS = value.toFixed(1);
    this.needsUpdate = true;
  }
  /**
   * Returns the amount of spiral turns in the occlusion sampling pattern.
   *
   * @deprecated Use rings instead.
   * @return {Number} The radius.
   */
  getRings() {
    return this.rings;
  }
  /**
   * Sets the amount of spiral turns in the occlusion sampling pattern.
   *
   * @deprecated Use rings instead.
   * @param {Number} value - The radius.
   */
  setRings(value) {
    this.rings = value;
  }
  /**
   * The intensity.
   *
   * @type {Number}
   * @deprecated Use SSAOEffect.intensity instead.
   */
  get intensity() {
    return this.uniforms.intensity.value;
  }
  set intensity(value) {
    this.uniforms.intensity.value = value;
    if (this.defines.LEGACY_INTENSITY === void 0) {
      this.defines.LEGACY_INTENSITY = "1";
      this.needsUpdate = true;
    }
  }
  /**
   * Returns the intensity.
   *
   * @deprecated Use SSAOEffect.intensity instead.
   * @return {Number} The intensity.
   */
  getIntensity() {
    return this.uniforms.intensity.value;
  }
  /**
   * Sets the intensity.
   *
   * @deprecated Use SSAOEffect.intensity instead.
   * @param {Number} value - The intensity.
   */
  setIntensity(value) {
    this.uniforms.intensity.value = value;
  }
  /**
   * The depth fade factor.
   *
   * @type {Number}
   */
  get fade() {
    return this.uniforms.fade.value;
  }
  set fade(value) {
    this.uniforms.fade.value = value;
  }
  /**
   * Returns the depth fade factor.
   *
   * @deprecated Use fade instead.
   * @return {Number} The fade factor.
   */
  getFade() {
    return this.uniforms.fade.value;
  }
  /**
   * Sets the depth fade factor.
   *
   * @deprecated Use fade instead.
   * @param {Number} value - The fade factor.
   */
  setFade(value) {
    this.uniforms.fade.value = value;
  }
  /**
   * The depth bias. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get bias() {
    return this.uniforms.bias.value;
  }
  set bias(value) {
    this.uniforms.bias.value = value;
  }
  /**
   * Returns the depth bias.
   *
   * @deprecated Use bias instead.
   * @return {Number} The bias.
   */
  getBias() {
    return this.uniforms.bias.value;
  }
  /**
   * Sets the depth bias.
   *
   * @deprecated Use bias instead.
   * @param {Number} value - The bias.
   */
  setBias(value) {
    this.uniforms.bias.value = value;
  }
  /**
   * The minimum radius scale for distance scaling. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get minRadiusScale() {
    return this.uniforms.minRadiusScale.value;
  }
  set minRadiusScale(value) {
    this.uniforms.minRadiusScale.value = value;
  }
  /**
   * Returns the minimum radius scale for distance scaling.
   *
   * @deprecated Use minRadiusScale instead.
   * @return {Number} The minimum radius scale.
   */
  getMinRadiusScale() {
    return this.uniforms.minRadiusScale.value;
  }
  /**
   * Sets the minimum radius scale for distance scaling.
   *
   * @deprecated Use minRadiusScale instead.
   * @param {Number} value - The minimum radius scale.
   */
  setMinRadiusScale(value) {
    this.uniforms.minRadiusScale.value = value;
  }
  /**
   * Updates the absolute radius.
   *
   * @private
   */
  updateRadius() {
    const radius = this.r * this.resolution.height;
    this.defines.RADIUS = radius.toFixed(11);
    this.defines.RADIUS_SQ = (radius * radius).toFixed(11);
    this.needsUpdate = true;
  }
  /**
   * The occlusion sampling radius. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get radius() {
    return this.r;
  }
  set radius(value) {
    this.r = Math.min(Math.max(value, 1e-6), 1);
    this.updateRadius();
  }
  /**
   * Returns the occlusion sampling radius.
   *
   * @deprecated Use radius instead.
   * @return {Number} The radius.
   */
  getRadius() {
    return this.radius;
  }
  /**
   * Sets the occlusion sampling radius.
   *
   * @deprecated Use radius instead.
   * @param {Number} value - The radius. Range [1e-6, 1.0].
   */
  setRadius(value) {
    this.radius = value;
  }
  /**
   * Indicates whether distance-based radius scaling is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get distanceScaling() {
    return true;
  }
  set distanceScaling(value) {
  }
  /**
   * Indicates whether distance-based radius scaling is enabled.
   *
   * @deprecated
   * @return {Boolean} Whether distance scaling is enabled.
   */
  isDistanceScalingEnabled() {
    return this.distanceScaling;
  }
  /**
   * Enables or disables distance-based radius scaling.
   *
   * @deprecated
   * @param {Boolean} value - Whether distance scaling should be enabled.
   */
  setDistanceScalingEnabled(value) {
    this.distanceScaling = value;
  }
  /**
   * The occlusion distance threshold. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get distanceThreshold() {
    return this.uniforms.distanceCutoff.value.x;
  }
  set distanceThreshold(value) {
    this.uniforms.distanceCutoff.value.set(
      Math.min(Math.max(value, 0), 1),
      Math.min(Math.max(value + this.distanceFalloff, 0), 1)
    );
  }
  /**
   * The occlusion distance threshold in world units.
   *
   * @type {Number}
   */
  get worldDistanceThreshold() {
    return -orthographicDepthToViewZ(this.distanceThreshold, this.near, this.far);
  }
  set worldDistanceThreshold(value) {
    this.distanceThreshold = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * The occlusion distance falloff. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get distanceFalloff() {
    return this.uniforms.distanceCutoff.value.y - this.distanceThreshold;
  }
  set distanceFalloff(value) {
    this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + value, 0), 1);
  }
  /**
   * The occlusion distance falloff in world units.
   *
   * @type {Number}
   */
  get worldDistanceFalloff() {
    return -orthographicDepthToViewZ(this.distanceFalloff, this.near, this.far);
  }
  set worldDistanceFalloff(value) {
    this.distanceFalloff = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * Sets the occlusion distance cutoff.
   *
   * @deprecated Use distanceThreshold and distanceFalloff instead.
   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setDistanceCutoff(threshold, falloff) {
    this.uniforms.distanceCutoff.value.set(
      Math.min(Math.max(threshold, 0), 1),
      Math.min(Math.max(threshold + falloff, 0), 1)
    );
  }
  /**
   * The occlusion proximity threshold. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get proximityThreshold() {
    return this.uniforms.proximityCutoff.value.x;
  }
  set proximityThreshold(value) {
    this.uniforms.proximityCutoff.value.set(
      Math.min(Math.max(value, 0), 1),
      Math.min(Math.max(value + this.proximityFalloff, 0), 1)
    );
  }
  /**
   * The occlusion proximity threshold in world units.
   *
   * @type {Number}
   */
  get worldProximityThreshold() {
    return -orthographicDepthToViewZ(this.proximityThreshold, this.near, this.far);
  }
  set worldProximityThreshold(value) {
    this.proximityThreshold = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * The occlusion proximity falloff. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get proximityFalloff() {
    return this.uniforms.proximityCutoff.value.y - this.proximityThreshold;
  }
  set proximityFalloff(value) {
    this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + value, 0), 1);
  }
  /**
   * The occlusion proximity falloff in world units.
   *
   * @type {Number}
   */
  get worldProximityFalloff() {
    return -orthographicDepthToViewZ(this.proximityFalloff, this.near, this.far);
  }
  set worldProximityFalloff(value) {
    this.proximityFalloff = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * Sets the occlusion proximity cutoff.
   *
   * @deprecated Use proximityThreshold and proximityFalloff instead.
   * @param {Number} threshold - The range threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setProximityCutoff(threshold, falloff) {
    this.uniforms.proximityCutoff.value.set(
      Math.min(Math.max(threshold, 0), 1),
      Math.min(Math.max(threshold + falloff, 0), 1)
    );
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);
      this.uniforms.projectionMatrix.value.copy(camera.projectionMatrix);
      this.uniforms.inverseProjectionMatrix.value.copy(camera.projectionMatrix).invert();
      if (camera instanceof import_three55.PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    const noiseTexture = uniforms.noiseTexture.value;
    if (noiseTexture !== null) {
      uniforms.noiseScale.value.set(
        width / noiseTexture.image.width,
        height / noiseTexture.image.height
      );
    }
    uniforms.texelSize.value.set(1 / width, 1 / height);
    this.resolution.set(width, height);
    this.updateRadius();
  }
};

// src/passes/DepthDownsamplingPass.js
var import_three57 = __webpack_require__(39437);

// src/materials/DepthDownsamplingMaterial.js
var import_three56 = __webpack_require__(39437);

// src/materials/glsl/depth-downsampling.frag
var depth_downsampling_default = "#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\n#ifdef DOWNSAMPLE_NORMALS\nuniform lowp sampler2D normalBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);\n#ifdef DOWNSAMPLE_NORMALS\nvec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;\n#else\nvec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);\n#endif\ngl_FragColor=vec4(n[index],d[index]);}";

// src/materials/glsl/depth-downsampling.vert
var depth_downsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/DepthDownsamplingMaterial.js
var DepthDownsamplingMaterial = class extends import_three56.ShaderMaterial {
  /**
   * Constructs a new depth downsampling material.
   */
  constructor() {
    super({
      name: "DepthDownsamplingMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new import_three56.Uniform(null),
        normalBuffer: new import_three56.Uniform(null),
        texelSize: new import_three56.Uniform(new import_three56.Vector2())
      },
      blending: import_three56.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_downsampling_default,
      vertexShader: depth_downsampling_default2
    });
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = import_three56.BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * The normal buffer.
   *
   * @type {Texture}
   */
  set normalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
    if (value !== null) {
      this.defines.DOWNSAMPLE_NORMALS = "1";
    } else {
      delete this.defines.DOWNSAMPLE_NORMALS;
    }
    this.needsUpdate = true;
  }
  /**
   * Sets the normal buffer.
   *
   * @deprecated Use normalBuffer instead.
   * @param {Texture} value - The normal buffer.
   */
  setNormalBuffer(value) {
    this.normalBuffer = value;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/passes/DepthDownsamplingPass.js
var DepthDownsamplingPass = class extends Pass {
  /**
   * Constructs a new depth downsampling pass.
   *
   * @param {Object} [options] - The options.
   * @param {Texture} [options.normalBuffer=null] - A texture that contains view space normals. See {@link NormalPass}.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    normalBuffer = null,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("DepthDownsamplingPass");
    const material = new DepthDownsamplingMaterial();
    material.normalBuffer = normalBuffer;
    this.fullscreenMaterial = material;
    this.needsDepthTexture = true;
    this.needsSwap = false;
    this.renderTarget = new import_three57.WebGLRenderTarget(1, 1, {
      minFilter: import_three57.NearestFilter,
      magFilter: import_three57.NearestFilter,
      depthBuffer: false,
      type: import_three57.FloatType
    });
    this.renderTarget.texture.name = "DepthDownsamplingPass.Target";
    this.renderTarget.texture.generateMipmaps = false;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * The normal(RGB) + depth(A) texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the normal(RGB) + depth(A) texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthTexture(depthTexture, depthPacking = import_three57.BasicDepthPacking) {
    this.fullscreenMaterial.depthBuffer = depthTexture;
    this.fullscreenMaterial.depthPacking = depthPacking;
  }
  /**
   * Downsamples depth and scene normals.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.fullscreenMaterial.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    const gl = renderer.getContext();
    const renderable = gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float");
    if (!renderable) {
      throw new Error("Rendering to float texture is not supported.");
    }
  }
};

// src/effects/glsl/ssao.frag
var ssao_default3 = "uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\n#endif\n#ifdef COLORIZE\nuniform vec3 color;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300\nvec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);\n#else\nfloat ao=aoLinear;\n#endif\nfloat l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);\n#ifdef COLORIZE\noutputColor=vec4(1.0-ao*(1.0-color),inputColor.a);\n#else\noutputColor=vec4(vec3(1.0-ao),inputColor.a);\n#endif\n}";

// src/effects/SSAOEffect.js
var NOISE_TEXTURE_SIZE = 64;
var SSAOEffect = class extends Effect {
  /**
   * Constructs a new SSAO effect.
   *
   * @todo Move normalBuffer to options.
   * @param {Camera} [camera] - The main camera.
   * @param {Texture} [normalBuffer] - A texture that contains the scene normals.
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.MULTIPLY] - The blend function of this effect.
   * @param {Boolean} [options.distanceScaling=true] - Deprecated.
   * @param {Boolean} [options.depthAwareUpsampling=true] - Enables or disables depth-aware upsampling. Has no effect if WebGL 2 is not supported.
   * @param {Texture} [options.normalDepthBuffer=null] - Deprecated.
   * @param {Number} [options.samples=9] - The amount of samples per pixel. Should not be a multiple of the ring count.
   * @param {Number} [options.rings=7] - The amount of spiral turns in the occlusion sampling pattern. Should be a prime number.
   * @param {Number} [options.worldDistanceThreshold] - The world distance threshold at which the occlusion effect starts to fade out.
   * @param {Number} [options.worldDistanceFalloff] - The world distance falloff. Influences the smoothness of the occlusion cutoff.
   * @param {Number} [options.worldProximityThreshold] - The world proximity threshold at which the occlusion starts to fade out.
   * @param {Number} [options.worldProximityFalloff] - The world proximity falloff. Influences the smoothness of the proximity cutoff.
   * @param {Number} [options.distanceThreshold=0.97] - Deprecated.
   * @param {Number} [options.distanceFalloff=0.03] - Deprecated.
   * @param {Number} [options.rangeThreshold=0.0005] - Deprecated.
   * @param {Number} [options.rangeFalloff=0.001] - Deprecated.
   * @param {Number} [options.minRadiusScale=0.1] - The minimum radius scale.
   * @param {Number} [options.luminanceInfluence=0.7] - Determines how much the luminance of the scene influences the ambient occlusion.
   * @param {Number} [options.radius=0.1825] - The occlusion sampling radius, expressed as a scale relative to the resolution. Range [1e-6, 1.0].
   * @param {Number} [options.intensity=1.0] - The intensity of the ambient occlusion.
   * @param {Number} [options.bias=0.025] - An occlusion bias. Eliminates artifacts caused by depth discontinuities.
   * @param {Number} [options.fade=0.01] - Influences the smoothness of the shadows. A lower value results in higher contrast.
   * @param {Color} [options.color=null] - The color of the ambient occlusion.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(camera, normalBuffer, {
    blendFunction = BlendFunction.MULTIPLY,
    samples = 9,
    rings = 7,
    normalDepthBuffer = null,
    depthAwareUpsampling = true,
    worldDistanceThreshold,
    worldDistanceFalloff,
    worldProximityThreshold,
    worldProximityFalloff,
    distanceThreshold = 0.97,
    distanceFalloff = 0.03,
    rangeThreshold = 5e-4,
    rangeFalloff = 1e-3,
    minRadiusScale = 0.1,
    luminanceInfluence = 0.7,
    radius = 0.1825,
    intensity = 1,
    bias = 0.025,
    fade = 0.01,
    color: color2 = null,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("SSAOEffect", ssao_default3, {
      blendFunction,
      attributes: EffectAttribute.DEPTH,
      defines: /* @__PURE__ */ new Map([
        ["THRESHOLD", "0.997"]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["aoBuffer", new import_three58.Uniform(null)],
        ["normalDepthBuffer", new import_three58.Uniform(normalDepthBuffer)],
        ["luminanceInfluence", new import_three58.Uniform(luminanceInfluence)],
        ["color", new import_three58.Uniform(null)],
        ["intensity", new import_three58.Uniform(intensity)],
        ["scale", new import_three58.Uniform(0)]
        // Unused.
      ])
    });
    this.renderTarget = new import_three58.WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "AO.Target";
    this.uniforms.get("aoBuffer").value = this.renderTarget.texture;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.camera = camera;
    this.depthDownsamplingPass = new DepthDownsamplingPass({ normalBuffer, resolutionScale });
    this.depthDownsamplingPass.enabled = normalDepthBuffer === null;
    this.ssaoPass = new ShaderPass(new SSAOMaterial(camera));
    const noiseTexture = new NoiseTexture(NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE, import_three58.RGBAFormat);
    noiseTexture.wrapS = noiseTexture.wrapT = import_three58.RepeatWrapping;
    const ssaoMaterial = this.ssaoMaterial;
    ssaoMaterial.normalBuffer = normalBuffer;
    ssaoMaterial.noiseTexture = noiseTexture;
    ssaoMaterial.minRadiusScale = minRadiusScale;
    ssaoMaterial.samples = samples;
    ssaoMaterial.radius = radius;
    ssaoMaterial.rings = rings;
    ssaoMaterial.fade = fade;
    ssaoMaterial.bias = bias;
    ssaoMaterial.distanceThreshold = distanceThreshold;
    ssaoMaterial.distanceFalloff = distanceFalloff;
    ssaoMaterial.proximityThreshold = rangeThreshold;
    ssaoMaterial.proximityFalloff = rangeFalloff;
    if (worldDistanceThreshold !== void 0) {
      ssaoMaterial.worldDistanceThreshold = worldDistanceThreshold;
    }
    if (worldDistanceFalloff !== void 0) {
      ssaoMaterial.worldDistanceFalloff = worldDistanceFalloff;
    }
    if (worldProximityThreshold !== void 0) {
      ssaoMaterial.worldProximityThreshold = worldProximityThreshold;
    }
    if (worldProximityFalloff !== void 0) {
      ssaoMaterial.worldProximityFalloff = worldProximityFalloff;
    }
    if (normalDepthBuffer !== null) {
      this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;
      this.defines.set("NORMAL_DEPTH", "1");
    }
    this.depthAwareUpsampling = depthAwareUpsampling;
    this.color = color2;
  }
  set mainCamera(value) {
    this.camera = value;
    this.ssaoMaterial.copyCameraSettings(value);
  }
  /**
   * Sets the normal buffer.
   *
   * @type {Texture}
   */
  get normalBuffer() {
    return this.ssaoMaterial.normalBuffer;
  }
  set normalBuffer(value) {
    this.ssaoMaterial.normalBuffer = value;
    this.depthDownsamplingPass.fullscreenMaterial.normalBuffer = value;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * The SSAO material.
   *
   * @type {SSAOMaterial}
   */
  get ssaoMaterial() {
    return this.ssaoPass.fullscreenMaterial;
  }
  /**
   * Returns the SSAO material.
   *
   * @deprecated Use ssaoMaterial instead.
   * @return {SSAOMaterial} The material.
   */
  getSSAOMaterial() {
    return this.ssaoMaterial;
  }
  /**
   * The amount of occlusion samples per pixel.
   *
   * @type {Number}
   * @deprecated Use ssaoMaterial.samples instead.
   */
  get samples() {
    return this.ssaoMaterial.samples;
  }
  set samples(value) {
    this.ssaoMaterial.samples = value;
  }
  /**
   * The amount of spiral turns in the occlusion sampling pattern.
   *
   * @type {Number}
   * @deprecated Use ssaoMaterial.rings instead.
   */
  get rings() {
    return this.ssaoMaterial.rings;
  }
  set rings(value) {
    this.ssaoMaterial.rings = value;
  }
  /**
   * The occlusion sampling radius.
   *
   * @type {Number}
   * @deprecated Use ssaoMaterial.radius instead.
   */
  get radius() {
    return this.ssaoMaterial.radius;
  }
  set radius(value) {
    this.ssaoMaterial.radius = value;
  }
  /**
   * Indicates whether depth-aware upsampling is enabled.
   *
   * @type {Boolean}
   */
  get depthAwareUpsampling() {
    return this.defines.has("DEPTH_AWARE_UPSAMPLING");
  }
  set depthAwareUpsampling(value) {
    if (this.depthAwareUpsampling !== value) {
      if (value) {
        this.defines.set("DEPTH_AWARE_UPSAMPLING", "1");
      } else {
        this.defines.delete("DEPTH_AWARE_UPSAMPLING");
      }
      this.setChanged();
    }
  }
  /**
   * Indicates whether depth-aware upsampling is enabled.
   *
   * @deprecated Use depthAwareUpsampling instead.
   * @return {Boolean} Whether depth-aware upsampling is enabled.
   */
  isDepthAwareUpsamplingEnabled() {
    return this.depthAwareUpsampling;
  }
  /**
   * Enables or disables depth-aware upsampling.
   *
   * @deprecated Use depthAwareUpsampling instead.
   * @param {Boolean} value - Whether depth-aware upsampling should be enabled.
   */
  setDepthAwareUpsamplingEnabled(value) {
    this.depthAwareUpsampling = value;
  }
  /**
   * Indicates whether distance-based radius scaling is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get distanceScaling() {
    return true;
  }
  set distanceScaling(value) {
  }
  /**
   * The color of the ambient occlusion. Set to `null` to disable.
   *
   * @type {Color}
   */
  get color() {
    return this.uniforms.get("color").value;
  }
  set color(value) {
    const uniforms = this.uniforms;
    const defines = this.defines;
    if (value !== null) {
      if (defines.has("COLORIZE")) {
        uniforms.get("color").value.set(value);
      } else {
        defines.set("COLORIZE", "1");
        uniforms.get("color").value = new import_three58.Color(value);
        this.setChanged();
      }
    } else if (defines.has("COLORIZE")) {
      defines.delete("COLORIZE");
      uniforms.get("color").value = null;
      this.setChanged();
    }
  }
  /**
   * The luminance influence factor. Range: [0.0, 1.0].
   *
   * @type {Boolean}
   */
  get luminanceInfluence() {
    return this.uniforms.get("luminanceInfluence").value;
  }
  set luminanceInfluence(value) {
    this.uniforms.get("luminanceInfluence").value = value;
  }
  /**
   * The intensity.
   *
   * @type {Number}
   */
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(value) {
    this.uniforms.get("intensity").value = value;
  }
  /**
   * Returns the color of the ambient occlusion.
   *
   * @deprecated Use color instead.
   * @return {Color} The color.
   */
  getColor() {
    return this.color;
  }
  /**
   * Sets the color of the ambient occlusion. Set to `null` to disable colorization.
   *
   * @deprecated Use color instead.
   * @param {Color} value - The color.
   */
  setColor(value) {
    this.color = value;
  }
  /**
   * Sets the occlusion distance cutoff.
   *
   * @deprecated Use ssaoMaterial instead.
   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setDistanceCutoff(threshold, falloff) {
    this.ssaoMaterial.distanceThreshold = threshold;
    this.ssaoMaterial.distanceFalloff = falloff;
  }
  /**
   * Sets the occlusion proximity cutoff.
   *
   * @deprecated Use ssaoMaterial instead.
   * @param {Number} threshold - The proximity threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setProximityCutoff(threshold, falloff) {
    this.ssaoMaterial.proximityThreshold = threshold;
    this.ssaoMaterial.proximityFalloff = falloff;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = import_three58.BasicDepthPacking) {
    this.depthDownsamplingPass.setDepthTexture(depthTexture, depthPacking);
    this.ssaoMaterial.depthBuffer = depthTexture;
    this.ssaoMaterial.depthPacking = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget = this.renderTarget;
    if (this.depthDownsamplingPass.enabled) {
      this.depthDownsamplingPass.render(renderer);
    }
    this.ssaoPass.render(renderer, null, renderTarget);
  }
  /**
   * Sets the size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.ssaoMaterial.copyCameraSettings(this.camera);
    this.ssaoMaterial.setSize(w, h);
    this.renderTarget.setSize(w, h);
    this.depthDownsamplingPass.resolution.scale = resolution.scale;
    this.depthDownsamplingPass.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    try {
      let normalDepthBuffer = this.uniforms.get("normalDepthBuffer").value;
      if (normalDepthBuffer === null) {
        this.depthDownsamplingPass.initialize(renderer, alpha, frameBufferType);
        normalDepthBuffer = this.depthDownsamplingPass.texture;
        this.uniforms.get("normalDepthBuffer").value = normalDepthBuffer;
        this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;
        this.defines.set("NORMAL_DEPTH", "1");
      }
    } catch (e) {
      this.depthDownsamplingPass.enabled = false;
    }
  }
};

// src/effects/TextureEffect.js
var import_three59 = __webpack_require__(39437);

// src/effects/glsl/texture.frag
var texture_default = "#ifdef TEXTURE_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nvarying vec2 vUv2;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#ifdef UV_TRANSFORM\nvec4 texel=texture2D(map,vUv2);\n#else\nvec4 texel=texture2D(map,uv);\n#endif\noutputColor=TEXEL;}";

// src/effects/glsl/texture.vert
var texture_default2 = "#ifdef ASPECT_CORRECTION\nuniform float scale;\n#else\nuniform mat3 uvTransform;\n#endif\nvarying vec2 vUv2;void mainSupport(const in vec2 uv){\n#ifdef ASPECT_CORRECTION\nvUv2=uv*vec2(aspect,1.0)*scale;\n#else\nvUv2=(uvTransform*vec3(uv,1.0)).xy;\n#endif\n}";

// src/effects/TextureEffect.js
var TextureEffect = class extends Effect {
  /**
   * Constructs a new texture effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
   * @param {Texture} [options.texture] - A texture.
   * @param {Boolean} [options.aspectCorrection=false] - Deprecated. Adjust the texture's offset, repeat and center instead.
   */
  constructor({ blendFunction, texture = null, aspectCorrection = false } = {}) {
    super("TextureEffect", texture_default, {
      blendFunction,
      defines: /* @__PURE__ */ new Map([
        ["TEXEL", "texel"]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["map", new import_three59.Uniform(null)],
        ["scale", new import_three59.Uniform(1)],
        ["uvTransform", new import_three59.Uniform(null)]
      ])
    });
    this.texture = texture;
    this.aspectCorrection = aspectCorrection;
  }
  /**
   * The texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.uniforms.get("map").value;
  }
  set texture(value) {
    const prevTexture = this.texture;
    const uniforms = this.uniforms;
    const defines = this.defines;
    if (prevTexture !== value) {
      uniforms.get("map").value = value;
      uniforms.get("uvTransform").value = value.matrix;
      defines.delete("TEXTURE_PRECISION_HIGH");
      if (value !== null) {
        if (value.matrixAutoUpdate) {
          defines.set("UV_TRANSFORM", "1");
          this.setVertexShader(texture_default2);
        } else {
          defines.delete("UV_TRANSFORM");
          this.setVertexShader(null);
        }
        if (value.type !== import_three59.UnsignedByteType) {
          defines.set("TEXTURE_PRECISION_HIGH", "1");
        }
        if (prevTexture === null || prevTexture.type !== value.type || prevTexture.encoding !== value.encoding) {
          this.setChanged();
        }
      }
    }
  }
  /**
   * Returns the texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.texture;
  }
  /**
   * Sets the texture.
   *
   * @deprecated Use texture instead.
   * @param {Texture} value - The texture.
   */
  setTexture(value) {
    this.texture = value;
  }
  /**
   * Indicates whether aspect correction is enabled.
   *
   * @type {Number}
   * @deprecated Adjust the texture's offset, repeat, rotation and center instead.
   */
  get aspectCorrection() {
    return this.defines.has("ASPECT_CORRECTION");
  }
  set aspectCorrection(value) {
    if (this.aspectCorrection !== value) {
      if (value) {
        this.defines.set("ASPECT_CORRECTION", "1");
      } else {
        this.defines.delete("ASPECT_CORRECTION");
      }
      this.setChanged();
    }
  }
  /**
   * Indicates whether the texture UV coordinates will be transformed using the transformation matrix of the texture.
   *
   * @type {Boolean}
   * @deprecated Use texture.matrixAutoUpdate instead.
   */
  get uvTransform() {
    const texture = this.texture;
    return texture !== null && texture.matrixAutoUpdate;
  }
  set uvTransform(value) {
    const texture = this.texture;
    if (texture !== null) {
      texture.matrixAutoUpdate = value;
    }
  }
  /**
   * Sets the swizzles that will be applied to the components of a texel before it is written to the output color.
   *
   * @param {ColorChannel} r - The swizzle for the `r` component.
   * @param {ColorChannel} [g=r] - The swizzle for the `g` component.
   * @param {ColorChannel} [b=r] - The swizzle for the `b` component.
   * @param {ColorChannel} [a=r] - The swizzle for the `a` component.
   */
  setTextureSwizzleRGBA(r, g = r, b = r, a = r) {
    const rgba = "rgba";
    let swizzle = "";
    if (r !== ColorChannel.RED || g !== ColorChannel.GREEN || b !== ColorChannel.BLUE || a !== ColorChannel.ALPHA) {
      swizzle = [".", rgba[r], rgba[g], rgba[b], rgba[a]].join("");
    }
    this.defines.set("TEXEL", "texel" + swizzle);
    this.setChanged();
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    if (this.texture.matrixAutoUpdate) {
      this.texture.updateMatrix();
    }
  }
};

// src/effects/TiltShiftEffect.js
var import_three61 = __webpack_require__(39437);

// src/materials/TiltShiftBlurMaterial.js
var import_three60 = __webpack_require__(39437);

// src/materials/glsl/convolution.tilt-shift.frag
var convolution_tilt_shift_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform vec4 maskParams;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;float linearGradientMask(const in float x){return smoothstep(maskParams.x,maskParams.y,x)-smoothstep(maskParams.w,maskParams.z,x);}void main(){vec2 dUv=vOffset*(1.0-linearGradientMask(vUv2.y));vec4 sum=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y-dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y-dUv.y));gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}";

// src/materials/glsl/convolution.tilt-shift.vert
var convolution_tilt_shift_default2 = "uniform vec4 texelSize;uniform float kernel;uniform float scale;uniform float aspect;uniform vec2 rotation;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;void main(){vec2 uv=position.xy*0.5+0.5;vUv=uv;vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));vOffset=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/TiltShiftBlurMaterial.js
var TiltShiftBlurMaterial = class extends KawaseBlurMaterial {
  /**
   * Constructs a new tilt shift blur material.
   *
   * @param {Object} [options] - The options.
   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.
   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.
   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.
   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.
   */
  constructor({
    kernelSize = KernelSize.MEDIUM,
    offset = 0,
    rotation = 0,
    focusArea = 0.4,
    feather = 0.3
  } = {}) {
    super();
    this.fragmentShader = convolution_tilt_shift_default;
    this.vertexShader = convolution_tilt_shift_default2;
    this.kernelSize = kernelSize;
    this.fragmentShader = updateFragmentShader(this.fragmentShader);
    this.uniforms.aspect = new import_three60.Uniform(1);
    this.uniforms.rotation = new import_three60.Uniform(new import_three60.Vector2());
    this.uniforms.maskParams = new import_three60.Uniform(new import_three60.Vector4());
    this._offset = offset;
    this._focusArea = focusArea;
    this._feather = feather;
    this.rotation = rotation;
    this.updateParams();
  }
  /**
   * The relative offset of the focus area.
   *
   * @private
   */
  updateParams() {
    const params = this.uniforms.maskParams.value;
    const a = Math.max(this.focusArea, 0);
    const b = Math.max(a - this.feather, 0);
    params.set(
      this.offset - a,
      this.offset - b,
      this.offset + a,
      this.offset + b
    );
  }
  /**
   * The rotation of the focus area in radians.
   *
   * @type {Number}
   */
  get rotation() {
    return Math.acos(this.uniforms.rotation.value.x);
  }
  set rotation(value) {
    this.uniforms.rotation.value.set(Math.cos(value), Math.sin(value));
  }
  /**
   * The relative offset of the focus area.
   *
   * @type {Number}
   */
  get offset() {
    return this._offset;
  }
  set offset(value) {
    this._offset = value;
    this.updateParams();
  }
  /**
   * The relative size of the focus area.
   *
   * @type {Number}
   */
  get focusArea() {
    return this._focusArea;
  }
  set focusArea(value) {
    this._focusArea = value;
    this.updateParams();
  }
  /**
   * The softness of the focus area edges.
   *
   * @type {Number}
   */
  get feather() {
    return this._feather;
  }
  set feather(value) {
    this._feather = value;
    this.updateParams();
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    super.setSize(width, height);
    this.uniforms.aspect.value = width / height;
  }
};

// src/passes/TiltShiftBlurPass.js
var TiltShiftBlurPass = class extends KawaseBlurPass {
  /**
   * Constructs a new Kawase blur pass.
   *
   * @param {Object} [options] - The options.
   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.
   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.
   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.
   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.
   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   */
  constructor({
    offset = 0,
    rotation = 0,
    focusArea = 0.4,
    feather = 0.3,
    kernelSize = KernelSize.MEDIUM,
    resolutionScale = 0.5,
    resolutionX = Resolution.AUTO_SIZE,
    resolutionY = Resolution.AUTO_SIZE
  } = {}) {
    super({ kernelSize, resolutionScale, resolutionX, resolutionY });
    this.blurMaterial = new TiltShiftBlurMaterial({ kernelSize, offset, rotation, focusArea, feather });
  }
};

// src/effects/glsl/tilt-shift.frag
var tilt_shift_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform vec2 maskParams;varying vec2 vUv2;float linearGradientMask(const in float x){return step(maskParams.x,x)-step(maskParams.y,x);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float mask=linearGradientMask(vUv2.y);vec4 texel=texture2D(map,uv);outputColor=mix(texel,inputColor,mask);}";

// src/effects/glsl/tilt-shift.vert
var tilt_shift_default2 = "uniform vec2 rotation;varying vec2 vUv2;void mainSupport(const in vec2 uv){vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));}";

// src/effects/TiltShiftEffect.js
var TiltShiftEffect = class extends Effect {
  /**
   * Constructs a new tilt shift Effect
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.
   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.
   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.
   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.
   * @param {Number} [options.bias=0.06] - Deprecated.
   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   */
  constructor({
    blendFunction,
    offset = 0,
    rotation = 0,
    focusArea = 0.4,
    feather = 0.3,
    kernelSize = KernelSize.MEDIUM,
    resolutionScale = 0.5,
    resolutionX = Resolution.AUTO_SIZE,
    resolutionY = Resolution.AUTO_SIZE
  } = {}) {
    super("TiltShiftEffect", tilt_shift_default, {
      vertexShader: tilt_shift_default2,
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["rotation", new import_three61.Uniform(new import_three61.Vector2())],
        ["maskParams", new import_three61.Uniform(new import_three61.Vector2())],
        ["map", new import_three61.Uniform(null)]
      ])
    });
    this._offset = offset;
    this._focusArea = focusArea;
    this._feather = feather;
    this.renderTarget = new import_three61.WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "TiltShift.Target";
    this.uniforms.get("map").value = this.renderTarget.texture;
    this.blurPass = new TiltShiftBlurPass({
      kernelSize,
      resolutionScale,
      resolutionX,
      resolutionY,
      offset,
      rotation,
      focusArea,
      feather
    });
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.rotation = rotation;
    this.updateParams();
  }
  /**
   * Updates the mask params.
   *
   * @private
   */
  updateParams() {
    const params = this.uniforms.get("maskParams").value;
    const x = Math.max(this.focusArea - this.feather, 0);
    params.set(this.offset - x, this.offset + x);
  }
  /**
   * The rotation of the focus area in radians.
   *
   * @type {Number}
   */
  get rotation() {
    return Math.acos(this.uniforms.get("rotation").value.x);
  }
  set rotation(value) {
    this.uniforms.get("rotation").value.set(Math.cos(value), Math.sin(value));
    this.blurPass.blurMaterial.rotation = value;
  }
  /**
   * The relative offset of the focus area.
   *
   * @type {Number}
   */
  get offset() {
    return this._offset;
  }
  set offset(value) {
    this._offset = value;
    this.blurPass.blurMaterial.offset = value;
    this.updateParams();
  }
  /**
   * The relative size of the focus area.
   *
   * @type {Number}
   */
  get focusArea() {
    return this._focusArea;
  }
  set focusArea(value) {
    this._focusArea = value;
    this.blurPass.blurMaterial.focusArea = value;
    this.updateParams();
  }
  /**
   * The softness of the focus area edges.
   *
   * @type {Number}
   */
  get feather() {
    return this._feather;
  }
  set feather(value) {
    this._feather = value;
    this.blurPass.blurMaterial.feather = value;
    this.updateParams();
  }
  /**
   * A blend bias.
   *
   * @type {Number}
   * @deprecated
   */
  get bias() {
    return 0;
  }
  set bias(value) {
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    this.blurPass.render(renderer, inputBuffer, this.renderTarget);
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.blurPass.resolution.copy(resolution);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.blurPass.initialize(renderer, alpha, frameBufferType);
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (renderer !== null && renderer.outputColorSpace === import_three61.SRGBColorSpace) {
        this.renderTarget.texture.colorSpace = import_three61.SRGBColorSpace;
      }
    }
  }
};

// src/effects/ToneMappingEffect.js
var import_three64 = __webpack_require__(39437);

// src/passes/AdaptiveLuminancePass.js
var import_three63 = __webpack_require__(39437);

// src/materials/AdaptiveLuminanceMaterial.js
var import_three62 = __webpack_require__(39437);

// src/materials/glsl/adaptive-luminance.frag
var adaptive_luminance_default = "#include <packing>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\nuniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));\n#if __VERSION__ < 300\nfloat l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#else\nfloat l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#endif\nl0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}";

// src/materials/AdaptiveLuminanceMaterial.js
var AdaptiveLuminanceMaterial = class extends import_three62.ShaderMaterial {
  /**
   * Constructs a new adaptive luminance material.
   */
  constructor() {
    super({
      name: "AdaptiveLuminanceMaterial",
      defines: {
        MIP_LEVEL_1X1: "0.0"
      },
      uniforms: {
        luminanceBuffer0: new import_three62.Uniform(null),
        luminanceBuffer1: new import_three62.Uniform(null),
        minLuminance: new import_three62.Uniform(0.01),
        deltaTime: new import_three62.Uniform(0),
        tau: new import_three62.Uniform(1)
      },
      extensions: {
        shaderTextureLOD: true
      },
      blending: import_three62.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: adaptive_luminance_default,
      vertexShader: common_default
    });
  }
  /**
   * The primary luminance buffer that contains the downsampled average luminance.
   *
   * @type {Texture}
   */
  set luminanceBuffer0(value) {
    this.uniforms.luminanceBuffer0.value = value;
  }
  /**
   * Sets the primary luminance buffer that contains the downsampled average luminance.
   *
   * @deprecated Use luminanceBuffer0 instead.
   * @param {Texture} value - The buffer.
   */
  setLuminanceBuffer0(value) {
    this.uniforms.luminanceBuffer0.value = value;
  }
  /**
   * The secondary luminance buffer.
   *
   * @type {Texture}
   */
  set luminanceBuffer1(value) {
    this.uniforms.luminanceBuffer1.value = value;
  }
  /**
   * Sets the secondary luminance buffer.
   *
   * @deprecated Use luminanceBuffer1 instead.
   * @param {Texture} value - The buffer.
   */
  setLuminanceBuffer1(value) {
    this.uniforms.luminanceBuffer1.value = value;
  }
  /**
   * The 1x1 mipmap level.
   *
   * This level is used to identify the smallest mipmap of the primary luminance buffer.
   *
   * @type {Number}
   */
  set mipLevel1x1(value) {
    this.defines.MIP_LEVEL_1X1 = value.toFixed(1);
    this.needsUpdate = true;
  }
  /**
   * Sets the 1x1 mipmap level.
   *
   * @deprecated Use mipLevel1x1 instead.
   * @param {Number} value - The level.
   */
  setMipLevel1x1(value) {
    this.mipLevel1x1 = value;
  }
  /**
   * The delta time.
   *
   * @type {Number}
   */
  set deltaTime(value) {
    this.uniforms.deltaTime.value = value;
  }
  /**
   * Sets the delta time.
   *
   * @deprecated Use deltaTime instead.
   * @param {Number} value - The delta time.
   */
  setDeltaTime(value) {
    this.uniforms.deltaTime.value = value;
  }
  /**
   * The lowest possible luminance value.
   *
   * @type {Number}
   */
  get minLuminance() {
    return this.uniforms.minLuminance.value;
  }
  set minLuminance(value) {
    this.uniforms.minLuminance.value = value;
  }
  /**
   * Returns the lowest possible luminance value.
   *
   * @deprecated Use minLuminance instead.
   * @return {Number} The minimum luminance.
   */
  getMinLuminance() {
    return this.uniforms.minLuminance.value;
  }
  /**
   * Sets the minimum luminance.
   *
   * @deprecated Use minLuminance instead.
   * @param {Number} value - The minimum luminance.
   */
  setMinLuminance(value) {
    this.uniforms.minLuminance.value = value;
  }
  /**
   * The luminance adaptation rate.
   *
   * @type {Number}
   */
  get adaptationRate() {
    return this.uniforms.tau.value;
  }
  set adaptationRate(value) {
    this.uniforms.tau.value = value;
  }
  /**
   * Returns the luminance adaptation rate.
   *
   * @deprecated Use adaptationRate instead.
   * @return {Number} The adaptation rate.
   */
  getAdaptationRate() {
    return this.uniforms.tau.value;
  }
  /**
   * Sets the luminance adaptation rate.
   *
   * @deprecated Use adaptationRate instead.
   * @param {Number} value - The adaptation rate.
   */
  setAdaptationRate(value) {
    this.uniforms.tau.value = value;
  }
};

// src/passes/AdaptiveLuminancePass.js
var AdaptiveLuminancePass = class extends Pass {
  /**
   * Constructs a new adaptive luminance pass.
   *
   * @param {Texture} luminanceBuffer - A buffer that contains the current scene luminance.
   * @param {Object} [options] - The options.
   * @param {Number} [options.minLuminance=0.01] - The minimum luminance.
   * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.
   */
  constructor(luminanceBuffer, { minLuminance = 0.01, adaptationRate = 1 } = {}) {
    super("AdaptiveLuminancePass");
    this.fullscreenMaterial = new AdaptiveLuminanceMaterial();
    this.needsSwap = false;
    this.renderTargetPrevious = new import_three63.WebGLRenderTarget(1, 1, {
      minFilter: import_three63.NearestFilter,
      magFilter: import_three63.NearestFilter,
      depthBuffer: false
    });
    this.renderTargetPrevious.texture.name = "Luminance.Previous";
    const material = this.fullscreenMaterial;
    material.luminanceBuffer0 = this.renderTargetPrevious.texture;
    material.luminanceBuffer1 = luminanceBuffer;
    material.minLuminance = minLuminance;
    material.adaptationRate = adaptationRate;
    this.renderTargetAdapted = this.renderTargetPrevious.clone();
    this.renderTargetAdapted.texture.name = "Luminance.Adapted";
    this.copyPass = new CopyPass(this.renderTargetPrevious, false);
  }
  /**
   * The adaptive luminance texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTargetAdapted.texture;
  }
  /**
   * Returns the adaptive 1x1 luminance texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTargetAdapted.texture;
  }
  /**
   * Sets the 1x1 mipmap level.
   *
   * This level is used to identify the smallest mipmap of the main luminance texture which contains the downsampled
   * average scene luminance.
   *
   * @type {Number}
   * @deprecated Use fullscreenMaterial.mipLevel1x1 instead.
   */
  set mipLevel1x1(value) {
    this.fullscreenMaterial.mipLevel1x1 = value;
  }
  /**
   * The luminance adaptation rate.
   *
   * @type {Number}
   * @deprecated Use fullscreenMaterial.adaptationRate instead.
   */
  get adaptationRate() {
    return this.fullscreenMaterial.adaptationRate;
  }
  /**
   * @type {Number}
   * @deprecated Use fullscreenMaterial.adaptationRate instead.
   */
  set adaptationRate(value) {
    this.fullscreenMaterial.adaptationRate = value;
  }
  /**
   * Renders the scene normals.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    this.fullscreenMaterial.deltaTime = deltaTime;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted);
    renderer.render(this.scene, this.camera);
    this.copyPass.render(renderer, this.renderTargetAdapted);
  }
};

// src/effects/glsl/tone-mapping.frag
var tone_mapping_default = "#include <tonemapping_pars_fragment>\nuniform float whitePoint;\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\nuniform float middleGrey;\n#if TONE_MAPPING_MODE == 3\nuniform lowp sampler2D luminanceBuffer;\n#else\nuniform float averageLuminance;\n#endif\nvec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);\n#if TONE_MAPPING_MODE == 3\nfloat lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));\n#else\nfloat lumAvg=averageLuminance;\n#endif\nfloat lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}\n#elif TONE_MAPPING_MODE == 4\n#define A 0.15\n#define B 0.50\n#define C 0.10\n#define D 0.20\n#define E 0.02\n#define F 0.30\nvec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\noutputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);\n#elif TONE_MAPPING_MODE == 4\noutputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);\n#else\noutputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);\n#endif\n}";

// src/effects/ToneMappingEffect.js
var ToneMappingEffect = class extends Effect {
  /**
   * Constructs a new tone mapping effect.
   *
   * The additional parameters only affect the Reinhard2 operator.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {Boolean} [options.adaptive=false] - Deprecated. Use mode instead.
   * @param {ToneMappingMode} [options.mode=ToneMappingMode.AGX] - The tone mapping mode.
   * @param {Number} [options.resolution=256] - The resolution of the luminance texture. Must be a power of two.
   * @param {Number} [options.maxLuminance=4.0] - Deprecated. Same as whitePoint.
   * @param {Number} [options.whitePoint=4.0] - The white point.
   * @param {Number} [options.middleGrey=0.6] - The middle grey factor.
   * @param {Number} [options.minLuminance=0.01] - The minimum luminance. Prevents very high exposure in dark scenes.
   * @param {Number} [options.averageLuminance=1.0] - The average luminance. Used for the non-adaptive Reinhard operator.
   * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.
   */
  constructor({
    blendFunction = BlendFunction.SRC,
    adaptive = false,
    mode = adaptive ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.AGX,
    resolution = 256,
    maxLuminance = 4,
    whitePoint = maxLuminance,
    middleGrey = 0.6,
    minLuminance = 0.01,
    averageLuminance = 1,
    adaptationRate = 1
  } = {}) {
    super("ToneMappingEffect", tone_mapping_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["luminanceBuffer", new import_three64.Uniform(null)],
        ["maxLuminance", new import_three64.Uniform(maxLuminance)],
        // Unused
        ["whitePoint", new import_three64.Uniform(whitePoint)],
        ["middleGrey", new import_three64.Uniform(middleGrey)],
        ["averageLuminance", new import_three64.Uniform(averageLuminance)]
      ])
    });
    this.renderTargetLuminance = new import_three64.WebGLRenderTarget(1, 1, {
      minFilter: import_three64.LinearMipmapLinearFilter,
      depthBuffer: false
    });
    this.renderTargetLuminance.texture.generateMipmaps = true;
    this.renderTargetLuminance.texture.name = "Luminance";
    this.luminancePass = new LuminancePass({
      renderTarget: this.renderTargetLuminance
    });
    this.adaptiveLuminancePass = new AdaptiveLuminancePass(this.luminancePass.texture, {
      minLuminance,
      adaptationRate
    });
    this.uniforms.get("luminanceBuffer").value = this.adaptiveLuminancePass.texture;
    this.resolution = resolution;
    this.mode = mode;
  }
  /**
   * The tone mapping mode.
   *
   * @type {ToneMappingMode}
   */
  get mode() {
    return Number(this.defines.get("TONE_MAPPING_MODE"));
  }
  set mode(value) {
    if (this.mode !== value) {
      this.defines.clear();
      this.defines.set("TONE_MAPPING_MODE", value.toFixed(0));
      switch (value) {
        case ToneMappingMode.LINEAR:
          this.defines.set("toneMapping(texel)", "LinearToneMapping(texel)");
          break;
        case ToneMappingMode.REINHARD:
          this.defines.set("toneMapping(texel)", "ReinhardToneMapping(texel)");
          break;
        case ToneMappingMode.OPTIMIZED_CINEON:
          this.defines.set("toneMapping(texel)", "OptimizedCineonToneMapping(texel)");
          break;
        case ToneMappingMode.ACES_FILMIC:
          this.defines.set("toneMapping(texel)", "ACESFilmicToneMapping(texel)");
          break;
        case ToneMappingMode.AGX:
          this.defines.set("toneMapping(texel)", "AgXToneMapping(texel)");
          break;
        case ToneMappingMode.NEUTRAL:
          this.defines.set("toneMapping(texel)", "NeutralToneMapping(texel)");
          break;
        default:
          this.defines.set("toneMapping(texel)", "texel");
          break;
      }
      this.adaptiveLuminancePass.enabled = value === ToneMappingMode.REINHARD2_ADAPTIVE;
      this.setChanged();
    }
  }
  /**
   * Returns the current tone mapping mode.
   *
   * @deprecated Use mode instead.
   * @return {ToneMappingMode} The tone mapping mode.
   */
  getMode() {
    return this.mode;
  }
  /**
   * Sets the tone mapping mode.
   *
   * @deprecated Use mode instead.
   * @param {ToneMappingMode} value - The tone mapping mode.
   */
  setMode(value) {
    this.mode = value;
  }
  /**
   * The white point. Default is `4.0`.
   *
   * Only applies to Reinhard2 (Modified & Adaptive).
   *
   * @type {Number}
   */
  get whitePoint() {
    return this.uniforms.get("whitePoint").value;
  }
  set whitePoint(value) {
    this.uniforms.get("whitePoint").value = value;
  }
  /**
   * The middle grey factor. Default is `0.6`.
   *
   * Only applies to Reinhard2 (Modified & Adaptive).
   *
   * @type {Number}
   */
  get middleGrey() {
    return this.uniforms.get("middleGrey").value;
  }
  set middleGrey(value) {
    this.uniforms.get("middleGrey").value = value;
  }
  /**
   * The average luminance.
   *
   * Only applies to Reinhard2 (Modified).
   *
   * @type {Number}
   */
  get averageLuminance() {
    return this.uniforms.get("averageLuminance").value;
  }
  set averageLuminance(value) {
    this.uniforms.get("averageLuminance").value = value;
  }
  /**
   * The adaptive luminance material.
   *
   * @type {AdaptiveLuminanceMaterial}
   */
  get adaptiveLuminanceMaterial() {
    return this.adaptiveLuminancePass.fullscreenMaterial;
  }
  /**
   * Returns the adaptive luminance material.
   *
   * @deprecated Use adaptiveLuminanceMaterial instead.
   * @return {AdaptiveLuminanceMaterial} The material.
   */
  getAdaptiveLuminanceMaterial() {
    return this.adaptiveLuminanceMaterial;
  }
  /**
   * The resolution of the luminance texture. Must be a power of two.
   *
   * @type {Number}
   */
  get resolution() {
    return this.luminancePass.resolution.width;
  }
  set resolution(value) {
    const exponent = Math.max(0, Math.ceil(Math.log2(value)));
    const size = Math.pow(2, exponent);
    this.luminancePass.resolution.setPreferredSize(size, size);
    this.adaptiveLuminanceMaterial.mipLevel1x1 = exponent;
  }
  /**
   * Returns the resolution of the luminance texture.
   *
   * @deprecated Use resolution instead.
   * @return {Number} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Sets the resolution of the luminance texture. Must be a power of two.
   *
   * @deprecated Use resolution instead.
   * @param {Number} value - The resolution.
   */
  setResolution(value) {
    this.resolution = value;
  }
  /**
   * Indicates whether this pass uses adaptive luminance.
   *
   * @type {Boolean}
   * @deprecated Use mode instead.
   */
  get adaptive() {
    return this.mode === ToneMappingMode.REINHARD2_ADAPTIVE;
  }
  set adaptive(value) {
    this.mode = value ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.REINHARD2;
  }
  /**
   * The luminance adaptation rate.
   *
   * @type {Number}
   * @deprecated Use adaptiveLuminanceMaterial.adaptationRate instead.
   */
  get adaptationRate() {
    return this.adaptiveLuminanceMaterial.adaptationRate;
  }
  set adaptationRate(value) {
    this.adaptiveLuminanceMaterial.adaptationRate = value;
  }
  /**
   * @type {Number}
   * @deprecated
   */
  get distinction() {
    console.warn(this.name, "distinction was removed.");
    return 1;
  }
  set distinction(value) {
    console.warn(this.name, "distinction was removed.");
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    if (this.adaptiveLuminancePass.enabled) {
      this.luminancePass.render(renderer, inputBuffer);
      this.adaptiveLuminancePass.render(renderer, null, null, deltaTime);
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.adaptiveLuminancePass.initialize(renderer, alpha, frameBufferType);
  }
};

// src/effects/VignetteEffect.js
var import_three65 = __webpack_require__(39437);

// src/effects/glsl/vignette.frag
var vignette_default = "uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#if VIGNETTE_TECHNIQUE == 0\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#else\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#endif\noutputColor=vec4(color,inputColor.a);}";

// src/effects/VignetteEffect.js
var VignetteEffect = class extends Effect {
  /**
   * Constructs a new Vignette effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
   * @param {VignetteTechnique} [options.technique=VignetteTechnique.DEFAULT] - The Vignette technique.
   * @param {Boolean} [options.eskil=false] - Deprecated. Use technique instead.
   * @param {Number} [options.offset=0.5] - The Vignette offset.
   * @param {Number} [options.darkness=0.5] - The Vignette darkness.
   */
  constructor({
    blendFunction,
    eskil = false,
    technique = eskil ? VignetteTechnique.ESKIL : VignetteTechnique.DEFAULT,
    offset = 0.5,
    darkness = 0.5
  } = {}) {
    super("VignetteEffect", vignette_default, {
      blendFunction,
      defines: /* @__PURE__ */ new Map([
        ["VIGNETTE_TECHNIQUE", technique.toFixed(0)]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["offset", new import_three65.Uniform(offset)],
        ["darkness", new import_three65.Uniform(darkness)]
      ])
    });
  }
  /**
   * The Vignette technique.
   *
   * @type {VignetteTechnique}
   */
  get technique() {
    return Number(this.defines.get("VIGNETTE_TECHNIQUE"));
  }
  set technique(value) {
    if (this.technique !== value) {
      this.defines.set("VIGNETTE_TECHNIQUE", value.toFixed(0));
      this.setChanged();
    }
  }
  /**
   * Indicates whether Eskil's Vignette technique is enabled.
   *
   * @type {Boolean}
   * @deprecated Use technique instead.
   */
  get eskil() {
    return this.technique === VignetteTechnique.ESKIL;
  }
  /**
   * Indicates whether Eskil's Vignette technique is enabled.
   *
   * @type {Boolean}
   * @deprecated Use technique instead.
   */
  set eskil(value) {
    this.technique = value ? VignetteTechnique.ESKIL : VignetteTechnique.DEFAULT;
  }
  /**
   * Returns the Vignette technique.
   *
   * @deprecated Use technique instead.
   * @return {VignetteTechnique} The technique.
   */
  getTechnique() {
    return this.technique;
  }
  /**
   * Sets the Vignette technique.
   *
   * @deprecated Use technique instead.
   * @param {VignetteTechnique} value - The technique.
   */
  setTechnique(value) {
    this.technique = value;
  }
  /**
   * The Vignette offset.
   *
   * @type {Number}
   */
  get offset() {
    return this.uniforms.get("offset").value;
  }
  set offset(value) {
    this.uniforms.get("offset").value = value;
  }
  /**
   * Returns the Vignette offset.
   *
   * @deprecated Use offset instead.
   * @return {Number} The offset.
   */
  getOffset() {
    return this.offset;
  }
  /**
   * Sets the Vignette offset.
   *
   * @deprecated Use offset instead.
   * @param {Number} value - The offset.
   */
  setOffset(value) {
    this.offset = value;
  }
  /**
   * The Vignette darkness.
   *
   * @type {Number}
   */
  get darkness() {
    return this.uniforms.get("darkness").value;
  }
  set darkness(value) {
    this.uniforms.get("darkness").value = value;
  }
  /**
   * Returns the Vignette darkness.
   *
   * @deprecated Use darkness instead.
   * @return {Number} The darkness.
   */
  getDarkness() {
    return this.darkness;
  }
  /**
   * Sets the Vignette darkness.
   *
   * @deprecated Use darkness instead.
   * @param {Number} value - The darkness.
   */
  setDarkness(value) {
    this.darkness = value;
  }
};

// src/loaders/LUT3dlLoader.js
var import_three66 = __webpack_require__(39437);
var LUT3dlLoader = class extends import_three66.Loader {
  /**
   * Loads a LUT.
   *
   * @param {String} url - The URL of the 3dl-file.
   * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.
   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.
   * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.
   * @return {Promise<LookupTexture>} A promise that returns the lookup texture.
   */
  load(url, onLoad = () => {
  }, onProgress = () => {
  }, onError = null) {
    const externalManager = this.manager;
    const internalManager = new import_three66.LoadingManager();
    const loader = new import_three66.FileLoader(internalManager);
    loader.setPath(this.path);
    loader.setResponseType("text");
    return new Promise((resolve, reject) => {
      internalManager.onError = (url2) => {
        externalManager.itemError(url2);
        if (onError !== null) {
          onError(`Failed to load ${url2}`);
          resolve();
        } else {
          reject(`Failed to load ${url2}`);
        }
      };
      externalManager.itemStart(url);
      loader.load(url, (data) => {
        try {
          const result = this.parse(data);
          externalManager.itemEnd(url);
          onLoad(result);
          resolve(result);
        } catch (e) {
          console.error(e);
          internalManager.onError(url);
        }
      }, onProgress);
    });
  }
  /**
   * Parses the given data.
   *
   * @param {String} input - The LUT data.
   * @return {LookupTexture} The lookup texture.
   * @throws {Error} Fails if the data is invalid.
   */
  parse(input) {
    const regExpGridInfo = /^[\d ]+$/m;
    const regExpDataPoints = /^([\d.e+-]+) +([\d.e+-]+) +([\d.e+-]+) *$/gm;
    let result = regExpGridInfo.exec(input);
    if (result === null) {
      throw new Error("Missing grid information");
    }
    const gridLines = result[0].trim().split(/\s+/g).map((n) => Number(n));
    const gridStep = gridLines[1] - gridLines[0];
    const size = gridLines.length;
    const sizeSq = size ** 2;
    for (let i = 1, l = gridLines.length; i < l; ++i) {
      if (gridStep !== gridLines[i] - gridLines[i - 1]) {
        throw new Error("Inconsistent grid size");
      }
    }
    const data = new Float32Array(size ** 3 * 4);
    let maxValue = 0;
    let index = 0;
    while ((result = regExpDataPoints.exec(input)) !== null) {
      const r = Number(result[1]);
      const g = Number(result[2]);
      const b = Number(result[3]);
      maxValue = Math.max(maxValue, r, g, b);
      const bLayer = index % size;
      const gLayer = Math.floor(index / size) % size;
      const rLayer = Math.floor(index / sizeSq) % size;
      const d4 = (bLayer * sizeSq + gLayer * size + rLayer) * 4;
      data[d4 + 0] = r;
      data[d4 + 1] = g;
      data[d4 + 2] = b;
      data[d4 + 3] = 1;
      ++index;
    }
    const bits = Math.ceil(Math.log2(maxValue));
    const maxBitValue = Math.pow(2, bits);
    for (let i = 0, l = data.length; i < l; i += 4) {
      data[i + 0] /= maxBitValue;
      data[i + 1] /= maxBitValue;
      data[i + 2] /= maxBitValue;
    }
    return new LookupTexture(data, size);
  }
};

// src/loaders/LUTCubeLoader.js
var import_three67 = __webpack_require__(39437);
var LUTCubeLoader = class extends import_three67.Loader {
  /**
   * Loads a LUT.
   *
   * @param {String} url - The URL of the CUBE-file.
   * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.
   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.
   * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.
   * @return {Promise<LookupTexture>} A promise that returns the lookup texture.
   */
  load(url, onLoad = () => {
  }, onProgress = () => {
  }, onError = null) {
    const externalManager = this.manager;
    const internalManager = new import_three67.LoadingManager();
    const loader = new import_three67.FileLoader(internalManager);
    loader.setPath(this.path);
    loader.setResponseType("text");
    return new Promise((resolve, reject) => {
      internalManager.onError = (url2) => {
        externalManager.itemError(url2);
        if (onError !== null) {
          onError(`Failed to load ${url2}`);
          resolve();
        } else {
          reject(`Failed to load ${url2}`);
        }
      };
      externalManager.itemStart(url);
      loader.load(url, (data) => {
        try {
          const result = this.parse(data);
          externalManager.itemEnd(url);
          onLoad(result);
          resolve(result);
        } catch (e) {
          console.error(e);
          internalManager.onError(url);
        }
      }, onProgress);
    });
  }
  /**
   * Parses the given data.
   *
   * @param {String} input - The LUT data.
   * @return {LookupTexture} The lookup texture.
   * @throws {Error} Fails if the data is invalid.
   */
  parse(input) {
    const regExpTitle = /TITLE +"([^"]*)"/;
    const regExpSize = /LUT_3D_SIZE +(\d+)/;
    const regExpDomainMin = /DOMAIN_MIN +([\d.]+) +([\d.]+) +([\d.]+)/;
    const regExpDomainMax = /DOMAIN_MAX +([\d.]+) +([\d.]+) +([\d.]+)/;
    const regExpDataPoints = /^([\d.e+-]+) +([\d.e+-]+) +([\d.e+-]+) *$/gm;
    let result = regExpTitle.exec(input);
    const title = result !== null ? result[1] : null;
    result = regExpSize.exec(input);
    if (result === null) {
      throw new Error("Missing LUT_3D_SIZE information");
    }
    const size = Number(result[1]);
    const data = new Float32Array(size ** 3 * 4);
    const domainMin = new import_three67.Vector3(0, 0, 0);
    const domainMax = new import_three67.Vector3(1, 1, 1);
    result = regExpDomainMin.exec(input);
    if (result !== null) {
      domainMin.set(Number(result[1]), Number(result[2]), Number(result[3]));
    }
    result = regExpDomainMax.exec(input);
    if (result !== null) {
      domainMax.set(Number(result[1]), Number(result[2]), Number(result[3]));
    }
    if (domainMin.x > domainMax.x || domainMin.y > domainMax.y || domainMin.z > domainMax.z) {
      domainMin.set(0, 0, 0);
      domainMax.set(1, 1, 1);
      throw new Error("Invalid input domain");
    }
    let i = 0;
    while ((result = regExpDataPoints.exec(input)) !== null) {
      data[i++] = Number(result[1]);
      data[i++] = Number(result[2]);
      data[i++] = Number(result[3]);
      data[i++] = 1;
    }
    const lut = new LookupTexture(data, size);
    lut.domainMin.copy(domainMin);
    lut.domainMax.copy(domainMax);
    if (title !== null) {
      lut.name = title;
    }
    return lut;
  }
};

// src/loaders/SMAAImageLoader.js
var import_three68 = __webpack_require__(39437);
var SMAAImageLoader = class extends import_three68.Loader {
  /**
   * Loads the SMAA data images.
   *
   * @param {Function} [onLoad] - A callback that receives the search image and area image as a pair.
   * @param {Function} [onError] - An error callback that receives the URL of the image that failed to load.
   * @return {Promise<Image[]>} A promise that returns the search image and area image as a pair.
   */
  load(onLoad = () => {
  }, onError = null) {
    if (arguments.length === 4) {
      onLoad = arguments[1];
      onError = arguments[3];
    } else if (arguments.length === 3 || typeof arguments[0] !== "function") {
      onLoad = arguments[1];
      onError = null;
    }
    const externalManager = this.manager;
    const internalManager = new import_three68.LoadingManager();
    return new Promise((resolve, reject) => {
      const searchImage = new Image();
      const areaImage = new Image();
      internalManager.onError = (url) => {
        externalManager.itemError(url);
        if (onError !== null) {
          onError(`Failed to load ${url}`);
          resolve();
        } else {
          reject(`Failed to load ${url}`);
        }
      };
      internalManager.onLoad = () => {
        const result = [searchImage, areaImage];
        onLoad(result);
        resolve(result);
      };
      searchImage.addEventListener("error", (e) => {
        internalManager.itemError("smaa-search");
      });
      areaImage.addEventListener("error", (e) => {
        internalManager.itemError("smaa-area");
      });
      searchImage.addEventListener("load", () => {
        externalManager.itemEnd("smaa-search");
        internalManager.itemEnd("smaa-search");
      });
      areaImage.addEventListener("load", () => {
        externalManager.itemEnd("smaa-area");
        internalManager.itemEnd("smaa-area");
      });
      externalManager.itemStart("smaa-search");
      externalManager.itemStart("smaa-area");
      internalManager.itemStart("smaa-search");
      internalManager.itemStart("smaa-area");
      searchImage.src = searchImageDataURL_default;
      areaImage.src = areaImageDataURL_default;
    });
  }
};

// src/materials/BoxBlurMaterial.js
var import_three69 = __webpack_require__(39437);

// src/materials/glsl/convolution.box.frag
var convolution_box_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef BILATERAL\n#include <packing>\nuniform vec2 cameraNearFar;\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nfloat getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}\n#ifdef PERSPECTIVE_CAMERA\n#define linearDepth(v) viewZToOrthographicDepth(getViewZ(readDepth(v)), cameraNearFar.x, cameraNearFar.y)\n#else\n#define linearDepth(v) readDepth(v)\n#endif\n#endif\n#define getTexel(v) texture2D(inputBuffer, v)\n#if KERNEL_SIZE == 3\nvarying vec2 vUv00,vUv01,vUv02;varying vec2 vUv03,vUv04,vUv05;varying vec2 vUv06,vUv07,vUv08;\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\nvarying vec2 vUv00,vUv01,vUv02,vUv03,vUv04;varying vec2 vUv05,vUv06,vUv07,vUv08,vUv09;varying vec2 vUv10,vUv11,vUv12,vUv13,vUv14;varying vec2 vUv15,vUv16,vUv17,vUv18,vUv19;varying vec2 vUv20,vUv21,vUv22,vUv23,vUv24;\n#else\nuniform vec2 texelSize;uniform float scale;varying vec2 vUv;\n#endif\nvoid main(){\n#if KERNEL_SIZE == 3\nvec4 c[]=vec4[KERNEL_SIZE_SQ](getTexel(vUv00),getTexel(vUv01),getTexel(vUv02),getTexel(vUv03),getTexel(vUv04),getTexel(vUv05),getTexel(vUv06),getTexel(vUv07),getTexel(vUv08));\n#ifdef BILATERAL\nfloat z[]=float[KERNEL_SIZE_SQ](linearDepth(vUv00),linearDepth(vUv01),linearDepth(vUv02),linearDepth(vUv03),linearDepth(vUv04),linearDepth(vUv05),linearDepth(vUv06),linearDepth(vUv07),linearDepth(vUv08));\n#endif\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\nvec4 c[]=vec4[KERNEL_SIZE_SQ](getTexel(vUv00),getTexel(vUv01),getTexel(vUv02),getTexel(vUv03),getTexel(vUv04),getTexel(vUv05),getTexel(vUv06),getTexel(vUv07),getTexel(vUv08),getTexel(vUv09),getTexel(vUv10),getTexel(vUv11),getTexel(vUv12),getTexel(vUv13),getTexel(vUv14),getTexel(vUv15),getTexel(vUv16),getTexel(vUv17),getTexel(vUv18),getTexel(vUv19),getTexel(vUv20),getTexel(vUv21),getTexel(vUv22),getTexel(vUv23),getTexel(vUv24));\n#ifdef BILATERAL\nfloat z[]=float[KERNEL_SIZE_SQ](linearDepth(vUv00),linearDepth(vUv01),linearDepth(vUv02),linearDepth(vUv03),linearDepth(vUv04),linearDepth(vUv05),linearDepth(vUv06),linearDepth(vUv07),linearDepth(vUv08),linearDepth(vUv09),linearDepth(vUv10),linearDepth(vUv11),linearDepth(vUv12),linearDepth(vUv13),linearDepth(vUv14),linearDepth(vUv15),linearDepth(vUv16),linearDepth(vUv17),linearDepth(vUv18),linearDepth(vUv19),linearDepth(vUv20),linearDepth(vUv21),linearDepth(vUv22),linearDepth(vUv23),linearDepth(vUv24));\n#endif\n#endif\nvec4 result=vec4(0.0);\n#ifdef BILATERAL\nfloat w=0.0;\n#if KERNEL_SIZE == 3 || (KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13)\nfloat centerDepth=z[KERNEL_SIZE_SQ_HALF];for(int i=0;i<KERNEL_SIZE_SQ;++i){float d=step(abs(z[i]-centerDepth),DISTANCE_THRESHOLD);result+=c[i]*d;w+=d;}\n#else\nfloat centerDepth=linearDepth(vUv);vec2 s=texelSize*scale;for(int x=-KERNEL_SIZE_HALF;x<=KERNEL_SIZE_HALF;++x){for(int y=-KERNEL_SIZE_HALF;y<=KERNEL_SIZE_HALF;++y){vec2 coords=vUv+vec2(x,y)*s;vec4 c=getTexel(coords);float z=(x==0&&y==0)?centerDepth:linearDepth(coords);float d=step(abs(z-centerDepth),DISTANCE_THRESHOLD);result+=c*d;w+=d;}}\n#endif\ngl_FragColor=result/max(w,1.0);\n#else\n#if KERNEL_SIZE == 3 || (KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13)\nfor(int i=0;i<KERNEL_SIZE_SQ;++i){result+=c[i];}\n#else\nvec2 s=texelSize*scale;for(int x=-KERNEL_SIZE_HALF;x<=KERNEL_SIZE_HALF;++x){for(int y=-KERNEL_SIZE_HALF;y<=KERNEL_SIZE_HALF;++y){result+=getTexel(uv+vec2(x,y)*s);}}\n#endif\ngl_FragColor=result*INV_KERNEL_SIZE_SQ;\n#endif\n}";

// src/materials/glsl/convolution.box.vert
var convolution_box_default2 = "uniform vec2 texelSize;uniform float scale;\n#if KERNEL_SIZE == 3\nvarying vec2 vUv00,vUv01,vUv02;varying vec2 vUv03,vUv04,vUv05;varying vec2 vUv06,vUv07,vUv08;\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\nvarying vec2 vUv00,vUv01,vUv02,vUv03,vUv04;varying vec2 vUv05,vUv06,vUv07,vUv08,vUv09;varying vec2 vUv10,vUv11,vUv12,vUv13,vUv14;varying vec2 vUv15,vUv16,vUv17,vUv18,vUv19;varying vec2 vUv20,vUv21,vUv22,vUv23,vUv24;\n#else\nvarying vec2 vUv;\n#endif\nvoid main(){vec2 uv=position.xy*0.5+0.5;\n#if KERNEL_SIZE == 3\nvec2 s=texelSize*scale;vUv00=uv+s*vec2(-1.0,-1.0);vUv01=uv+s*vec2(0.0,-1.0);vUv02=uv+s*vec2(1.0,-1.0);vUv03=uv+s*vec2(-1.0,0.0);vUv04=uv;vUv05=uv+s*vec2(1.0,0.0);vUv06=uv+s*vec2(-1.0,1.0);vUv07=uv+s*vec2(0.0,1.0);vUv08=uv+s*vec2(1.0,1.0);\n#elif KERNEL_SIZE == 5\nvec2 s=texelSize*scale;vUv00=uv+s*vec2(-2.0,-2.0);vUv01=uv+s*vec2(-1.0,-2.0);vUv02=uv+s*vec2(0.0,-2.0);vUv03=uv+s*vec2(1.0,-2.0);vUv04=uv+s*vec2(2.0,-2.0);vUv05=uv+s*vec2(-2.0,-1.0);vUv06=uv+s*vec2(-1.0,-1.0);vUv07=uv+s*vec2(0.0,-1.0);vUv08=uv+s*vec2(1.0,-1.0);vUv09=uv+s*vec2(2.0,-1.0);vUv10=uv+s*vec2(-2.0,0.0);vUv11=uv+s*vec2(-1.0,0.0);vUv12=uv;vUv13=uv+s*vec2(1.0,0.0);vUv14=uv+s*vec2(2.0,0.0);vUv15=uv+s*vec2(-2.0,1.0);vUv16=uv+s*vec2(-1.0,1.0);vUv17=uv+s*vec2(0.0,1.0);vUv18=uv+s*vec2(1.0,1.0);vUv19=uv+s*vec2(2.0,1.0);vUv20=uv+s*vec2(-2.0,2.0);vUv21=uv+s*vec2(-1.0,2.0);vUv22=uv+s*vec2(0.0,2.0);vUv23=uv+s*vec2(1.0,2.0);vUv24=uv+s*vec2(2.0,2.0);\n#else\nvUv=uv;\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/BoxBlurMaterial.js
var BoxBlurMaterial = class extends import_three69.ShaderMaterial {
  /**
   * Constructs a new box blur material.
   *
   * @param {Object} [options] - The options.
   * @param {Number} [options.bilateral=false] - Enables or disables bilateral blurring.
   * @param {Number} [options.kernelSize=5] - The kernel size.
   */
  constructor({ bilateral = false, kernelSize = 5 } = {}) {
    super({
      name: "BoxBlurMaterial",
      defines: {
        DEPTH_PACKING: "0",
        DISTANCE_THRESHOLD: "0.1"
      },
      uniforms: {
        inputBuffer: new import_three69.Uniform(null),
        depthBuffer: new import_three69.Uniform(null),
        normalDepthBuffer: new import_three69.Uniform(null),
        texelSize: new import_three69.Uniform(new import_three69.Vector2()),
        cameraNearFar: new import_three69.Uniform(new import_three69.Vector2()),
        scale: new import_three69.Uniform(1)
      },
      blending: import_three69.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_box_default,
      vertexShader: convolution_box_default2
    });
    this.bilateral = bilateral;
    this.kernelSize = kernelSize;
    this.maxVaryingVectors = 8;
  }
  /**
   * The maximum amount of varying vectors.
   *
   * Should be synced with `renderer.capabilities.maxVaryings`. Default is 8.
   *
   * @type {Number}
   */
  set maxVaryingVectors(value) {
    this.defines.MAX_VARYING_VECTORS = value.toFixed(0);
  }
  /**
   * The kernel size.
   *
   * - Must be an odd number
   * - Kernel size 3 and 5 use optimized code paths
   * - Default is 5
   *
   * @type {Number}
   */
  get kernelSize() {
    return Number(this.defines.KERNEL_SIZE);
  }
  set kernelSize(value) {
    if (value % 2 === 0) {
      throw new Error("The kernel size must be an odd number");
    }
    this.defines.KERNEL_SIZE = value.toFixed(0);
    this.defines.KERNEL_SIZE_HALF = Math.floor(value / 2).toFixed(0);
    this.defines.KERNEL_SIZE_SQ = (value ** 2).toFixed(0);
    this.defines.KERNEL_SIZE_SQ_HALF = Math.floor(value ** 2 / 2).toFixed(0);
    this.defines.INV_KERNEL_SIZE_SQ = (1 / value ** 2).toFixed(6);
    this.needsUpdate = true;
  }
  /**
   * The blur scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * The current near plane setting.
   *
   * @type {Number}
   * @private
   */
  get near() {
    return this.uniforms.cameraNearFar.value.x;
  }
  /**
   * The current far plane setting.
   *
   * @type {Number}
   * @private
   */
  get far() {
    return this.uniforms.cameraNearFar.value.y;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * A combined normal-depth buffer. Overrides {@link depthBuffer} if set.
   *
   * @type {Texture}
   */
  set normalDepthBuffer(value) {
    this.uniforms.normalDepthBuffer.value = value;
    if (value !== null) {
      this.defines.NORMAL_DEPTH = "1";
    } else {
      delete this.defines.NORMAL_DEPTH;
    }
    this.needsUpdate = true;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Indicates whether bilateral filtering is enabled.
   *
   * @type {Boolean}
   */
  get bilateral() {
    return this.defines.BILATERAL !== void 0;
  }
  set bilateral(value) {
    if (value !== null) {
      this.defines.BILATERAL = "1";
    } else {
      delete this.defines.BILATERAL;
    }
    this.needsUpdate = true;
  }
  /**
   * The bilateral filter distance threshold in world units.
   *
   * @type {Number}
   */
  get worldDistanceThreshold() {
    return -orthographicDepthToViewZ(Number(this.defines.DISTANCE_THRESHOLD), this.near, this.far);
  }
  set worldDistanceThreshold(value) {
    const threshold = viewZToOrthographicDepth(-value, this.near, this.far);
    this.defines.DISTANCE_THRESHOLD = threshold.toFixed(12);
    this.needsUpdate = true;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);
      if (camera instanceof import_three69.PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/materials/DepthCopyMaterial.js
var import_three70 = __webpack_require__(39437);

// src/materials/glsl/depth-copy.frag
var depth_copy_default = "#include <packing>\nvarying vec2 vUv;\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\n#if INPUT_DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if INPUT_DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nvoid main(){\n#if INPUT_DEPTH_PACKING == OUTPUT_DEPTH_PACKING\ngl_FragColor=texture2D(depthBuffer,vUv);\n#else\nfloat depth=readDepth(vUv);\n#if OUTPUT_DEPTH_PACKING == 3201\ngl_FragColor=(depth==1.0)?vec4(1.0):packDepthToRGBA(depth);\n#else\ngl_FragColor=vec4(vec3(depth),1.0);\n#endif\n#endif\n}";

// src/materials/glsl/depth-copy.vert
var depth_copy_default2 = "varying vec2 vUv;\n#if DEPTH_COPY_MODE == 1\nuniform vec2 texelPosition;\n#endif\nvoid main(){\n#if DEPTH_COPY_MODE == 1\nvUv=texelPosition;\n#else\nvUv=position.xy*0.5+0.5;\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/DepthCopyMaterial.js
var DepthCopyMaterial = class extends import_three70.ShaderMaterial {
  /**
   * Constructs a new depth copy material.
   */
  constructor() {
    super({
      name: "DepthCopyMaterial",
      defines: {
        INPUT_DEPTH_PACKING: "0",
        OUTPUT_DEPTH_PACKING: "0",
        DEPTH_COPY_MODE: "0"
      },
      uniforms: {
        depthBuffer: new import_three70.Uniform(null),
        texelPosition: new import_three70.Uniform(new import_three70.Vector2())
      },
      blending: import_three70.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_copy_default,
      vertexShader: depth_copy_default2
    });
    this.depthCopyMode = DepthCopyMode.FULL;
  }
  /**
   * The input depth buffer.
   *
   * @type {Texture}
   */
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The input depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set inputDepthPacking(value) {
    this.defines.INPUT_DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * The output depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  get outputDepthPacking() {
    return Number(this.defines.OUTPUT_DEPTH_PACKING);
  }
  set outputDepthPacking(value) {
    this.defines.OUTPUT_DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the input depth buffer.
   *
   * @deprecated Use depthBuffer and inputDepthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = import_three70.BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.inputDepthPacking = depthPacking;
  }
  /**
   * Returns the current input depth packing strategy.
   *
   * @deprecated
   * @return {DepthPackingStrategies} The input depth packing strategy.
   */
  getInputDepthPacking() {
    return Number(this.defines.INPUT_DEPTH_PACKING);
  }
  /**
   * Sets the input depth packing strategy.
   *
   * @deprecated Use inputDepthPacking instead.
   * @param {DepthPackingStrategies} value - The new input depth packing strategy.
   */
  setInputDepthPacking(value) {
    this.defines.INPUT_DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the current output depth packing strategy.
   *
   * @deprecated Use outputDepthPacking instead.
   * @return {DepthPackingStrategies} The output depth packing strategy.
   */
  getOutputDepthPacking() {
    return Number(this.defines.OUTPUT_DEPTH_PACKING);
  }
  /**
   * Sets the output depth packing strategy.
   *
   * @deprecated Use outputDepthPacking instead.
   * @param {DepthPackingStrategies} value - The new output depth packing strategy.
   */
  setOutputDepthPacking(value) {
    this.defines.OUTPUT_DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * The screen space position used for single-texel copy operations.
   *
   * @type {Vector2}
   */
  get texelPosition() {
    return this.uniforms.texelPosition.value;
  }
  /**
   * Returns the screen space position used for single-texel copy operations.
   *
   * @deprecated Use texelPosition instead.
   * @return {Vector2} The position.
   */
  getTexelPosition() {
    return this.uniforms.texelPosition.value;
  }
  /**
   * Sets the screen space position used for single-texel copy operations.
   *
   * @deprecated
   * @param {Vector2} value - The position.
   */
  setTexelPosition(value) {
    this.uniforms.texelPosition.value = value;
  }
  /**
   * The depth copy mode.
   *
   * @type {DepthCopyMode}
   */
  get mode() {
    return this.depthCopyMode;
  }
  set mode(value) {
    this.depthCopyMode = value;
    this.defines.DEPTH_COPY_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the depth copy mode.
   *
   * @deprecated Use mode instead.
   * @return {DepthCopyMode} The depth copy mode.
   */
  getMode() {
    return this.mode;
  }
  /**
   * Sets the depth copy mode.
   *
   * @deprecated Use mode instead.
   * @param {DepthCopyMode} value - The new mode.
   */
  setMode(value) {
    this.mode = value;
  }
};

// src/materials/EffectMaterial.js
var import_three71 = __webpack_require__(39437);

// src/materials/glsl/effect.frag
var effect_default = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;\n#if THREE_REVISION < 143\n#define luminance(v) linearToRelativeLuminance(v)\n#endif\n#if THREE_REVISION >= 137\nvec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}";

// src/materials/glsl/effect.vert
var effect_default2 = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/EffectMaterial.js
var EffectMaterial = class extends import_three71.ShaderMaterial {
  /**
   * Constructs a new effect material.
   *
   * @param {Map<String, String>} [shaderParts] - Deprecated. Use setShaderData instead.
   * @param {Map<String, String>} [defines] - Deprecated. Use setShaderData instead.
   * @param {Map<String, Uniform>} [uniforms] - Deprecated. Use setShaderData instead.
   * @param {Camera} [camera] - A camera.
   * @param {Boolean} [dithering=false] - Deprecated.
   */
  constructor(shaderParts, defines, uniforms, camera, dithering = false) {
    super({
      name: "EffectMaterial",
      defines: {
        THREE_REVISION: import_three71.REVISION.replace(/\D+/g, ""),
        DEPTH_PACKING: "0",
        ENCODE_OUTPUT: "1"
      },
      uniforms: {
        inputBuffer: new import_three71.Uniform(null),
        depthBuffer: new import_three71.Uniform(null),
        resolution: new import_three71.Uniform(new import_three71.Vector2()),
        texelSize: new import_three71.Uniform(new import_three71.Vector2()),
        cameraNear: new import_three71.Uniform(0.3),
        cameraFar: new import_three71.Uniform(1e3),
        aspect: new import_three71.Uniform(1),
        time: new import_three71.Uniform(0)
      },
      blending: import_three71.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      dithering
    });
    if (shaderParts) {
      this.setShaderParts(shaderParts);
    }
    if (defines) {
      this.setDefines(defines);
    }
    if (uniforms) {
      this.setUniforms(uniforms);
    }
    this.copyCameraSettings(camera);
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  get depthPacking() {
    return Number(this.defines.DEPTH_PACKING);
  }
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = import_three71.BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * Sets the shader data.
   *
   * @param {EffectShaderData} data - The shader data.
   * @return {EffectMaterial} This material.
   */
  setShaderData(data) {
    this.setShaderParts(data.shaderParts);
    this.setDefines(data.defines);
    this.setUniforms(data.uniforms);
    this.setExtensions(data.extensions);
  }
  /**
   * Sets the shader parts.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, String>} shaderParts - A collection of shader snippets. See {@link EffectShaderSection}.
   * @return {EffectMaterial} This material.
   */
  setShaderParts(shaderParts) {
    this.fragmentShader = effect_default.replace(EffectShaderSection.FRAGMENT_HEAD, shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || "").replace(EffectShaderSection.FRAGMENT_MAIN_UV, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || "").replace(EffectShaderSection.FRAGMENT_MAIN_IMAGE, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || "");
    this.vertexShader = effect_default2.replace(EffectShaderSection.VERTEX_HEAD, shaderParts.get(EffectShaderSection.VERTEX_HEAD) || "").replace(EffectShaderSection.VERTEX_MAIN_SUPPORT, shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || "");
    this.fragmentShader = updateFragmentShader(this.fragmentShader);
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets the shader macros.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, String>} defines - A collection of preprocessor macro definitions.
   * @return {EffectMaterial} This material.
   */
  setDefines(defines) {
    for (const entry of defines.entries()) {
      this.defines[entry[0]] = entry[1];
    }
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets the shader uniforms.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, Uniform>} uniforms - A collection of uniforms.
   * @return {EffectMaterial} This material.
   */
  setUniforms(uniforms) {
    for (const entry of uniforms.entries()) {
      this.uniforms[entry[0]] = entry[1];
    }
    return this;
  }
  /**
   * Sets the required shader extensions.
   *
   * @deprecated Use setShaderData instead.
   * @param {Set<WebGLExtension>} extensions - A collection of extensions.
   * @return {EffectMaterial} This material.
   */
  setExtensions(extensions) {
    this.extensions = {};
    for (const extension of extensions) {
      this.extensions[extension] = true;
    }
    return this;
  }
  /**
   * Indicates whether output encoding is enabled.
   *
   * @type {Boolean}
   */
  get encodeOutput() {
    return this.defines.ENCODE_OUTPUT !== void 0;
  }
  set encodeOutput(value) {
    if (this.encodeOutput !== value) {
      if (value) {
        this.defines.ENCODE_OUTPUT = "1";
      } else {
        delete this.defines.ENCODE_OUTPUT;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Indicates whether output encoding is enabled.
   *
   * @deprecated Use encodeOutput instead.
   * @return {Boolean} Whether output encoding is enabled.
   */
  isOutputEncodingEnabled(value) {
    return this.encodeOutput;
  }
  /**
   * Enables or disables output encoding.
   *
   * @deprecated Use encodeOutput instead.
   * @param {Boolean} value - Whether output encoding should be enabled.
   */
  setOutputEncodingEnabled(value) {
    this.encodeOutput = value;
  }
  /**
   * The time in seconds.
   *
   * @type {Number}
   */
  get time() {
    return this.uniforms.time.value;
  }
  set time(value) {
    this.uniforms.time.value = value;
  }
  /**
   * Sets the delta time.
   *
   * @deprecated Use time instead.
   * @param {Number} value - The delta time in seconds.
   */
  setDeltaTime(value) {
    this.uniforms.time.value += value;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof import_three71.PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Sets the resolution.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    uniforms.resolution.value.set(width, height);
    uniforms.texelSize.value.set(1 / width, 1 / height);
    uniforms.aspect.value = width / height;
  }
  /**
   * An enumeration of shader code placeholders.
   *
   * @deprecated Use EffectShaderSection instead.
   * @type {Object}
   */
  static get Section() {
    return EffectShaderSection;
  }
};

// src/materials/GaussianBlurMaterial.js
var import_three72 = __webpack_require__(39437);

// src/materials/glsl/convolution.gaussian.frag
var convolution_gaussian_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform vec2 kernel[STEPS];varying vec2 vOffset;varying vec2 vUv;void main(){vec4 result=texture2D(inputBuffer,vUv)*kernel[0].y;for(int i=1;i<STEPS;++i){vec2 offset=kernel[i].x*vOffset;vec4 c0=texture2D(inputBuffer,vUv+offset);vec4 c1=texture2D(inputBuffer,vUv-offset);result+=(c0+c1)*kernel[i].y;}gl_FragColor=result;\n#include <colorspace_fragment>\n}";

// src/materials/glsl/convolution.gaussian.vert
var convolution_gaussian_default2 = "uniform vec2 texelSize;uniform vec2 direction;uniform float scale;varying vec2 vOffset;varying vec2 vUv;void main(){vOffset=direction*texelSize*scale;vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/GaussianBlurMaterial.js
var GaussianBlurMaterial = class extends import_three72.ShaderMaterial {
  /**
   * Constructs a new convolution material.
   *
   * @param {Object} [options] - The options.
   * @param {Number} [options.kernelSize=35] - The kernel size.
   */
  constructor({ kernelSize = 35 } = {}) {
    super({
      name: "GaussianBlurMaterial",
      uniforms: {
        inputBuffer: new import_three72.Uniform(null),
        texelSize: new import_three72.Uniform(new import_three72.Vector2()),
        direction: new import_three72.Uniform(new import_three72.Vector2()),
        kernel: new import_three72.Uniform(null),
        scale: new import_three72.Uniform(1)
      },
      blending: import_three72.NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_gaussian_default,
      vertexShader: convolution_gaussian_default2
    });
    this.fragmentShader = updateFragmentShader(this.fragmentShader);
    this._kernelSize = 0;
    this.kernelSize = kernelSize;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The kernel size.
   *
   * @type {Number}
   */
  get kernelSize() {
    return this._kernelSize;
  }
  set kernelSize(value) {
    this._kernelSize = value;
    this.generateKernel(value);
  }
  /**
   * The blur direction.
   *
   * @type {Vector2}
   */
  get direction() {
    return this.uniforms.direction.value;
  }
  /**
   * The blur kernel scale. Values greater than 1.0 may introduce artifacts.
   *
   * @type {Number}
   */
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Generates the Gauss kernel.
   *
   * @param {KernelSize} kernelSize - The kernel size. Should be an odd number.
   * @private
   */
  generateKernel(kernelSize) {
    const kernel = new GaussKernel(kernelSize);
    const steps = kernel.linearSteps;
    const kernelData = new Float64Array(steps * 2);
    for (let i = 0, j = 0; i < steps; ++i) {
      kernelData[j++] = kernel.linearOffsets[i];
      kernelData[j++] = kernel.linearWeights[i];
    }
    this.uniforms.kernel.value = kernelData;
    this.defines.STEPS = steps.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/passes/BoxBlurPass.js
var import_three73 = __webpack_require__(39437);
var BoxBlurPass = class extends Pass {
  /**
   * Constructs a new box blur pass.
   *
   * @param {Object} [options] - The options.
   * @param {Number} [options.kernelSize=5] - Must be an odd number. The sizes 3 and 5 use optimized code paths.
   * @param {Number} [options.iterations=1] - The amount of times the blur should be applied.
   * @param {Number} [options.bilateral=false] - Enables or disables bilateral blurring.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   */
  constructor({
    kernelSize = 5,
    iterations = 1,
    bilateral = false,
    resolutionScale = 1,
    resolutionX = Resolution.AUTO_SIZE,
    resolutionY = Resolution.AUTO_SIZE
  } = {}) {
    super("BoxBlurPass");
    this.needsDepthTexture = bilateral;
    this.renderTargetA = new import_three73.WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetA.texture.name = "Blur.Target.A";
    this.renderTargetB = new import_three73.WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetB.texture.name = "Blur.Target.B";
    this.blurMaterial = new BoxBlurMaterial({ bilateral, kernelSize });
    this.copyMaterial = new CopyMaterial();
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.iterations = iterations;
  }
  set mainCamera(value) {
    this.blurMaterial.copyCameraSettings(value);
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthTexture(depthTexture, depthPacking = import_three73.BasicDepthPacking) {
    this.blurMaterial.depthBuffer = depthTexture;
    this.blurMaterial.depthPacking = depthPacking;
  }
  /**
   * Renders the blur.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    const blurMaterial = this.blurMaterial;
    this.fullscreenMaterial = blurMaterial;
    let previousBuffer = inputBuffer;
    for (let i = 0, l = Math.max(this.iterations, 1); i < l; ++i) {
      const buffer = (i & 1) === 0 ? renderTargetA : renderTargetB;
      blurMaterial.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(buffer);
      renderer.render(scene, camera);
      previousBuffer = buffer;
    }
    this.copyMaterial.inputBuffer = previousBuffer.texture;
    this.fullscreenMaterial = this.copyMaterial;
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(scene, camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.renderTargetA.setSize(w, h);
    this.renderTargetB.setSize(w, h);
    this.blurMaterial.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (renderer !== null) {
      this.blurMaterial.maxVaryingVectors = renderer.capabilities.maxVaryings;
    }
    if (frameBufferType !== void 0) {
      this.renderTargetA.texture.type = frameBufferType;
      this.renderTargetB.texture.type = frameBufferType;
      if (frameBufferType !== import_three73.UnsignedByteType) {
        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === import_three73.SRGBColorSpace) {
        this.renderTargetA.texture.colorSpace = import_three73.SRGBColorSpace;
        this.renderTargetB.texture.colorSpace = import_three73.SRGBColorSpace;
      }
    }
  }
};

// src/passes/DepthPickingPass.js
var import_three75 = __webpack_require__(39437);

// src/passes/DepthCopyPass.js
var import_three74 = __webpack_require__(39437);
var DepthCopyPass = class extends Pass {
  /**
   * Constructs a new depth save pass.
   *
   * @param {Object} [options] - The options.
   * @param {DepthPackingStrategies} [options.depthPacking=RGBADepthPacking] - The output depth packing.
   */
  constructor({ depthPacking = import_three74.RGBADepthPacking } = {}) {
    super("DepthCopyPass");
    const material = new DepthCopyMaterial();
    material.outputDepthPacking = depthPacking;
    this.fullscreenMaterial = material;
    this.needsDepthTexture = true;
    this.needsSwap = false;
    this.renderTarget = new import_three74.WebGLRenderTarget(1, 1, {
      type: depthPacking === import_three74.RGBADepthPacking ? import_three74.UnsignedByteType : import_three74.FloatType,
      minFilter: import_three74.NearestFilter,
      magFilter: import_three74.NearestFilter,
      depthBuffer: false
    });
    this.renderTarget.texture.name = "DepthCopyPass.Target";
  }
  /**
   * The output depth texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the output depth texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * The output depth packing.
   *
   * @type {DepthPackingStrategies}
   */
  get depthPacking() {
    return this.fullscreenMaterial.outputDepthPacking;
  }
  /**
   * Returns the output depth packing.
   *
   * @deprecated Use depthPacking instead.
   * @return {DepthPackingStrategies} The depth packing.
   */
  getDepthPacking() {
    return this.fullscreenMaterial.outputDepthPacking;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = import_three74.BasicDepthPacking) {
    this.fullscreenMaterial.depthBuffer = depthTexture;
    this.fullscreenMaterial.inputDepthPacking = depthPacking;
  }
  /**
   * Copies depth from a depth texture.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.renderTarget.setSize(width, height);
  }
};

// src/passes/DepthPickingPass.js
var unpackFactors = new Float32Array([
  255 / 256 / 256 ** 3,
  255 / 256 / 256 ** 2,
  255 / 256 / 256,
  255 / 256
]);
function unpackRGBAToDepth(packedDepth) {
  return (packedDepth[0] * unpackFactors[0] + packedDepth[1] * unpackFactors[1] + packedDepth[2] * unpackFactors[2] + packedDepth[3] * unpackFactors[3]) / 255;
}
var DepthPickingPass = class extends DepthCopyPass {
  /**
   * Constructs a new depth picking pass.
   *
   * @param {Object} [options] - The options.
   * @param {DepthPackingStrategies} [options.depthPacking=RGBADepthPacking] - The depth packing.
   * @param {Number} [options.mode=DepthCopyMode.SINGLE] - The depth copy mode.
   */
  constructor({ depthPacking = import_three75.RGBADepthPacking, mode = DepthCopyMode.SINGLE } = {}) {
    super({ depthPacking });
    this.name = "DepthPickingPass";
    this.fullscreenMaterial.mode = mode;
    this.pixelBuffer = depthPacking === import_three75.RGBADepthPacking ? new Uint8Array(4) : new Float32Array(4);
    this.callback = null;
  }
  /**
   * Reads depth at a specific screen position.
   *
   * Only one depth value can be picked per frame. Calling this method multiple times per frame will overwrite the
   * picking coordinates. Unresolved promises will be abandoned.
   *
   * @example
   * const ndc = new Vector3();
   * const clientRect = myViewport.getBoundingClientRect();
   * const clientX = pointerEvent.clientX - clientRect.left;
   * const clientY = pointerEvent.clientY - clientRect.top;
   * ndc.x = (clientX / myViewport.clientWidth) * 2.0 - 1.0;
   * ndc.y = -(clientY / myViewport.clientHeight) * 2.0 + 1.0;
   * const depth = await depthPickingPass.readDepth(ndc);
   * ndc.z = depth * 2.0 - 1.0;
   *
   * const worldPosition = ndc.unproject(camera);
   *
   * @param {Vector2|Vector3} ndc - Normalized device coordinates. Only X and Y are relevant.
   * @return {Promise<Number>} A promise that returns the depth on the next frame.
   */
  readDepth(ndc) {
    this.fullscreenMaterial.texelPosition.set(ndc.x * 0.5 + 0.5, ndc.y * 0.5 + 0.5);
    return new Promise((resolve) => {
      this.callback = resolve;
    });
  }
  /**
   * Copies depth and resolves depth picking promises.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const material = this.fullscreenMaterial;
    const mode = material.mode;
    if (mode === DepthCopyMode.FULL) {
      super.render(renderer);
    }
    if (this.callback !== null) {
      const renderTarget = this.renderTarget;
      const pixelBuffer = this.pixelBuffer;
      const packed = renderTarget.texture.type !== import_three75.FloatType;
      let x = 0, y = 0;
      if (mode === DepthCopyMode.SINGLE) {
        super.render(renderer);
      } else {
        const texelPosition = material.texelPosition;
        x = Math.round(texelPosition.x * renderTarget.width);
        y = Math.round(texelPosition.y * renderTarget.height);
      }
      renderer.readRenderTargetPixels(renderTarget, x, y, 1, 1, pixelBuffer);
      this.callback(packed ? unpackRGBAToDepth(pixelBuffer) : pixelBuffer[0]);
      this.callback = null;
    }
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    if (this.fullscreenMaterial.mode === DepthCopyMode.FULL) {
      super.setSize(width, height);
    }
  }
};

// src/passes/EffectPass.js
var import_three76 = __webpack_require__(39437);
function prefixSubstrings(prefix, substrings, strings) {
  for (const substring of substrings) {
    const prefixed = "$1" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);
    const regExp = new RegExp("([^\\.])(\\b" + substring + "\\b)", "g");
    for (const entry of strings.entries()) {
      if (entry[1] !== null) {
        strings.set(entry[0], entry[1].replace(regExp, prefixed));
      }
    }
  }
}
function integrateEffect(prefix, effect, data) {
  let fragmentShader = effect.getFragmentShader();
  let vertexShader = effect.getVertexShader();
  const mainImageExists = fragmentShader !== void 0 && /mainImage/.test(fragmentShader);
  const mainUvExists = fragmentShader !== void 0 && /mainUv/.test(fragmentShader);
  data.attributes |= effect.getAttributes();
  if (fragmentShader === void 0) {
    throw new Error(`Missing fragment shader (${effect.name})`);
  } else if (mainUvExists && (data.attributes & EffectAttribute.CONVOLUTION) !== 0) {
    throw new Error(`Effects that transform UVs are incompatible with convolution effects (${effect.name})`);
  } else if (!mainImageExists && !mainUvExists) {
    throw new Error(`Could not find mainImage or mainUv function (${effect.name})`);
  } else {
    const functionRegExp = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g;
    const shaderParts = data.shaderParts;
    let fragmentHead = shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || "";
    let fragmentMainUv = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || "";
    let fragmentMainImage = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || "";
    let vertexHead = shaderParts.get(EffectShaderSection.VERTEX_HEAD) || "";
    let vertexMainSupport = shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || "";
    const varyings = /* @__PURE__ */ new Set();
    const names = /* @__PURE__ */ new Set();
    if (mainUvExists) {
      fragmentMainUv += `	${prefix}MainUv(UV);
`;
      data.uvTransformation = true;
    }
    if (vertexShader !== null && /mainSupport/.test(vertexShader)) {
      const needsUv = /mainSupport *\([\w\s]*?uv\s*?\)/.test(vertexShader);
      vertexMainSupport += `	${prefix}MainSupport(`;
      vertexMainSupport += needsUv ? "vUv);\n" : ");\n";
      for (const m2 of vertexShader.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g)) {
        for (const n of m2[1].split(/\s*,\s*/)) {
          data.varyings.add(n);
          varyings.add(n);
          names.add(n);
        }
      }
      for (const m2 of vertexShader.matchAll(functionRegExp)) {
        names.add(m2[1]);
      }
    }
    for (const m2 of fragmentShader.matchAll(functionRegExp)) {
      names.add(m2[1]);
    }
    for (const d of effect.defines.keys()) {
      names.add(d.replace(/\([\w\s,]*\)/g, ""));
    }
    for (const u of effect.uniforms.keys()) {
      names.add(u);
    }
    names.delete("while");
    names.delete("for");
    names.delete("if");
    effect.uniforms.forEach((val, key) => data.uniforms.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));
    effect.defines.forEach((val, key) => data.defines.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));
    const shaders = /* @__PURE__ */ new Map([["fragment", fragmentShader], ["vertex", vertexShader]]);
    prefixSubstrings(prefix, names, data.defines);
    prefixSubstrings(prefix, names, shaders);
    fragmentShader = shaders.get("fragment");
    vertexShader = shaders.get("vertex");
    const blendMode = effect.blendMode;
    data.blendModes.set(blendMode.blendFunction, blendMode);
    if (mainImageExists) {
      if (effect.inputColorSpace !== null && effect.inputColorSpace !== data.colorSpace) {
        fragmentMainImage += effect.inputColorSpace === import_three76.SRGBColorSpace ? "color0 = LinearTosRGB(color0);\n	" : "color0 = sRGBToLinear(color0);\n	";
      }
      if (effect.outputColorSpace !== import_three76.NoColorSpace) {
        data.colorSpace = effect.outputColorSpace;
      } else if (effect.inputColorSpace !== null) {
        data.colorSpace = effect.inputColorSpace;
      }
      const depthParamRegExp = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
      fragmentMainImage += `${prefix}MainImage(color0, UV, `;
      if ((data.attributes & EffectAttribute.DEPTH) !== 0 && depthParamRegExp.test(fragmentShader)) {
        fragmentMainImage += "depth, ";
        data.readDepth = true;
      }
      fragmentMainImage += "color1);\n	";
      const blendOpacity = prefix + "BlendOpacity";
      data.uniforms.set(blendOpacity, blendMode.opacity);
      fragmentMainImage += `color0 = blend${blendMode.blendFunction}(color0, color1, ${blendOpacity});

	`;
      fragmentHead += `uniform float ${blendOpacity};

`;
    }
    fragmentHead += fragmentShader + "\n";
    if (vertexShader !== null) {
      vertexHead += vertexShader + "\n";
    }
    shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);
    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);
    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);
    shaderParts.set(EffectShaderSection.VERTEX_HEAD, vertexHead);
    shaderParts.set(EffectShaderSection.VERTEX_MAIN_SUPPORT, vertexMainSupport);
    if (effect.extensions !== null) {
      for (const extension of effect.extensions) {
        data.extensions.add(extension);
      }
    }
  }
}
var EffectPass = class extends Pass {
  /**
   * Constructs a new effect pass.
   *
   * @param {Camera} camera - The main camera.
   * @param {...Effect} effects - The effects that will be rendered by this pass.
   */
  constructor(camera, ...effects) {
    super("EffectPass");
    this.fullscreenMaterial = new EffectMaterial(null, null, null, camera);
    this.listener = (event) => this.handleEvent(event);
    this.effects = [];
    this.setEffects(effects);
    this.skipRendering = false;
    this.minTime = 1;
    this.maxTime = Number.POSITIVE_INFINITY;
    this.timeScale = 1;
  }
  set mainScene(value) {
    for (const effect of this.effects) {
      effect.mainScene = value;
    }
  }
  set mainCamera(value) {
    this.fullscreenMaterial.copyCameraSettings(value);
    for (const effect of this.effects) {
      effect.mainCamera = value;
    }
  }
  /**
   * Indicates whether this pass encodes its output when rendering to screen.
   *
   * @type {Boolean}
   * @deprecated Use fullscreenMaterial.encodeOutput instead.
   */
  get encodeOutput() {
    return this.fullscreenMaterial.encodeOutput;
  }
  set encodeOutput(value) {
    this.fullscreenMaterial.encodeOutput = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   */
  get dithering() {
    return this.fullscreenMaterial.dithering;
  }
  set dithering(value) {
    const material = this.fullscreenMaterial;
    material.dithering = value;
    material.needsUpdate = true;
  }
  /**
   * Sets the effects.
   *
   * @param {Effect[]} effects - The effects.
   * @protected
   */
  setEffects(effects) {
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.listener);
    }
    this.effects = effects.sort((a, b) => b.attributes - a.attributes);
    for (const effect of this.effects) {
      effect.addEventListener("change", this.listener);
    }
  }
  /**
   * Updates the compound shader material.
   *
   * @protected
   */
  updateMaterial() {
    const data = new EffectShaderData();
    let id = 0;
    for (const effect of this.effects) {
      if (effect.blendMode.blendFunction === BlendFunction.DST) {
        data.attributes |= effect.getAttributes() & EffectAttribute.DEPTH;
      } else if ((data.attributes & effect.getAttributes() & EffectAttribute.CONVOLUTION) !== 0) {
        throw new Error(`Convolution effects cannot be merged (${effect.name})`);
      } else {
        integrateEffect("e" + id++, effect, data);
      }
    }
    let fragmentHead = data.shaderParts.get(EffectShaderSection.FRAGMENT_HEAD);
    let fragmentMainImage = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE);
    let fragmentMainUv = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV);
    const blendRegExp = /\bblend\b/g;
    for (const blendMode of data.blendModes.values()) {
      fragmentHead += blendMode.getShaderCode().replace(blendRegExp, `blend${blendMode.blendFunction}`) + "\n";
    }
    if ((data.attributes & EffectAttribute.DEPTH) !== 0) {
      if (data.readDepth) {
        fragmentMainImage = "float depth = readDepth(UV);\n\n	" + fragmentMainImage;
      }
      this.needsDepthTexture = this.getDepthTexture() === null;
    } else {
      this.needsDepthTexture = false;
    }
    if (data.colorSpace === import_three76.SRGBColorSpace) {
      fragmentMainImage += "color0 = sRGBToLinear(color0);\n	";
    }
    if (data.uvTransformation) {
      fragmentMainUv = "vec2 transformedUv = vUv;\n" + fragmentMainUv;
      data.defines.set("UV", "transformedUv");
    } else {
      data.defines.set("UV", "vUv");
    }
    data.shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);
    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);
    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);
    for (const [key, value] of data.shaderParts) {
      if (value !== null) {
        data.shaderParts.set(key, value.trim().replace(/^#/, "\n#"));
      }
    }
    this.skipRendering = id === 0;
    this.needsSwap = !this.skipRendering;
    this.fullscreenMaterial.setShaderData(data);
  }
  /**
   * Rebuilds the shader material.
   */
  recompile() {
    this.updateMaterial();
  }
  /**
   * Returns the current depth texture.
   *
   * @return {Texture} The current depth texture, or null if there is none.
   */
  getDepthTexture() {
    return this.fullscreenMaterial.depthBuffer;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = import_three76.BasicDepthPacking) {
    this.fullscreenMaterial.depthBuffer = depthTexture;
    this.fullscreenMaterial.depthPacking = depthPacking;
    for (const effect of this.effects) {
      effect.setDepthTexture(depthTexture, depthPacking);
    }
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    for (const effect of this.effects) {
      effect.update(renderer, inputBuffer, deltaTime);
    }
    if (!this.skipRendering || this.renderToScreen) {
      const material = this.fullscreenMaterial;
      material.inputBuffer = inputBuffer.texture;
      material.time += deltaTime * this.timeScale;
      renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
      renderer.render(this.scene, this.camera);
    }
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.fullscreenMaterial.setSize(width, height);
    for (const effect of this.effects) {
      effect.setSize(width, height);
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.renderer = renderer;
    for (const effect of this.effects) {
      effect.initialize(renderer, alpha, frameBufferType);
    }
    this.updateMaterial();
    if (frameBufferType !== void 0 && frameBufferType !== import_three76.UnsignedByteType) {
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
  /**
   * Deletes disposable objects.
   */
  dispose() {
    super.dispose();
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.listener);
      effect.dispose();
    }
  }
  /**
   * Handles events.
   *
   * @param {Event} event - An event.
   */
  handleEvent(event) {
    switch (event.type) {
      case "change":
        this.recompile();
        break;
    }
  }
};

// src/passes/GaussianBlurPass.js
var import_three77 = __webpack_require__(39437);
var GaussianBlurPass = class extends Pass {
  /**
   * Constructs a new Gaussian blur pass.
   *
   * @param {Object} [options] - The options.
   * @param {Number} [options.kernelSize=35] - The kernel size. Should be an odd number in the range [3, 1020].
   * @param {Number} [options.iterations=1] - The amount of times the blur should be applied.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   */
  constructor({
    kernelSize = 35,
    iterations = 1,
    resolutionScale = 1,
    resolutionX = Resolution.AUTO_SIZE,
    resolutionY = Resolution.AUTO_SIZE
  } = {}) {
    super("GaussianBlurPass");
    this.renderTargetA = new import_three77.WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetA.texture.name = "Blur.Target.A";
    this.renderTargetB = this.renderTargetA.clone();
    this.renderTargetB.texture.name = "Blur.Target.B";
    this.blurMaterial = new GaussianBlurMaterial({ kernelSize });
    this.copyMaterial = new CopyMaterial();
    this.copyMaterial.inputBuffer = this.renderTargetB.texture;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.iterations = iterations;
  }
  /**
   * Renders the blur.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    const blurMaterial = this.blurMaterial;
    this.fullscreenMaterial = blurMaterial;
    let previousBuffer = inputBuffer;
    for (let i = 0, l = Math.max(this.iterations, 1); i < l; ++i) {
      blurMaterial.direction.set(1, 0);
      blurMaterial.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(renderTargetA);
      renderer.render(scene, camera);
      blurMaterial.direction.set(0, 1);
      blurMaterial.inputBuffer = renderTargetA.texture;
      renderer.setRenderTarget(renderTargetB);
      renderer.render(scene, camera);
      if (i === 0 && l > 1) {
        previousBuffer = renderTargetB;
      }
    }
    this.fullscreenMaterial = this.copyMaterial;
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(scene, camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.renderTargetA.setSize(w, h);
    this.renderTargetB.setSize(w, h);
    this.blurMaterial.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      this.renderTargetA.texture.type = frameBufferType;
      this.renderTargetB.texture.type = frameBufferType;
      if (frameBufferType !== import_three77.UnsignedByteType) {
        this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === import_three77.SRGBColorSpace) {
        this.renderTargetA.texture.colorSpace = import_three77.SRGBColorSpace;
        this.renderTargetB.texture.colorSpace = import_three77.SRGBColorSpace;
      }
    }
  }
};

// src/passes/LambdaPass.js
var LambdaPass = class extends Pass {
  /**
   * Constructs a new lambda pass.
   *
   * @param {Function} f - A function.
   */
  constructor(f) {
    super("LambdaPass", null, null);
    this.needsSwap = false;
    this.f = f;
  }
  /**
   * Executes the function.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    this.f();
  }
};

// src/passes/NormalPass.js
var import_three78 = __webpack_require__(39437);
var NormalPass = class extends Pass {
  /**
   * Constructs a new normal pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Object} [options] - The options.
   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(scene, camera, {
    renderTarget,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("NormalPass");
    this.needsSwap = false;
    this.renderPass = new RenderPass(scene, camera, new import_three78.MeshNormalMaterial());
    const renderPass = this.renderPass;
    renderPass.ignoreBackground = true;
    renderPass.skipShadowMapUpdate = true;
    const clearPass = renderPass.getClearPass();
    clearPass.overrideClearColor = new import_three78.Color(7829503);
    clearPass.overrideClearAlpha = 1;
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new import_three78.WebGLRenderTarget(1, 1, {
        minFilter: import_three78.NearestFilter,
        magFilter: import_three78.NearestFilter
      });
      this.renderTarget.texture.name = "NormalPass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  set mainScene(value) {
    this.renderPass.mainScene = value;
  }
  set mainCamera(value) {
    this.renderPass.mainCamera = value;
  }
  /**
   * The normal texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * The normal texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Renders the scene normals.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const renderTarget = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(renderer, renderTarget, renderTarget);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
};

// src/textures/lut/TetrahedralUpscaler.js
var P = [
  new Float32Array(3),
  new Float32Array(3)
];
var C = [
  new Float32Array(3),
  new Float32Array(3),
  new Float32Array(3),
  new Float32Array(3)
];
var T = [
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1])
  ]
];
function calculateTetrahedronVolume(a, b, c2, d) {
  const bcX = c2[0] - b[0];
  const bcY = c2[1] - b[1];
  const bcZ = c2[2] - b[2];
  const baX = a[0] - b[0];
  const baY = a[1] - b[1];
  const baZ = a[2] - b[2];
  const crossX = bcY * baZ - bcZ * baY;
  const crossY = bcZ * baX - bcX * baZ;
  const crossZ = bcX * baY - bcY * baX;
  const length = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);
  const triangleArea = length * 0.5;
  const normalX = crossX / length;
  const normalY = crossY / length;
  const normalZ = crossZ / length;
  const constant = -(a[0] * normalX + a[1] * normalY + a[2] * normalZ);
  const dot = d[0] * normalX + d[1] * normalY + d[2] * normalZ;
  const height = Math.abs(dot + constant);
  return height * triangleArea / 3;
}
function sample(data, size, x, y, z, color2) {
  const i4 = (x + y * size + z * size * size) * 4;
  color2[0] = data[i4 + 0];
  color2[1] = data[i4 + 1];
  color2[2] = data[i4 + 2];
}
function tetrahedralSample(data, size, u, v3, w, color2) {
  const px = u * (size - 1);
  const py = v3 * (size - 1);
  const pz = w * (size - 1);
  const minX = Math.floor(px);
  const minY = Math.floor(py);
  const minZ = Math.floor(pz);
  const maxX = Math.ceil(px);
  const maxY = Math.ceil(py);
  const maxZ = Math.ceil(pz);
  const su = px - minX;
  const sv = py - minY;
  const sw = pz - minZ;
  if (minX === px && minY === py && minZ === pz) {
    sample(data, size, px, py, pz, color2);
  } else {
    let vertices;
    if (su >= sv && sv >= sw) {
      vertices = T[0];
    } else if (su >= sw && sw >= sv) {
      vertices = T[1];
    } else if (sw >= su && su >= sv) {
      vertices = T[2];
    } else if (sv >= su && su >= sw) {
      vertices = T[3];
    } else if (sv >= sw && sw >= su) {
      vertices = T[4];
    } else if (sw >= sv && sv >= su) {
      vertices = T[5];
    }
    const [P0, P1, P2, P3] = vertices;
    const coords = P[0];
    coords[0] = su;
    coords[1] = sv;
    coords[2] = sw;
    const tmp = P[1];
    const diffX = maxX - minX;
    const diffY = maxY - minY;
    const diffZ = maxZ - minZ;
    tmp[0] = diffX * P0[0] + minX;
    tmp[1] = diffY * P0[1] + minY;
    tmp[2] = diffZ * P0[2] + minZ;
    sample(data, size, tmp[0], tmp[1], tmp[2], C[0]);
    tmp[0] = diffX * P1[0] + minX;
    tmp[1] = diffY * P1[1] + minY;
    tmp[2] = diffZ * P1[2] + minZ;
    sample(data, size, tmp[0], tmp[1], tmp[2], C[1]);
    tmp[0] = diffX * P2[0] + minX;
    tmp[1] = diffY * P2[1] + minY;
    tmp[2] = diffZ * P2[2] + minZ;
    sample(data, size, tmp[0], tmp[1], tmp[2], C[2]);
    tmp[0] = diffX * P3[0] + minX;
    tmp[1] = diffY * P3[1] + minY;
    tmp[2] = diffZ * P3[2] + minZ;
    sample(data, size, tmp[0], tmp[1], tmp[2], C[3]);
    const V0 = calculateTetrahedronVolume(P1, P2, P3, coords) * 6;
    const V1 = calculateTetrahedronVolume(P0, P2, P3, coords) * 6;
    const V2 = calculateTetrahedronVolume(P0, P1, P3, coords) * 6;
    const V3 = calculateTetrahedronVolume(P0, P1, P2, coords) * 6;
    C[0][0] *= V0;
    C[0][1] *= V0;
    C[0][2] *= V0;
    C[1][0] *= V1;
    C[1][1] *= V1;
    C[1][2] *= V1;
    C[2][0] *= V2;
    C[2][1] *= V2;
    C[2][2] *= V2;
    C[3][0] *= V3;
    C[3][1] *= V3;
    C[3][2] *= V3;
    color2[0] = C[0][0] + C[1][0] + C[2][0] + C[3][0];
    color2[1] = C[0][1] + C[1][1] + C[2][1] + C[3][1];
    color2[2] = C[0][2] + C[1][2] + C[2][2] + C[3][2];
  }
}
var TetrahedralUpscaler = class {
  /**
   * Expands the given data to the target size.
   *
   * @param {TypedArray} data - The input RGBA data. Assumed to be cubic.
   * @param {Number} size - The target size.
   * @return {TypedArray} The new data.
   */
  static expand(data, size) {
    const originalSize = Math.cbrt(data.length / 4);
    const rgb = new Float32Array(3);
    const array = new data.constructor(size ** 3 * 4);
    const maxValue = data instanceof Uint8Array ? 255 : 1;
    const sizeSq = size ** 2;
    const s = 1 / (size - 1);
    for (let z = 0; z < size; ++z) {
      for (let y = 0; y < size; ++y) {
        for (let x = 0; x < size; ++x) {
          const u = x * s;
          const v3 = y * s;
          const w = z * s;
          const i4 = Math.round(x + y * size + z * sizeSq) * 4;
          tetrahedralSample(data, originalSize, u, v3, w, rgb);
          array[i4 + 0] = rgb[0];
          array[i4 + 1] = rgb[1];
          array[i4 + 2] = rgb[2];
          array[i4 + 3] = maxValue;
        }
      }
    }
    return array;
  }
};

// src/textures/smaa/SMAAAreaImageData.js
var area = [
  new Float32Array(2),
  new Float32Array(2)
];
var ORTHOGONAL_SIZE = 16;
var DIAGONAL_SIZE = 20;
var DIAGONAL_SAMPLES = 30;
var SMOOTH_MAX_DISTANCE = 32;
var orthogonalSubsamplingOffsets = new Float32Array([
  0,
  -0.25,
  0.25,
  -0.125,
  0.125,
  -0.375,
  0.375
]);
var diagonalSubsamplingOffsets = [
  new Float32Array([0, 0]),
  new Float32Array([0.25, -0.25]),
  new Float32Array([-0.25, 0.25]),
  new Float32Array([0.125, -0.125]),
  new Float32Array([-0.125, 0.125])
];
var orthogonalEdges = [
  new Uint8Array([0, 0]),
  new Uint8Array([3, 0]),
  new Uint8Array([0, 3]),
  new Uint8Array([3, 3]),
  new Uint8Array([1, 0]),
  new Uint8Array([4, 0]),
  new Uint8Array([1, 3]),
  new Uint8Array([4, 3]),
  new Uint8Array([0, 1]),
  new Uint8Array([3, 1]),
  new Uint8Array([0, 4]),
  new Uint8Array([3, 4]),
  new Uint8Array([1, 1]),
  new Uint8Array([4, 1]),
  new Uint8Array([1, 4]),
  new Uint8Array([4, 4])
];
var diagonalEdges = [
  new Uint8Array([0, 0]),
  new Uint8Array([1, 0]),
  new Uint8Array([0, 2]),
  new Uint8Array([1, 2]),
  new Uint8Array([2, 0]),
  new Uint8Array([3, 0]),
  new Uint8Array([2, 2]),
  new Uint8Array([3, 2]),
  new Uint8Array([0, 1]),
  new Uint8Array([1, 1]),
  new Uint8Array([0, 3]),
  new Uint8Array([1, 3]),
  new Uint8Array([2, 1]),
  new Uint8Array([3, 1]),
  new Uint8Array([2, 3]),
  new Uint8Array([3, 3])
];
function lerp(a, b, p) {
  return a + (b - a) * p;
}
function saturate(a) {
  return Math.min(Math.max(a, 0), 1);
}
function smoothArea(d) {
  const a1 = area[0];
  const a2 = area[1];
  const b1X = Math.sqrt(a1[0] * 2) * 0.5;
  const b1Y = Math.sqrt(a1[1] * 2) * 0.5;
  const b2X = Math.sqrt(a2[0] * 2) * 0.5;
  const b2Y = Math.sqrt(a2[1] * 2) * 0.5;
  const p = saturate(d / SMOOTH_MAX_DISTANCE);
  a1[0] = lerp(b1X, a1[0], p);
  a1[1] = lerp(b1Y, a1[1], p);
  a2[0] = lerp(b2X, a2[0], p);
  a2[1] = lerp(b2Y, a2[1], p);
}
function getOrthArea(p1X, p1Y, p2X, p2Y, x, result) {
  const dX = p2X - p1X;
  const dY = p2Y - p1Y;
  const x1 = x;
  const x2 = x + 1;
  const y1 = p1Y + dY * (x1 - p1X) / dX;
  const y2 = p1Y + dY * (x2 - p1X) / dX;
  if (x1 >= p1X && x1 < p2X || x2 > p1X && x2 <= p2X) {
    if (Math.sign(y1) === Math.sign(y2) || Math.abs(y1) < 1e-4 || Math.abs(y2) < 1e-4) {
      const a = (y1 + y2) / 2;
      if (a < 0) {
        result[0] = Math.abs(a);
        result[1] = 0;
      } else {
        result[0] = 0;
        result[1] = Math.abs(a);
      }
    } else {
      const t = -p1Y * dX / dY + p1X;
      const tInt = Math.trunc(t);
      const a1 = t > p1X ? y1 * (t - tInt) / 2 : 0;
      const a2 = t < p2X ? y2 * (1 - (t - tInt)) / 2 : 0;
      const a = Math.abs(a1) > Math.abs(a2) ? a1 : -a2;
      if (a < 0) {
        result[0] = Math.abs(a1);
        result[1] = Math.abs(a2);
      } else {
        result[0] = Math.abs(a2);
        result[1] = Math.abs(a1);
      }
    }
  } else {
    result[0] = 0;
    result[1] = 0;
  }
  return result;
}
function getOrthAreaForPattern(pattern, left, right, offset, result) {
  const a1 = area[0];
  const a2 = area[1];
  const o1 = 0.5 + offset;
  const o2 = 0.5 + offset - 1;
  const d = left + right + 1;
  switch (pattern) {
    case 0: {
      result[0] = 0;
      result[1] = 0;
      break;
    }
    case 1: {
      if (left <= right) {
        getOrthArea(0, o2, d / 2, 0, left, result);
      } else {
        result[0] = 0;
        result[1] = 0;
      }
      break;
    }
    case 2: {
      if (left >= right) {
        getOrthArea(d / 2, 0, d, o2, left, result);
      } else {
        result[0] = 0;
        result[1] = 0;
      }
      break;
    }
    case 3: {
      getOrthArea(0, o2, d / 2, 0, left, a1);
      getOrthArea(d / 2, 0, d, o2, left, a2);
      smoothArea(d, area);
      result[0] = a1[0] + a2[0];
      result[1] = a1[1] + a2[1];
      break;
    }
    case 4: {
      if (left <= right) {
        getOrthArea(0, o1, d / 2, 0, left, result);
      } else {
        result[0] = 0;
        result[1] = 0;
      }
      break;
    }
    case 5: {
      result[0] = 0;
      result[1] = 0;
      break;
    }
    case 6: {
      if (Math.abs(offset) > 0) {
        getOrthArea(0, o1, d, o2, left, a1);
        getOrthArea(0, o1, d / 2, 0, left, a2);
        getOrthArea(d / 2, 0, d, o2, left, result);
        a2[0] = a2[0] + result[0];
        a2[1] = a2[1] + result[1];
        result[0] = (a1[0] + a2[0]) / 2;
        result[1] = (a1[1] + a2[1]) / 2;
      } else {
        getOrthArea(0, o1, d, o2, left, result);
      }
      break;
    }
    case 7: {
      getOrthArea(0, o1, d, o2, left, result);
      break;
    }
    case 8: {
      if (left >= right) {
        getOrthArea(d / 2, 0, d, o1, left, result);
      } else {
        result[0] = 0;
        result[1] = 0;
      }
      break;
    }
    case 9: {
      if (Math.abs(offset) > 0) {
        getOrthArea(0, o2, d, o1, left, a1);
        getOrthArea(0, o2, d / 2, 0, left, a2);
        getOrthArea(d / 2, 0, d, o1, left, result);
        a2[0] = a2[0] + result[0];
        a2[1] = a2[1] + result[1];
        result[0] = (a1[0] + a2[0]) / 2;
        result[1] = (a1[1] + a2[1]) / 2;
      } else {
        getOrthArea(0, o2, d, o1, left, result);
      }
      break;
    }
    case 10: {
      result[0] = 0;
      result[1] = 0;
      break;
    }
    case 11: {
      getOrthArea(0, o2, d, o1, left, result);
      break;
    }
    case 12: {
      getOrthArea(0, o1, d / 2, 0, left, a1);
      getOrthArea(d / 2, 0, d, o1, left, a2);
      smoothArea(d, area);
      result[0] = a1[0] + a2[0];
      result[1] = a1[1] + a2[1];
      break;
    }
    case 13: {
      getOrthArea(0, o2, d, o1, left, result);
      break;
    }
    case 14: {
      getOrthArea(0, o1, d, o2, left, result);
      break;
    }
    case 15: {
      result[0] = 0;
      result[1] = 0;
      break;
    }
  }
  return result;
}
function isInsideArea(a1X, a1Y, a2X, a2Y, x, y) {
  let result = a1X === a2X && a1Y === a2Y;
  if (!result) {
    const xm = (a1X + a2X) / 2;
    const ym = (a1Y + a2Y) / 2;
    const a = a2Y - a1Y;
    const b = a1X - a2X;
    const c2 = a * (x - xm) + b * (y - ym);
    result = c2 > 0;
  }
  return result;
}
function getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, pX, pY) {
  let n = 0;
  for (let y = 0; y < DIAGONAL_SAMPLES; ++y) {
    for (let x = 0; x < DIAGONAL_SAMPLES; ++x) {
      const offsetX = x / (DIAGONAL_SAMPLES - 1);
      const offsetY = y / (DIAGONAL_SAMPLES - 1);
      if (isInsideArea(a1X, a1Y, a2X, a2Y, pX + offsetX, pY + offsetY)) {
        ++n;
      }
    }
  }
  return n / (DIAGONAL_SAMPLES * DIAGONAL_SAMPLES);
}
function getDiagArea(pattern, a1X, a1Y, a2X, a2Y, left, offset, result) {
  const e = diagonalEdges[pattern];
  const e1 = e[0];
  const e2 = e[1];
  if (e1 > 0) {
    a1X += offset[0];
    a1Y += offset[1];
  }
  if (e2 > 0) {
    a2X += offset[0];
    a2Y += offset[1];
  }
  result[0] = 1 - getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 0 + left);
  result[1] = getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 1 + left);
  return result;
}
function getDiagAreaForPattern(pattern, left, right, offset, result) {
  const a1 = area[0];
  const a2 = area[1];
  const d = left + right + 1;
  switch (pattern) {
    case 0: {
      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 1: {
      getDiagArea(pattern, 1, 0, 0 + d, 0 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 2: {
      getDiagArea(pattern, 0, 0, 1 + d, 0 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 3: {
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, result);
      break;
    }
    case 4: {
      getDiagArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);
      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 5: {
      getDiagArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 6: {
      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, result);
      break;
    }
    case 7: {
      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 8: {
      getDiagArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 9: {
      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);
      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);
      break;
    }
    case 10: {
      getDiagArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 11: {
      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 12: {
      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, result);
      break;
    }
    case 13: {
      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 14: {
      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 15: {
      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
  }
  return result;
}
function generatePatterns(patterns, offset, orthogonal) {
  const result = new Float32Array(2);
  for (let i = 0, l = patterns.length; i < l; ++i) {
    const pattern = patterns[i];
    const data = pattern.data;
    const size = pattern.width;
    for (let y = 0; y < size; ++y) {
      for (let x = 0; x < size; ++x) {
        if (orthogonal) {
          getOrthAreaForPattern(i, x, y, offset, result);
        } else {
          getDiagAreaForPattern(i, x, y, offset, result);
        }
        const c2 = (y * size + x) * 2;
        data[c2] = result[0] * 255;
        data[c2 + 1] = result[1] * 255;
      }
    }
  }
}
function assemble(baseX, baseY, patterns, edges2, size, orthogonal, target) {
  const dstData = target.data;
  const dstWidth = target.width;
  for (let i = 0, l = patterns.length; i < l; ++i) {
    const edge = edges2[i];
    const pattern = patterns[i];
    const srcData = pattern.data;
    const srcWidth = pattern.width;
    for (let y = 0; y < size; ++y) {
      for (let x = 0; x < size; ++x) {
        const pX = edge[0] * size + baseX + x;
        const pY = edge[1] * size + baseY + y;
        const c2 = (pY * dstWidth + pX) * 4;
        const d = orthogonal ? (y * y * srcWidth + x * x) * 2 : (y * srcWidth + x) * 2;
        dstData[c2] = srcData[d];
        dstData[c2 + 1] = srcData[d + 1];
        dstData[c2 + 2] = 0;
        dstData[c2 + 3] = 255;
      }
    }
  }
}
var SMAAAreaImageData = class {
  /**
   * Creates a new area image.
   *
   * @return {RawImageData} The generated image data.
   */
  static generate() {
    const width = 2 * 5 * ORTHOGONAL_SIZE;
    const height = orthogonalSubsamplingOffsets.length * 5 * ORTHOGONAL_SIZE;
    const data = new Uint8ClampedArray(width * height * 4);
    const result = new RawImageData(width, height, data);
    const orthPatternSize = Math.pow(ORTHOGONAL_SIZE - 1, 2) + 1;
    const diagPatternSize = DIAGONAL_SIZE;
    const orthogonalPatterns = [];
    const diagonalPatterns = [];
    for (let i = 3, l = data.length; i < l; i += 4) {
      data[i] = 255;
    }
    for (let i = 0; i < 16; ++i) {
      orthogonalPatterns.push(new RawImageData(
        orthPatternSize,
        orthPatternSize,
        new Uint8ClampedArray(orthPatternSize * orthPatternSize * 2),
        2
      ));
      diagonalPatterns.push(new RawImageData(
        diagPatternSize,
        diagPatternSize,
        new Uint8ClampedArray(diagPatternSize * diagPatternSize * 2),
        2
      ));
    }
    for (let i = 0, l = orthogonalSubsamplingOffsets.length; i < l; ++i) {
      generatePatterns(orthogonalPatterns, orthogonalSubsamplingOffsets[i], true);
      assemble(
        0,
        5 * ORTHOGONAL_SIZE * i,
        orthogonalPatterns,
        orthogonalEdges,
        ORTHOGONAL_SIZE,
        true,
        result
      );
    }
    for (let i = 0, l = diagonalSubsamplingOffsets.length; i < l; ++i) {
      generatePatterns(diagonalPatterns, diagonalSubsamplingOffsets[i], false);
      assemble(
        5 * ORTHOGONAL_SIZE,
        4 * DIAGONAL_SIZE * i,
        diagonalPatterns,
        diagonalEdges,
        DIAGONAL_SIZE,
        false,
        result
      );
    }
    return result;
  }
};

// src/textures/smaa/SMAAImageGenerator.js
var import_three79 = __webpack_require__(39437);

// tmp/smaa/worker.txt
var worker_default2 = '"use strict";(()=>{function q(t,a,s){let e=document.createElement("canvas"),n=e.getContext("2d");if(e.width=t,e.height=a,s instanceof Image)n.drawImage(s,0,0);else{let r=n.createImageData(t,a);r.data.set(s),n.putImageData(r,0,0)}return e}var F=class t{constructor(a=0,s=0,e=null){this.width=a,this.height=s,this.data=e}toCanvas(){return typeof document=="undefined"?null:q(this.width,this.height,this.data)}static from(a){let{width:s,height:e}=a,n;if(a instanceof Image){let r=q(s,e,a);r!==null&&(n=r.getContext("2d").getImageData(0,0,s,e).data)}else n=a.data;return new t(s,e,n)}};var M=[new Float32Array(2),new Float32Array(2)],D=16,W=20,I=30,j=32,v=new Float32Array([0,-.25,.25,-.125,.125,-.375,.375]),N=[new Float32Array([0,0]),new Float32Array([.25,-.25]),new Float32Array([-.25,.25]),new Float32Array([.125,-.125]),new Float32Array([-.125,.125])],z=[new Uint8Array([0,0]),new Uint8Array([3,0]),new Uint8Array([0,3]),new Uint8Array([3,3]),new Uint8Array([1,0]),new Uint8Array([4,0]),new Uint8Array([1,3]),new Uint8Array([4,3]),new Uint8Array([0,1]),new Uint8Array([3,1]),new Uint8Array([0,4]),new Uint8Array([3,4]),new Uint8Array([1,1]),new Uint8Array([4,1]),new Uint8Array([1,4]),new Uint8Array([4,4])],p=[new Uint8Array([0,0]),new Uint8Array([1,0]),new Uint8Array([0,2]),new Uint8Array([1,2]),new Uint8Array([2,0]),new Uint8Array([3,0]),new Uint8Array([2,2]),new Uint8Array([3,2]),new Uint8Array([0,1]),new Uint8Array([1,1]),new Uint8Array([0,3]),new Uint8Array([1,3]),new Uint8Array([2,1]),new Uint8Array([3,1]),new Uint8Array([2,3]),new Uint8Array([3,3])];function C(t,a,s){return t+(a-t)*s}function B(t){return Math.min(Math.max(t,0),1)}function _(t){let a=M[0],s=M[1],e=Math.sqrt(a[0]*2)*.5,n=Math.sqrt(a[1]*2)*.5,r=Math.sqrt(s[0]*2)*.5,o=Math.sqrt(s[1]*2)*.5,c=B(t/j);a[0]=C(e,a[0],c),a[1]=C(n,a[1],c),s[0]=C(r,s[0],c),s[1]=C(o,s[1],c)}function d(t,a,s,e,n,r){let o=s-t,c=e-a,h=n,i=n+1,w=a+c*(h-t)/o,b=a+c*(i-t)/o;if(h>=t&&h<s||i>t&&i<=s)if(Math.sign(w)===Math.sign(b)||Math.abs(w)<1e-4||Math.abs(b)<1e-4){let g=(w+b)/2;g<0?(r[0]=Math.abs(g),r[1]=0):(r[0]=0,r[1]=Math.abs(g))}else{let g=-a*o/c+t,k=Math.trunc(g),m=g>t?w*(g-k)/2:0,U=g<s?b*(1-(g-k))/2:0;(Math.abs(m)>Math.abs(U)?m:-U)<0?(r[0]=Math.abs(m),r[1]=Math.abs(U)):(r[0]=Math.abs(U),r[1]=Math.abs(m))}else r[0]=0,r[1]=0;return r}function J(t,a,s,e,n){let r=M[0],o=M[1],c=.5+e,h=.5+e-1,i=a+s+1;switch(t){case 0:{n[0]=0,n[1]=0;break}case 1:{a<=s?d(0,h,i/2,0,a,n):(n[0]=0,n[1]=0);break}case 2:{a>=s?d(i/2,0,i,h,a,n):(n[0]=0,n[1]=0);break}case 3:{d(0,h,i/2,0,a,r),d(i/2,0,i,h,a,o),_(i,M),n[0]=r[0]+o[0],n[1]=r[1]+o[1];break}case 4:{a<=s?d(0,c,i/2,0,a,n):(n[0]=0,n[1]=0);break}case 5:{n[0]=0,n[1]=0;break}case 6:{Math.abs(e)>0?(d(0,c,i,h,a,r),d(0,c,i/2,0,a,o),d(i/2,0,i,h,a,n),o[0]=o[0]+n[0],o[1]=o[1]+n[1],n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2):d(0,c,i,h,a,n);break}case 7:{d(0,c,i,h,a,n);break}case 8:{a>=s?d(i/2,0,i,c,a,n):(n[0]=0,n[1]=0);break}case 9:{Math.abs(e)>0?(d(0,h,i,c,a,r),d(0,h,i/2,0,a,o),d(i/2,0,i,c,a,n),o[0]=o[0]+n[0],o[1]=o[1]+n[1],n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2):d(0,h,i,c,a,n);break}case 10:{n[0]=0,n[1]=0;break}case 11:{d(0,h,i,c,a,n);break}case 12:{d(0,c,i/2,0,a,r),d(i/2,0,i,c,a,o),_(i,M),n[0]=r[0]+o[0],n[1]=r[1]+o[1];break}case 13:{d(0,h,i,c,a,n);break}case 14:{d(0,c,i,h,a,n);break}case 15:{n[0]=0,n[1]=0;break}}return n}function K(t,a,s,e,n,r){let o=t===s&&a===e;if(!o){let c=(t+s)/2,h=(a+e)/2,i=e-a,w=t-s;o=i*(n-c)+w*(r-h)>0}return o}function G(t,a,s,e,n,r){let o=0;for(let c=0;c<I;++c)for(let h=0;h<I;++h){let i=h/(I-1),w=c/(I-1);K(t,a,s,e,n+i,r+w)&&++o}return o/(I*I)}function A(t,a,s,e,n,r,o,c){let h=p[t],i=h[0],w=h[1];return i>0&&(a+=o[0],s+=o[1]),w>0&&(e+=o[0],n+=o[1]),c[0]=1-G(a,s,e,n,1+r,0+r),c[1]=G(a,s,e,n,1+r,1+r),c}function Q(t,a,s,e,n){let r=M[0],o=M[1],c=a+s+1;switch(t){case 0:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 1:{A(t,1,0,0+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 2:{A(t,0,0,1+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 3:{A(t,1,0,1+c,0+c,a,e,n);break}case 4:{A(t,1,1,0+c,0+c,a,e,r),A(t,1,1,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 5:{A(t,1,1,0+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 6:{A(t,1,1,1+c,0+c,a,e,n);break}case 7:{A(t,1,1,1+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 8:{A(t,0,0,1+c,1+c,a,e,r),A(t,1,0,1+c,1+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 9:{A(t,1,0,1+c,1+c,a,e,n),A(t,1,0,1+c,1+c,a,e,n);break}case 10:{A(t,0,0,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 11:{A(t,1,0,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 12:{A(t,1,1,1+c,1+c,a,e,n);break}case 13:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,1+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 14:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,1,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 15:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}}return n}function R(t,a,s){let e=new Float32Array(2);for(let n=0,r=t.length;n<r;++n){let o=t[n],c=o.data,h=o.width;for(let i=0;i<h;++i)for(let w=0;w<h;++w){s?J(n,w,i,a,e):Q(n,w,i,a,e);let b=(i*h+w)*2;c[b]=e[0]*255,c[b+1]=e[1]*255}}}function T(t,a,s,e,n,r,o){let c=o.data,h=o.width;for(let i=0,w=s.length;i<w;++i){let b=e[i],g=s[i],k=g.data,m=g.width;for(let U=0;U<n;++U)for(let x=0;x<n;++x){let Z=b[0]*n+t+x,O=((b[1]*n+a+U)*h+Z)*4,L=r?(U*U*m+x*x)*2:(U*m+x)*2;c[O]=k[L],c[O+1]=k[L+1],c[O+2]=0,c[O+3]=255}}}var S=class{static generate(){let a=10*D,s=v.length*5*D,e=new Uint8ClampedArray(a*s*4),n=new F(a,s,e),r=Math.pow(D-1,2)+1,o=W,c=[],h=[];for(let i=3,w=e.length;i<w;i+=4)e[i]=255;for(let i=0;i<16;++i)c.push(new F(r,r,new Uint8ClampedArray(r*r*2),2)),h.push(new F(o,o,new Uint8ClampedArray(o*o*2),2));for(let i=0,w=v.length;i<w;++i)R(c,v[i],!0),T(0,5*D*i,c,z,D,!0,n);for(let i=0,w=N.length;i<w;++i)R(h,N[i],!1),T(5*D,4*W*i,h,p,W,!1,n);return n}};var P=new Map([[y(0,0,0,0),new Float32Array([0,0,0,0])],[y(0,0,0,1),new Float32Array([0,0,0,1])],[y(0,0,1,0),new Float32Array([0,0,1,0])],[y(0,0,1,1),new Float32Array([0,0,1,1])],[y(0,1,0,0),new Float32Array([0,1,0,0])],[y(0,1,0,1),new Float32Array([0,1,0,1])],[y(0,1,1,0),new Float32Array([0,1,1,0])],[y(0,1,1,1),new Float32Array([0,1,1,1])],[y(1,0,0,0),new Float32Array([1,0,0,0])],[y(1,0,0,1),new Float32Array([1,0,0,1])],[y(1,0,1,0),new Float32Array([1,0,1,0])],[y(1,0,1,1),new Float32Array([1,0,1,1])],[y(1,1,0,0),new Float32Array([1,1,0,0])],[y(1,1,0,1),new Float32Array([1,1,0,1])],[y(1,1,1,0),new Float32Array([1,1,1,0])],[y(1,1,1,1),new Float32Array([1,1,1,1])]]);function H(t,a,s){return t+(a-t)*s}function y(t,a,s,e){let n=H(t,a,.75),r=H(s,e,1-.25);return H(n,r,1-.125)}function V(t,a){let s=0;return a[3]===1&&(s+=1),s===1&&a[2]===1&&t[1]!==1&&t[3]!==1&&(s+=1),s}function $(t,a){let s=0;return a[3]===1&&t[1]!==1&&t[3]!==1&&(s+=1),s===1&&a[2]===1&&t[0]!==1&&t[2]!==1&&(s+=1),s}var E=class{static generate(){let o=new Uint8ClampedArray(2178),c=new Uint8ClampedArray(64*16*4);for(let h=0;h<33;++h)for(let i=0;i<66;++i){let w=.03125*i,b=.03125*h;if(P.has(w)&&P.has(b)){let g=P.get(w),k=P.get(b),m=h*66+i;o[m]=127*V(g,k),o[m+33]=127*$(g,k)}}for(let h=0,i=17;i<33;++i)for(let w=0;w<64;++w,h+=4)c[h]=o[i*66+w],c[h+3]=255;return new F(64,16,c)}};self.addEventListener("message",t=>{let a=S.generate(),s=E.generate();postMessage({areaImageData:a,searchImageData:s},[a.data.buffer,s.data.buffer]),close()});})();\n';

// src/textures/smaa/SMAAImageGenerator.js
function generate(useCache = true) {
  const workerURL = URL.createObjectURL(new Blob([worker_default2], {
    type: "text/javascript"
  }));
  const worker = new Worker(workerURL);
  URL.revokeObjectURL(workerURL);
  return new Promise((resolve, reject) => {
    worker.addEventListener("error", (event) => reject(event.error));
    worker.addEventListener("message", (event) => {
      const searchImageData = RawImageData.from(event.data.searchImageData);
      const areaImageData = RawImageData.from(event.data.areaImageData);
      const urls = [
        searchImageData.toCanvas().toDataURL("image/png", 1),
        areaImageData.toCanvas().toDataURL("image/png", 1)
      ];
      if (useCache) {
        localStorage.setItem("smaa-search", urls[0]);
        localStorage.setItem("smaa-area", urls[1]);
      }
      resolve(urls);
    });
    worker.postMessage(null);
  });
}
var SMAAImageGenerator = class {
  /**
   * Constructs a new SMAA image generator.
   */
  constructor() {
    this.disableCache = false;
  }
  /**
   * Enables or disables caching via localStorage.
   *
   * @param {Boolean} value - Whether the cache should be enabled.
   */
  setCacheEnabled(value) {
    this.disableCache = !value;
  }
  /**
   * Generates the SMAA data images.
   *
   * @example
   * SMAAImageGenerator.generate().then(([search, area]) => {
   *   const smaaEffect = new SMAAEffect(search, area);
   * });
   * @return {Promise<Image[]>} A promise that returns the search image and area image as a pair.
   */
  generate() {
    const useCache = !this.disableCache && window.localStorage !== void 0;
    const cachedURLs = useCache ? [
      localStorage.getItem("smaa-search"),
      localStorage.getItem("smaa-area")
    ] : [null, null];
    const promise = cachedURLs[0] !== null && cachedURLs[1] !== null ? Promise.resolve(cachedURLs) : generate(useCache);
    return promise.then((urls) => {
      return new Promise((resolve, reject) => {
        const searchImage = new Image();
        const areaImage = new Image();
        const manager = new import_three79.LoadingManager();
        manager.onLoad = () => resolve([searchImage, areaImage]);
        manager.onError = reject;
        searchImage.addEventListener("error", (e) => manager.itemError("smaa-search"));
        areaImage.addEventListener("error", (e) => manager.itemError("smaa-area"));
        searchImage.addEventListener("load", () => manager.itemEnd("smaa-search"));
        areaImage.addEventListener("load", () => manager.itemEnd("smaa-area"));
        manager.itemStart("smaa-search");
        manager.itemStart("smaa-area");
        searchImage.src = urls[0];
        areaImage.src = urls[1];
      });
    });
  }
};

// src/textures/smaa/SMAASearchImageData.js
var edges = /* @__PURE__ */ new Map([
  [bilinear(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])],
  [bilinear(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])],
  [bilinear(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])],
  [bilinear(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])],
  [bilinear(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])],
  [bilinear(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])],
  [bilinear(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])],
  [bilinear(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])],
  [bilinear(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])],
  [bilinear(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])],
  [bilinear(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])],
  [bilinear(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])],
  [bilinear(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])],
  [bilinear(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])],
  [bilinear(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])],
  [bilinear(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]
]);
function lerp2(a, b, p) {
  return a + (b - a) * p;
}
function bilinear(e0, e1, e2, e3) {
  const a = lerp2(e0, e1, 1 - 0.25);
  const b = lerp2(e2, e3, 1 - 0.25);
  return lerp2(a, b, 1 - 0.125);
}
function deltaLeft(left, top) {
  let d = 0;
  if (top[3] === 1) {
    d += 1;
  }
  if (d === 1 && top[2] === 1 && left[1] !== 1 && left[3] !== 1) {
    d += 1;
  }
  return d;
}
function deltaRight(left, top) {
  let d = 0;
  if (top[3] === 1 && left[1] !== 1 && left[3] !== 1) {
    d += 1;
  }
  if (d === 1 && top[2] === 1 && left[0] !== 1 && left[2] !== 1) {
    d += 1;
  }
  return d;
}
var SMAASearchImageData = class {
  /**
   * Creates a new search image.
   *
   * @return {RawImageData} The generated image data.
   */
  static generate() {
    const width = 66;
    const height = 33;
    const halfWidth = width / 2;
    const croppedWidth = 64;
    const croppedHeight = 16;
    const data = new Uint8ClampedArray(width * height);
    const croppedData = new Uint8ClampedArray(croppedWidth * croppedHeight * 4);
    for (let y = 0; y < height; ++y) {
      for (let x = 0; x < width; ++x) {
        const s = 0.03125 * x;
        const t = 0.03125 * y;
        if (edges.has(s) && edges.has(t)) {
          const e1 = edges.get(s);
          const e2 = edges.get(t);
          const i = y * width + x;
          data[i] = 127 * deltaLeft(e1, e2);
          data[i + halfWidth] = 127 * deltaRight(e1, e2);
        }
      }
    }
    for (let i = 0, y = height - croppedHeight; y < height; ++y) {
      for (let x = 0; x < croppedWidth; ++x, i += 4) {
        croppedData[i] = data[y * width + x];
        croppedData[i + 3] = 255;
      }
    }
    return new RawImageData(croppedWidth, croppedHeight, croppedData);
  }
};


/***/ })

}]);
//# sourceMappingURL=vendors-46ae0e6a.bundle.js.map